var globalLWGDebug = false;
(function () { function r(e, n, t) { function o(i, f) { if (!n[i]) { if (!e[i]) { var c = "function" == typeof require && require; if (!f && c) return c(i, !0); if (u) return u(i, !0); var a = new Error("Cannot find module '" + i + "'"); throw a.code = "MODULE_NOT_FOUND", a } var p = n[i] = { exports: {} }; e[i][0].call(p.exports, function (r) { var n = e[i][1][r]; return o(n || r) }, p, p.exports, r, e, n, t) } return n[i].exports } for (var u = "function" == typeof require && require, i = 0; i < t.length; i++)o(t[i]); return o } return r })()({
  1: [function (require, module, exports) {
    function assert(bool) {
      if (!bool) {
        throw `Assertion failed\n${Error().stack}`;
      }
    }

    module.exports = assert;

  }, {}], 2: [function (require, module, exports) {
    // TODO: Would be nice to make this a method of HTMLBuilder but would require a lot of refactoring, instead we add to global scope in config.js
    // Returns an ID guaranteed to be unique that starts with an optional prefix
    // The prefix may not end with numbers, which removes the guarantee of uniqueness
    const uniqueID = (() => {
      let counter = 0;
      return (prefix) => (prefix ? prefix : 'id') + counter++;
    })();

    function HTMLBuilder() {
      this.html = '';
      this.hooks = [];
    }

    HTMLBuilder.prototype.add = function (content) {
      if (typeof content === 'string') {
        this.html += content;
      } else if (typeof content === 'object' && 'html' in content && 'hooks' in content) {
        this.html += content.html;
        this.addHooks(content.hooks);
      } else {
        throw 'Input must be an HTML string or an HTMLBuilder-like object';
      }
      return this;
    };

    // Polls the function getValue at a specified for updated values and updates the HTML in the DOM
    // - getValue may return either a string or an HTMLBuilder, but either must be complete valid HTML (no unmatched tags)
    // - period specifies the time between updates in milliseconds (default 100 ms)
    HTMLBuilder.prototype.addReactive = function (getValue, period = 100) {
      const ID = uniqueID('reactive');
      this.html += `<span id=${ID}></span>`;
      this.addHook(() => {
        (function update() {
          const el = document.getElementById(ID);
          if (el) {
            const value = getValue();

            if (value instanceof HTMLBuilder) {
              value.insertInto(el);
            } else {
              el.innerHTML = value;
            }

            setTimeout(update, period);
          }
        })();
      });
      return this;
    };

    HTMLBuilder.prototype.addDOM = function (domElement) {
      const ID = uniqueID('DOM');
      this.html += `<span id='${ID}'></span>`;
      this.addHook(() => $(`#${ID}`).html(domElement));
      return this;
    };

    HTMLBuilder.prototype.addHook = function (hook) {
      this.hooks.push(hook);
      return this;
    };

    HTMLBuilder.prototype.addHooks = function (hooks) {
      this.hooks = this.hooks.concat(hooks);
      return this;
    };

    HTMLBuilder.prototype.insertInto = function (selector) {
      $(selector).html(this.html);
      this.hooks.forEach((hook) => hook());
    };

    HTMLBuilder.prototype.appendInto = function (selector) {
      $(selector).append(this.html);
      this.hooks.forEach((hook) => hook());
    };

    HTMLBuilder.prototype.appendAfter = function (selector) {
      $(selector).after(this.html);
      this.hooks.forEach((hook) => hook());
    };

    HTMLBuilder.prototype.appendBefore = function (selector) {
      $(selector).before(this.html);
      this.hooks.forEach((hook) => hook());
    };

    HTMLBuilder.prototype.print = function () {
      console.log(this.html);
      console.log(this.hooks);
      return this;
    };

    module.exports.HTMLBuilder = HTMLBuilder;
    module.exports.uniqueID = uniqueID;

  }, {}], 3: [function (require, module, exports) {
    class LocalConfigValue {
      constructor(key, configuration, defaultValue = undefined) {
        this.key = key;
        this.configuration = configuration;
        this.onChangeListeners = [];

        this.value = this.configuration.__get(this.key, defaultValue);
      }

      get(defaultValue = undefined) {
        return this.value ?? defaultValue;
      }

      set(value) {
        this.configuration.__set(this.key, value);
        this.value = value;
        this.onChangeListeners.forEach((c) => c(value));
      }

      onChange(cb) {
        this.onChangeListeners.push(cb);
      }
    };

    const LOCAL_STORAGE_KEY_NAME_CONFIG = 'configuration';

    function LocalConfig() {
      if (!localStorage.getItem(LOCAL_STORAGE_KEY_NAME_CONFIG)) {
        localStorage.setItem(LOCAL_STORAGE_KEY_NAME_CONFIG, JSON.stringify({}));
      }
    }

    LocalConfig.prototype.__getAndSet = function (cb) {
      const obj = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY_NAME_CONFIG));
      cb(obj);
      localStorage.setItem(LOCAL_STORAGE_KEY_NAME_CONFIG, JSON.stringify(obj));
    };

    // Gets the config value for the given key, and returns the defaultValue if specified
    // Additionally sets the config value to the defaultValue if provided
    LocalConfig.prototype.__get = function (key, defaultValue = undefined) {
      let value;
      this.__getAndSet((obj) => {
        if (!(key in obj) && defaultValue != undefined) {
          obj[key] = defaultValue;
        }
        value = obj[key];
      });
      return value;
    };

    LocalConfig.prototype.__set = function (key, value) {
      this.__getAndSet((obj) => obj[key] = value);
    };

    LocalConfig.prototype.registerValue = function (key, defaultValue = undefined) {
      return new LocalConfigValue(key, this, defaultValue);
    };

    module.exports = new LocalConfig();

  }, {}], 4: [function (require, module, exports) {
    // plays and manages all the sounds
    const LocalConfig = require('./LocalConfig.js');
    const SOUND = require('./data/Sound.js');


    var DEFAULT_VOLUME = 0.20;

    function SoundManager() {
      this.volume = LocalConfig.registerValue('sound_volume', DEFAULT_VOLUME);

      this.sounds = [];

      this.sounds[SOUND.FLESH] = this.loadSound([
        'sounds/hit05.ogg',
        'sounds/hit08.ogg',
        'sounds/hit13.ogg',
        'sounds/hit14.ogg',
      ]);

      this.sounds[SOUND.LADDER_START] = this.loadSound([
        'sounds/ladder-start.ogg',
      ]);

      this.sounds[SOUND.ARCHIVEMENT] = this.loadSound([
        'sounds/archivement.ogg',
      ]);

      this.sounds[SOUND.ARCHIVEMENT2] = this.loadSound([
        'sounds/archivement2.ogg',
      ]);

      this.sounds[SOUND.ARCHIVEMENT3] = this.loadSound([
        'sounds/archivement3.ogg',
      ]);

      this.sounds[SOUND.WARP] = this.loadSound([
        'sounds/warp-totem.ogg',
        'sounds/warp-totem.ogg',
      ]);

      this.sounds[SOUND.OPEN_WINDOW] = this.loadSound([
        'sounds/zip-new.ogg',
      ]);

      this.sounds[SOUND.PAIN] = this.loadSound([
        'sounds/pain1.ogg',
        'sounds/pain2.ogg',
        'sounds/pain5.ogg',
        'sounds/pain1.ogg',
      ]);

      this.sounds[SOUND.WOLF_PAIN] = this.loadSound([
        'sounds/wolf-pain.ogg',
        'sounds/wolf-pain-2.ogg',
        'sounds/wolf-pain.ogg',
        'sounds/wolf-pain-2.ogg',
      ]);

      this.sounds[SOUND.BIRD_SPAWN] = this.loadSound([
        'sounds/bird1.ogg',
      ]);

      this.sounds[SOUND.BIRD_YES] = this.loadSound([
        'sounds/bird2.ogg',
      ]);

      this.sounds[SOUND.BIRD_DEATH] = this.loadSound([
        'sounds/bird3.ogg',
      ]);

      this.sounds[SOUND.BIRD_SLAM] = this.loadSound([
        'sounds/bird-slam.ogg',
      ]);

      this.sounds[SOUND.DEATH] = this.loadSound([
        'sounds/die1.ogg',
        'sounds/die2.ogg',
        'sounds/die1.ogg',
      ]);

      this.sounds[SOUND.WOLF_DEATH] = this.loadSound([
        'sounds/wolf-die.ogg',
        'sounds/wolf-die-2.ogg',
      ]);

      this.sounds[SOUND.WOLF_HIT] = this.loadSound([
        'sounds/wolf-hit.ogg',
        'sounds/wolf-hit-2.ogg',
        'sounds/wolf-hit.ogg',
      ]);

      this.sounds[SOUND.SWING] = this.loadSound([
        'sounds/swing.ogg',
        'sounds/swing2.ogg',
        'sounds/swing4.ogg',
      ]);

      this.sounds[SOUND.READY] = this.loadSound([
        'sounds/voices/ready1.ogg',
        'sounds/voices/ready2.ogg',
        'sounds/voices/ready3.ogg',
        'sounds/voices/ready4.ogg',
        'sounds/voices/ready5.ogg',
        'sounds/voices/ready7.ogg',
        'sounds/voices/ready8.ogg',
      ]);

      this.sounds[SOUND.YES] = this.loadSound([
        'sounds/voices/yes1.ogg',
        'sounds/voices/yes2.ogg',
        'sounds/voices/yes3.ogg',
        'sounds/voices/yes4.ogg',
        'sounds/voices/yes5.ogg',
      ]);

      this.sounds[SOUND.WOLF_YES] = this.loadSound([
        'sounds/voices/wolf-yes.ogg',
        'sounds/voices/wolf-yes-2.ogg',
      ]);

      this.sounds[SOUND.WOLF_READY] = this.loadSound([
        'sounds/voices/wolf-spawn.ogg',
      ]);

      this.sounds[SOUND.SWORD] = this.loadSound([
        'sounds/sword.ogg',
        'sounds/sword.ogg',
        'sounds/sword.ogg',
        'sounds/sword.ogg',
      ]);

      this.sounds[SOUND.PLACE] = this.loadSound([
        'sounds/clic02.ogg',
      ]);

      this.sounds[SOUND.NEGATIVE] = this.loadSound([
        'sounds/negative_2.ogg',
      ]);

      this.sounds[SOUND.POSITIVE] = this.loadSound([
        'sounds/misc_menu.ogg',
      ]);

      this.sounds[SOUND.CLICK] = this.loadSound([
        'sounds/click1.ogg',
      ]);

      this.sounds[SOUND.CLICK2] = this.loadSound([
        'sounds/click.ogg',
      ]);

      this.sounds[SOUND.BUILD] = this.loadSound([
        'sounds/build.ogg',
      ]);

      this.sounds[SOUND.BUILDING_DEATH] = this.loadSound([
        'sounds/building_destroy.ogg',
        'sounds/building_destroy.ogg',
        'sounds/building_destroy.ogg',
      ]);

      this.sounds[SOUND.REPAIR] = this.loadSound([
        'sounds/hammer1.ogg',
        'sounds/hammer2.ogg',
        'sounds/hammer3.ogg',
        'sounds/hammer1.ogg',
        'sounds/hammer2.ogg',
      ]);

      this.sounds[SOUND.INGAMECLICK] = this.loadSound([
        'sounds/mouseclick1.ogg',
      ]);

      this.sounds[SOUND.BUILDING_FINISHED] = this.loadSound([
        'sounds/building_finished.ogg',
        'sounds/building_finished.ogg',
      ]);

      this.sounds[SOUND.UNDER_ATTACK] = this.loadSound([
        'sounds/under-attack.ogg',
      ]);

      this.sounds[SOUND.VICTORY] = this.loadSound([
        'sounds/yeah.ogg',
      ]);

      this.sounds[SOUND.DEFEAT] = this.loadSound([
        'sounds/defeat.ogg',
      ]);

      this.sounds[SOUND.FLAMESTRIKE_LAUNCH] = this.loadSound([
        'sounds/flamestrike-throw.ogg',
        'sounds/flamestrike-throw.ogg',
        'sounds/flamestrike-throw.ogg',
      ]);

      this.sounds[SOUND.FLAMESTRIKE_IMPACT] = this.loadSound([
        'sounds/flamestrike-impact.ogg',
        'sounds/flamestrike-impact.ogg',
        'sounds/flamestrike-impact.ogg',
      ]);

      this.sounds[SOUND.MAGE_IMPACT] = this.loadSound([
        'sounds/mage-impact.ogg',
        'sounds/mage-impact.ogg',
        'sounds/mage-impact.ogg',
      ]);

      this.sounds[SOUND.MAGE_ATTACK] = this.loadSound([
        'sounds/mage-attack.ogg',
        'sounds/mage-attack.ogg',
        'sounds/mage-attack.ogg',
      ]);

      this.sounds[SOUND.GUN] = this.loadSound([
        'sounds/gun.ogg',
        'sounds/gun.ogg',
      ]);

      this.sounds[SOUND.CATA_HIT] = this.loadSound([
        'sounds/cata-hit.ogg',
        'sounds/cata-hit.ogg',
      ]);

      this.sounds[SOUND.CATA_LAUNCH] = this.loadSound([
        'sounds/catapult-launch.ogg',
        'sounds/catapult-launch-2.ogg',
        'sounds/catapult-launch.ogg',
        'sounds/catapult-launch-2.ogg',
      ]);

      this.sounds[SOUND.CATA_IMPACT] = this.loadSound([
        'sounds/catapult-impact.ogg',
        'sounds/catapult-impact-2.ogg',
        'sounds/catapult-impact-3.ogg',
        'sounds/catapult-impact-4.ogg',
      ]);

      this.sounds[SOUND.BUILDING_PAIN] = this.loadSound([
        'sounds/building-hit.ogg',
        'sounds/building-hit-3.ogg',
        'sounds/building-hit.ogg',
        'sounds/building-hit-3.ogg',
      ]);

      this.sounds[SOUND.CATA_DEATH] = this.loadSound([
        'sounds/catapult_death.ogg',
        'sounds/catapult_death.ogg',
      ]);

      this.sounds[SOUND.GAME_START] = this.loadSound([
        'sounds/gamestart.ogg',
      ]);

      this.sounds[SOUND.HEAL] = this.loadSound([
        'sounds/heal.ogg',
        'sounds/heal.ogg',
      ]);

      this.sounds[SOUND.BING] = this.loadSound([
        'sounds/bing2.ogg',
      ]);

      this.sounds[SOUND.BING2] = this.loadSound([
        'sounds/bing.ogg',
      ]);

      this.sounds[SOUND.SWITCH] = this.loadSound([
        'sounds/switch.ogg',
      ]);

      this.sounds[SOUND.ZIP] = this.loadSound([
        'sounds/zip.ogg',
      ]);

      this.sounds[SOUND.ZIP3] = this.loadSound([
        'sounds/zip3.ogg',
      ]);

      this.sounds[SOUND.SPELL] = this.loadSound([
        'sounds/spell.ogg',
        'sounds/spell.ogg',
      ]);

      this.sounds[SOUND.DRAGON_SPAWN] = this.loadSound([
        'sounds/dragon_spawn.ogg',
        'sounds/dragon_spawn.ogg',
      ]);

      this.sounds[SOUND.DRAGON_DEATH] = this.loadSound([
        'sounds/dragon_death.ogg',
        'sounds/dragon_death.ogg',
      ]);

      this.sounds[SOUND.DRAGON_YES] = this.loadSound([
        'sounds/dragon_yes_1.ogg',
        'sounds/dragon_yes_2.ogg',
        'sounds/dragon_yes_3.ogg',
      ]);

      this.sounds[SOUND.FALL] = this.loadSound([
        'sounds/fall.ogg',
        'sounds/fall.ogg',
      ]);

      this.sounds[SOUND.DRAGON_FIRE] = this.loadSound([
        'sounds/dragon_fire_1.ogg',
        'sounds/dragon_fire_2.ogg',
        'sounds/dragon_fire_1.ogg',
        'sounds/dragon_fire_2.ogg',
      ]);

      this.sounds[SOUND.MINE] = this.loadSound([
        'sounds/mine1.ogg',
        'sounds/mine2.ogg',
        'sounds/mine3.ogg',
        'sounds/mine1.ogg',
        'sounds/mine2.ogg',
      ]);

      this.sounds[SOUND.ROUNDHOUSE] = this.loadSound([
        'sounds/roundhouse.ogg',
        'sounds/roundhouse.ogg',
      ]);

      this.sounds[SOUND.BIGHIT] = this.loadSound([
        'sounds/big-hit.ogg',
        'sounds/big-hit-2.ogg',
        'sounds/big-hit.ogg',
        'sounds/big-hit-2.ogg',
      ]);

      this.sounds[SOUND.STRONG_HIT] = this.loadSound([
        'sounds/strong-hit.ogg',
        'sounds/strong-hit-2.ogg',
      ]);

      this.sounds[SOUND.BEAST_READY] = this.loadSound([
        'sounds/beast-ready.ogg',
      ]);

      this.sounds[SOUND.BEAST_YES] = this.loadSound([
        'sounds/beast-yes.ogg',
        'sounds/beast-yes-2.ogg',
      ]);

      this.sounds[SOUND.BEAST_DIE] = this.loadSound([
        'sounds/beast-die.ogg',
      ]);

      this.sounds[SOUND.FLAK] = this.loadSound([
        'sounds/flak1.ogg',
        'sounds/flak2.ogg',
        'sounds/flak3.ogg',
      ]);

      this.sounds[SOUND.SHOCKWAVE] = this.loadSound([
        'sounds/shockwave.ogg',
        'sounds/shockwave.ogg',
      ]);

      this.sounds[SOUND.FIREBALL] = this.loadSound([
        'sounds/fireball.ogg',
        'sounds/fireball.ogg',
      ]);

      this.sounds[SOUND.SKELETON_PAIN] = this.loadSound([
        'sounds/skeleton-hit.ogg',
        'sounds/skeleton-hit.ogg',
      ]);

      this.sounds[SOUND.SKELETON_YES] = this.loadSound([
        'sounds/skeleton1.ogg',
        'sounds/skeleton3.ogg',
      ]);

      this.sounds[SOUND.SKELETON_SPAWN] = this.loadSound([
        'sounds/skeleton2.ogg',
        'sounds/skeleton2.ogg',
      ]);

      this.sounds[SOUND.AURA_HEAL] = this.loadSound([
        'sounds/heal-aura.ogg',
        'sounds/heal-aura.ogg',
      ]);

      this.sounds[SOUND.PLASMA_SHIELD] = this.loadSound([
        'sounds/plasma-shield.ogg',
        'sounds/plasma-shield2.ogg',
        'sounds/plasma-shield3.ogg',
      ]);

      this.sounds[SOUND.BATTLE_FANFARE] = this.loadSound([
        'sounds/battle-fanfare.ogg',
      ]);

      this.sounds[SOUND.A_WS] = this.loadSound([
        'sounds/buildings/advanced_Workshop.ogg',
      ]);

      this.sounds[SOUND.CC] = this.loadSound([
        'sounds/buildings/cc.ogg',
      ]);

      this.sounds[SOUND.CHURCH] = this.loadSound([
        'sounds/buildings/church.ogg',
      ]);

      this.sounds[SOUND.DRAGONS_LAIR] = this.loadSound([
        'sounds/buildings/dragons_lair.ogg',
      ]);

      this.sounds[SOUND.FORGE] = this.loadSound([
        'sounds/buildings/forge.ogg',
      ]);

      this.sounds[SOUND.HOUSE] = this.loadSound([
        'sounds/buildings/house.ogg',
      ]);

      this.sounds[SOUND.LAB] = this.loadSound([
        'sounds/buildings/lab.ogg',
      ]);

      this.sounds[SOUND.MAGES_GUILD] = this.loadSound([
        'sounds/buildings/magesguild.ogg',
      ]);

      this.sounds[SOUND.RAX] = this.loadSound([
        'sounds/buildings/rax.ogg',
      ]);

      this.sounds[SOUND.WW_DEN] = this.loadSound([
        'sounds/buildings/ww_den.ogg',
      ]);

      this.sounds[SOUND.W_DEN] = this.loadSound([
        'sounds/buildings/w_den.ogg',
      ]);

      this.sounds[SOUND.WORKSHOP] = this.loadSound([
        'sounds/buildings/workshop.ogg',
      ]);

      this.sounds[SOUND.MILL] = this.loadSound([
        'sounds/buildings/mill.ogg',
      ]);

      this.sounds[SOUND.SNAKE_CHARMER] = this.loadSound([
        'sounds/buildings/snake_charmer.ogg',
      ]);

      this.sounds[SOUND.ARMORY] = this.loadSound([
        'sounds/buildings/armory.ogg',
      ]);

      this.sounds[SOUND.AIRSHIP] = this.loadSound([
        'sounds/voices/airship.ogg',
      ]);

      this.sounds[SOUND.ARCHER_READY] = this.loadSound([
        'sounds/voices/archer_ready.ogg',
      ]);

      this.sounds[SOUND.ARCHER] = this.loadSound([
        'sounds/voices/archer1.ogg',
        'sounds/voices/archer2.ogg',
        'sounds/voices/archer3.ogg',
        'sounds/voices/archer2.ogg',
        'sounds/voices/archer1.ogg',
      ]);

      this.sounds[SOUND.BALLISTA] = this.loadSound([
        'sounds/voices/ballista.ogg',
      ]);

      this.sounds[SOUND.CALTROP] = this.loadSound([
        'sounds/voices/caltrop.ogg',
      ]);

      this.sounds[SOUND.CATAPULT] = this.loadSound([
        'sounds/voices/catapult.ogg',
      ]);

      this.sounds[SOUND.GATLING_GUN] = this.loadSound([
        'sounds/voices/gatlinggun.ogg',
      ]);

      this.sounds[SOUND.GYROCRAFT_READY] = this.loadSound([
        'sounds/voices/gyro_ready1.ogg',
        'sounds/voices/gyro_ready2.ogg',
      ]);

      this.sounds[SOUND.MAGE_READY] = this.loadSound([
        'sounds/voices/mage_ready.ogg',
      ]);

      this.sounds[SOUND.MAGE] = this.loadSound([
        'sounds/voices/mage1.ogg',
        'sounds/voices/mage2.ogg',
        'sounds/voices/mage3.ogg',
        'sounds/voices/mage2.ogg',
        'sounds/voices/mage1.ogg',
      ]);

      this.sounds[SOUND.PRIEST] = this.loadSound([
        'sounds/voices/priest1.ogg',
        'sounds/voices/priest2.ogg',
        'sounds/voices/priest3.ogg',
        'sounds/voices/priest1.ogg',
        'sounds/voices/priest3.ogg',
      ]);

      this.sounds[SOUND.RAIDER] = this.loadSound([
        'sounds/voices/raider1.ogg',
        'sounds/voices/raider2.ogg',
        'sounds/voices/raider3.ogg',
        'sounds/voices/raider2.ogg',
        'sounds/voices/raider1.ogg',
      ]);

      this.sounds[SOUND.SOLDIER] = this.loadSound([
        'sounds/voices/soldier1.ogg',
        'sounds/voices/soldier2.ogg',
        'sounds/voices/soldier3.ogg',
        'sounds/voices/soldier2.ogg',
        'sounds/voices/soldier1.ogg',
      ]);

      this.sounds[SOUND.GYROCRAFT_YES] = this.loadSound([
        'sounds/voices/gyro_yes1.ogg',
        'sounds/voices/gyro_yes2.ogg',
        'sounds/voices/gyro_yes3.ogg',
        'sounds/voices/gyro_yes4.ogg',
      ]);

      this.sounds[SOUND.GYROCRAFT_PAIN] = this.loadSound([
        'sounds/voices/gyro_hurt1.ogg',
        'sounds/voices/gyro_hurt2.ogg',
      ]);

      this.buildingClickSound = [];
    };

    SoundManager.prototype.loadSound = function (files) {
      var target = [];

      for (var i = 0; i < files.length; i++) {
        target.push(new Audio(files[i]));
      }

      return target;
    };


    SoundManager.prototype.playSound = function (sound, volume = 1, isUnitClickSound = false) {
      // if sound is disabled (by the user in options) return
      if (!(this.volume.get() > 0) || !this.sounds[sound]) {
        return;
      }

      if (volume <= 0) {
        return;
      }

      var s = this.sounds[sound];
      var readySounds = [];

      // find sound(s), which are / is ready
      for (var i = 0; i < s.length; i++) {
        if (s[i].currentTime >= s[i].duration || s[i].currentTime == 0 || !s[i].currentTime) {
          readySounds.push(s[i]);
        }
      }

      // all sounds still in use, return
      if (readySounds.length == 0) {
        return;
      }

      // random one of the ready sounds
      var soundToPlay = readySounds[Math.floor(Math.random() * readySounds.length)];

      // play sound
      // soundToPlay.load();
      soundToPlay.loop = false;
      // soundToPlay.currentTime = 0;
      soundToPlay.play();
      soundToPlay.volume = volume * this.volume.get();

      if (isUnitClickSound) {
        this.buildingClickSound.push({
          sound: soundToPlay,
          maxVolume: soundToPlay.volume,
        });
      }
    };

    module.exports = new SoundManager();

  }, { "./LocalConfig.js": 3, "./data/Sound.js": 6 }], 5: [function (require, module, exports) {
    soundManager = require('./SoundManager.js');
    const SOUND = require('./data/Sound.js');

    // a html div, that has children
    function UIWindow(id, condition, closeable, title, draggable, onKey, onClose) {
      this.id = id;

      this.domElement = document.createElement('div');
      this.domElement.id = id;
      this.domElement.className = 'ingameWindow' + (draggable ? ' draggable' : '');
      this.draggable = draggable;
      if (condition) {
        this.domElement.style.display = 'none';
        this.active = true; // some elements are closable; it not closable, this is always true
        this.condition = condition; // decides if this should be drawn
        // TODO: MOVE THIS.CONDITION OUT OF HERE - CURRENTLY BREAKS EVERYTHING
      }
      document.body.appendChild(this.domElement);

      this.onKey = onKey;

      // if this is true, the windiw has a "x" button for closing in the corner
      if (closeable) {
        this.active = false;
        this.wasActiveLastFrame = false;

        // create close button
        var closeButton = document.createElement('button');
        closeButton.className = 'closeButton';
        closeButton.innerHTML = 'X';
        this.closeButton = closeButton;
        closeButton.parent_ = this;
        closeButton.onclick = function () {
          soundManager.playSound(SOUND.CLICK);
          this.parent_.active = false;
          closeButton.parent_.fadeOut($(this.parent_.domElement));
          if (onClose) {
            onClose();
          }

          if (this.parent_.domElement.id == 'infoWindow2') {
            setTimeout(showAchievement, 1000); // TODO: Bug found. showAchievement is undefined. No read access to showAchievement or storedAchievements
          }
        };

        // make it close on escape
        this.domElement.parent_ = this;
        this.domElement.onkeydown = function (e) {
          if (keyManager.getKeyCode(e) == KEY.ESC) {
            soundManager.playSound(SOUND.CLICK);
            this.parent_.active = false;
            closeButton.parent_.fadeOut($(this.closeButton.domElement));

            if (this.parent_.domElement.id == 'infoWindow2') {
              setTimeout(showAchievement, 1000);
            } // TODO: showAchievement is undefined. No read access to showAchievement or storedAchievements
          }
        };

        // add it to the window
        this.domElement.appendChild(closeButton);
      }

      // if a title is set
      if (title) {
        var title_ = document.createElement('h2');
        title_.innerHTML = '&raquo; ' + title;
        title_.className = 'windowTitle';
        this.title = title_;
        this.domElement.appendChild(title_);
      }

      // head rider
      this.head_rider = document.createElement('div');
      this.head_rider.className = 'head_rider';
      this.domElement.appendChild(this.head_rider);

      this.blocksCanvas = true;
      // elements.push(this);
      // TODO: ADD THIS - currently divs default to visible so this causes issues.
    };

    // [DEPRECATE] Use setTitleText + setTitleStyle + setRider instead
    UIWindow.prototype.setTitle = function (newTitle, head_rider) {
      this.head_rider.innerHTML = head_rider ? head_rider : '';

      var h2s = this.domElement.getElementsByTagName('h2');

      if (h2s.length == 0) {
        return;
      }

      h2s[0].innerHTML = newTitle;
    };

    UIWindow.prototype.setTitleText = function (title) {
      if (this.title) {
        this.title.textContent = title;
      }
    };

    UIWindow.prototype.setTitleTitle = function (title) {
      if (this.title) {
        this.title.title = title;
      }
    };

    UIWindow.prototype.setTitleStyle = function (style) {
      if (!this.title) {
        return;
      }
      this.title.className = style;
    };

    UIWindow.prototype.setHeadRider = function (riderBuilder) {
      riderBuilder.insertInto(this.head_rider);
    };

    UIWindow.prototype.setRider = function (riderBuilder) {
      riderBuilder.insertInto('#riderDiv');
    };

    UIWindow.prototype.setCloseButtonStyle = function (style) {
      this.closeButton.className = style;
    };

    UIWindow.prototype.setBackgroundStyle = function (style) {
      this.domElement.className = style;
      this.closeButton.className = style;
    };

    // adds a scrollable subdiv to the parent div, which covers most of the div, usually used for text content (chat window for example)
    UIWindow.prototype.addScrollableSubDiv = function (id) {
      var textArea = document.createElement('div');
      textArea.className = 'textContainer';
      textArea.id = id;
      this.domElement.appendChild(textArea);
      return textArea;
    };

    UIWindow.prototype.addSubDiv = function (id) {
      const div = document.createElement('div');
      div.id = id;
      this.domElement.appendChild(div);
      return div;
    };

    // called every frame; checks if this element should be drawn and then does so
    UIWindow.prototype.refreshVisibility = function () {
      if (this.active && this.condition()) {
        if (this.wasActiveLastFrame) {
          return this.blocksCanvas;
        }

        this.wasActiveLastFrame = true;
        this.domElement.style.display = 'inline';
        this.domElement.style.opacity = 1;

        // if the window contains an input, set focus on it
        var inputs = this.domElement.getElementsByTagName('input');
        if (inputs[0]) {
          inputs[0].focus();
          var val = inputs[0].value;
          inputs[0].value = '-';
          inputs[0].value = val;
        }
        return this.blocksCanvas;
      }

      if (!this.wasActiveLastFrame) {
        return false;
      }

      this.wasActiveLastFrame = false;
      this.domElement.style.display = 'none';
      return false;
    };

    // Duplicated in functions.js for other elements
    UIWindow.prototype.fadeOut = function (jQueryElement) {
      if (jQueryElement[0].style.display == 'none') {
        return;
      }

      jQueryElement[0].style.display = 'inline';

      jQueryElement.css({
        opacity: 1,
      }).animate({
        opacity: 0,
        top: (parseInt(jQueryElement.css('top')) + 30) + 'px',
      }, 200, function () {
        jQueryElement.css({
          display: 'none',
          top: (parseInt(jQueryElement.css('top')) - 30) + 'px',
        });
      });

      if (jQueryElement.attr('id') == 'infoWindow2') {
        this.fadeOut($('#darkScreenDiv'));
      }
    };

    module.exports = UIWindow;


  }, { "./SoundManager.js": 4, "./data/Sound.js": 6 }], 6: [function (require, module, exports) {

    const SOUND = Object.freeze({
      NONE: 0,
      PAIN: 1,
      DEATH: 2,
      SWING: 3,
      PLACE: 4,
      POSITIVE: 5,
      NEGATIVE: 6,
      CLICK: 7,
      CLICK2: 8,
      GUN: 9,
      SWORD: 10,
      BUILD: 11,
      BUILDING_DEATH: 12,
      READY: 13,
      YES: 14,
      INGAMECLICK: 15,
      BUILDING_FINISHED: 16,
      UNDER_ATTACK: 17,
      VICTORY: 18,
      DEFEAT: 19,
      FLAMESTRIKE_LAUNCH: 20,
      FLAMESTRIKE_IMPACT: 21,
      MAGE_ATTACK: 22,
      MAGE_IMPACT: 23,
      CATA_HIT: 24,
      CATA_LAUNCH: 25,
      CATA_IMPACT: 26,
      BUILDING_PAIN: 27,
      REPAIR: 28,
      CATA_DEATH: 29,
      GAME_START: 30,
      HEAL: 31,
      BING: 32,
      SWITCH: 33,
      ZIP: 34,
      ZIP3: 35,
      SPELL: 36,
      DRAGON_YES: 37,
      DRAGON_SPAWN: 38,
      DRAGON_DEATH: 39,
      FALL: 40,
      DRAGON_FIRE: 41,
      MINE: 42,
      WOLF_YES: 43,
      WOLF_READY: 44,
      WOLF_DEATH: 45,
      WOLF_HIT: 46,
      WOLF_PAIN: 47,
      LADDER_START: 48,
      ROUNDHOUSE: 49,
      BIGHIT: 50,
      STRONG_HIT: 51,
      BEAST_DIE: 52,
      BEAST_YES: 53,
      BEAST_READY: 54,
      FLESH: 55,
      FLAK: 56,
      SHOCKWAVE: 57,
      FIREBALL: 58,
      SKELETON_SPAWN: 59,
      SKELETON_YES: 60,
      SKELETON_PAIN: 61,
      BING2: 62,
      ARCHIVEMENT: 63,
      ARCHIVEMENT2: 64,
      ARCHIVEMENT3: 65,
      AURA_HEAL: 66,
      PLASMA_SHIELD: 67,
      WARP: 68,
      BIRD_SPAWN: 69,
      BIRD_YES: 70,
      BIRD_DEATH: 71,
      BIRD_SLAM: 72,
      BATTLE_FANFARE: 73,
      A_WS: 74,
      CC: 75,
      CHURCH: 76,
      DRAGONS_LAIR: 77,
      FORGE: 78,
      HOUSE: 79,
      LAB: 80,
      MAGES_GUILD: 81,
      RAX: 82,
      WW_DEN: 83,
      W_DEN: 84,
      WORKSHOP: 85,
      MILL: 86,
      SNAKE_CHARMER: 87,
      ARMORY: 88,
      AIRSHIP: 89,
      ARCHER_READY: 90,
      ARCHER: 91,
      BALLISTA: 92,
      CALTROP: 93,
      CATAPULT: 94,
      GATLING_GUN: 95,
      GYROCRAFT_READY: 96,
      MAGE_READY: 97,
      MAGE: 98,
      PRIEST: 99,
      RAIDER: 100,
      SOLDIER: 101,
      GYROCRAFT_YES: 102,
      GYROCRAFT_PAIN: 103,
    });

    module.exports = SOUND;

  }, {}], 7: [function (require, module, exports) {
    (function (Buffer) {
      (function () {
        // TODO: deduplicate this with server when/if we merge server and client repos

        const Compression = (() => {
          const zlib = require('minizlib');

          function compress(str) {
            return new zlib.Deflate().end(str).read();
          }

          function decompress(bytes) {
            try {
              return new zlib.Inflate().end(bytes).read().toString();
            } catch (e) {
              return null;
            }
          }

          function buf2str(buf) {
            return buf.toString('binary');
          }

          function str2buf(str) {
            return Buffer.from(str, 'binary');
          }

          return {
            compress,
            decompress,
            buf2str,
            str2buf,
            compressToString: (str) => buf2str(compress(str)),
            decompressFromString: (str) => decompress(str2buf(str)),
          };
        })();

        const Initialization = (() => {
          const Stage = Object.freeze({
            NO_DEPENDENCY: 0,
            UI_GENERATED: 1,
            RESOURCES_LOADED: 2,
            INITIALIZATION_COMPLETE: 3,
          });

          const callbacks = {};
          let totalResources = 0;
          let pendingResources = 0;
          let currentStage = Stage.NO_DEPENDENCY;

          function __registerCallback(callback, stage) {
            if (!(stage in callbacks)) {
              callbacks[stage] = [];
            }

            callbacks[stage].push(callback);
          }

          function onDocumentReady(callback) {
            __registerCallback(callback, Stage.NO_DEPENDENCY);
          }

          function onUIGenerated(callback) {
            __registerCallback(callback, Stage.UI_GENERATED);
          }

          function onResourcesLoaded(callback) {
            __registerCallback(callback, Stage.RESOURCES_LOADED);
          }

          function onInitializationComplete(callback) {
            __registerCallback(callback, Stage.INITIALIZATION_COMPLETE);
          }

          async function runCallbacks(stage) {
            currentStage = stage;
            if (!callbacks[stage]) {
              return;
            }
            await Promise.all(callbacks[stage].map((cb) => cb()));
          }

          function addPendingResource() {
            ++totalResources;
            ++pendingResources;
          }

          function loadedPendingResource() {
            --pendingResources;

            // display % loaded
            const percent = (totalResources - pendingResources) / totalResources;
            c.fillRect(WIDTH / 2 - 296, HEIGHT - 146, 592 * percent, 42);

            if (pendingResources == 0) {
              // setTimeout used to prevent out of order execution, since
              // callbacks from previous stages can trigger pendingResources to
              // hit 0
              setTimeout(async () => {
                await runCallbacks(Stage.RESOURCES_LOADED);
                await runCallbacks(Stage.INITIALIZATION_COMPLETE);
              });
            }
          }

          function getStage() {
            return currentStage;
          }

          $(document).ready(() => {
            // jQuery cannot handle async callbacks unless we upgrade the version,
            // but this causes a tooltip visual bug that is out of the scope of this
            // change
            // TODO: upgrade the jQuery version
            runCallbacks(Stage.NO_DEPENDENCY).then(() => runCallbacks(Stage.UI_GENERATED));
          });

          return { onDocumentReady, onUIGenerated, onResourcesLoaded, onInitializationComplete, Stage, addPendingResource, loadedPendingResource, getStage };
        })();

        const AIManager = (() => {
          const names = {};
          const customNames = new Set();
          const manifests = {};
          let aiCommit;

          // Register a pending resource for the manifest and commit
          Initialization.addPendingResource();

          async function sendAIToWorker(commit, name, code, isCustom) {
            try {
              await WorkerClient.call('load-ai', {
                commit: commit,
                name: name,
                code: code,
              });
            } catch (e) {
              displayInfoMsg(`Error parsing AI file: ${e}`);
              return false;
            }

            if (isCustom) {
              interface_.lastChosenAI.set(name);
              displayInfoMsg(`AI has been loaded as "${name}". To play it, start a singleplayer game and select the AI for one or more of the CPU players.`);

              customNames.add(name);
            } else {
              if (!(commit in names)) {
                names[commit] = new Set();
              }
              names[commit].add(name);
            }
            return true;
          }

          async function loadManifest(commit) {
            if (commit in manifests) {
              return manifests[commit];
            }
            manifests[commit] = JSON.parse(await httpGet(`https://raw.githubusercontent.com/littlewargame/customai/${commit}/manifest.json`));
            return manifests[commit];
          }

          // @brief Loads the AI from the given commit with the given name. Leaving name
          // unspecified will load all AIs, as will "Random AI".
          async function loadAI(commit, name = undefined) {
            const manifest = await loadManifest(commit);
            if (!name || name == 'Random AI') {
              // Just load 'em all!
              const results = await Promise.all(manifest.map((ai) => loadAI(commit, ai.name)));
              return results.every(Boolean);
            }

            const ai = manifest.find((ai) => ai.name == name);
            if (!ai) {
              displayInfoMsg(`Failed to find AI named ${name} in commit ${commit}`);
              return false;
            }
            if (commit in names && names[commit].has(name)) {
              return true;
            }
            let code;
            try {
              code = await httpGet(`https://raw.githubusercontent.com/littlewargame/customai/${commit}/${ai.src}`);
            } catch (e) {
              return false;
            }
            return await sendAIToWorker(commit, name, code, /* isCustom=*/false);
          }

          async function init() {
            try {
              aiCommit = await httpGet('https://sockets.littlewargame.com:8084/ai_commit');
              await WorkerClient.call('set-ai-commit', { aiCommit: aiCommit });

              const manifest = await loadManifest(aiCommit);
              await Promise.all(manifest.map(async (ai) => {
                Initialization.addPendingResource();
                const code = await httpGet(`https://raw.githubusercontent.com/littlewargame/customai/${aiCommit}/${ai.src}`);
                await sendAIToWorker(aiCommit, ai.name, code, /* isCustom=*/false);
                Initialization.loadedPendingResource();
              }));
            } catch (e) {
              console.log(`Failed to load AIs: ${e}`);
              return;
            }

            // We got the manifest and commit
            Initialization.loadedPendingResource();
          }

          function getAICommit() {
            return aiCommit;
          }

          function getNames(includeRegularAI, includeCustomAI, commit = undefined) {
            if (!commit) {
              commit = aiCommit;
            }
            const regularAIs = includeRegularAI ? [...names[commit]] : [];
            const customAIs = includeCustomAI ? [...customNames] : [];
            return regularAIs.concat(customAIs);
          }

          // Called when a user uploads an AI file in the main thread
          async function sendCustomAIToWorker(code) {
            const aiNum = customNames.size + 1;
            const name = `Custom AI ${aiNum}`;
            sendAIToWorker('', name, code, /* isCustom=*/true);
          }

          Initialization.onDocumentReady(init);

          return { getAICommit, getNames, loadAI, sendCustomAIToWorker };
        })();

        const Changelog = (() => {
          function Changelog_() {
            Initialization.onDocumentReady(() => this.init());
            this.__html = null;
          }

          Changelog_.prototype.init = function () {
            $.ajax('Changelog.html').then((data) => this.__html = data);

            new HTMLBuilder()
              .add(`
            <div id='changelogDiv'>
                <div id='changelogContents'></div>
                <div id='changelogFadeTop' class='changelogFade'></div>
                <div id='changelogFadeBottom' class='changelogFade'></div>
            </div>
        `)
              .addHook(() => $('#changelogDiv').click(function (e) {
                if ($(this).is(e.target)) {
                  fadeOut($('#changelogDiv'));
                }
              }))
              .appendInto(document.body);
          };

          // Inserts a unit or building image into the provided <td> element
          // The <td> is expected to have property data-name with the id_string of the graphic object
          Changelog_.prototype.__insertUnitImage = function (el) {
            const isUnit = $(el).attr('data-type') == 'unit';
            const size = isUnit ? 180 : 80;
            const imgKey = isUnit ? 'idle' : 'img';

            const img = unit_imgs[$(el).attr('data-name')];
            const file = img.file[1];

            // TODO: this is copy-pasted in many places and should be centralized
            let w = img[imgKey].frameWidth;
            let h = img[imgKey].h / img._angles;
            if (w > h) {
              h = size * (h / w);
              w = size;
            } else {
              w = size * (w / h);
              h = size;
            }
            const w2 = file.width * (w / img[imgKey].frameWidth);
            const h2 = file.height * (h * img._angles / img[imgKey].h);
            const x = img[imgKey].x * (w2 / file.width);
            const y = img[imgKey].y * (h2 / file.height);

            $(el).html(`
        <div style='width: ${w}px; height: ${h}px; overflow: hidden'>
        <img src='${file.toDataURL()}' style='position: absolute; width: ${w2}px; height: ${h2}px; left: ${-x}px; top: ${-y}px'></img>
        </div>
    `);
          };

          Changelog_.prototype.tryShow = function (showImmediately = false) {
            if (!showImmediately) {
              return;
            }

            const show = () => {
              // Wait for the HTML to load if it hasn't loaded
              if (!this.__html) {
                setTimeout(show, 500);
                return;
              }

              $('#changelogContents').html(this.__html);

              // Insert all unit images
              const self = this;
              $('.infoImage').each(function () {
                self.__insertUnitImage(this);
              });

              // Add links
              $('.changelogLink').each(function () {
                const targetID = $(this).attr('data-target');
                $(this).click(() => setTimeout(() => {
                  document.getElementById(targetID).scrollIntoView({ behavior: 'smooth' });
                  $('.jumpTarget').removeClass('highlightedFromJump');
                  $(`#${targetID}`).addClass('highlightedFromJump');
                }, 0));
              });

              fadeIn($('#changelogDiv'));
            };
            setTimeout(show, showImmediately ? 0 : 1000);
          };

          return new Changelog_();
        })();

        // Uncomment when making private and add Initialization
        // const UIWindow = require('./UIWindow.js');
        // const assert = require('./Assert.js');
        // const { generateButton } = require('./functions-new.js');
        // const HTMLBuilder = require('./HTMLBuilder.js');

        const LOCAL_STORAGE_KEY_NAME_HOTKEYS = 'hotkeys';

        class HotkeySetting {
          constructor(name, defaultValue, id = null) {
            this.name = name;
            this.id = id ?? name;
            this.defaultValue = defaultValue;
            this.data = {};
          }

          setData(key, value) {
            this.data[key] = value;
            return this;
          }

          getData(key) {
            return this.data[key];
          }

          __getObjectKey(prefix) {
            return `${prefix}${this.id}`;
          }

          __loadFromObject(obj, prefix) {
            this.value = obj[this.__getObjectKey(prefix)] ?? this.defaultValue;
            if (this.input) {
              this.input.val(getKeyName(this.value));
            }
          }

          __saveToObject(obj, prefix) {
            if (this.value != this.defaultValue) {
              obj[this.__getObjectKey(prefix)] = this.value;
            }
          }

          __reset(prefix) {
            this.value = this.defaultValue;
            this.__refreshUI();
          }

          __refreshUI() {
            assert(this.input && this.text);
            this.input.val(getKeyName(this.value));
            this.input.blur();
            this.input.removeClass('hotkeyInputActive');
            this.text.toggleClass('yellowfont', this.value != this.defaultValue);
          }

          __generateUI(onChangeCallback) {
            const textID = uniqueID();
            const inputID = uniqueID();

            return new HTMLBuilder()
              .add(`
                <p class='hotkeyEntry' id='${textID}'>${this.name}
                    <input type='text' id='${inputID}' class='hotkeyInput' style="width: 80px;" readonly></input>
                </p>`)
              .addHook(() => this.text = $(`#${textID}`))
              .addHook(() => this.input = $(`#${inputID}`))
              .addHook(() => this.input.click(() => {
                const deactivateAllInputs = () => {
                  $('.hotkeyInput').removeClass('hotkeyInputActive');
                  $('.hotkeyInput').off('keydown');
                  $('.hotkeyInput').off('blur');
                };
                deactivateAllInputs();

                // Start listening for a key, and disable if they click outside of the input
                this.input.focus();
                this.input.addClass('hotkeyInputActive');
                this.input.keydown((e) => {
                  this.value = keyManager.getKeyCode(e);
                  this.__refreshUI();
                  onChangeCallback();
                });
                this.input.blur(() => deactivateAllInputs());
              }))
              .addHook(() => this.__refreshUI());
          }
        }

        class HotkeyGroup {
          // Parameter containsGroups determines whether or not this HotkeyGroup contains only HotkeyGroups
          // A value of true means that it does, and a value of false means it contains only HotkeySettings
          constructor(name, containsGroups, description = '', id = null) {
            this.name = name;
            this.id = id ?? name;
            this.containsGroups = containsGroups;
            this.description = description;

            this.children = {};
          }

          addChild(c, insertAtBeginning) {
            assert(!(c.id in this.children));
            if (this.containsGroups) {
              assert(c instanceof HotkeyGroup);
            } else {
              assert(c instanceof HotkeySetting);
            }

            if (insertAtBeginning) {
              this.children = { [c.id]: c, ...this.children };
            } else {
              this.children[c.id] = c;
            }
            return this;
          }

          getHotkeyValue(id) {
            assert(!this.containsGroups);
            assert(id in this.children);
            return this.children[id].value;
          }

          forEach(c) {
            assert(!this.containsGroup);
            let i = 0;
            for (let id in this.children) {
              c(this.children[id], i++);
            }
          }

          // Returns the HotkeySetting or HotkeyGroup corresponding to the traversal down the tree defined by
          // the provided list of group and setting IDs
          __getHotkeyGroup(ids) {
            assert(ids.length > 0);
            assert(ids[0] in this.children);

            if (ids.length == 1) {
              return this.children[ids[0]];
            } else {
              return this.children[ids[0]].getChild(ids.slice(1));
            }
          }

          __loadFromObject(obj, prefix = '') {
            Object.values(this.children).forEach((c) => c.__loadFromObject(obj, `${prefix}${this.id}`));
          }

          __saveToObject(obj, prefix = '') {
            Object.values(this.children).forEach((c) => c.__saveToObject(obj, `${prefix}${this.id}`));
          }

          __reset(prefix = '') {
            Object.values(this.children).forEach((c) => c.__reset(`${prefix}${this.id}`));
          }

          __exportHotkeys() {
            let hotkeyString = localStorage.getItem(LOCAL_STORAGE_KEY_NAME_HOTKEYS);
            const blob = new Blob([hotkeyString], { encoding: 'UTF-8', type: 'text/plain;charset=utf-8' });
            saveAs(blob, 'lwg_hotkeys.file');
          }

          __importHotkeys(hotkeysClass) {
            fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.click();

            fileInput.onchange = () => {
              const file = fileInput.files[0];
              if (file) {
                const reader = new FileReader();
                reader.addEventListener(
                  'load',
                  () => {
                    let hotkeysFile = reader.result;
                    localStorage.setItem(LOCAL_STORAGE_KEY_NAME_HOTKEYS, hotkeysFile);
                    hotkeysClass.init();
                  },
                  false,
                );

                reader.readAsText(file);
              }
            };
          }

          __generateUI(onChangeCallback, depth = 0) {
            assert(depth <= 2);
            const headingClass = {
              0: 'invis',
              1: 'hotkeyHeadline',
              2: 'hotkeySectionTitle',
            };

            // Closure variable that keeps track of whether or not the children are visible
            let isCollapsed = depth > 0; // Root element is not collapsed

            const headingID = uniqueID();
            const collapseButtonID = uniqueID();
            const collapsibleDivID = uniqueID();
            const builder = new HTMLBuilder()
              .add(`
                <div id='${headingID}' class='${headingClass[depth]}'>
                    ${this.name} <button id='${collapseButtonID}'>+</button>
                </div>
            `)
              .addHook(() => $(`#${collapseButtonID}`).click(() => {
                if (isCollapsed) {
                  $(`#${collapsibleDivID}`).removeClass('invis');
                  $(`#${collapseButtonID}`).text('-');
                  isCollapsed = false;
                } else {
                  $(`#${collapsibleDivID}`).addClass('invis');
                  $(`#${collapseButtonID}`).text('+');
                  isCollapsed = true;
                }
              }));

            builder.add(`<div id='${collapsibleDivID}'>`);
            if (this.description) {
              builder.add(`<div class='hotkeyGroupDescription'>${this.description}</div>`);
            }

            Object.values(this.children).forEach((c) => builder.add(c.__generateUI(onChangeCallback, depth + 1)));
            builder.add('</div>');

            if (isCollapsed) {
              builder.addHook(() => $(`#${collapsibleDivID}`).addClass('invis'));
            }

            return builder;
          }
        }

        // To add a custom hotkey, use the function registerHotkeyGroup or modify an existing HotkeyGroup
        // To get the hotkey value, use getHotkeyValue from the parent HotkeyGroup,
        //  and getHotkeyGroup to get the group by name if necessary
        // Hotkey values should only be read from within a onHotkeysChanged callback,
        //  which is guaranteed to be called on page load and whenever hotkeys are changed
        const Hotkeys = (() => {
          function Hotkeys_() {
            Initialization.onDocumentReady(() => this.init());
            this.__hotkeys = new HotkeyGroup('', true);
            this.__onChangedListeners = {};

            // Initialize the localStorage entry to an empty object if it does not exist
            if (!localStorage.getItem(LOCAL_STORAGE_KEY_NAME_HOTKEYS)) {
              localStorage.setItem(LOCAL_STORAGE_KEY_NAME_HOTKEYS, Compression.compressToString('{}'));
            }
          }

          Hotkeys_.prototype.registerHotkeyGroup = function (group, insertAtBeginning) {
            this.__hotkeys.addChild(group, insertAtBeginning);
          };

          Hotkeys_.prototype.onHotkeysChanged = function (id, callback) {
            this.__onChangedListeners[id] = callback;
          };

          Hotkeys_.prototype.removeHotkeysChangedListener = function (id) {
            delete this.__onChangedListeners?.[id];
          };

          // Returns the HotkeyGroup corresponding to the provided depth-first traversal down the tree
          // The traversal must be composed of the IDs of each HotkeyGroup, and must be non-empty
          // Asserts on failure
          Hotkeys_.prototype.getHotkeyGroup = function (ids) {
            return this.__hotkeys.__getHotkeyGroup(ids);
          };

          Hotkeys_.prototype.init = function () {
            // Load the hotkeys from localStorage and notify all listeners
            let obj = {};
            try {
              const data = Compression.decompressFromString(localStorage.getItem(LOCAL_STORAGE_KEY_NAME_HOTKEYS));
              if (data) {
                obj = JSON.parse(data);
              }
            } catch (e) { }
            this.__hotkeys.__loadFromObject(obj);
            for (const id in this.__onChangedListeners) {
              this.__onChangedListeners[id]();
            }

            this.__initUI();
          };

          Hotkeys_.prototype.__initUI = function () {
            this.window = new UIWindow('customHotkeysWindow', () => true, true, 'Hotkeys', true);
            this.window.addScrollableSubDiv('customHotkeysWindowSubdiv');

            const onChangeCallback = () => {
              const obj = {};
              this.__hotkeys.__saveToObject(obj);
              localStorage.setItem(LOCAL_STORAGE_KEY_NAME_HOTKEYS, Compression.compressToString(JSON.stringify(obj)));
              for (const id in this.__onChangedListeners) {
                this.__onChangedListeners[id]();
              }
            };

            if ($('#resetHotkeysButton').length == 0) {
              generateButton('resetHotkeysButton', null, null, addClickSound(() => {
                const ID = uniqueID();
                displayInfoMsg(new HTMLBuilder()
                  .add('Reset all hotkeys to default?<br><br>')
                  .add(generateButton(null, null, null, addClickSound(() => {
                    this.__hotkeys.__reset();
                    $('#infoWindow').hide();
                    onChangeCallback();
                  }), 'reset')));
              }), 'Reset').appendInto('#customHotkeysWindow');
            }


            if ($('#exportHotkeysButton').length == 0) {
              generateButton('exportHotkeysButton', null, null, addClickSound(() => {
                this.__hotkeys.__exportHotkeys();
              }), 'Export').appendInto('#customHotkeysWindow');
            }


            if ($('#importHotkeysButton').length == 0) {
              generateButton('importHotkeysButton', null, null, addClickSound(() => {
                this.__hotkeys.__importHotkeys(this);
              }), 'Import').appendInto('#customHotkeysWindow');
            }

            this.__hotkeys.__generateUI(onChangeCallback, 0).insertInto('#customHotkeysWindowSubdiv');
          };

          Hotkeys_.prototype.showWindow = function () {
            fadeIn($(this.window.domElement));
          };

          return new Hotkeys_();
        })();


        // const Hotkeys = new Hotkeys();

        // module.exports.HotkeyGroup = HotkeyGroup;
        // module.exports.HotkeySetting = HotkeySetting;
        // module.exports.Hotkeys = Hotkeys_;

        var emotes = /* emotesstart*/
          [
            {
              'name': 'Kappa',
              'img': 'kappa.png',
              'free': true,
              'text': 'Kappa',
              'type': 'emotes',
            },

            {
              'name': 'Apple',
              'img': 'apple.png',
              'free': true,
              'text': 'Apple',
              'type': 'emotes',
            },

            {
              'name': 'GG',
              'img': 'gg.png',
              'free': true,
              'text': 'GG',
              'type': 'emotes',
            },

            {
              'name': 'Nr. 1',
              'img': 'nr1.png',
              'playerLvl': 2,
              'text': '#1',
              'type': 'emotes',
              'dbPos': 1,
              'artNr': 'e0001',
            },

            {
              'name': 'OP',
              'img': 'op.png',
              'playerLvl': 6,
              'text': 'OP',
              'type': 'emotes',
              'dbPos': 2,
              'artNr': 'e0002',
            },

            {
              'name': 'Jbs pls fix',
              'img': 'jbsplsfix.png',
              'price': 0.79,
              'text': 'JbsPlsFix',
              'type': 'emotes',
              'dbPos': 3,
              'artNr': 'e0003',
            },

            {
              'name': 'Doge',
              'img': 'doge.png',
              'gold': 800,
              'text': 'Doge',
              'type': 'emotes',
              'dbPos': 4,
              'artNr': 'e0004',
            },

            {
              'name': 'Nyan Cat',
              'img': 'nyancat.png',
              'gold': 800,
              'text': 'Nyancat',
              'type': 'emotes',
              'dbPos': 5,
              'artNr': 'e0005',
            },

            {
              'name': 'WTF?',
              'img': 'wtf.png',
              'gold': 1000,
              'text': 'WTF',
              'type': 'emotes',
              'dbPos': 6,
              'artNr': 'e0006',
            },

            {
              'name': 'You Dont Say',
              'img': 'youdontsay.png',
              'price': 0.79,
              'text': 'YouDontSay',
              'type': 'emotes',
              'dbPos': 8,
              'artNr': 'e0008',
            },

            {
              'name': 'Fuuuuuuu',
              'img': 'fuu.png',
              'gold': 1500,
              'text': 'FU',
              'type': 'emotes',
              'dbPos': 9,
              'artNr': 'e0009',
            },

            {
              'name': 'Pie',
              'img': 'pie.png',
              'free': true,
              'text': 'pielons',
              'type': 'emotes',
            },

            {
              'name': 'Soldier',
              'img': 'soldier.png',
              'free': true,
              'text': 'Soldier',
              'type': 'emotes',
            },

            {
              'name': 'Skeleton',
              'img': 'skeleton.png',
              'playerLvl': 9,
              'text': 'Skeleton',
              'type': 'emotes',
              'dbPos': 10,
              'artNr': 'e0010',
            },

            {
              'name': 'Priest',
              'img': 'priest.gif',
              'price': 0.79,
              'text': 'Priest',
              'type': 'emotes',
              'dbPos': 11,
              'artNr': 'e0011',
            },

            {
              'name': 'Wolf',
              'img': 'wolf.png',
              'free': true,
              'text': 'Wolf',
              'type': 'emotes',
            },

            {
              'name': 'ItanoCircus',
              'img': 'itano.png',
              'text': 'ItanoCircus',
              'dbPos': 12,
              'price': 0.79,
              'artNr': 'e0012',
              'type': 'emotes',
            },

            {
              'name': 'Dirty Itano Money',
              'img': 'dirtyitanomoney.png',
              'text': 'DirtyItanoMoney',
              'price': 1.09,
              'type': 'emotes',
              'dbPos': 13,
              'artNr': 'e0013',
            },

            {
              'name': 'Worker',
              'img': 'worker.gif',
              'text': 'Worker',
              'playerLvl': 13,
              'artNr': 'e0014',
              'type': 'emotes',
              'dbPos': 14,
            },

            {
              'name': 'Ballista',
              'img': 'ballista.png',
              'text': 'Ballista',
              'gold': 1500,
              'artNr': 'e0015',
              'type': 'emotes',
              'dbPos': 15,
            },

            {
              'name': 'Archer',
              'img': 'archer.gif',
              'text': 'Archer',
              'gold': 1000,
              'artNr': 'e0016',
              'type': 'emotes',
              'dbPos': 16,
            },

            {
              'name': 'Rifleman',
              'img': 'rifleman.gif',
              'text': 'Rifleman',
              'gold': 1500,
              'artNr': 'e0017',
              'type': 'emotes',
              'dbPos': 17,
            },

            {
              'name': 'Catapult',
              'img': 'catapult.png',
              'text': 'Catapult',
              'price': 0.79,
              'artNr': 'e0018',
              'type': 'emotes',
              'dbPos': 18,
            },

            {
              'name': 'Mage',
              'img': 'mage.gif',
              'text': 'Mage',
              'price': 0.89,
              'artNr': 'e0019',
              'type': 'emotes',
              'dbPos': 19,
            },

            {
              'name': 'Airship',
              'img': 'airship.gif',
              'text': 'Airship',
              'playerLvl': 17,
              'artNr': 'e0020',
              'type': 'emotes',
              'dbPos': 20,
            },

            {
              'name': 'Dragon',
              'img': 'dragon.gif',
              'text': 'Dragon',
              'playerLvl': 20,
              'artNr': 'e0021',
              'type': 'emotes',
              'dbPos': 21,
            },

            {
              'name': 'Werewolf',
              'img': 'werewolf.gif',
              'text': 'Werewolf',
              'gold': 2000,
              'artNr': 'e0022',
              'type': 'emotes',
              'dbPos': 22,
            },

            {
              'name': '5th Division',
              'img': 'div5.png',
              'text': 'Div5',
              'div': 1,
              'type': 'emotes',
              'dbPos': 23,
              'artNr': 'e0023',
            },

            {
              'name': '4th Division',
              'img': 'div4.png',
              'text': 'Div4',
              'div': 2,
              'type': 'emotes',
              'dbPos': 24,
              'artNr': 'e0024',
            },

            {
              'name': '3rd Division',
              'img': 'div3.png',
              'text': 'Div3',
              'div': 3,
              'type': 'emotes',
              'dbPos': 25,
              'artNr': 'e0025',
            },

            {
              'name': '2nd Division',
              'img': 'div2.png',
              'text': 'Div2',
              'div': 4,
              'type': 'emotes',
              'dbPos': 26,
              'artNr': 'e0026',
            },

            {
              'name': '1st Division',
              'img': 'div1.png',
              'text': 'Div1',
              'div': 5,
              'type': 'emotes',
              'dbPos': 27,
              'artNr': 'e0027',
            },

            {
              'name': 'Gamma Division',
              'img': 'divgamma.png',
              'text': 'DivGamma',
              'div': 6,
              'type': 'emotes',
              'dbPos': 30,
              'artNr': 'e0030',
            },

            {
              'name': 'Beta Division',
              'img': 'divbeta.png',
              'text': 'DivBeta',
              'div': 7,
              'type': 'emotes',
              'dbPos': 29,
              'artNr': 'e0029',
            },

            {
              'name': 'Alpha Division',
              'img': 'divalpha.png',
              'text': 'DivAlpha',
              'div': 8,
              'type': 'emotes',
              'dbPos': 28,
              'artNr': 'e0028',
            },

            {
              'name': 'O RLY ?',
              'img': 'orly.jpg',
              'text': 'Orly',
              'price': 0.79,
              'type': 'emotes',
              'dbPos': 31,
              'artNr': 'e0031',
            },

            {
              'name': '#REKT',
              'img': 'rekt.png',
              'text': '#REKT',
              'price': 0.79,
              'type': 'emotes',
              'dbPos': 32,
              'artNr': 'e0032',
            },

            {
              'name': 'Star',
              'img': 'premium.png',
              'text': 'Star',
              'type': 'emotes',
              'special': 'requires_premium',
              'requirementText': 'Requires premium account',
              'requirementTitle': 'Get a premium account to unlock this emote',
              'dbPos': 33,
              'artNr': 'e0033',
            },

            {
              'name': 'Not Bad',
              'img': 'not-bad.png',
              'text': 'notbad',
              'playerLvl': 8,
              'type': 'emotes',
              'dbPos': 34,
              'artNr': 'e0034',
            },

            {
              'name': 'XZibit',
              'img': 'xzibit.png',
              'text': 'xzibit',
              'gold': 800,
              'type': 'emotes',
              'dbPos': 35,
              'artNr': 'e0035',
            },

            {
              'name': 'Castle',
              'img': 'castle.png',
              'text': 'Castle',
              'gold': 1500,
              'type': 'emotes',
              'dbPos': 36,
              'artNr': 'e0036',
            },

            {
              'name': 'Barracks',
              'img': 'rax.png',
              'text': 'Barracks',
              'gold': 1100,
              'type': 'emotes',
              'dbPos': 37,
              'artNr': 'e0037',
            },

            {
              'name': 'Tower',
              'img': 'tower.png',
              'text': 'Tower',
              'gold': 1000,
              'type': 'emotes',
              'dbPos': 38,
              'artNr': 'e0038',
            },

            {
              'name': 'House',
              'img': 'house.png',
              'text': 'House',
              'gold': 900,
              'type': 'emotes',
              'dbPos': 39,
              'artNr': 'e0039',
            },

            {
              'name': 'Goldmine',
              'img': 'mine.png',
              'text': 'Goldmine',
              'gold': 1100,
              'type': 'emotes',
              'dbPos': 40,
              'artNr': 'e0040',
            },

            {
              'name': 'Magesguild',
              'img': 'guild.png',
              'text': 'Guild',
              'gold': 1400,
              'type': 'emotes',
              'dbPos': 41,
              'artNr': 'e0041',
            },

            {
              'name': 'Workshop',
              'img': 'workshop.png',
              'text': 'Workshop',
              'gold': 1400,
              'type': 'emotes',
              'dbPos': 42,
              'artNr': 'e0042',
            },

            {
              'name': 'Forge',
              'img': 'forge.png',
              'text': 'Forge',
              'gold': 1200,
              'type': 'emotes',
              'dbPos': 43,
              'artNr': 'e0043',
            },

            {
              'name': 'Fortress',
              'img': 'fort.png',
              'text': 'Fortress',
              'gold': 1600,
              'type': 'emotes',
              'dbPos': 44,
              'artNr': 'e0044',
            },

            {
              'name': 'Dragonslair',
              'img': 'dragonslair.png',
              'text': 'Lair',
              'gold': 1400,
              'type': 'emotes',
              'dbPos': 45,
              'artNr': 'e0045',
            },

            {
              'name': 'Wolvesden',
              'img': 'wolfden.png',
              'text': 'Wolvesden',
              'gold': 1100,
              'type': 'emotes',
              'dbPos': 46,
              'artNr': 'e0046',
            },

            {
              'name': 'Animal Testing Lab',
              'img': 'lab.png',
              'text': 'Animaltestinglab',
              'gold': 1200,
              'type': 'emotes',
              'dbPos': 47,
              'artNr': 'e0047',
            },

            {
              'name': 'Advanced Workshop',
              'img': 'adv-workshop.png',
              'text': 'Advancedworkshop',
              'gold': 1400,
              'type': 'emotes',
              'dbPos': 48,
              'artNr': 'e0048',
            },

            {
              'name': 'Werewolves Den',
              'img': 'wwden.png',
              'text': 'Werewolvesden',
              'gold': 1800,
              'type': 'emotes',
              'dbPos': 49,
              'artNr': 'e0049',
            },

            {
              'name': 'Church',
              'img': 'church.png',
              'text': 'Church',
              'gold': 1400,
              'type': 'emotes',
              'dbPos': 50,
              'artNr': 'e0050',
            },

            {
              'name': 'Basketball',
              'img': 'basketball.png',
              'gold': 1500,
              'text': 'Basketball',
              'type': 'emotes',
              'dbPos': 51,
              'artNr': 'e0051',
            },

            {
              'name': 'Frog',
              'img': 'frog.png',
              'playerLvl': 26,
              'text': 'Frog',
              'type': 'emotes',
              'dbPos': 52,
              'artNr': 'e0052',
            },

            {
              'name': 'Machinegun',
              'img': 'machinegun.png',
              'special': 'requires_premium',
              'requirementText': 'Requires premium account',
              'requirementTitle': 'Get a premium account to unlock this emote',
              'text': 'Machinegun',
              'type': 'emotes',
              'dbPos': 53,
              'artNr': 'e0053',
            },

            {
              'name': 'Cookie',
              'img': 'cookie.png',
              'special': 'requires_premium',
              'requirementText': 'Requires premium account',
              'requirementTitle': 'Get a premium account to unlock this emote',
              'text': 'Cookie',
              'type': 'emotes',
              'dbPos': 54,
              'artNr': 'e0054',
            },

            {
              'name': 'Gatling Gun',
              'img': 'gatlinggun.gif',
              'gold': 1000,
              'text': 'Gatlinggun',
              'type': 'emotes',
              'dbPos': 55,
              'artNr': 'e0055',
            },

            {
              'name': 'Snake',
              'img': 'snake.gif',
              'gold': 1000,
              'text': 'Snake',
              'type': 'emotes',
              'dbPos': 56,
              'artNr': 'e0056',
            },

            {
              'name': 'Raider',
              'img': 'raider.gif',
              'gold': 1000,
              'text': 'Raider',
              'type': 'emotes',
              'dbPos': 57,
              'artNr': 'e0057',
            },

            {
              'name': 'Gyrocraft',
              'img': 'gyro.gif',
              'gold': 1000,
              'text': 'Gyrocraft',
              'type': 'emotes',
              'dbPos': 58,
              'artNr': 'e0058',
            },

            // {
            // 	"name": "pumpkin",
            // 	"img": "pumpkin.png",
            // 	"free": true,
            // 	"text": "pumpkin",
            // 	"type": "emotes"
            // },

            // {
            // 	"name": "spookyhead",
            // 	"img": "pumpkin_soldier.png",
            // 	"free": true,
            // 	"text": "spookyhead",
            // 	"type": "emotes"
            // },

            // {
            // 	"name": "skeleton",
            // 	"img": "skeleton.png",
            // 	"free": true,
            // 	"text": "skeleton",
            // 	"type": "emotes"
            // }

          ]/* emotesend*/;

        var skins = /* skinsstart*/
          [

            {
              'name': 'Redhead Worker',
              'img': 'workerS1',
              'unit_id_string': 'worker',
              'dbPos': 1,
              'gold': 2000,
              'artNr': 's0001',
              'type': 'skins',
            },

            {
              'name': 'Blonde Worker',
              'img': 'workerS2',
              'unit_id_string': 'worker',
              'dbPos': 2,
              'gold': 2000,
              'artNr': 's0002',
              'type': 'skins',
            },

            {
              'name': 'Soldier 2',
              'img': 'soldierS1',
              'unit_id_string': 'soldier',
              'dbPos': 3,
              'price': 1.39,
              'artNr': 's0003',
              'type': 'skins',
            },

            {
              'name': 'Viking Archer',
              'img': 'archerS1',
              'unit_id_string': 'archer',
              'dbPos': 4,
              'playerLvl': 14,
              'artNr': 's0004',
              'type': 'skins',
            },

            {
              'name': 'Soldier 3',
              'img': 'soldierS2',
              'unit_id_string': 'soldier',
              'dbPos': 5,
              'price': 1.39,
              'artNr': 's0005',
              'type': 'skins',
            },

            {
              'name': 'British Mage',
              'img': 'mageS1',
              'unit_id_string': 'mage',
              'dbPos': 6,
              'price': 1.19,
              'artNr': 's0006',
              'type': 'skins',
            },

            {
              'name': 'Christmas Worker',
              'img': 'worker_christmas',
              'unit_id_string': 'worker',
              // "dbPos": 7,
              'free': true,
              'artNr': 's0007',
              'type': 'skins',
            },

          ]/* skinsend*/;

        var dances = /* dancesstart*/
          [

            {
              'name': 'Worker 01',
              'unit_id_string': 'worker',
              'dbPos': 1,
              'artNr': 'd0001',
              'animName': 'dance1',
              'price': 0.99,
              'type': 'dances',
              'chat_str': '/dance',
              'img': 'worker',
            },

            {
              'name': 'Soldier 01',
              'unit_id_string': 'soldier',
              'dbPos': 2,
              'gold': 1500,
              'artNr': 'd0002',
              'animName': 'dance1',
              'type': 'dances',
              'chat_str': '/dance',
              'img': 'soldier',
            },

            {
              'name': 'Soldier 02',
              'unit_id_string': 'soldier',
              'dbPos': 3,
              'price': 0.99,
              'artNr': 'd0003',
              'animName': 'dance2',
              'type': 'dances',
              'chat_str': '/dance2',
              'img': 'soldier',
            },

          ]/* dancesend*/;

        var achivements = /* achivementsstart*/
          [

            {
              'name': 'The First Step',
              'a_type': 'ladderwins',
              'type': 'achivements',
              'text': 'Win 1 ladder game',
              'count': 1,
              'dbPos': 1,
              'reward': 10,
              'img': 'ladderwins1.png',
            },

            {
              'name': 'Ranked Up!',
              'a_type': 'ladderwins',
              'type': 'achivements',
              'text': 'Win 5 ladder games',
              'count': 5,
              'dbPos': 2,
              'reward': 20,
              'img': 'ladderwins5.png',
            },

            {
              'name': 'Ladder Hiker',
              'a_type': 'ladderwins',
              'type': 'achivements',
              'text': 'Win 10 ladder games',
              'count': 10,
              'dbPos': 3,
              'reward': 35,
              'img': 'ladderwins10.png',
            },

            {
              'name': 'Matchmaking Battler',
              'a_type': 'ladderwins',
              'type': 'achivements',
              'text': 'Win 20 ladder games',
              'count': 20,
              'dbPos': 4,
              'reward': 70,
              'img': 'ladderwins20.png',
            },

            {
              'name': 'The Steep Climb',
              'a_type': 'ladderwins',
              'type': 'achivements',
              'text': 'Win 50 ladder games',
              'count': 50,
              'dbPos': 5,
              'reward': 150,
              'img': 'ladderwins50.png',
            },

            {
              'name': 'Contender',
              'a_type': 'ladderwins',
              'type': 'achivements',
              'text': 'Win 100 ladder games',
              'count': 100,
              'dbPos': 6,
              'reward': 250,
              'img': 'ladderwins100.png',
            },

            {
              'name': 'Matchmaking Maestro',
              'a_type': 'ladderwins',
              'type': 'achivements',
              'text': 'Win 200 ladder games',
              'count': 200,
              'dbPos': 7,
              'reward': 450,
              'img': 'ladderwins200.png',
            },

            {
              'name': 'Ladder Hero',
              'a_type': 'ladderwins',
              'type': 'achivements',
              'text': 'Win 500 ladder games',
              'count': 500,
              'dbPos': 8,
              'reward': 1000,
              'img': 'ladderwins500.png',
            },

            {
              'name': 'Chief Of Ladder',
              'a_type': 'ladderwins',
              'type': 'achivements',
              'text': 'Win 1000 ladder games',
              'count': 1000,
              'dbPos': 9,
              'reward': 1700,
              'img': 'ladderwins1000.png',
            },

            {
              'name': 'Ladder King',
              'a_type': 'ladderwins',
              'type': 'achivements',
              'text': 'Win 2000 ladder games',
              'count': 2000,
              'dbPos': 10,
              'reward': 3000,
              'img': 'ladderwins2000.png',
            },

            {
              'name': 'Ladder Boss',
              'a_type': 'ladderwins',
              'type': 'achivements',
              'text': 'Win 5000 ladder games',
              'count': 5000,
              'dbPos': 11,
              'reward': 5000,
              'img': 'ladderwins5000.png',
            },

            {
              'name': 'Ladder God',
              'a_type': 'ladderwins',
              'type': 'achivements',
              'text': 'Win 10000 ladder games',
              'count': 10000,
              'dbPos': 12,
              'reward': 10000,
              'img': 'ladderwins10000.png',
            },

            // laddergames

            {
              'name': 'Ladder Player',
              'a_type': 'laddergames',
              'type': 'achivements',
              'text': 'Play 5 ladder games',
              'count': 5,
              'dbPos': 13,
              'reward': 25,
              'img': 'laddergames5.png',
            },

            {
              'name': 'Ladder Rookie',
              'a_type': 'laddergames',
              'type': 'achivements',
              'text': 'Play 10 ladder games',
              'count': 10,
              'dbPos': 14,
              'reward': 40,
              'img': 'laddergames10.png',
            },

            {
              'name': 'Better Ladder Player',
              'a_type': 'laddergames',
              'type': 'achivements',
              'text': 'Play 20 ladder games',
              'count': 20,
              'dbPos': 15,
              'reward': 70,
              'img': 'laddergames20.png',
            },

            {
              'name': 'Experienced Matchmaker',
              'a_type': 'laddergames',
              'type': 'achivements',
              'text': 'Play 50 ladder games',
              'count': 50,
              'dbPos': 16,
              'reward': 150,
              'img': 'laddergames50.png',
            },

            {
              'name': 'Ladder Champ',
              'a_type': 'laddergames',
              'type': 'achivements',
              'text': 'Play 100 ladder games',
              'count': 100,
              'dbPos': 17,
              'reward': 250,
              'img': 'laddergames100.png',
            },

            {
              'name': 'Durable Fighter',
              'a_type': 'laddergames',
              'type': 'achivements',
              'text': 'Play 200 ladder games',
              'count': 200,
              'dbPos': 18,
              'reward': 450,
              'img': 'laddergames200.png',
            },

            {
              'name': 'Competitive Spirit',
              'a_type': 'laddergames',
              'type': 'achivements',
              'text': 'Play 500 ladder games',
              'count': 500,
              'dbPos': 19,
              'reward': 1000,
              'img': 'laddergames500.png',
            },

            {
              'name': 'One Grand',
              'a_type': 'laddergames',
              'type': 'achivements',
              'text': 'Play 1000 ladder games',
              'count': 1000,
              'dbPos': 20,
              'reward': 1750,
              'img': 'laddergames1000.png',
            },

            {
              'name': 'Unstoppable',
              'a_type': 'laddergames',
              'type': 'achivements',
              'text': 'Play 2000 ladder games',
              'count': 2000,
              'dbPos': 21,
              'reward': 3000,
              'img': 'laddergames2000.png',
            },

            {
              'name': 'Matchmaking Specialist',
              'a_type': 'laddergames',
              'type': 'achivements',
              'text': 'Play 5000 ladder games',
              'count': 5000,
              'dbPos': 22,
              'reward': 5000,
              'img': 'laddergames5000.png',
            },

            {
              'name': 'Ladder Warrior',
              'a_type': 'laddergames',
              'type': 'achivements',
              'text': 'Play 10000 ladder games',
              'count': 10000,
              'dbPos': 23,
              'reward': 10000,
              'img': 'laddergames10000.png',
            },

            // games

            {
              'name': 'Beginner',
              'a_type': 'games',
              'type': 'achivements',
              'text': 'Play 5 multiplayer games',
              'count': 5,
              'dbPos': 24,
              'reward': 25,
              'img': 'games5.png',
            },

            {
              'name': 'One Step Further',
              'a_type': 'games',
              'type': 'achivements',
              'text': 'Play 10 multiplayer games',
              'count': 10,
              'dbPos': 25,
              'reward': 40,
              'img': 'games10.png',
            },

            {
              'name': 'Fighter',
              'a_type': 'games',
              'type': 'achivements',
              'text': 'Play 20 multiplayer games',
              'count': 20,
              'dbPos': 26,
              'reward': 70,
              'img': 'games20.png',
            },

            {
              'name': 'Soldier',
              'a_type': 'games',
              'type': 'achivements',
              'text': 'Play 50 multiplayer games',
              'count': 50,
              'dbPos': 27,
              'reward': 150,
              'img': 'games50.png',
            },

            {
              'name': 'Experienced Player',
              'a_type': 'games',
              'type': 'achivements',
              'text': 'Play 100 multiplayer games',
              'count': 100,
              'dbPos': 28,
              'reward': 250,
              'img': 'games100.png',
            },

            {
              'name': 'Littlewargame Expert',
              'a_type': 'games',
              'type': 'achivements',
              'text': 'Play 200 multiplayer games',
              'count': 200,
              'dbPos': 29,
              'reward': 450,
              'img': 'games200.png',
            },

            {
              'name': 'Littlewargame Specialist',
              'a_type': 'games',
              'type': 'achivements',
              'text': 'Play 500 multiplayer games',
              'count': 500,
              'dbPos': 30,
              'reward': 1000,
              'img': 'games500.png',
            },

            {
              'name': 'Master Of Littlewargame',
              'a_type': 'games',
              'type': 'achivements',
              'text': 'Play 1000 multiplayer games',
              'count': 1000,
              'dbPos': 31,
              'reward': 1750,
              'img': 'games1000.png',
            },

            {
              'name': 'Living Legend',
              'a_type': 'games',
              'type': 'achivements',
              'text': 'Play 2000 multiplayer games',
              'count': 2000,
              'dbPos': 32,
              'reward': 3000,
              'img': 'games2000.png',
            },

            {
              'name': 'Based God',
              'a_type': 'games',
              'type': 'achivements',
              'text': 'Play 5000 multiplayer games',
              'count': 5000,
              'dbPos': 33,
              'reward': 5000,
              'img': 'games5000.png',
            },

            {
              'name': 'It\'s Over 9000!!!',
              'a_type': 'games',
              'type': 'achivements',
              'text': 'Play over 9000 multiplayer games',
              'count': 9001,
              'dbPos': 34,
              'reward': 10000,
              'img': 'games9001.png',
            },

            {
              'name': 'Holiday Spirit',
              'a_type': 'games',
              'type': 'achivements',
              'text': 'Play a game during the christmas event',
              'expires': 1580564544072, // New year's day
              'count': 1,
              'dbPos': 35,
              'img': 'christmas.png',
            },

          ]/* achivementsend*/;

        var goldPacks = /* goldstart*/
          [

            {
              'name': 'Gold Pack 1000',
              'artNr': 'g0001',
              'type': 'gold',
              'price': 0.99,
              'reward': 1000,
            },

            {
              'name': 'Gold Pack 2000',
              'artNr': 'g0002',
              'type': 'gold',
              'price': 1.89,
              'reward': 2000,
            },

            {
              'name': 'Gold Pack 5000',
              'artNr': 'g0003',
              'type': 'gold',
              'price': 3.99,
              'reward': 5000,
            },

            {
              'name': 'Gold Pack 10000',
              'artNr': 'g0004',
              'type': 'gold',
              'price': 7.49,
              'reward': 10000,
            },

          ]/* goldend*/;

        var specials = /* specialsstart*/
          [

            {
              'name': 'Premium Account',
              'artNr': 'x0001',
              'type': 'special',
              'type_2': 'premium',
              'dbPos': 1,
              'gold': 3500,
              'img': 'premium.png',
            },

            {
              'name': 'Treasure Chest',
              'artNr': 'x0002',
              'type': 'special',
              'type_2': 'treasure',
              'dbPos': 2,
              'gold': 1000,
              'img': 'chest.png',
            },

          ]/* specialsend*/;


        if (typeof exports !== 'undefined') {
          exports.emotes = emotes;
          exports.skins = skins;
          exports.dances = dances;
          exports.achivements = achivements;
          exports.goldPacks = goldPacks;
          exports.specials = specials;
        }

        var _emotes2 = /* emotesstart*/
          [

            {
              'name': 'Teddy',
              'img': 'teddy.png',
              'text': 'Teddy',
              'type': 'emotes',
              'hidd': true,
              'dbPos': 55,
              'artNr': 'e0055',
            },

            {
              'name': 'Minigun',
              'img': 'minigun.png',
              'text': 'Minigun',
              'type': 'emotes',
              'hidd': true,
              'dbPos': 56,
              'artNr': 'e0056',
            },

            {
              'name': 'Cheese',
              'img': 'cheese.png',
              'text': 'Cheese',
              'type': 'emotes',
              'hidd': true,
              'dbPos': 57,
              'artNr': 'e0057',
            },

            {
              'name': 'Violin',
              'img': 'violin.png',
              'text': 'Violin',
              'type': 'emotes',
              'hidd': true,
              'dbPos': 58,
              'artNr': 'e0058',
            },

          ]/* emotesend*/;

        if (typeof exports !== 'undefined') {
          exports.emotes = _emotes2;
        }


        var browserWindow;
        try {
          browserWindow = window;
        } catch (e) { }; // In worker thread before window load
        var KEY = Object.freeze({
          UP: 38,
          DOWN: 40,
          LEFT: 37,
          RIGHT: 39,
          A: 65,
          B: 66,
          C: 67,
          D: 68,
          E: 69,
          F: 70,
          G: 71,
          H: 72,
          I: 73,
          J: 74,
          K: 75,
          L: 76,
          M: 77,
          N: 78,
          O: 79,
          P: 80,
          Q: 81,
          R: 82,
          S: 83,
          T: 84,
          U: 85,
          V: 86,
          W: 87,
          X: 88,
          Y: 89,
          Z: 90,
          SHIFT: 16,
          CTRL: 17,
          ALT: 18,
          NUM1: 49,
          NUM2: 50,
          NUM3: 51,
          NUM4: 52,
          NUM5: 53,
          NUM6: 54,
          NUM7: 55,
          NUM8: 56,
          NUM9: 57,
          NUM0: 48,
          NUMPAD0: 96,
          NUMPAD1: 97,
          NUMPAD2: 98,
          NUMPAD3: 99,
          NUMPAD4: 100,
          NUMPAD5: 101,
          NUMPAD6: 102,
          NUMPAD7: 103,
          NUMPAD8: 104,
          NUMPAD9: 105,
          CIRCUMFLEX: (browserWindow && browserWindow.chrome) ? 220 : 160,
          ENTER: 13,
          BACKSPACE: 8,
          DELETE: 46,
          PAUSE: 19,
          F1: 112,
          F2: 113,
          F3: 114,
          F4: 115,
          F5: 116,
          F6: 117,
          F7: 118,
          F8: 119,
          F9: 120,
          F10: 121,
          ESC: 27,
          TAB: 9,
          PLUS: 107,
          MINUS: 109,
          SPACE: 32,
          CAPSLOCK: 20,
          BACKTICK: 192,
          COMMA: 188,
          PERIOD: 190,
          OPENBRACKETS: 219,
          CLOSEBRACKETS: 221,
          SEMICOLON: 186,
          QUOTE: 222
        });

        const Cursors = Object.freeze({
          DEFAULT: 0,
          BLANK: 1,
          HEAL: 2,
          ATTACK: 3,
        });

        const CursorFiles = Object.freeze({
          [Cursors.DEFAULT]: 'imgs/cursor.cur',
          [Cursors.BLANK]: 'imgs/blank-pixel.cur',
          [Cursors.HEAL]: 'imgs/cursor-heal.cur',
          [Cursors.ATTACK]: 'imgs/cursor-attack.cur',
        });

        var CLIFF_HEIGHT = 1.5;
        var MIN_MAP_SIZE = 24;
        var MAX_MAP_SIZE = 256;
        var MAX_CLIFF_LEVEL = 2;
        var MAX_PLAYERS = 6;
        var BUILDING_QUEUE_LEN = 5;
        var BUILDING_START_HP_PERCENTAGE = 0.2;
        var MAX_SUPPLY = 150;
        var MINE_DIST = 7;
        var START_GOLD = 50;
        var START_WORKERS = 7;
        var TICK_TIME = 50;

        var customImgs = {};
        var possibleAngleCounts = { 'None': 0, '1': 1, '4': 4, '8': 8 };

        function toInt(i) {
          var i2 = parseInt(i);
          return isNaN(i2) ? 0 : i2;
        }

        function checkField(field, val, unscaled) {
          if (field.type == 'selection') {
            return val;
          }

          if (field.type == 'bool') {
            if (val) {
              return true;
            }
            return false;
          }

          if (field.type == 'integer') {
            val = parseInt(val);

            if (isNaN(val)) {
              val = 0;
            }

            if (val > field.max_val) {
              val = field.max_val;
            } else if (val < field.min_val) {
              val = field.min_val;
            }

            return val;
          }

          if (field.type == 'float') {
            val = parseFloat(val);

            if (isNaN(val)) {
              val = 0;
            }

            var max_val = field.max_val;
            var min_val = field.min_val;

            if (unscaled && field.displayScale) {
              max_val /= field.displayScale;
              min_val /= field.displayScale;
            }

            if (val > max_val) {
              val = max_val;
            } else if (val < min_val) {
              val = min_val;
            }

            return val;
          }

          if (field.type == 'string') {
            if (!val) {
              val = '';
            }

            if (val.length > field.max_len) {
              val = val.slice(0, field.max_len);
            } else if (val.length < field.min_len) {
              for (var i = 0; i < field.min_len - val.length; i++) {
                val += '_';
              }
            }

            return val;
          }
        }

        function getRampTypeFromCode(code) {
          var ramps = (game.theme && game.theme.ramps) ? game.theme.ramps : ramps;

          for (var i = 0; i < ramps.length; i++) {
            if (ramps[i].code == code) {
              return ramps[i];
            }
          }

          return ramps[0];
        }

        function getThemeByName(name) {
          for (var i = 0; i < mapThemes.length; i++) {
            if (mapThemes[i].name == name) {
              return mapThemes[i];
            }
          }
        }

        // TODO: move all data structure extensions / definitions elsewhere
        Array.prototype.contains = function (value) {
          for (var i = 0; i < this.length; i++) {
            if (this[i] == value) {
              return true;
            }
          }
          return false;
        };

        Array.prototype.erease = function (element) {
          for (var i = 0; i < this.length; i++) {
            if (this[i] == element) {
              this.splice(i, 1);
              return true;
            }
          }
          return false;
        };

        Array.prototype.remove = function (predicate) {
          for (let i = 0; i < this.length; i++) {
            if (predicate(this[i])) {
              this.splice(i, 1);
              return true;
            }
          }
          return false;
        };

        Array.prototype.last = function () {
          if (this.length == 0) {
            return undefined;
          }
          return this[this.length - 1];
        };

        Array.prototype.count = function (predicate) {
          let n = 0;
          for (let i = 0; i < this.length; i++) {
            if (predicate(this[i], i)) {
              n++;
            }
          }
          return n;
        };

        const tryGet = function (obj, key, defaultValue = undefined) {
          if (!(key in obj) && defaultValue) {
            obj[key] = defaultValue;
          }
          return obj[key];
        };

        String.prototype.toUnitType = function () {
          var types_ = game ? game.unitTypes.concat(game.buildingTypes, tileTypes, cliffs, cliffs_winter, egypt_cliffs, grave_cliffs, ramp_tiles, ramp_tiles_egypt, ramp_tiles_grave, game.upgrades) : basicUnitTypes.concat(basicBuildingTypes, tileTypes, cliffs, cliffs_winter, ramp_tiles, basicUpgrades);

          for (var i = 0; i < types_.length; i++) {
            if (this == types_[i].name) {
              return types_[i];
            }
          }

          return null;
        };

        function Multiset(arr) {
          this.data = {};
          if (arr) {
            arr.forEach((i) => this.add(i));
          }
        }

        Multiset.prototype.count = function (i) {
          return this.data[i] || 0;
        };

        Multiset.prototype.add = function (i) {
          this.data[i] = this.count(i) + 1;
        };

        Multiset.prototype.forEach = function (callback) {
          for (let i in this.data) {
            callback(i);
          }
        };

        var COMMAND = Object.freeze({
          MAKEUNIT: 1,
          UNIVERSAL: 2,
          MAKEBUILDING: 3,
          IDLE: 7,
          HOLDPOSITION: 8,
          ATTACK: 9,
          CANCEL: 10,
          MOVE: 11,
          MOVETO: 12,
          MINE: 13,
          REPAIR: 14,
          AMOVE: 15,
          SWITCH_CC: 22,
          UPGRADE: 23,
          BUILDING_UPGRADE: 25,
          LOAD: 26,
          UNLOAD: 27,
          UNLOAD2: 28,
          ATTACK_GROUND: 29,
          TELEPORT: 30,
          DAMAGING_PROJECTILE: 31,
          DANCE: 32,
        });

        var EDITOR_COMMANDS = Object.freeze({
          MAKEUNIT: 1,
          MAKEBUILDING: 3,
          IDLE: 7,
          HOLDPOSITION: 8,
          ATTACK: 9,
          CANCEL: 10,
          MOVE: 11,
          REPAIR: 14,
          UNIVERSAL: 2,
          SWITCH_CC: 22,
          UPGRADE: 23,
          BUILDING_UPGRADE: 25,
          ATTACK_GROUND: 29,
          TELEPORT: 30,
        });

        var ability_type_fields = {};

        ability_type_fields[COMMAND.MAKEUNIT] =
          [
            'name',
            'type',
            'unitType',
            'hotkey',
            'commandCard',
            'interfacePosX',
            'interfacePosY',
            'image',
            'description',
            'requirementType',
            'requirementLevel',
            'requirementText',
            'manaCost',
            'hasAutocast',
            'autocastDefault',
            'requiredLevels',
            'learnCommandCard',
            'learnInterfacePosX',
            'learnInterfacePosY',
            'learnHotkey',
          ];

        ability_type_fields[COMMAND.MAKEBUILDING] =
          [
            'name',
            'type',
            'unitType',
            'hotkey',
            'commandCard',
            'interfacePosX',
            'interfacePosY',
            'image',
            'description',
            'requirementType',
            'requirementLevel',
            'requirementText',
            'manaCost',
            'range',
            'requiredLevels',
            'learnCommandCard',
            'learnInterfacePosX',
            'learnInterfacePosY',
            'learnHotkey',
          ];

        ability_type_fields[COMMAND.IDLE] =
          [
            'name',
            'type',
            'hotkey',
            'commandCard',
            'interfacePosX',
            'interfacePosY',
            'image',
            'description',
            'requirementType',
            'requirementLevel',
            'requirementText',
            'manaCost',
          ];

        ability_type_fields[COMMAND.REPAIR] =
          [
            'name',
            'type',
            'hotkey',
            'commandCard',
            'interfacePosX',
            'interfacePosY',
            'image',
            'description',
            'targetRequirements1',
            'targetRequirements2',
            'targetRequirements3',
            'requirementType',
            'requirementLevel',
            'requirementText',
            'manaCost',
            'range',
            'hasAutocast',
            'autocastConditions',
            'cursor',
          ];

        ability_type_fields[COMMAND.HOLDPOSITION] =
          [
            'name',
            'type',
            'hotkey',
            'commandCard',
            'interfacePosX',
            'interfacePosY',
            'image',
            'description',
            'requirementType',
            'requirementLevel',
            'requirementText',
            'manaCost',
          ];

        ability_type_fields[COMMAND.ATTACK] =
          [
            'name',
            'type',
            'hotkey',
            'commandCard',
            'interfacePosX',
            'interfacePosY',
            'image',
            'description',
            'requirementType',
            'requirementLevel',
            'requirementText',
            'manaCost',
            'cursor',
          ];

        ability_type_fields[COMMAND.CANCEL] =
          [
            'name',
            'type',
            'hotkey',
            'commandCard',
            'interfacePosX',
            'interfacePosY',
            'image',
            'description',
            'requirementType',
            'requirementLevel',
            'requirementText',
          ];

        ability_type_fields[COMMAND.MOVE] =
          [
            'name',
            'type',
            'hotkey',
            'commandCard',
            'interfacePosX',
            'interfacePosY',
            'image',
            'description',
            'requirementType',
            'requirementLevel',
            'requirementText',
          ];

        ability_type_fields[COMMAND.TELEPORT] =
          [
            'name',
            'type',
            'hotkey',
            'commandCard',
            'interfacePosX',
            'interfacePosY',
            'image',
            'attackEffect',
            'description',
            'requirementType',
            'requirementLevel',
            'requirementText',
            'launchSound',
            'manaCost',
            'goldCost',
            'effectScale',
            'castingDelay',
            'cooldown',
            'cooldown2',
            'range',
            'minRange',
            'animationName',
            'requiresVision',
            'requiredLevels',
            'modifiersSelf',
            'learnInterfacePosX',
            'learnInterfacePosY',
            'learnCommandCard',
            'learnHotkey',
            'attackEffectInit',
            'cursor',
          ];

        ability_type_fields[COMMAND.UNIVERSAL] =
          [
            'name',
            'type',
            'hotkey',
            'targetIsPoint',
            'targetIsUnit',
            'isInstant',
            'isChanneled',
            'playLaunchSoundOnce',
            'useAoeCursor',
            'commandCard',
            'interfacePosX',
            'interfacePosY',
            'image',
            'attackEffect',
            'description',
            'requirementType',
            'requirementLevel',
            'requirementText',
            'targetRequirements1',
            'targetRequirements2',
            'targetRequirements3',
            'launchSound',
            'manaCost',
            'goldCost',
            'aoeRadius',
            'damage',
            'projectileDamage',
            'projectileAoeRadius',
            'maximizeRangeWhenCasting',
            'hitsFriendly',
            'hitsEnemy',
            'hitsSelf',
            'targetFilters',
            'targetFiltersExclude',
            'effectScale',
            'projectileSpeed',
            'duration',
            'castingDelay',
            'cooldown',
            'cooldown2',
            'range',
            'minRange',
            'bounceDistMin',
            'bounceDistMax',
            'bouncePower',
            'animationName',
            'causesFlameDeath',
            'modifiers',
            'summonedUnits',
            'summonsUseWaypoint',
            'summonsWaypointAMove',
            'ignoreSupplyCheck',
            'requiresVision',
            'requiredLevels',
            'modifiersSelf',
            'learnInterfacePosX',
            'learnInterfacePosY',
            'learnCommandCard',
            'learnHotkey',
            'hasAutocast',
            'autocastDefault',
            'autocastConditions',
            'attackEffectInit',
            'cursor',
          ];

        ability_type_fields[COMMAND.SWITCH_CC] =
          [
            'name',
            'type',
            'hotkey',
            'commandCard',
            'interfacePosX',
            'interfacePosY',
            'image',
            'description',
            'requirementType',
            'requirementLevel',
            'requirementText',
            'targetCC',
          ];

        ability_type_fields[COMMAND.UPGRADE] =
          [
            'name',
            'type',
            'hotkey',
            'commandCard',
            'interfacePosX',
            'interfacePosY',
            'image',
            'description',
            'requirementType',
            'requirementLevel',
            'requirementText',
            'upgrade',
            'manaCost',
            'hasAutocast',
            'autocastDefault',
          ];

        ability_type_fields[COMMAND.BUILDING_UPGRADE] =
          [
            'name',
            'type',
            'hotkey',
            'commandCard',
            'interfacePosX',
            'interfacePosY',
            'image',
            'description',
            'requirementType',
            'requirementLevel',
            'requirementText',
            'improvedBuilding',
            'manaCost',
          ];

        ability_type_fields[COMMAND.ATTACK_GROUND] =
          [
            'name',
            'type',
            'hotkey',
            'useAoeCursor',
            'commandCard',
            'interfacePosX',
            'interfacePosY',
            'image',
            'description',
            'requirementType',
            'requirementLevel',
            'requirementText',
            'manaCost',
            'cursor',
          ];

        var commandTypeDescriptions = {
          MAKEUNIT: 'This command will produce / train a unit. Set a unit type to determine which unit will be produced.',
          MAKEBUILDING: 'This command will construct a building. Set a unit type to determine which building will be constructed',
          UNIVERSAL: 'This is a universal type that you want to pick for most spells (damagespells, heal, ...). It uses most of the fields like dmg, aoeRadius, range, ...',
          SWITCH_CC: 'This command will switch the command menu. This is used for example to go to the submenu for making buildings. Set the targetCC field to determine which command menu to go.',
          UPGRADE: 'This command will research an upgrade.',
          BUILDING_UPGRADE: 'This command will upgrade this building / unit to another one set the improvedBuilding field to determine which building / unit it will be morphed into.',
          ATTACK_GROUND: 'This command will order the unit to attack the target position.',
        };


        var graphic_type_fields = {};


        var BUILDING_STATE = Object.freeze({
          NORMAL: 1,
          UNDER_CONSTRUCTION: 2,
          BUSY: 3,
          BUSY_DAMAGED: 4,
          DAMAGED: 5,
          UPGRADING: 6,
          UPGRADING_DAMAGED: 7,
          EMPTY: 8,
          DEAD: 0,
        });

        var CONTROLLER = Object.freeze({
          HUMAN: 0,
          COMPUTER: 1,
          NONE: 2,
          REMOTE: 3,
          SPECTATOR: 4,
        });


        var checkAngles = [[1, 0], [3, 1], [1, 1], [1, 3], [0, 1], [-1, 3], [-1, 1], [-3, 1], [-1, 0], [-3, -1], [-1, -1], [-1, -3], [0, -1], [1, -3], [1, -1], [3, -1]];
        var angleOffsets = [[0.5, 0.86], [0.86, 0.5], [1, 0], [0.86, -0.5], [0.5, -0.86], [0, -1], [-0.5, -0.86], [-0.86, -0.5], [-1, 0], [-0.86, 0.5], [-0.5, 0.86], [0, 1]];


        var targetRequirements = {
          isHuman: {
            func: (target) => target.type.isHuman,
            text: 'Target needs to be a human unit.',
            isTargetRequirement: true,
            funcName: 'isHuman',
          },

          isBiological: {
            func: (target) => target.type.isBiological,
            text: 'Target needs to be a biological unit.',
            isTargetRequirement: true,
            funcName: 'isBiological',
          },

          isMechanical: {
            func: (target) => target.type.isMechanical,
            text: 'Target needs to be a mechanical unit.',
            isTargetRequirement: true,
            funcName: 'isMechanical',
          },

          isUndead: {
            func: (target) => target.type.isUndead,
            text: 'Target needs to be an undead unit.',
            isTargetRequirement: true,
            funcName: 'isUndead',
          },

          isBuilding: {
            func: (target) => target.type.isBuilding,
            text: 'Target needs to be a building.',
            isTargetRequirement: true,
            funcName: 'isBuilding',
          },

          isUnit: {
            func: (target) => target.type.isUnit,
            text: 'Target needs to be a unit.',
            isTargetRequirement: true,
            funcName: 'isUnit',
          },

          isFlying: {
            func: (target) => target.type.flying,
            text: 'Target needs to be flying.',
            isTargetRequirement: true,
            funcName: 'isFlying',
          },

          isGround: {
            func: (target) => !target.type.flying,
            text: 'Target needs to be on the ground.',
            isTargetRequirement: true,
            funcName: 'isGround',
          },

          notFullHp: {
            func: (target) => target.hp < target.type.hp,
            text: 'Target has full life.',
            isTargetRequirement: true,
            funcName: 'notFullHp',
          },
        };


        var targetFilters1 = {

          flying: 'flying',
          isBiological: 'isBiological',
          isMechanical: 'isMechanical',
          isUndead: 'isUndead',
          uniqueAndHeroic: 'uniqueAndHeroic',
          isBeast: 'isBeast',
          isHuman: 'isHuman',
          isInvisible: 'isInvisible',

        };

        const IS_WORKER = false;

        // canvas
        var canvas = document.getElementById('canvas');
        var c = canvas.getContext('2d');
        var originalC = c;

        // dummy canvas
        var canvas2 = document.createElement('canvas');
        var c2 = canvas2.getContext('2d');

        // LocalConfig
        const LocalConfig = require('./LocalConfig.js');

        // Assert
        const assert = require('./Assert.js');

        // HTMLBuilder
        const { HTMLBuilder } = require('./HTMLBuilder.js');
        const { uniqueID } = require('./HTMLBuilder.js');

        // UIWindow
        const UIWindow = require('./UIWindow.js');

        // SoundManager
        soundManager = require('./SoundManager.js');

        const scaleFactorConfig = LocalConfig.registerValue('scale_factor', 3);
        var SCALE_FACTOR;

        function setScaleFactor(value) {
          value = Math.max(2, Math.min(10, value));
          scaleFactorConfig.set(value);
          SCALE_FACTOR = value;
        }
        setScaleFactor(scaleFactorConfig.get());

        var WIDTH = window.innerWidth;
        var HEIGHT = window.innerHeight;
        var SCROLL_RANGE = 10; // in which distance to the border the cursor starts scrolling
        var FIELD_SIZE = 16 * SCALE_FACTOR;
        var INTERFACE_HEIGHT = 176;
        var MINIMAP_WIDTH = 192;
        var MINIMAP_HEIGHT = 192;
        var Y_OFFSET = 1 / 8;
        var CLICK_TOLERANCE = 0.25; // click tolerance when selecting a unit, in fields
        var TICKS_DELAY = 6; // delay in multiplayer game. Too low delay can lead to slow running game if connection is bad; is dynamically changed while playing
        var MAX_DELAY = 20;
        var MIN_DELAY = 2;
        var PLAYING_PLAYER = null;
        var DEAD_MAP_SPACE = 36;
        var DEFAULT_VOLUME = 0.20; // default volume percentage for game sounds, music and littlechatgame

        // var SERVER_ADRESS = "ws://jbs.hercules.uberspace.de:64978";
        // var SERVER_ADRESS = "ws://108.61.78.37:8083";
        // var SERVER_ADRESS = "wss://us1.littlewargame.com:8083";
        // var SERVER_ADRESS = "wss://us1-dev.littlewargame.com:8083";
        // var SERVER_ADRESS = 'ws://localhost:8083';

        // The server and special event placeholders will be filled out by the gulp build
        var SERVER_ADRESS = 'wss://sockets.littlewargame.com:9000';
        const SPECIAL_EVENT = '@@special_event';
        const MICROTRANSACTIONSENABLED = false;

        var IS_LOGIC = false;
        var COMMAND_BUTTON_SIZE = 72;
        var INTERFACE_UNIT_IMG_SIZE = 100; // px
        const GAME_VERSION = '5.0.0';

        // Global Variables
        var timestamp = performance.now();
        var timeDiff = 0;
        var gameTimeDiff = 0;
        var timeOfLastUpdate = 0;
        var show_fps = false;
        var frameTimes = []; // to calculate fps from weighted average of last three frame times
        var mspfCap = 25; // "ms per frame cap" = inverse fps cap: 25ms per frame = 40 frames per second (1000/x), varies adaptively between 25 and 40 for more consistent performance under high load
        var show_unit_details = true;
        var fps = 0;
        var ticksCounter = 0;
        var percentageOfCurrentTickPassed = 0;
        var game_paused = false;
        var tickDiff = 0;
        var lastFramesTick = 0;
        var fileInput = '';
        var replayFile = '';
        var replaySpeedIndex = 1;
        var tickTimes = [0, 0, 0, 0, 0];
        var clan = null;
        var mapData = null;
        var lastSentTick = -1;
        var storedAchievements = [];
        var npf = 'This anonymous survey gives you some free gold.';
        var lcg = {};
        var lcg_interval = null;
        var path2Print = null;
        var printPathUntil = 0;
        var srvState = '';
        var tileImgs = {};

        // network variables
        var network_game = false;
        var ladder_game = false;
        var incomingOrders = {};
        var outgoingOrders = {};
        var playerLefts = {};
        var incomingCameraUpdates = {};
        var outgoingCameraUpdate = {};
        var timeOfLastPingSent = 0;

        // strings
        const goldDescription = 'Use gold to unlock new emotes, skins or dances. You can get gold from achievements or levelling up.';

        function getKeyName(key) {
          let keyName;
          for (let i in KEY) {
            if (KEY[i] == key) {
              keyName = i;
              break;
            }
          }

          if (keyName.indexOf('NUM') == 0) {
            return keyName.substring(3);
          } else if (keyName == 'CIRCUMFLEX') {
            return '^';
          } else if (keyName == 'BACKTICK') {
            return '`';
          } else {
            return keyName;
          }
        }

        // League Names
        var leagueNames = [
          '5th Division',
          '4th Division',
          '3rd Division',
          '2nd Division',
          '1st Division',
          'Gamma Division',
          'Beta Division',
          'Alpha Division',
        ];

        var imgs = {

          dust1: { x: 155, y: 0, w: 7, h: 7 },
          dust2: { x: 155, y: 7, w: 7, h: 7 },

          particle: { x: 155, y: 14, w: 1, h: 1 },
          hammer: { x: 278, y: 0, w: 22, h: 22 },
          research: { x: 145, y: 44, w: 17, h: 17 },
          attentionmark: { x: 32, y: 0, w: 19, h: 18 },
          attentionmarkYellow: { x: 51, y: 0, w: 19, h: 18 },
          underAttack: { x: 201, y: 102, w: 18, h: 20 },
          stop: { x: 3, y: 141, w: 26, h: 30 },
          holdposition: { x: 109, y: 92, w: 32, h: 32 },
          attack: { x: 2, y: 3, w: 27, h: 27 },
          cancel: { x: 139, y: 0, w: 16, h: 16 },
          flamestrike: { x: 101, y: 69, w: 32, h: 23 },
          heal: { x: 73, y: 80, w: 18, h: 19 },
          button: { x: 70, y: 0, w: 69, h: 69 },
          button2: { x: 0, y: 69, w: 69, h: 69 },
          soot: { x: 141, y: 80, w: 60, h: 60 },
          attackUpg: { x: 31, y: 146, w: 24, h: 24 },
          armorUpg: { x: 55, y: 146, w: 24, h: 24 },
          interfaceLeft: { x: 0, y: 202, w: 260, h: 29 },
          interfaceRight: { x: 0, y: 172, w: 260, h: 29 },
          interfaceMapBorder: { x: 0, y: 321, w: 108, h: 109 },
          interfaceButtonDiv: { x: 0, y: 232, w: 205, h: 88 },
          interfaceUnitInfo: { x: 0, y: 431, w: 293, h: 76 },
          dragonAttUpg: { x: 103, y: 146, w: 24, h: 24 },
          dragonDefUpg: { x: 128, y: 146, w: 24, h: 24 },
          towerUpg: { x: 269, y: 35, w: 32, h: 32 },
          unload: { x: 268, y: 108, w: 32, h: 32 },
          load: { x: 268, y: 71, w: 32, h: 32 },
          repair: { x: 139, y: 16, w: 23, h: 23 },
          groundAttack: { x: 229, y: 32, w: 32, h: 32 },
          smash: { x: 184, y: 153, w: 16, h: 16 },
          speedUpg: { x: 79, y: 146, w: 24, h: 24 },
          beastSpeedUpg: { x: 155, y: 146, w: 24, h: 24 },
          mechAttUpg: { x: 207, y: 146, w: 24, h: 24 },
          mechDefUpg: { x: 232, y: 146, w: 24, h: 24 },
          mechSpeedUpg: { x: 257, y: 146, w: 24, h: 24 },
          flakUpg: { x: 238, y: 121, w: 24, h: 24 },
          lightGround: { x: 187, y: 62, w: 29, h: 26 },
          soot2: { x: 221, y: 70, w: 34, h: 32 },
          shockwave: { x: 209, y: 234, w: 24, h: 24 },
          gold: { x: 261, y: 172, w: 20, h: 19 },
          supply: { x: 284, y: 172, w: 11, h: 19 },
          beastRangeUpg: { x: 210, y: 260, w: 23, h: 21 },
          rangeUpg: { x: 210, y: 284, w: 23, h: 21 },
          mechRangeUpg: { x: 237, y: 235, w: 25, h: 22 },
          invisibility: { x: 73, y: 123, w: 19, h: 21 },
          telescope: { x: 237, y: 259, w: 17, h: 21 },
          eye: { x: 266, y: 195, w: 11, h: 9 },
          slowfield: { x: 282, y: 195, w: 18, h: 12 },
          leaf: { x: 280, y: 208, w: 20, h: 20 },
          cake: { x: 279, y: 233, w: 21, h: 22 },
          book: { x: 259, y: 259, w: 17, h: 21 },
          tree: { x: 280, y: 258, w: 20, h: 22 },
          back: { x: 236, y: 283, w: 19, h: 22 },
          bow: { x: 258, y: 283, w: 20, h: 20 },
          spell_1: { x: 282, y: 284, w: 16, h: 20 },
          spell_2: { x: 110, y: 382, w: 22, h: 22 },
          gun: { x: 135, y: 382, w: 21, h: 24 },
          teleport: { x: 159, y: 382, w: 23, h: 22 },
          whitePixel: { x: 74, y: 112, w: 1, h: 1 },

          fire1: { x: 69, y: 73, w: 3, h: 3 },
          fire2: { x: 73, y: 72, w: 4, h: 4 },
          fire3: { x: 78, y: 71, w: 5, h: 5 },
          fire4: { x: 84, y: 70, w: 7, h: 7 },
          fire5: { x: 91, y: 69, w: 9, h: 9 },

          heal1: { x: 74, y: 103, w: 1, h: 1 },
          heal2: { x: 76, y: 103, w: 1, h: 1 },
          heal3: { x: 78, y: 103, w: 1, h: 1 },
          heal4: { x: 80, y: 103, w: 3, h: 3 },

          mageAttack1: { x: 133, y: 70, w: 2, h: 2 },
          mageAttack2: { x: 137, y: 70, w: 2, h: 2 },
          mageAttack3: { x: 141, y: 70, w: 4, h: 4 },
          mageAttack4: { x: 146, y: 70, w: 4, h: 4 },

          flyingRock1: { x: 0, y: 31, w: 9, h: 8 },
          flyingRock2: { x: 9, y: 31, w: 9, h: 9 },
          flyingRock3: { x: 18, y: 31, w: 8, h: 8 },
          flyingRock4: { x: 26, y: 31, w: 8, h: 9 },
          flyingRock5: { x: 34, y: 31, w: 8, h: 8 },
          flyingRock6: { x: 42, y: 31, w: 9, h: 9 },
          flyingRock7: { x: 51, y: 31, w: 9, h: 8 },
          flyingRock8: { x: 60, y: 31, w: 9, h: 9 },

        };

        var arrowImg = {
          s: [
            { x: 74, y: 1065, w: 10, h: 12 },
            { x: 74, y: 1089, w: 10, h: 19 },
          ],

          w: [
            { x: 87, y: 1063, w: 25, h: 15 },
            { x: 86, y: 1092, w: 26, h: 9 },
          ],

          e: [
            { x: 116, y: 1063, w: 25, h: 15 },
            { x: 116, y: 1092, w: 26, h: 9 },
          ],

          n: [
            { x: 145, y: 1055, w: 8, h: 26 },
            { x: 145, y: 1086, w: 8, h: 20 },
          ],

          sw: [
            { x: 159, y: 1065, w: 25, h: 10 },
            { x: 160, y: 1086, w: 21, h: 20 },
          ],

          se: [
            { x: 190, y: 1065, w: 25, h: 10 },
            { x: 194, y: 1086, w: 21, h: 20 },
          ],

          nw: [
            { x: 218, y: 1061, w: 16, h: 21 },
            { x: 217, y: 1091, w: 21, h: 20 },
          ],

          ne: [
            { x: 240, y: 2061, w: 16, h: 21 },
            { x: 239, y: 1091, w: 21, h: 20 },
          ],
        };

        var lists = {
          types: {},
          imgs: { none: null },
          upgrades: { none: null },
          unitTypes: { none: null },
          buildingTypes: { none: null },
          buildingsUpgrades: {},
          modifiers: {},
          commands: {},
        };

        TileType.prototype = new MapObjectType();
        function TileType(data) {
          _.extend(this, data);

          /*
          // if img is an array (= animated tile), load all the images, else only load one img
          if(Object.prototype.toString.call(data.img) === '[object Array]')
          {
            for(var i = 0; i < data.img.length; i++)
              this.img[i] = loadImage(data.img[i]);
          }
          else
            this.img = loadImage(data.img);
          */

          this.minimapColor = '#ffffff'; // will be calculated correctly, when img is loaded
          this.isTile = true;

          this.circleOffset = 0.16;
          this.circleSize = this.sizeX * 0.75;
        };

        TileType.prototype.replaceReferences = function () {
          if (this.img && lists.imgs[this.name]) {
            this.img = lists.imgs[this.name];
          }
        };

        // loads an image and returns the image object
        function loadImage(imgFile) {
          try {
            Initialization.addPendingResource();

            var img = new Image();

            img.onload = () => {
              if (img && (!img.complete || !(img.width > 0))) {
                img.src = '';
                img.src = img.srcCpy;
                return;
              }

              Initialization.loadedPendingResource();
            };
            img.src = imgFile;
            img.srcCpy = imgFile; // in case we must load img again, store the path

            return img;
          } catch (error) {
            console.error(`Failed to load image from ${imgFile}`);
          }
        };

        function initCustomImgsObj() {
          for (key in customImgs) {
            delete customImgs[key];
          }

          for (key in unit_imgs) {
            customImgs[key] = unit_imgs[key].file;
          }

          customImgs['buildingSheet'] = buildingSheet;
          customImgs['tileSheet'] = tileSheet;
          customImgs['miscSheet'] = miscSheet;
        };

        // gets called when all the images are loaded, creates the color specific unit images from the original ones
        function createColorTransformedUnitImages() {
          var animNames = ['idle', 'walk', 'walkGold', 'attack', 'die', 'special1', 'dance1', 'dance2'];

          // units
          _.each(unit_imgs, function (img) {
            var img_ = img.idle ? img.idle : img.walk;

            img.file = [img.file].concat(ImageTransformer.replaceColors(img.file, searchColors, playerColors));
            img.file = img.file.concat(ImageTransformer.getGreyScaledImage(img.file[0]));

            // creating non existing images by linking them to walk img
            for (var i = 0; i < animNames.length; i++) {
              if (!img[animNames[i]]) {
                img[animNames[i]] = img.walk;
              }
            }
          });

          buildingSheet = [buildingSheet].concat(ImageTransformer.replaceColors(buildingSheet, searchColors, playerColors));
          buildingSheet = buildingSheet.concat(ImageTransformer.getGreyScaledImage(buildingSheet[0]));

          miscSheet = [miscSheet].concat(ImageTransformer.replaceColors(miscSheet, searchColors, playerColors));
          miscSheet = miscSheet.concat(ImageTransformer.getGreyScaledImage(miscSheet[0]));

          tileSheet = [tileSheet].concat(ImageTransformer.replaceColors(tileSheet, searchColors, playerColors));
          tileSheet = tileSheet.concat(ImageTransformer.getGreyScaledImage(tileSheet[0]));
        };

        Initialization.onResourcesLoaded(() => {
          // load replace colors
          var len = searchColors.length;
          var colorsImg = ImageTransformer.getImgFromSheet(tileSheet, { x: 196, y: 0, w: len, h: 1 });
          var colorsImgData = colorsImg.getContext('2d').getImageData(0, 0, colorsImg.width, colorsImg.height).data;
          for (var i = 0; i < len; i++) {
            searchColors[i] = [colorsImgData[i * 4], colorsImgData[i * 4 + 1], colorsImgData[i * 4 + 2]];
          }

          // create images for units for the other players by transforming colors from original image
          createColorTransformedUnitImages();

          // load tile imgs from spritesheet
          var tiles = tileTypes.concat(cliffs, cliffs_winter, egypt_cliffs, grave_cliffs, ramp_tiles, ramp_tiles_egypt, ramp_tiles_grave);
          for (var i = 0; i < tiles.length; i++) {
            tiles[i].img.frameWidth = tiles[i].img.w;
            tiles[i].img = { img: tiles[i].img, file: tileSheet, name: tiles[i].name };

            tiles[i].minimapColor = tiles[i].minimap_color ? tiles[i].minimap_color : ImageTransformer.getAverageColor(tiles[i].img);

            if (tiles[i].imgEditor) {
              tiles[i].img.imgEditor = tiles[i].imgEditor;
            }

            tileImgs[tiles[i].name] = tiles[i].img;
          }

          for (var i = 0; i < tileTypes.length; i++) {
            building_imgs[tileTypes[i].name] = tileTypes[i].img;
            tileTypes[i].img = tileTypes[i].name;
          }

          for (key in building_imgs) {
            building_imgs[key].name = key;
          }

          for (key in imgs) {
            imgs[key].frameWidth = 0;
            imgs[key] = {
              img: imgs[key],
              name: key,
              id_string: key,
              file: miscSheet,
            };
          }

          initCustomImgsObj();

          $('#loadingSoldier').remove();
          // Login after this?
        });


        var tileSheet = loadImage('imgs/tileSheet.png');
        var miscSheet = loadImage('imgs/miscSheet.png');
        var buildingSheet = (SPECIAL_EVENT == 'christmas') ? loadImage('imgs/buildingSheet_christmas.png') : loadImage('imgs/buildingSheet_new.png');

        var unit_imgs = {
          'soldier': {
            file: loadImage('imgs/units/soldier.png'),
            _angles: 8,
            idle: { x: 0, y: 0, w: 64, h: 256, frameWidth: 32 },
            walk: { x: 64, y: 0, w: 256, h: 256, frameWidth: 32 },
            die: { x: 672, y: 0, w: 256, h: 256, frameWidth: 32 },
            attack: { x: 320, y: 0, w: 352, h: 256, frameWidth: 32 },
            dance1: { x: 0, y: 256, w: 992, h: 32, frameWidth: 32 },
            dance2: { x: 0, y: 285, w: 256, h: 32, frameWidth: 32 },
            name: 'soldier',
          },

          'soldierS1': {
            file: loadImage('imgs/units/soldierS1.png'),
            _angles: 8,
            idle: { x: 0, y: 0, w: 64, h: 256, frameWidth: 32 },
            walk: { x: 64, y: 0, w: 256, h: 256, frameWidth: 32 },
            die: { x: 672, y: 0, w: 256, h: 256, frameWidth: 32 },
            attack: { x: 320, y: 0, w: 352, h: 256, frameWidth: 32 },
            dance1: { x: 0, y: 256, w: 992, h: 32, frameWidth: 32 },
            dance2: { x: 0, y: 285, w: 256, h: 32, frameWidth: 32 },
            name: 'soldierS1',
            isSkin: true,
          },

          'soldierS2': {
            file: loadImage('imgs/units/soldierS2.png'),
            _angles: 8,
            idle: { x: 0, y: 0, w: 64, h: 256, frameWidth: 32 },
            walk: { x: 64, y: 0, w: 256, h: 256, frameWidth: 32 },
            die: { x: 672, y: 0, w: 256, h: 256, frameWidth: 32 },
            attack: { x: 320, y: 0, w: 352, h: 256, frameWidth: 32 },
            dance1: { x: 0, y: 256, w: 992, h: 32, frameWidth: 32 },
            dance2: { x: 0, y: 285, w: 256, h: 32, frameWidth: 32 },
            name: 'soldierS2',
            isSkin: true,
          },

          'skeleton': {
            file: loadImage('imgs/units/skeletton.png'),
            _angles: 4,
            idle: { x: 0, y: 0, w: 72, h: 80, frameWidth: 18 },
            walk: { x: 75, y: 0, w: 144, h: 80, frameWidth: 18 },
            die: { x: 0, y: 87, w: 144, h: 80, frameWidth: 18 },
            attack: { x: 148, y: 87, w: 160, h: 80, frameWidth: 20 },
            special1: { x: 219, y: 0, w: 90, h: 80, frameWidth: 18 },
            name: 'skeleton',
          },

          'archer': {
            file: loadImage('imgs/units/archer.png'),
            _angles: 8,
            idle: { x: 0, y: 0, w: 64, h: 256, frameWidth: 32 },
            walk: { x: 64, y: 0, w: 256, h: 256, frameWidth: 32 },
            die: { x: 704, y: 0, w: 256, h: 256, frameWidth: 32 },
            attack: { x: 320, y: 0, w: 384, h: 256, frameWidth: 32 },
            name: 'archer',
          },

          'archerS1': {
            file: loadImage('imgs/units/archerS1.png'),
            _angles: 8,
            idle: { x: 0, y: 0, w: 64, h: 256, frameWidth: 32 },
            walk: { x: 64, y: 0, w: 256, h: 256, frameWidth: 32 },
            die: { x: 704, y: 0, w: 256, h: 256, frameWidth: 32 },
            attack: { x: 320, y: 0, w: 384, h: 256, frameWidth: 32 },
            name: 'archerS1',
            isSkin: true,
          },

          'rifleman': {
            file: loadImage('imgs/units/rifleman_old.png'),
            _angles: 4,
            idle: { x: 0, y: 0, w: 44, h: 80, frameWidth: 22 },
            walk: { x: 51, y: 0, w: 176, h: 80, frameWidth: 22 },
            die: { x: 0, y: 87, w: 176, h: 80, frameWidth: 22 },
            attack: { x: 187, y: 87, w: 132, h: 80, frameWidth: 22 },
            name: 'rifleman',
          },

          'worker': {
            file: (SPECIAL_EVENT == 'christmas') ? loadImage('imgs/units/worker_christmas.png') : loadImage('imgs/units/worker.png'),
            _angles: 8,
            idle: { x: 0, y: 0, w: 64, h: 256, frameWidth: 32 },
            walk: { x: 64, y: 0, w: 256, h: 256, frameWidth: 32 },
            walkGold: { x: 320, y: 0, w: 256, h: 256, frameWidth: 32 },
            die: { x: 768, y: 0, w: 256, h: 256, frameWidth: 32 },
            attack: { x: 576, y: 0, w: 192, h: 256, frameWidth: 32 },
            dance1: { x: 0, y: 256, w: 864, h: 32, frameWidth: 18 },
            name: 'worker',
          },

          'worker_christmas': {
            file: loadImage('imgs/units/worker_christmas.png'),
            _angles: 8,
            idle: { x: 0, y: 0, w: 64, h: 256, frameWidth: 32 },
            walk: { x: 64, y: 0, w: 256, h: 256, frameWidth: 32 },
            walkGold: { x: 320, y: 0, w: 256, h: 256, frameWidth: 32 },
            die: { x: 768, y: 0, w: 256, h: 256, frameWidth: 32 },
            attack: { x: 576, y: 0, w: 192, h: 256, frameWidth: 32 },
            dance1: { x: 0, y: 256, w: 864, h: 32, frameWidth: 18 },
            name: 'worker christmas',
          },

          'workerS1': {
            file: loadImage('imgs/units/workerS1.png'),
            _angles: 8,
            idle: { x: 0, y: 0, w: 64, h: 256, frameWidth: 32 },
            walk: { x: 64, y: 0, w: 256, h: 256, frameWidth: 32 },
            walkGold: { x: 320, y: 0, w: 256, h: 256, frameWidth: 32 },
            die: { x: 768, y: 0, w: 256, h: 256, frameWidth: 32 },
            attack: { x: 576, y: 0, w: 192, h: 256, frameWidth: 32 },
            dance1: { x: 0, y: 256, w: 864, h: 32, frameWidth: 18 },
            name: 'workerS1',
            isSkin: true,
          },

          'workerS2': {
            file: loadImage('imgs/units/workerS2.png'),
            _angles: 8,
            idle: { x: 0, y: 0, w: 64, h: 256, frameWidth: 32 },
            walk: { x: 64, y: 0, w: 256, h: 256, frameWidth: 32 },
            walkGold: { x: 320, y: 0, w: 256, h: 256, frameWidth: 32 },
            die: { x: 768, y: 0, w: 256, h: 256, frameWidth: 32 },
            attack: { x: 576, y: 0, w: 192, h: 256, frameWidth: 32 },
            dance1: { x: 0, y: 256, w: 864, h: 32, frameWidth: 18 },
            name: 'workerS2',
            isSkin: true,
          },

          'mage': {
            file: loadImage('imgs/units/mage.png'),
            _angles: 8,
            idle: { x: 0, y: 0, w: 64, h: 256, frameWidth: 32 },
            walk: { x: 64, y: 0, w: 256, h: 256, frameWidth: 32 },
            die: { x: 608, y: 0, w: 256, h: 256, frameWidth: 32 },
            attack: { x: 320, y: 0, w: 288, h: 256, frameWidth: 32 },
            name: 'mage',
          },

          'mageS1': {
            file: loadImage('imgs/units/mageS1.png'),
            _angles: 8,
            idle: { x: 0, y: 0, w: 64, h: 256, frameWidth: 32 },
            walk: { x: 64, y: 0, w: 256, h: 256, frameWidth: 32 },
            die: { x: 608, y: 0, w: 256, h: 256, frameWidth: 32 },
            attack: { x: 320, y: 0, w: 288, h: 256, frameWidth: 32 },
            name: 'mageS1',
            isSkin: true,
          },

          'priest': {
            file: loadImage('imgs/units/priest.png'),
            _angles: 8,
            idle: { x: 0, y: 0, w: 96, h: 256, frameWidth: 32 },
            walk: { x: 96, y: 0, w: 256, h: 256, frameWidth: 32 },
            die: { x: 544, y: 0, w: 256, h: 256, frameWidth: 32 },
            attack: { x: 352, y: 0, w: 192, h: 256, frameWidth: 32 },
            name: 'priest',
          },

          'catapult': {
            file: loadImage('imgs/units/catapult.png'),
            _angles: 8,
            idle: { x: 0, y: 0, w: 40, h: 264, frameWidth: 40 },
            walk: { x: 43, y: 0, w: 160, h: 264, frameWidth: 40 },
            die: { x: 233, y: 0, w: 357, h: 264, frameWidth: 51 },
            attack: { x: 0, y: 279, w: 722, h: 328, frameWidth: 38 },
            name: 'catapult',
          },

          'dragon': {
            file: loadImage('imgs/units/dragon.png'),
            _angles: 8,
            walk: { x: 0, y: 0, w: 720, h: 960, frameWidth: 120 },
            die: { x: 720, y: 0, w: 1920, h: 960, frameWidth: 120 },
            name: 'dragon',
          },

          'wolf': {
            file: loadImage('imgs/units/wolf.png'),
            _angles: 4,
            idle: { x: 0, y: 0, w: 60, h: 120, frameWidth: 30 },
            walk: { x: 121, y: 0, w: 180, h: 120, frameWidth: 30 },
            die: { x: 181, y: 121, w: 150, h: 120, frameWidth: 30 },
            attack: { x: 0, y: 120, w: 180, h: 120, frameWidth: 30 },
            name: 'wolf',
          },

          'bird': {
            file: loadImage('imgs/units/bird.png'),
            _angles: 8,
            walk: { x: 0, y: 0, w: 192, h: 572, frameWidth: 32 },
            die: { x: 192, y: 0, w: 256, h: 572, frameWidth: 32 },
            name: 'bird',
          },

          'airship': {
            file: loadImage('imgs/units/zeppelin.png'),
            _angles: 8,
            walk: { x: 0, y: 0, w: 800, h: 1120, frameWidth: 100 },
            die: { x: 800, y: 0, w: 800, h: 1120, frameWidth: 100 },
            name: 'airship',
          },

          'werewolf': {
            file: loadImage('imgs/units/beast.png'),
            _angles: 4,
            idle: { x: 623, y: 824, w: 267, h: 232, frameWidth: 89 },
            walk: { x: 0, y: 296, w: 712, h: 232, frameWidth: 89 },
            die: { x: 0, y: 824, w: 623, h: 232, frameWidth: 89 },
            attack: { x: 0, y: 528, w: 623, h: 296, frameWidth: 89 },
            special1: { x: 0, y: 0, w: 712, h: 296, frameWidth: 89 },
            name: 'werewolf',
          },

          'ballista': {
            file: loadImage('imgs/units/ballista.png'),
            _angles: 8,
            idle: { x: 0, y: 0, w: 66, h: 416, frameWidth: 66 },
            walk: { x: 0, y: 0, w: 264, h: 416, frameWidth: 66 },
            die: { x: 264, y: 0, w: 330, h: 416, frameWidth: 66 },
            attack: { x: 594, y: 0, w: 660, h: 416, frameWidth: 66 },
            name: 'ballista',
          },

          'totem': {
            file: loadImage('imgs/units/totem.png'),
            _angles: 1,
            idle: { x: 0, y: 0, w: 88, h: 30, frameWidth: 22 },
            walk: { x: 0, y: 0, w: 88, h: 30, frameWidth: 22 },
            die: { x: 0, y: 30, w: 324, h: 47, frameWidth: 54 },
            special1: { x: 88, y: 0, w: 154, h: 30, frameWidth: 22 },
            name: 'totem',
          },
          'raider': {
            'name': 'imgRaider',
            'file': loadImage('imgs/units/raider.png'),
            '_angles': 4,
            'idle': {
              'x': 0,
              'y': 0,
              'w': 64,
              'h': 128,
              'frameWidth': 32,
            },
            'walk': {
              'x': 64,
              'y': 0,
              'w': 192,
              'h': 128,
              'frameWidth': 32,
            },
            'walkGold': {
              'x': 64,
              'y': 0,
              'w': 192,
              'h': 128,
              'frameWidth': 32,
            },
            'die': {
              'x': 256,
              'y': 0,
              'w': 160,
              'h': 128,
              'frameWidth': 32,
            },
            'attack': {
              'x': 416,
              'y': 0,
              'w': 672,
              'h': 128,
              'frameWidth': 32,
            },
            'special1': {
              'x': 416,
              'y': 0,
              'w': 224,
              'h': 128,
              'frameWidth': 32,
            },
          },
          'snake': {
            'name': 'imgSnake',
            'file': loadImage('imgs/units/snake.png'),
            '_angles': 4,
            'idle': {
              'x': 1472,
              'y': 0,
              'w': 128,
              'h': 384,
              'frameWidth': 64,
            },
            'walk': {
              'x': 0,
              'y': 0,
              'w': 384,
              'h': 384,
              'frameWidth': 64,
            },
            'walkGold': {
              'x': 0,
              'y': 0,
              'w': 384,
              'h': 384,
              'frameWidth': 64,
            },
            'die': {
              'x': 384,
              'y': 0,
              'w': 448,
              'h': 384,
              'frameWidth': 64,
            },
            'attack': {
              'x': 382,
              'y': 0,
              'w': 640,
              'h': 384,
              'frameWidth': 64,
            },
            'special1': {
              'x': 382,
              'y': 0,
              'w': 640,
              'h': 384,
              'frameWidth': 64,
            },
          },
          'knight': {
            'name': 'imgKnight',
            'file': loadImage('imgs/units/knight.png'),
            '_angles': 8,
            'idle': {
              'x': 0,
              'y': 0,
              'w': 58,
              'h': 520,
              'frameWidth': 58,
            },
            'walk': {
              'x': 58,
              'y': 0,
              'w': 408,
              'h': 520,
              'frameWidth': 58,
            },
            'walkGold': {
              'x': 58,
              'y': 0,
              'w': 408,
              'h': 520,
              'frameWidth': 58,
            },
            'die': {
              'x': 408,
              'y': 520,
              'w': 58,
              'h': 520,
              'frameWidth': 58,
            },
            'attack': {
              'x': 0,
              'y': 520,
              'w': 348,
              'h': 520,
              'frameWidth': 58,
            },
            'special1': {
              'x': 348,
              'y': 520,
              'w': 58,
              'h': 520,
              'frameWidth': 58,
            },
          },
          'gatling_gun': {
            'name': 'imgCannon',
            'file': loadImage('imgs/units/gatling_gun.png'),
            '_angles': 8,
            'idle': {
              'x': 0,
              'y': 0,
              'w': 48,
              'h': 384,
              'frameWidth': 48,
            },
            'img': {
              'x': 0,
              'y': 0,
              'w': 48,
              'h': 384,
              'frameWidth': 48,
            },
            'walk': {
              'x': 0,
              'y': 0,
              'w': 192,
              'h': 384,
              'frameWidth': 48,
            },
            'walkGold': {
              'x': 0,
              'y': 0,
              'w': 192,
              'h': 384,
              'frameWidth': 48,
            },
            'die': {
              'x': 384,
              'y': 0,
              'w': 288,
              'h': 384,
              'frameWidth': 48,
            },
            'attack': {
              'x': 192,
              'y': 0,
              'w': 192,
              'h': 384,
              'frameWidth': 48,
            },
            'special1': {
              'x': 192,
              'y': 0,
              'w': 192,
              'h': 384,
              'frameWidth': 48,
            },
          },
          'shroud': {
            'name': 'imgShroud',
            'file': loadImage('imgs/shroud.png'),
            '_angles': 1,
            'idle': {
              'x': 0,
              'y': 0,
              'w': 88,
              'h': 88,
              'frameWidth': 88,
            },
            'walk': {
              'x': 0,
              'y': 0,
              'w': 352,
              'h': 88,
              'frameWidth': 88,
            },
            'die': {
              'x': 0,
              'y': 0,
              'w': 88,
              'h': 88,
              'frameWidth': 88,
            },
          },
          'buildings_snake': {
            'name': 'imgSnakeDen',
            'file': loadImage('imgs/buildings_snake.png'),
            '_angles': 1,
            'idle': {
              'x': 80,
              'y': 80,
              'w': 80,
              'h': 80,
              'frameWidth': 80,
            },
            'img': {
              'x': 80,
              'y': 80,
              'w': 80,
              'h': 80,
              'frameWidth': 80,
            },
            'constructionImg': {
              'x': 0,
              'y': 80,
              'w': 80,
              'h': 80,
              'frameWidth': 80,
            },
            'damagedImg': {
              'x': 160,
              'y': 80,
              'w': 80,
              'h': 80,
              'frameWidth': 80,
            },
            'busyImgs': {
              'x': 80,
              'y': 80,
              'w': 80,
              'h': 80,
              'frameWidth': 80,
            },
            'busyDamagedImgs': {
              'x': 160,
              'y': 80,
              'w': 80,
              'h': 80,
              'frameWidth': 80,
            },
            'upgradeImg': {
              'x': 80,
              'y': 80,
              'w': 80,
              'h': 80,
              'frameWidth': 80,
            },
            'upgradeImgDamaged': {
              'x': 160,
              'y': 80,
              'w': 80,
              'h': 80,
              'frameWidth': 80,
            },
          },
          'armory': {
            'name': 'imgArmory',
            'file': loadImage('imgs/buildings_snake.png'),
            '_angles': 1,
            'idle': {
              'x': 0,
              'y': 0,
              'w': 64,
              'h': 80,
              'frameWidth': 64,
            },
            'img': {
              'x': 0,
              'y': 0,
              'w': 64,
              'h': 80,
              'frameWidth': 64,
            },
            'constructionImg': {
              'x': 128,
              'y': 0,
              'w': 64,
              'h': 80,
              'frameWidth': 64,
            },
            'damagedImg': {
              'x': 64,
              'y': 0,
              'w': 64,
              'h': 80,
              'frameWidth': 64,
            },
            'busyImgs': {
              'x': 0,
              'y': 0,
              'w': 64,
              'h': 80,
              'frameWidth': 64,
            },
            'busyDamagedImgs': {
              'x': 64,
              'y': 0,
              'w': 64,
              'h': 80,
              'frameWidth': 64,
            },
            'upgradeImg': {
              'x': 0,
              'y': 0,
              'w': 46,
              'h': 80,
              'frameWidth': 64,
            },
            'upgradeImgDamaged': {
              'x': 64,
              'y': 0,
              'w': 64,
              'h': 80,
              'frameWidth': 64,
            },
          },
          'caltropg': {
            'name': 'zCaltrop',
            'file': loadImage('imgs/totem.png'),
            '_angles': 1,
            'idle': {
              'x': 0,
              'y': 0,
              'w': 22,
              'h': 30,
              'frameWidth': 22,
            },
            'walk': {
              'x': 0,
              'y': 0,
              'w': 88,
              'h': 30,
              'frameWidth': 22,
            },
            'walkGold': {
              'x': 0,
              'y': 0,
              'w': 88,
              'h': 30,
              'frameWidth': 22,
            },
            'die': {
              'x': 0,
              'y': 30,
              'w': 324,
              'h': 47,
              'frameWidth': 54,
            },
            'attack': {
              'x': 0,
              'y': 0,
              'w': 88,
              'h': 30,
              'frameWidth': 22,
            },
          },
          'gyrocopter': {
            'name': 'Gyrocraft',
            'file': loadImage('imgs/units/gyrocopter.png'),
            '_angles': 8,
            'idle': {
              'x': 0,
              'y': 0,
              'w': 576,
              'h': 648,
              'frameWidth': 48,
            },
            'walk': {
              'x': 0,
              'y': 0,
              'w': 576,
              'h': 648,
              'frameWidth': 48,
            },
            'walkGold': {
              'x': 0,
              'y': 0,
              'w': 600,
              'h': 520,
              'frameWidth': 48,
            },
            'die': {
              'x': 576,
              'y': 0,
              'w': 960,
              'h': 648,
              'frameWidth': 48,
            },
            'attack': {
              'x': 0,
              'y': 0,
              'w': 576,
              'h': 648,
              'frameWidth': 48,
            },
            'special1': {
              'x': 0,
              'y': 0,
              'w': 600,
              'h': 520,
              'frameWidth': 100,
            },
          },
          'mill': {
            'name': 'mill',
            'file': loadImage('imgs/mill.png'),
            '_angles': 1,
            'idle': {
              'x': 0,
              'y': 20,
              'w': 320,
              'h': 80,
              'frameWidth': 80,
              'frames': [
                0,
                0,
                0,
                1,
                1,
                1,
                2,
                2,
                2,
              ],
            },
            'img': {
              'x': 0,
              'y': 20,
              'w': 80,
              'h': 80,
              'frameWidth': 80,
            },
            'constructionImg': {
              'x': 640,
              'y': 20,
              'w': 80,
              'h': 80,
              'frameWidth': 80,
            },
            'damagedImg': {
              'x': 320,
              'y': 20,
              'w': 80,
              'h': 80,
              'frameWidth': 80,
            },
            'busyImgs': {
              'x': 0,
              'y': 20,
              'w': 320,
              'h': 80,
              'frameWidth': 80,
              'frames': [
                0,
                0,
                0,
                1,
                1,
                1,
                2,
                2,
                2,
                3,
                3,
                3,
              ],
            },
            'busyDamagedImgs': {
              'x': 320,
              'y': 20,
              'w': 320,
              'h': 80,
              'frameWidth': 80,
              'frames': [
                0,
                0,
                0,
                1,
                1,
                1,
                2,
                2,
                2,
                3,
                3,
                3,
              ],
            },
          },
        };

        // For some reason putting sound in config.js is not early enough
        const SOUND = require('./data/Sound.js');

        var buildingData = [
          {
            name: 'Castle',
            id_string: 'castle',
            hp: 2250,
            supplyProvided: 10,
            size: 4,
            weaponCooldown: 1 * 20,
            weaponDelay: 1 * 20,
            dmg: 0,
            armor: 1,
            range: 0,
            vision: 10,
            circleSize: 2.65,
            circleOffset: 0.625,
            commands: {
              trainworker: 'trainworker',
              upgradetofortress: 'upgradetofortress',
              trainbird: 'trainbird',
              bird_detection_cmd: 'bird_detection_cmd',
            },
            buildTime: 54 * 20,
            cost: 350,
            healthbarOffset: 3.25,
            healthbarWidth: 2.5,
            img: 'castle',
            description: 'The Castle is your main building. It can train Workers and is used to return gathered gold.',
            timeToMine: 2, // how many ticks workers stay to get / deliver gold
            projectileLen: 0.22,
            tabPriority: 16,
            takesGold: true,
            preventsReveal: true,
            goldPerDelivery: 0,
            clickSound: SOUND.CC,
            clickSoundVolume: 1,
            canHaveWaypoint: true,
          },
          {
            name: 'Barracks',
            id_string: 'barracks',
            hp: 1200,
            size: 3,
            weaponCooldown: 1 * 20,
            weaponDelay: 1 * 20,
            dmg: 0,
            armor: 1,
            range: 0,
            vision: 8,
            circleSize: 2.4,
            circleOffset: 0.25,
            commands: {
              trainsoldier: 'trainsoldier',
              trainarcher: 'trainarcher',
              train_raider: 'train_raider',
              trainmage: 'trainmage',
            },
            buildTime: 40 * 20,
            cost: 125,
            healthbarOffset: 3.7,
            healthbarWidth: 2.0,
            img: 'barracks',
            description: 'The Barracks can train Soldiers, Archers, Mages and Raiders.',
            tabPriority: 12,
            preventsReveal: false,
            clickSound: SOUND.RAX,
            clickSoundVolume: 0.8,
            canHaveWaypoint: true,
          },
          {
            name: 'Watchtower',
            id_string: 'watchtower',
            hp: 500,
            size: 2,
            weaponCooldown: 1.6 * 20,
            weaponDelay: 0.3 * 20,
            dmg: 30,
            armor: 1,
            range: 7,
            vision: 12,
            projectileSpeed: 14,
            projectileStartHeight: 1.75,
            attackLaunchSound: SOUND.SWING,
            circleSize: 1.45,
            circleOffset: 0.312,
            commands: {
              stop: 'stop',
              attack: 'attack',
              researchdetection: 'researchdetection',
            },
            buildTime: 40 * 20,
            cost: 130,
            costIncrease: 5,
            costIncreaseGroup: [
              'watchtower',
            ],
            healthbarOffset: 3.69,
            healthbarWidth: 1.56,
            img: 'watchtower',
            description: 'The Watchtower is a defensive structure, which shoots arrows at enemy units in range.',
            projectileLen: 0.22,
            tabPriority: 2,
            attackEffect: 'arrow',
            canAttackFlying: true,
            hasDetection: false,
            preventsReveal: false,
            attackPrio: 10,
          },
          {
            name: 'Watchtower (detection)',
            id_string: 'watchtower2',
            hp: 450,
            size: 2,
            weaponCooldown: 1.6 * 20,
            weaponDelay: 0.3 * 20,
            dmg: 30,
            armor: 1,
            range: 7,
            vision: 12,
            projectileSpeed: 14,
            projectileStartHeight: 1.75,
            attackLaunchSound: SOUND.SWING,
            circleSize: 1.45,
            circleOffset: 0.312,
            commands: {
              stop: 'stop',
              attack: 'attack',
            },
            buildTime: 30 * 20,
            cost: 25,
            healthbarOffset: 3.69,
            healthbarWidth: 1.56,
            img: 'watchtower',
            description: 'The Watchtower is a defensive structure, which shoots arrows at enemy units in range. Watchtowers get more expensive the more you have. Watchtowers have detection, that means they can see enemy invisible units.',
            projectileLen: 0.22,
            tabPriority: 2,
            attackEffect: 'arrow',
            canAttackFlying: true,
            hasDetection: true,
            preventsReveal: false,
            attackPrio: 10,
          },
          {
            name: 'House',
            id_string: 'house',
            hp: 900,
            supplyProvided: 10,
            size: 3,
            weaponCooldown: 1.8 * 20,
            weaponDelay: 1 * 20,
            dmg: 0,
            armor: 1,
            range: 0,
            vision: 8,
            circleSize: 2.4,
            circleOffset: 0.25,
            commands: {},
            buildTime: 25 * 20,
            cost: 100,
            healthbarOffset: 3.4,
            healthbarWidth: 2.1,
            img: 'house',
            description: 'A House increases your maximum population by 10. You require a house to construct Barracks, Wolf Dens, and Workshops',
            tabPriority: 1,
            preventsReveal: false,
            clickSound: SOUND.HOUSE,
            clickSoundVolume: 1,
          },
          {
            name: 'Goldmine',
            id_string: 'goldmine',
            hp: 40000,
            size: 3,
            weaponCooldown: 1 * 20,
            weaponDelay: 1 * 20,
            dmg: 0,
            armor: 10,
            range: 0,
            vision: 0,
            circleSize: 2.12,
            circleOffset: 0.17,
            commands: {},
            buildTime: 30 * 20,
            cost: 250,
            healthbarOffset: 2.15,
            healthbarWidth: 2.03,
            img: 'mine',
            description: 'The Goldmine contains gold for players to gather using Workers. Too many Workers on one mine leads to inefficient mining.',
            isInvincible: true,
            startGold: 6000,
            maxWorkers: 7,
            miningEfficiencyCoefficient: 0.5,
            minMiningRate: 0.25,
            timeToMine: 32,
            alwaysNeutral: true,
            goldPerDelivery: 5,
            preventsReveal: false,
          },
          {
            name: 'Mages Guild',
            id_string: 'magesguild',
            hp: 950,
            size: 3,
            weaponCooldown: 1 * 20,
            weaponDelay: 1 * 20,
            dmg: 0,
            armor: 1,
            range: 0,
            vision: 8,
            circleSize: 2.1,
            circleOffset: 0.2,
            commands: {
              researchfireball: 'researchfireball',
            },
            buildTime: 54 * 20,
            cost: 150,
            healthbarOffset: 3.45,
            healthbarWidth: 2.04,
            img: 'mages_guild',
            description: 'The Mages Guild allows you to train Mages from the barracks and research fireball. Mages are strong, but vulnerable units.',
            tabPriority: 3,
            preventsReveal: false,
            clickSound: SOUND.MAGES_GUILD,
            clickSoundVolume: 0.9,
            canHaveWaypoint: true,
          },
          {
            name: 'Workshop',
            id_string: 'workshop',
            hp: 1300,
            size: 4,
            weaponCooldown: 1 * 20,
            weaponDelay: 1 * 20,
            dmg: 0,
            armor: 1,
            range: 0,
            vision: 8,
            circleSize: 3,
            circleOffset: 0.4,
            commands: {
              constructcatapult: 'constructcatapult',
              construct_gatling: 'construct_gatling',
              spokedwheel_cmd: 'spokedwheel_cmd',
            },
            buildTime: 55 * 20,
            cost: 125,
            healthbarOffset: 3.6,
            healthbarWidth: 2.7,
            img: 'workshop',
            busySmokeEffectLocationX: 0.5,
            busySmokeEffectLocationY: 3,
            busySmokeEffectLocationZ: 5.7,
            description: 'The Workshop allows you to build Catapults, Gatling Guns and research upgrades.',
            tabPriority: 10,
            preventsReveal: false,
            clickSound: SOUND.WORKSHOP,
            clickSoundVolume: 1,
            canHaveWaypoint: true,
          },
          {
            name: 'Forge',
            id_string: 'forge',
            hp: 800,
            size: 4,
            weaponCooldown: 1 * 20,
            weaponDelay: 1 * 20,
            dmg: 0,
            armor: 1,
            range: 0,
            vision: 8,
            circleSize: 3,
            circleOffset: 0.2,
            commands: {
              attackupgrade: 'attackupgrade',
              armorupgrade: 'armorupgrade',
              mechattackupgrade: 'mechattackupgrade',
              mecharmorupgrade: 'mecharmorupgrade',
            },
            buildTime: 50 * 20,
            cost: 150,
            healthbarOffset: 3,
            healthbarWidth: 2.7,
            img: 'forge',
            busySmokeEffectLocationX: -1.3,
            busySmokeEffectLocationY: 3,
            busySmokeEffectLocationZ: 5.0,
            description: 'The Forge provides you with the ability to research armor and damage upgrades for human or mechanical units',
            tabPriority: 6,
            preventsReveal: false,
            clickSound: SOUND.FORGE,
            clickSoundVolume: 0.75,
          },
          {
            name: 'Start Location',
            id_string: 'startlocation',
            hp: 400,
            size: 4,
            weaponCooldown: 1 * 20,
            supplyProvided: 10,
            weaponDelay: 1 * 20,
            dmg: 0,
            armor: 1,
            range: 0,
            vision: 8,
            circleSize: 3,
            circleOffset: 0.2,
            commands: {},
            buildTime: 55 * 20,
            cost: 150,
            healthbarOffset: 3,
            healthbarWidth: 2.7,
            img: 'start_location',
            description: 'The Start Location marks where a player starts. When the game begins, a Castle and 6 Workers will be created at this position.',
            tabPriority: 1,
            isInvincible: true,
            limit: 1,
            takesGold: true,
            preventsReveal: true,
          },
          {
            name: 'Fortress',
            id_string: 'fortress',
            hp: 2900,
            supplyProvided: 10,
            size: 4,
            weaponCooldown: 2 * 20,
            weaponDelay: 1 * 20,
            dmg: 0,
            armor: 2,
            range: 0,
            projectileSpeed: 14,
            projectileStartHeight: 1.75,
            attackLaunchSound: SOUND.SWING,
            vision: 10,
            circleSize: 2.65,
            circleOffset: 0.625,
            commands: {
              trainworker: 'trainworker',
              trainbird: 'trainbird',
              bird_detection_cmd: 'bird_detection_cmd',
            },
            buildTime: 72 * 20,
            cost: 100,
            healthbarOffset: 4.25,
            healthbarWidth: 2.5,
            img: 'fortress',
            description: 'The Fortress is an advanced version of the Castle. It allows you to build a Dragons Lair.',
            timeToMine: 2, // how many ticks workers stay to get / deliver gold
            projectileLen: 0.22,
            tabPriority: 16,
            attackEffect: 'arrow',
            takesGold: true,
            preventsReveal: true,
            clickSound: SOUND.CC,
            clickSoundVolume: 1,
            canHaveWaypoint: true,
          },
          {
            name: 'Dragons Lair',
            id_string: 'dragonslair',
            hp: 950,
            size: 3,
            weaponCooldown: 1 * 20,
            weaponDelay: 1 * 20,
            dmg: 0,
            armor: 1,
            range: 0,
            vision: 8,
            circleSize: 2.5,
            circleOffset: 0.15,
            commands: {
              traindragon: 'traindragon',
            },
            buildTime: 72 * 20,
            cost: 200,
            healthbarOffset: 4.65,
            healthbarWidth: 2.5,
            img: 'dragons_lair',
            description: 'The Dragons Lair allows you to train Dragons.',
            tabPriority: 13,
            preventsReveal: false,
            clickSound: SOUND.DRAGONS_LAIR,
            clickSoundVolume: 0.85,
            canHaveWaypoint: true,
          },
          {
            name: 'Wolves Den',
            id_string: 'wolvesden',
            hp: 950,
            size: 3,
            weaponCooldown: 1 * 20,
            weaponDelay: 1 * 20,
            dmg: 0,
            armor: 1,
            range: 0,
            vision: 8,
            circleSize: 2.3,
            circleOffset: 0.125,
            commands: {
              trainwolf: 'trainwolf',
              train_snake: 'train_snake',
              upgradetowerewolvesden: 'upgradetowerewolvesden',
            },
            buildTime: 40 * 20,
            cost: 100,
            healthbarOffset: 2.95,
            healthbarWidth: 2.5,
            img: 'wolves_den',
            description: 'The Wolves Den allows you to train Wolves and Snakes.',
            tabPriority: 14,
            preventsReveal: false,
            clickSound: SOUND.W_DEN,
            clickSoundVolume: 1,
            canHaveWaypoint: true,
          },
          {
            name: 'Animal Testing Lab',
            id_string: 'animaltestinglab',
            hp: 900,
            size: 4,
            weaponCooldown: 1 * 20,
            weaponDelay: 1 * 20,
            dmg: 0,
            armor: 1,
            range: 0,
            vision: 8,
            circleSize: 3.4,
            circleOffset: 0.125,
            commands: {
              beastattackupgrade: 'beastattackupgrade',
              beastdefenseupgrade: 'beastdefenseupgrade',
            },
            buildTime: 54 * 20,
            cost: 150,
            healthbarOffset: 3.75,
            healthbarWidth: 3.1,
            img: 'animal_testing_lab',
            description: 'The Animal Testing Lab allows you to research upgrades for your beasts.',
            tabPriority: 7,
            preventsReveal: false,
            clickSound: SOUND.LAB,
            clickSoundVolume: 1,
          },
          {
            name: 'Advanced Workshop',
            id_string: 'advancedworkshop',
            hp: 1050,
            size: 4,
            weaponCooldown: 1 * 20,
            weaponDelay: 1 * 20,
            dmg: 0,
            armor: 1,
            range: 0,
            vision: 8,
            circleSize: 3.4,
            circleOffset: 0.125,
            commands: {
              constructballista: 'constructballista',
              constructairship: 'constructairship',
              ballistaexplosives: 'ballistaexplosives',
              researchtelescope: 'researchtelescope',
            },
            buildTime: 63 * 20,
            cost: 140,
            healthbarOffset: 3.75,
            healthbarWidth: 3.1,
            img: 'adv_workshop',
            description: 'The Advanced Workshop allows you to build Airships and Ballistas.',
            tabPriority: 9,
            preventsReveal: false,
            clickSound: SOUND.A_WS,
            clickSoundVolume: 1,
            canHaveWaypoint: true,
          },
          {
            name: 'Werewolves Den',
            id_string: 'werewolvesden',
            hp: 1200,
            size: 3,
            weaponCooldown: 1 * 20,
            weaponDelay: 1 * 20,
            dmg: 0,
            armor: 2,
            range: 0,
            vision: 8,
            circleSize: 2.3,
            circleOffset: 0.125,
            commands: {
              trainwolf: 'trainwolf',
              train_snake: 'train_snake',
              trainwerewolf: 'trainwerewolf',
            },
            buildTime: 65 * 20,
            cost: 225,
            healthbarOffset: 3.95,
            healthbarWidth: 2.5,
            img: 'werewolves_den',
            description: 'The Werewolves Den allows you to train Wolves, Snakes and Werewolves.',
            tabPriority: 15,
            preventsReveal: false,
            clickSound: SOUND.WW_DEN,
            clickSoundVolume: 1,
            canHaveWaypoint: true,
          },
          {
            name: 'Church',
            id_string: 'church',
            hp: 1100,
            size: 4,
            weaponCooldown: 1 * 20,
            weaponDelay: 1 * 20,
            dmg: 0,
            armor: 1,
            range: 0,
            vision: 8,
            circleSize: 3.3,
            circleOffset: 0.125,
            commands: {
              researchinvisibility: 'researchinvisibility',
              trainpriest: 'trainpriest',
            },
            buildTime: 54 * 20,
            cost: 175,
            healthbarOffset: 4.7,
            healthbarWidth: 2.5,
            img: 'church',
            description: 'The Church allows you to train Priests and research spells. Priests are strong, but vulnerable units.',
            tabPriority: 11,
            preventsReveal: false,
            clickSound: SOUND.CHURCH,
            clickSoundVolume: 1,
            canHaveWaypoint: true,
          },
          {
            name: 'Snake Charmer',
            id_string: 'snakecharmer',
            hp: 880,
            supplyProvided: 0,
            size: 2,
            weaponCooldown: 1 * 20,
            weaponDelay: 1 * 20,
            dmg: 0,
            armor: 1,
            range: 0,
            vision: 8,
            circleSize: 1.5,
            imageScale: 0.7,
            circleOffset: 0.1,
            buildTime: 40 * 20,
            commands: {
              research_sprint: 'research_sprint',
            },
            cost: 100,
            healthbarOffset: 1.9,
            healthbarWidth: 1.4,
            selectionOffsetY: 0,
            img: 'buildings_snake',
            description: 'Construction of this building allows you to build Snakes in the Wolf Den and unlock Wolf Sprint.',
            timeToMine: 2, // how many ticks workers stay to get / deliver gold
            projectileLen: 0.22,
            tabPriority: 5,
            takesGold: false,
            preventsReveal: false,
            clickSound: SOUND.SNAKE_CHARMER,
            clickSoundVolume: 1,
            canHaveWaypoint: false,
          },
          {
            name: 'Mill',
            id_string: 'mill',
            hp: 1050,
            mana: 0,
            startMana: 0,
            hpRegenerationRate: 0 / 20,
            manaRegenerationRate: 0 / 20,
            armor: 1,
            supply: 0,
            supplyProvided: 0,
            weaponCooldown: 1 * 20,
            weaponDelay: 1 * 20,
            dmg: 0,
            dmgModifierAttributes: [],
            dmgModifierAddition: [],
            dmgModifierMultiplier: [],
            lifesteal: 0,
            armorPenetration: 0,
            percDmg: 0,
            dmgCap: 1,
            range: 0,
            minRange: -999,
            aoeRadius: 0,
            bouncePower: 0,
            bounceDistMin: 0,
            bounceDistMax: 0,
            attackPrio: 5,
            vision: 8,
            projectileSpeed: 8,
            projectileLen: 0.2,
            attackLaunchSound: 0,
            attackEffect: null,
            projectileStartHeight: 0,
            circleSize: 3.4,
            imageScale: 1,
            circleOffset: 0.125,
            buildTime: 63 * 20,
            cost: 140,
            costIncrease: 150,
            costIncreaseGroup: [],
            healthbarOffset: 3.3,
            healthbarWidth: 3.1,
            selectionOffsetY: 0,
            img: 'mill',
            description: 'The Mill allows you to build Gyrocrafts.',
            tabPriority: 8,
            drawOffsetY: 6,
            size: 4,
            repairRate: 0 / 20,
            startGold: 0,
            timeToMine: 20,
            miningEfficiencyCoefficient: 0.5,
            minMiningRate: 0.1,
            maxWorkers: 6,
            limit: 0,
            visionHeightBonus: 0,
            commands: {
              construct_gyrocraft: 'construct_gyrocraft',
            },
            lifetime: 0,
            goldReward: 0,
            maxUnitsToRepair: 1,
            modifiers: [],
            modifiersSelf: [],
            spawnModifiers: [],
            deathSound: 12,
            clickSound: SOUND.MILL,
            clickSoundVolume: 1,
            hoverText: '',
            canHaveWaypoint: true,
            causesFlameDeath: false,
            hitscan: false,
            maximizeRangeWhenShooting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            canAttackGround: true,
            canAttackFlying: false,
            isHeatSeeking: true,
            ignoreEnemyHitscan: false,
            controllable: true,
            hasDetection: false,
            expOnlyFromOwnKills: false,
            alliesGetExperience: false,
            alliesGetGold: false,
            isReflectingProjectiles: false,
            isBlockingProjectiles: false,
            takeDamageOnBlock: false,
            isInvincible: false,
            isInvisible: false,
            alwaysNeutral: false,
            takesGold: false,
            spawnWithAMove: false,
            preventsReveal: false,
            preventsLoss: true,
            isMechanical: false,
            isUndead: false,
            isBiological: false,
            isBeast: false,
            isHuman: false,
            noShow: false,
          },
          {
            name: 'Armory',
            id_string: 'armory',
            hp: 880,
            mana: 0,
            startMana: 0,
            hpRegenerationRate: 0 / 20,
            manaRegenerationRate: 0 / 20,
            armor: 1,
            supply: 0,
            supplyProvided: 0,
            weaponCooldown: 1.8 * 20,
            weaponDelay: 1 * 20,
            dmg: 0,
            dmgModifierAttributes: [],
            dmgModifierAddition: [],
            dmgModifierMultiplier: [],
            lifesteal: 0,
            armorPenetration: 0,
            percDmg: 0,
            dmgCap: 1,
            range: 0.2,
            minRange: -999,
            aoeRadius: 0,
            bouncePower: 0,
            bounceDistMin: 0,
            bounceDistMax: 0,
            attackPrio: 5,
            vision: 8,
            projectileSpeed: 8,
            projectileLen: 0.2,
            attackLaunchSound: 0,
            attackEffect: null,
            projectileStartHeight: 0,
            circleSize: 2.2,
            imageScale: 1,
            circleOffset: 0.35,
            buildTime: 50 * 20,
            cost: 150,
            costIncrease: 150,
            costIncreaseGroup: [],
            healthbarOffset: 2.8,
            healthbarWidth: 2.1,
            selectionOffsetY: 0,
            img: 'armory',
            description: 'The Armory researches abilities for your Barracks units.',
            tabPriority: 4,
            drawOffsetY: 6,
            size: 3,
            repairRate: 0 / 20,
            startGold: 0,
            timeToMine: 20,
            miningEfficiencyCoefficient: 0.5,
            minMiningRate: 0.1,
            maxWorkers: 6,
            limit: 0,
            visionHeightBonus: 0,
            commands: {
              rangeupgrade: 'rangeupgrade',
              researchraidershroudupgrade: 'researchraidershroudupgrade',
            },
            lifetime: 0,
            goldReward: 0,
            maxUnitsToRepair: 1,
            modifiers: [],
            modifiersSelf: [],
            spawnModifiers: [],
            deathSound: 12,
            clickSound: SOUND.ARMORY,
            clickSoundVolume: 1,
            hoverText: '',
            canHaveWaypoint: false,
            causesFlameDeath: false,
            hitscan: false,
            maximizeRangeWhenShooting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            canAttackGround: true,
            canAttackFlying: false,
            isHeatSeeking: true,
            ignoreEnemyHitscan: false,
            controllable: true,
            hasDetection: false,
            expOnlyFromOwnKills: false,
            alliesGetExperience: false,
            alliesGetGold: false,
            isReflectingProjectiles: false,
            isBlockingProjectiles: false,
            takeDamageOnBlock: false,
            isInvincible: false,
            isInvisible: false,
            alwaysNeutral: false,
            takesGold: false,
            spawnWithAMove: false,
            preventsReveal: false,
            preventsLoss: true,
            isMechanical: false,
            isUndead: false,
            isBiological: false,
            isBeast: false,
            isHuman: false,
            noShow: false,
          },
        ];

        var commands = [
          {
            type: COMMAND.MAKEUNIT,
            unitType: 'worker',
            isInstant: true,
            image: 'worker',
            hotkey: KEY.Q,
            name: 'Train Worker',
            id_string: 'trainworker',
            description: 'Cost: getField(worker.cost) Gold#BRSupply: getField(worker.supply)#BRDuration: getField(worker.buildTime) sec#BRgetField(worker.description)',
            interfacePosX: 0,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.MAKEUNIT,
            unitType: 'soldier',
            isInstant: true,
            image: 'soldier',
            hotkey: KEY.Q,
            name: 'Train Soldier',
            id_string: 'trainsoldier',
            description: 'Cost: getField(soldier.cost) Gold#BRSupply: getField(soldier.supply)#BRDuration: getField(soldier.buildTime) sec#BRgetField(soldier.description)',
            interfacePosX: 0,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.MAKEUNIT,
            unitType: 'archer',
            isInstant: true,
            image: 'archer',
            hotkey: KEY.W,
            name: 'Train Archer',
            id_string: 'trainarcher',
            description: 'Cost: getField(archer.cost) Gold#BRSupply: getField(archer.supply)#BRDuration: getField(archer.buildTime) sec#BRgetField(archer.description)',
            interfacePosX: 1,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.MAKEBUILDING,
            unitType: 'castle',
            image: 'castle',
            hotkey: KEY.A,
            name: 'Build Castle',
            id_string: 'buildcastle',
            description: 'Cost: getField(castle.cost) Gold#BRDuration: getField(castle.buildTime) sec#BRgetField(castle.description)',
            targetIsPoint: true,
            commandCard: 1,
            interfacePosX: 0,
            interfacePosY: 1,
          },

          {
            type: COMMAND.MAKEBUILDING,
            unitType: 'barracks',
            image: 'barracks',
            hotkey: KEY.Q,
            name: 'Build Barracks',
            id_string: 'buildbarracks',
            requirementType: ['house'],
            requirementLevel: [1],
            requirementText: ['Requires a House'],
            description: 'Cost: getField(barracks.cost) Gold#BRDuration: getField(barracks.buildTime) sec#BRgetField(barracks.description)',
            targetIsPoint: true,
            commandCard: 2,
            interfacePosX: 0,
            interfacePosY: 0,
          },

          {
            type: COMMAND.MAKEBUILDING,
            unitType: 'watchtower',
            image: 'watchtower',
            hotkey: KEY.W,
            name: 'Build Watchtower',
            id_string: 'buildwatchtower',
            description: 'Cost: getField(watchtower.cost) Gold#BRDuration: getField(watchtower.buildTime) sec#BRgetField(watchtower.description)',
            targetIsPoint: true,
            commandCard: 1,
            interfacePosX: 1,
            interfacePosY: 0,
          },

          {
            type: COMMAND.MAKEBUILDING,
            unitType: 'house',
            image: 'house',
            hotkey: KEY.E,
            name: 'Build House',
            id_string: 'buildhouse',
            description: 'Cost: getField(house.cost) Gold#BRDuration: getField(house.buildTime) sec#BRgetField(house.description)',
            targetIsPoint: true,
            commandCard: 1,
            interfacePosX: 2,
            interfacePosY: 0,
          },

          {
            type: COMMAND.IDLE,
            isInstant: true,
            image: 'stop',
            hotkey: KEY.S,
            name: 'Stop',
            id_string: 'stop',
            description: 'Stop and cancel any existing orders.',
            interfacePosX: 1,
            interfacePosY: 1,
            commandCard: 0,
          },

          {
            type: COMMAND.HOLDPOSITION,
            isInstant: true,
            image: 'holdposition',
            hotkey: KEY.D,
            name: 'Hold Position',
            id_string: 'holdposition',
            description: 'The unit will stop and not move whatsoever.',
            interfacePosX: 2,
            interfacePosY: 1,
            commandCard: 0,
          },

          {
            type: COMMAND.ATTACK,
            image: 'attack',
            hotkey: KEY.A,
            name: 'Attack',
            id_string: 'attack',
            description: 'Order attack an enemy unit to attack it directly or order attack at a point to order your unit(s) to move there and attacking any enemies on its way.',
            targetIsUnit: true,
            interfacePosX: 0,
            interfacePosY: 1,
            commandCard: 0,
            cursor: Cursors.ATTACK,
          },

          {
            type: COMMAND.CANCEL,
            isInstant: true,
            targetIsInt: true,
            image: 'cancel',
            hotkey: KEY.R,
            name: 'Cancel',
            id_string: 'cancel',
            description: 'Cancel the current order.',
            interfacePosX: 4,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.MOVE,
            name: 'Move',
            id_string: 'move',
            targetIsPoint: true,
          },

          {
            type: COMMAND.MOVETO,
            name: 'Moveto',
            id_string: 'moveto',
            targetIsUnit: true,
            range: [0.2],
          },

          {
            type: COMMAND.MINE,
            name: 'Mine',
            id_string: 'mine',
            targetIsUnit: true,
            range: [0.2],
          },

          {
            type: COMMAND.REPAIR,
            name: 'Repair',
            id_string: 'repair',
            image: 'repair',
            description: 'Repair a building or a mechanical unit.',
            targetIsUnit: true,
            range: [0],
            hotkey: KEY.F,
            interfacePosX: 3,
            interfacePosY: 1,
            commandCard: 0,
            targetRequirements1: [targetRequirements.isBuilding, targetRequirements.isMechanical],
            hasAutocast: true,
            autocastConditions: 'hp < type.hp - 1 && owner == this.owner && isUnderConstruction != 1',
          },

          {
            type: COMMAND.AMOVE,
            name: 'AMove',
            id_string: 'amove',
            targetIsPoint: true,
          },

          {
            type: COMMAND.MAKEBUILDING,
            name: 'Makebuilding',
            id_string: 'makebuilding',
          },

          {
            type: COMMAND.MAKEUNIT,
            unitType: 'mage',
            isInstant: true,
            image: 'mage',
            hotkey: KEY.A,
            name: 'Train Mage',
            id_string: 'trainmage',
            description: 'Cost: getField(mage.cost) Gold#BRSupply: getField(mage.supply)#BRDuration: getField(mage.buildTime) sec#BRgetField(mage.description) Train a mage, requires a mage\'s guild.',
            requirementText: ['Requires a Mages Guild'],
            requirementType: ['magesguild'],
            requirementLevel: [1],
            interfacePosX: 0,
            interfacePosY: 1,
            commandCard: 0,
          },

          {
            type: COMMAND.MAKEUNIT,
            unitType: 'priest',
            id_string: 'trainpriest',
            isInstant: true,
            image: 'priest',
            hotkey: KEY.A,
            name: 'Train Priest',
            id_string: 'trainpriest',
            description: 'Cost: getField(priest.cost) Gold#BRSupply: getField(priest.supply)#BRDuration: getField(priest.buildTime) sec#BRgetField(priest.description)',
            interfacePosX: 0,
            interfacePosY: 1,
            commandCard: 0,
          },

          {
            type: COMMAND.MAKEBUILDING,
            unitType: 'magesguild',
            image: 'mages_guild',
            hotkey: KEY.E,
            name: 'Build Mages Guild',
            id_string: 'buildmagesguild',
            description: 'Cost: getField(magesguild.cost) Gold#BRDuration: getField(magesguild.buildTime) sec#BRgetField(magesguild.description)',
            requirementText: ['Requires a Barracks'],
            requirementType: ['barracks'],
            requirementLevel: [1],
            targetIsPoint: true,
            commandCard: 2,
            interfacePosX: 2,
            interfacePosY: 0,
          },

          {
            type: COMMAND.UNIVERSAL,
            image: 'flamestrike',
            hotkey: KEY.Q,
            name: 'Flamestrike',
            id_string: 'flamestrike',
            targetIsPoint: true,
            manaCost: [50],
            aoeRadius: [1.75],
            damage: [40],
            projectileSpeed: [6],
            duration: 0,
            range: [6],
            description: 'Casts a flamestrike at a target location, dealing getField(shockwave.damage) damage to nearby units and throwing them back.',
            interfacePosX: 2,
            interfacePosY: 1,
            commandCard: 0,
            cursor: Cursors.BLANK,
            useAoeCursor: true,
            castingDelay: 0.05 * 20,
            cooldown: 0.3 * 20,
            launchSound: SOUND.FLAMESTRIKE_LAUNCH,
            attackEffect: 'flamestrike',
            bounceDistMax: 6,
            bounceDistMin: 3,
            bouncePower: 1.5,
          },

          {
            type: COMMAND.MAKEUNIT,
            unitType: 'catapult',
            isInstant: true,
            image: 'catapult',
            hotkey: KEY.Q,
            name: 'Construct Catapult',
            id_string: 'constructcatapult',
            description: 'Cost: getField(catapult.cost) Gold#BRSupply: getField(catapult.supply)#BRDuration: getField(catapult.buildTime) sec#BRgetField(catapult.description)',
            interfacePosX: 0,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.MAKEBUILDING,
            unitType: 'workshop',
            image: 'workshop',
            hotkey: KEY.Q,
            name: 'Build Workshop',
            id_string: 'buildworkshop',
            description: 'Cost: getField(workshop.cost) Gold#BRDuration: getField(workshop.buildTime) sec#BRgetField(workshop.description)',
            requirementText: ['Requires a House'],
            requirementType: ['house'],
            requirementLevel: [1],
            targetIsPoint: true,
            interfacePosX: 0,
            interfacePosY: 0,
            commandCard: 4,
          },

          {
            type: COMMAND.MAKEBUILDING,
            unitType: 'forge',
            image: 'forge',
            hotkey: KEY.R,
            name: 'Build Forge',
            id_string: 'buildforge',
            description: 'Cost: getField(forge.cost) Gold#BRDuration: getField(forge.buildTime) sec#BRgetField(forge.description)',
            targetIsPoint: true,
            interfacePosX: 3,
            interfacePosY: 0,
            commandCard: 1,
          },

          {
            type: COMMAND.SWITCH_CC,
            image: 'hammer',
            hotkey: KEY.Q,
            name: 'Basic Buildings',
            id_string: 'basic_buildings',
            description: 'Construct basic buildings',
            interfacePosX: 0,
            interfacePosY: 0,
            commandCard: 0,
            targetCC: 1,
          },

          {
            type: COMMAND.SWITCH_CC,
            image: 'soldier',
            hotkey: KEY.W,
            name: 'Human Buildings',
            id_string: 'human_buildings',
            description: 'Construct buildings to train and upgrade human units',
            interfacePosX: 1,
            interfacePosY: 0,
            commandCard: 0,
            targetCC: 2,
          },

          {
            type: COMMAND.SWITCH_CC,
            image: 'wolf',
            hotkey: KEY.E,
            name: 'Beast Buildings',
            id_string: 'beast_buildings',
            description: 'Construct buildings to train and upgrade beast units',
            interfacePosX: 2,
            interfacePosY: 0,
            commandCard: 0,
            targetCC: 3,
          },

          {
            type: COMMAND.SWITCH_CC,
            image: 'catapult',
            hotkey: KEY.R,
            name: 'Mechancial Buildings',
            id_string: 'mech_buildings',
            description: 'Construct buildings to train and upgrade mechanical units',
            interfacePosX: 3,
            interfacePosY: 0,
            commandCard: 0,
            targetCC: 4,
          },
          // No longer used in the base game but needed for backwards compatability for mods
          {
            type: COMMAND.SWITCH_CC,
            image: 'hammer',
            hotkey: KEY.Q,
            name: 'Buildings',
            id_string: 'buildings',
            description: 'Construct Buildings',
            interfacePosX: 0,
            interfacePosY: 0,
            commandCard: 0,
            targetCC: 1,
          },
          // No longer used in the base game but needed for backwards compatability for mods
          {
            type: COMMAND.SWITCH_CC,
            image: 'hammer',
            hotkey: KEY.W,
            name: 'Buildings',
            id_string: 'buildings2',
            description: 'Construct additional Buildings',
            interfacePosX: 1,
            interfacePosY: 0,
            commandCard: 0,
            targetCC: 2,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgattack',
            isInstant: true,
            image: 'attackUpg',
            hotkey: KEY.Q,
            name: 'Attack Upgrade',
            id_string: 'attackupgrade',
            description: 'Level add(getUpgradeLevel(upgattack), upgradeCountInResearch(upgattack), 1)#BRCost: getField(upgattack.cost) Gold#BRDuration: getField(upgattack.buildTime) sec#BRgetField(upgattack.description)',
            interfacePosX: 0,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgarmor',
            isInstant: true,
            image: 'armorUpg',
            hotkey: KEY.W,
            name: 'Armor Upgrade',
            id_string: 'armorupgrade',
            description: 'Level add(getUpgradeLevel(upgarmor), upgradeCountInResearch(upgarmor), 1)#BRCost: getField(upgarmor.cost) Gold#BRDuration: getField(upgarmor.buildTime) sec#BRgetField(upgarmor.description)',
            interfacePosX: 1,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.UNIVERSAL,
            image: 'heal',
            hotkey: KEY.W,
            name: 'Heal',
            id_string: 'heal',
            targetRequirements1: [targetRequirements.isBiological],
            targetIsUnit: true,
            attackEffect: 'heal',
            manaCost: [25],
            range: [8],
            projectileSpeed: [0],
            damage: [-150],
            description: 'Heals a target unit by mul(getField(heal.damage), -1) HP',
            interfacePosX: 1,
            interfacePosY: 1,
            commandCard: 0,
            castingDelay: 0.05 * 20,
            cooldown: 0.4 * 20,
            launchSound: SOUND.HEAL,
            cursor: Cursors.HEAL,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgfireball',
            isInstant: true,
            image: 'flamestrike',
            hotkey: KEY.Q,
            name: 'Research Fireball',
            id_string: 'researchfireball',
            description: 'Cost: getField(upgfireball.cost) Gold#BRDuration: getField(upgfireball.buildTime) sec#BRgetField(upgfireball.description)',
            interfacePosX: 0,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgslowfield',
            isInstant: true,
            image: 'slowfield',
            hotkey: KEY.W,
            name: 'Research Slow Field',
            id_string: 'researchslowfield',
            description: 'Cost: getField(upgslowfield.cost) Gold#BRDuration: getField(upgslowfield.buildTime) sec#BRgetField(upgslowfield.description)',
            interfacePosX: 1,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgheal',
            isInstant: true,
            image: 'heal',
            hotkey: KEY.W,
            name: 'Research Heal',
            id_string: 'researchheal',
            description: 'Cost: getField(upgheal.cost) Gold#BRDuration: getField(upgheal.buildTime) sec#BRgetField(upgheal.description)',
            interfacePosX: 1,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.BUILDING_UPGRADE,
            isInstant: true,
            image: 'fortress',
            hotkey: KEY.A,
            improvedBuilding: 'fortress',
            name: 'Upgrade To Fortress',
            id_string: 'upgradetofortress',
            description: 'Cost: getField(fortress.cost) Gold#BRDuration: getField(fortress.buildTime) sec#BRgetField(fortress.description)',
            interfacePosX: 0,
            interfacePosY: 1,
            commandCard: 0,
          },

          {
            type: COMMAND.BUILDING_UPGRADE,
            isInstant: true,
            image: 'eye',
            hotkey: KEY.Q,
            improvedBuilding: 'watchtower2',
            name: 'Research Detection',
            id_string: 'researchdetection',
            description: 'Cost: getField(watchtower2.cost) Gold#BRDuration: getField(watchtower2.buildTime) sec#BRgetField(watchtower2.description)',
            interfacePosX: 0,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.MAKEBUILDING,
            unitType: 'dragonslair',
            image: 'dragons_lair',
            hotkey: KEY.W,
            name: 'Build Dragons Lair',
            id_string: 'builddragonslair',
            description: 'Cost: getField(dragonslair.cost) Gold#BRDuration: getField(dragonslair.buildTime) sec#BRgetField(dragonslair.description)',
            requirementText: ['Requires a Fortress'],
            requirementType: ['fortress'],
            requirementLevel: [1, 1],
            targetIsPoint: true,
            commandCard: 3,
            interfacePosX: 1,
            interfacePosY: 0,
          },

          {
            type: COMMAND.MAKEUNIT,
            unitType: 'dragon',
            isInstant: true,
            image: 'dragon',
            hotkey: KEY.Q,
            name: 'Train Dragon',
            id_string: 'traindragon',
            description: 'Cost: getField(dragon.cost) Gold#BRSupply: getField(dragon.supply)#BRDuration: getField(dragon.buildTime) sec#BRgetField(dragon.description)',
            interfacePosX: 0,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgbeastattack',
            isInstant: true,
            image: 'dragonAttUpg',
            hotkey: KEY.Q,
            name: 'Beast Attack Upgrade',
            id_string: 'beastattackupgrade',
            description: 'Level add(getUpgradeLevel(upgbeastattack), upgradeCountInResearch(upgbeastattack), 1)#BRCost: getField(upgbeastattack.cost) Gold#BRDuration: getField(upgbeastattack.buildTime) sec#BRgetField(upgbeastattack.description)',
            interfacePosX: 0,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgbeastdefense',
            isInstant: true,
            image: 'dragonDefUpg',
            hotkey: KEY.W,
            name: 'Beast Defense Upgrade',
            id_string: 'beastdefenseupgrade',
            description: 'Level add(getUpgradeLevel(upgbeastdefense), upgradeCountInResearch(upgbeastdefense), 1)#BRCost: getField(upgbeastdefense.cost) Gold#BRDuration: getField(upgbeastdefense.buildTime) sec#BRgetField(upgbeastdefense.description)',
            interfacePosX: 1,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.MAKEUNIT,
            unitType: 'wolf',
            isInstant: true,
            image: 'wolf',
            hotkey: KEY.Q,
            name: 'Train Wolf',
            id_string: 'trainwolf',
            description: 'Cost: getField(wolf.cost) Gold#BRSupply: getField(wolf.supply)#BRDuration: getField(wolf.buildTime) sec#BRgetField(wolf.description)',
            interfacePosX: 0,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.MAKEBUILDING,
            unitType: 'wolvesden',
            image: 'wolves_den',
            hotkey: KEY.Q,
            name: 'Build Wolves Den',
            id_string: 'buildwolvesden',
            description: 'Cost: getField(wolvesden.cost) Gold#BRDuration: getField(wolvesden.buildTime) sec#BRgetField(wolvesden.description)',
            requirementText: ['Requires a House'],
            requirementType: ['house'],
            requirementLevel: [1],
            targetIsPoint: true,
            commandCard: 3,
            interfacePosX: 0,
            interfacePosY: 0,
          },

          {
            type: COMMAND.MAKEBUILDING,
            unitType: 'animaltestinglab',
            image: 'animal_testing_lab',
            hotkey: KEY.R,
            name: 'Build Animal Testing Lab',
            id_string: 'buildanimaltestinglab',
            description: 'Cost: getField(animaltestinglab.cost) Gold#BRDuration: getField(animaltestinglab.buildTime) sec#BRgetField(animaltestinglab.description)',
            targetIsPoint: true,
            commandCard: 3,
            interfacePosX: 3,
            interfacePosY: 0,
          },

          {
            type: COMMAND.LOAD,
            image: 'load',
            hotkey: KEY.Q,
            name: 'Load in',
            id_string: 'loadin',
            description: 'Load units in',
            targetIsUnit: true,
            commandCard: 0,
            interfacePosX: 0,
            interfacePosY: 0,
          },

          {
            type: COMMAND.UNLOAD,
            image: 'unload',
            hotkey: KEY.W,
            name: 'Unload',
            id_string: 'unload',
            description: 'Unload units',
            targetIsPoint: true,
            commandCard: 0,
            interfacePosX: 1,
            interfacePosY: 0,
          },

          {
            type: COMMAND.MAKEBUILDING,
            unitType: 'advancedworkshop',
            image: 'adv_workshop',
            hotkey: KEY.W,
            name: 'Build Advanced Workshop',
            id_string: 'buildadvancedworkshop',
            description: 'Cost: getField(advancedworkshop.cost) Gold#BRDuration: getField(advancedworkshop.buildTime) sec#BRgetField(advancedworkshop.description)',
            targetIsPoint: true,
            commandCard: 4,
            interfacePosX: 1,
            interfacePosY: 0,
          },

          {
            type: COMMAND.MAKEBUILDING,
            unitType: 'advancedworkshop',
            image: 'adv_workshop',
            hotkey: KEY.S,
            name: 'Test building',
            id_string: 'buildadvancedworkshop2',
            description: 'Cost: getField(advancedworkshop.cost) Gold#BRDuration: getField(advancedworkshop.buildTime) sec#BRgetField(advancedworkshop.description)',
            targetIsPoint: true,
            commandCard: 4,
            interfacePosX: 1,
            interfacePosY: 1,
          },

          {
            type: COMMAND.MAKEUNIT,
            unitType: 'airship',
            isInstant: true,
            image: 'airship',
            hotkey: KEY.Q,
            name: 'Construct Airship',
            id_string: 'constructairship',
            description: 'Cost: getField(airship.cost) Gold#BRSupply: getField(airship.supply)#BRDuration: getField(airship.buildTime) sec#BRgetField(airship.description)',
            interfacePosX: 0,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgtower',
            isInstant: true,
            image: 'towerUpg',
            hotkey: KEY.W,
            name: 'Tower Upgrade',
            id_string: 'towerupgrade',
            description: 'Cost: getField(upgtower.cost) Gold#BRDuration: getField(upgtower.buildTime) sec#BRgetField(upgtower.description)',
            interfacePosX: 1,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.UNLOAD2,
            name: 'Direct Unload',
            id_string: 'directunload',
            targetIsInt: true,
          },

          {
            type: COMMAND.ATTACK_GROUND,
            hotkey: KEY.Q,
            name: 'Attack Ground',
            id_string: 'attackground',
            targetIsPoint: true,
            image: 'groundAttack',
            interfacePosX: 0,
            interfacePosY: 0,
            commandCard: 0,
            description: 'Fire at a certain point',
            cursor: Cursors.BLANK,
            useAoeCursor: true,
            aoeRadius: [0.45],
          },

          {
            type: COMMAND.UNIVERSAL,
            name: 'Smash',
            id_string: 'smash',
            image: 'smash',
            hotkey: KEY.Q,
            isInstant: true,
            interfacePosX: 0,
            interfacePosY: 0,
            commandCard: 0,
            description: 'Perform a round house hit, dealing damage and smashing back small nearby units (only hits enemy units)',
            aoeRadius: [3],
            damage: [40],
            hitsFriendly: false,
            cooldown2: 15 * 20,
            animationName: 'special1',
            castingDelay: 0.75 * 20,
            cooldown: 1.8 * 20,
            hitsSelf: false,
            launchSound: SOUND.ROUNDHOUSE,
            soundPerHit: SOUND.BIGHIT,
            bounceDistMax: 6.5,
            bounceDistMin: 4,
            bouncePower: 1.5,
            attackEffect: 'smoke',
            targetFiltersExclude: ['flying'],
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgspeed',
            isInstant: true,
            image: 'speedUpg',
            hotkey: KEY.E,
            name: 'Speed Upgrade',
            id_string: 'speedupgrade',
            description: 'Level add(getUpgradeLevel(upgspeed), upgradeCountInResearch(upgspeed), 1)#BRCost: getField(upgspeed.cost) Gold#BRDuration: getField(upgspeed.buildTime) sec#BRgetField(upgspeed.description)',
            interfacePosX: 2,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgbeastspeed',
            isInstant: true,
            image: 'beastSpeedUpg',
            hotkey: KEY.E,
            name: 'Beast Speed Upgrade',
            id_string: 'beastspeedupgrade',
            description: 'Level add(getUpgradeLevel(upgbeastspeed), upgradeCountInResearch(upgbeastspeed), 1)#BRCost: getField(upgbeastspeed.cost) Gold#BRDuration: getField(upgbeastspeed.buildTime) sec#BRgetField(upgbeastspeed.description)',
            interfacePosX: 2,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.BUILDING_UPGRADE,
            isInstant: true,
            image: 'werewolves_den',
            hotkey: KEY.A,
            improvedBuilding: 'werewolvesden',
            name: 'Upgrade To Werewolves Den',
            id_string: 'upgradetowerewolvesden',
            description: 'Cost: getField(werewolvesden.cost) Gold#BRDuration: getField(werewolvesden.buildTime) sec#BRgetField(werewolvesden.description)',
            interfacePosX: 0,
            interfacePosY: 1,
            commandCard: 0,
          },

          {
            type: COMMAND.MAKEUNIT,
            unitType: 'werewolf',
            isInstant: true,
            image: 'werewolf',
            hotkey: KEY.E,
            name: 'Train Werewolf',
            id_string: 'trainwerewolf',
            description: 'Cost: getField(werewolf.cost) Gold#BRSupply: getField(werewolf.supply)#BRDuration: getField(werewolf.buildTime) sec#BRgetField(werewolf.description)',
            interfacePosX: 2,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.MAKEUNIT,
            unitType: 'ballista',
            isInstant: true,
            image: 'ballista',
            hotkey: KEY.W,
            name: 'Construct Ballista',
            id_string: 'constructballista',
            description: 'Cost: getField(ballista.cost) Gold#BRSupply: getField(ballista.supply)#BRDuration: getField(ballista.buildTime) sec#BRgetField(ballista.description)',
            interfacePosX: 1,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgmechattack',
            isInstant: true,
            image: 'mechAttUpg',
            hotkey: KEY.A,
            name: 'Mech Attack Upgrade',
            id_string: 'mechattackupgrade',
            description: 'Level add(getUpgradeLevel(upgmechattack), upgradeCountInResearch(upgmechattack), 1)#BRCost: getField(upgmechattack.cost) Gold#BRDuration: getField(upgmechattack.buildTime) sec#BRgetField(upgmechattack.description)',
            interfacePosX: 0,
            interfacePosY: 1,
            commandCard: 0,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgmechdefense',
            isInstant: true,
            image: 'mechDefUpg',
            hotkey: KEY.S,
            name: 'Mech Armor Upgrade',
            id_string: 'mecharmorupgrade',
            description: 'Level add(getUpgradeLevel(upgmechdefense), upgradeCountInResearch(upgmechdefense), 1)#BRCost: getField(upgmechdefense.cost) Gold#BRDuration: getField(upgmechdefense.buildTime) sec#BRgetField(upgmechdefense.description)',
            interfacePosX: 1,
            interfacePosY: 1,
            commandCard: 0,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgmechspeed',
            isInstant: true,
            image: 'mechSpeedUpg',
            hotkey: KEY.D,
            name: 'Mech Speed Upgrade',
            id_string: 'mechspeedupgrade',
            description: 'Level add(getUpgradeLevel(upgmechspeed), upgradeCountInResearch(upgmechspeed), 1)#BRCost: getField(upgmechspeed.cost) Gold#BRDuration: getField(upgmechspeed.buildTime) sec#BRgetField(upgmechspeed.description)',
            interfacePosX: 2,
            interfacePosY: 1,
            commandCard: 0,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgballistaexplosives',
            isInstant: true,
            image: 'flakUpg',
            hotkey: KEY.S,
            name: 'Ballista Black Powder',
            id_string: 'ballistaexplosives',
            description: 'Cost: getField(upgballistaexplosives.cost) Gold#BRDuration: getField(upgballistaexplosives.buildTime) sec#BRgetField(upgballistaexplosives.description) Allows ballistas to use AOE shot and adds splash damage to ballistas attacks.',
            interfacePosX: 1,
            interfacePosY: 1,
            commandCard: 0,
          },

          {
            type: COMMAND.UNIVERSAL,
            name: 'Fireball',
            id_string: 'fireball',
            requirementText: ['This spell needs to be researched first'],
            requirementType: ['upgfireball'],
            requirementLevel: [1],
            description: 'Casts a fireball at a target location, dealing damage to all enemy units in the way.',
            targetIsPoint: true,
            manaCost: [55],
            image: 'flamestrike',
            attackEffect: 'flamestrike',
            hotkey: KEY.Q,
            projectileAoeRadius: [1.0],
            projectileDamage: [5],
            projectileSpeed: [6.6],
            maximizeRangeWhenCasting: true,
            hitsFriendly: false,
            hitsSelf: false,
            range: [13],
            effectScale: 2,
            interfacePosX: 0,
            interfacePosY: 0,
            commandCard: 0,
            castingDelay: 0.05 * 20,
            cooldown: 0.3 * 20,
            cooldown2: 0 * 20,
            launchSound: SOUND.FLAMESTRIKE_LAUNCH,
            causesFlameDeath: true,
            cursor: Cursors.ATTACK,
            targetFiltersExclude: ['flying'],
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgshockwave',
            isInstant: true,
            image: 'shockwave',
            hotkey: KEY.E,
            name: 'Research Shockwave',
            id_string: 'researchshockwave',
            description: 'Cost: getField(upgshockwave.cost) Gold#BRDuration: getField(upgshockwave.buildTime) sec#BRgetField(upgshockwave.description)',
            interfacePosX: 2,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.SWITCH_CC,
            image: 'cancel',
            hotkey: KEY.G,
            name: 'Back',
            id_string: 'back_basic',
            description: 'Back to main menu',
            interfacePosX: 4,
            interfacePosY: 1,
            commandCard: 1,
            targetCC: 0,
          },

          {
            type: COMMAND.SWITCH_CC,
            image: 'cancel',
            hotkey: KEY.G,
            name: 'Back',
            id_string: 'back_humans',
            description: 'Back to main menu',
            interfacePosX: 4,
            interfacePosY: 1,
            commandCard: 2,
            targetCC: 0,
          },

          {
            type: COMMAND.SWITCH_CC,
            image: 'cancel',
            hotkey: KEY.G,
            name: 'Back',
            id_string: 'back_beast',
            description: 'Back to main menu',
            interfacePosX: 4,
            interfacePosY: 1,
            commandCard: 3,
            targetCC: 0,
          },

          {
            type: COMMAND.SWITCH_CC,
            image: 'cancel',
            hotkey: KEY.G,
            name: 'Back',
            id_string: 'back_mech',
            description: 'Back to main menu',
            interfacePosX: 4,
            interfacePosY: 1,
            commandCard: 4,
            targetCC: 0,
          },

          // No longer used in the base game but needed for backwards compatability for mods
          {
            type: COMMAND.SWITCH_CC,
            image: 'cancel',
            hotkey: KEY.G,
            name: 'Back',
            id_string: 'back',
            description: 'Back to main menu',
            interfacePosX: 4,
            interfacePosY: 1,
            commandCard: 1,
            targetCC: 0,
          },

          // No longer used in the base game but needed for backwards compatability for mods
          {
            type: COMMAND.SWITCH_CC,
            image: 'cancel',
            hotkey: KEY.G,
            name: 'Back',
            id_string: 'back2',
            description: 'Back to main menu',
            interfacePosX: 4,
            interfacePosY: 1,
            commandCard: 2,
            targetCC: 0,
          },
          {
            type: COMMAND.SWITCH_CC,
            image: 'cancel',
            hotkey: KEY.G,
            name: 'Back',
            id_string: 'back3',
            description: 'Back to main menu',
            interfacePosX: 4,
            interfacePosY: 1,
            commandCard: 3,
            targetCC: 0,
          },

          {
            type: COMMAND.SWITCH_CC,
            image: 'cancel',
            hotkey: KEY.G,
            name: 'Back',
            id_string: 'back4',
            description: 'Back to main menu',
            interfacePosX: 4,
            interfacePosY: 1,
            commandCard: 4,
            targetCC: 0,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgrange',
            isInstant: true,
            image: 'rangeUpg',
            hotkey: KEY.W,
            name: 'Research Archer Range',
            id_string: 'rangeupgrade',
            description: 'Level add(getUpgradeLevel(upgrange), upgradeCountInResearch(upgrange), 1)#BRCost: getField(upgrange.cost) Gold#BRDuration: getField(upgrange.buildTime) sec#BRgetField(upgrange.description)',
            interfacePosX: 1,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgbeastrange',
            isInstant: true,
            image: 'beastRangeUpg',
            hotkey: KEY.T,
            name: 'Beast Range Upgrade',
            id_string: 'beastrangeupgrade',
            description: 'Level add(getUpgradeLevel(upgbeastrange), upgradeCountInResearch(upgbeastrange), 1)#BRCost: getField(upgbeastrange.cost) Gold#BRDuration: getField(upgbeastrange.buildTime) sec#BRgetField(upgbeastrange.description)',
            interfacePosX: 3,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgmechrange',
            isInstant: true,
            image: 'mechRangeUpg',
            hotkey: KEY.F,
            name: 'Mech Range Upgrade',
            id_string: 'mechrangeupgrade',
            description: 'Level add(getUpgradeLevel(upgmechrange), upgradeCountInResearch(upgmechrange), 1)#BRCost: getField(upgmechrange.cost) Gold#BRDuration: getField(upgmechrange.buildTime) sec#BRgetField(upgmechrange.description)',
            interfacePosX: 3,
            interfacePosY: 1,
            commandCard: 0,
          },

          {
            type: COMMAND.UNIVERSAL,
            name: 'Dmg Buff',
            id_string: 'dmgbuffability',
            image: 'worker',
            hotkey: KEY.Q,
            targetIsPoint: true,
            interfacePosX: 0,
            interfacePosY: 1,
            commandCard: 0,
            range: [8],
            description: 'Gives a dmg buff',
            aoeRadius: [3.5],
            cooldown2: 10 * 20,
            castingDelay: 1 * 20,
            cooldown: 1.8 * 20,
            launchSound: SOUND.ROUNDHOUSE,
            modifiers: ['dmgbuff'],
          },

          {
            type: COMMAND.UNIVERSAL,
            name: 'Invisibility',
            id_string: 'invisibilityspell',
            image: 'invisibility',
            hotkey: KEY.Q,
            targetIsUnit: true,
            hitsEnemy: false,
            interfacePosX: 0,
            interfacePosY: 0,
            commandCard: 0,
            range: [9],
            description: 'Makes target unit or building invisible and gives a small damage buff',
            castingDelay: 0.05 * 20,
            cooldown: 0.5 * 20,
            manaCost: [50],
            requirementText: ['This spell needs to be researched first'],
            requirementType: ['upginvis'],
            requirementLevel: [1],
            launchSound: SOUND.ROUNDHOUSE,
            modifiers: ['invisibility'],
            attackEffect: 'smoke',
          },

          {
            type: COMMAND.UNIVERSAL,
            name: 'Summon Skeleton',
            id_string: 'summonskeleton',
            image: 'skeleton',
            hotkey: KEY.W,
            targetIsPoint: true,
            interfacePosX: 1,
            interfacePosY: 1,
            commandCard: 0,
            range: [6],
            description: 'Summons a skeleton that has a limited lifetime',
            castingDelay: 0.05 * 20,
            cooldown: 0.5 * 20,
            manaCost: [50],
            requirementText: ['This spell needs to be researched first'],
            requirementType: ['upgskeleton'],
            requirementLevel: [1],
            launchSound: SOUND.ROUNDHOUSE,
            summonedUnits: ['skeleton'],
            attackEffect: 'smoke',
            requiresVision: true,
          },

          {
            type: COMMAND.MAKEBUILDING,
            unitType: 'church',
            image: 'church',
            hotkey: KEY.A,
            name: 'Build Church',
            id_string: 'buildchurch',
            description: 'Cost: getField(church.cost) Gold#BRDuration: getField(church.buildTime) sec#BRgetField(church.description)',
            targetIsPoint: true,
            commandCard: 2,
            interfacePosX: 0,
            interfacePosY: 1,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upginvis',
            id_string: 'researchinvisibility',
            isInstant: true,
            image: 'invisibility',
            hotkey: KEY.Q,
            name: 'Research Invisibility',
            id_string: 'researchinvisibility',
            description: 'Cost: getField(upginvis.cost) Gold#BRDuration: getField(upginvis.buildTime) sec#BRgetField(upginvis.description)',
            interfacePosX: 0,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgskeleton',
            isInstant: true,
            image: 'skeleton',
            hotkey: KEY.W,
            name: 'Research Summon Skeleton',
            id_string: 'researchsummonskeleton',
            description: 'Cost: getField(upgskeleton.cost) Gold#BRDuration: getField(upgskeleton.buildTime) sec#BRgetField(upgskeleton.description)',
            interfacePosX: 1,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upghealingward',
            id_string: 'researchsummonhealingward',
            isInstant: true,
            image: 'heal',
            hotkey: KEY.W,
            name: 'Research Summon Healing Ward',
            id_string: 'researchsummonhealingward',
            description: 'Cooldown: getField(summonhealingward.cooldown2)#BRSummons a healing ward that heals nearby allied units.',
            interfacePosX: 1,
            interfacePosY: 0,
            cooldown2: 0.5 * 20,
            commandCard: 0,
          },

          {
            type: COMMAND.UPGRADE,
            upgrade: 'upgtelescope',
            isInstant: true,
            image: 'telescope',
            hotkey: KEY.A,
            name: 'Airship Telescope Extension',
            id_string: 'researchtelescope',
            description: 'Cost: getField(upgtelescope.cost) Gold#BRDuration: getField(upgtelescope.buildTime) sec#BRgetField(upgtelescope.description)',
            interfacePosX: 0,
            interfacePosY: 1,
            commandCard: 0,
          },

          {
            type: COMMAND.DANCE,
            isInstant: true,
            name: 'Dance',
            id_string: 'dance',
            dance_img: 'dance1',
            chat_str: '/dance',
            hide: true,
          },

          {
            type: COMMAND.DANCE,
            isInstant: true,
            name: 'Dance2',
            id_string: 'dance2',
            dance_img: 'dance2',
            chat_str: '/dance2',
            hide: true,
          },

          {
            type: COMMAND.UNIVERSAL,
            name: 'Summon Healing Ward',
            id_string: 'summonhealingward',
            image: 'heal',
            hotkey: KEY.W,
            targetIsPoint: true,
            interfacePosX: 1,
            interfacePosY: 0,
            commandCard: 0,
            range: [6],
            description: 'Summons a healing ward that heals nearby allied non-undead units and damages enemy undead units',
            castingDelay: 0.05 * 20,
            cooldown: 0.5 * 20,
            cooldown2: 10 * 20,
            manaCost: [25],
            requirementText: [],
            requirementType: [],
            requirementLevel: [1],
            launchSound: SOUND.WARP,
            summonedUnits: ['healingward'],
            attackEffect: 'smoke',
            aoeRadius: [2.75],
            useAoeCursor: true,
            requiresVision: true,
          },

          {
            type: COMMAND.UNIVERSAL,
            name: 'Slow Field',
            id_string: 'summonslowfield',
            image: 'slowfield',
            hotkey: KEY.W,
            targetIsPoint: true,
            interfacePosX: 1,
            interfacePosY: 0,
            commandCard: 0,
            range: [7],
            description: 'Summons a slow field that slows nearby ground units.',
            castingDelay: 0.05 * 20,
            cooldown: 0.5 * 2,
            manaCost: [80],
            launchSound: SOUND.WARP,
            summonedUnits: ['slowingfield'],
            attackEffect: 'smoke',
            useAoeCursor: true,
            aoeRadius: [3.5],
            requiresVision: true,
          },

          {
            type: COMMAND.MAKEUNIT,
            unitType: 'bird',
            isInstant: true,
            image: 'bird',
            hotkey: KEY.W,
            name: 'Train Bird',
            id_string: 'trainbird',
            description: 'Cost: getField(bird.cost) Gold#BRSupply: getField(bird.supply)#BRDuration: getField(bird.buildTime) sec#BRgetField(bird.description)',
            requirementText: ['Requires a House'],
            requirementType: ['house'],
            requirementLevel: [1],
            interfacePosX: 1,
            interfacePosY: 0,
            commandCard: 0,
          },

          {
            type: COMMAND.UNIVERSAL,
            name: 'Fire',
            id_string: 'fire',
            image: 'heal',
            hotkey: KEY.Q,
            learnHotkey: KEY.W,
            targetIsUnit: true,
            interfacePosX: 0,
            interfacePosY: 1,
            commandCard: 0,
            learnCommandCard: 0,
            learnInterfacePosX: 1,
            learnInterfacePosY: 1,
            requiredLevels: [1, 3, 5],
            range: [2, 6, 10],
            damage: [20, 100, 800],
            description: 'Summons a healing ward that heals nearby allied non-undead units and damages enemy undead units',
            castingDelay: 0.05 * 20,
            cooldown: 0.5 * 20,
            manaCost: [10, 20, 30],
            launchSound: SOUND.WARP,
            attackEffect: 'smoke',
            requiresVision: true,
          },

          {
            type: COMMAND.TELEPORT,
            name: 'Teleport',
            id_string: 'teleport',
            image: 'teleport',
            hotkey: KEY.Q,
            interfacePosX: 0,
            interfacePosY: 1,
            commandCard: 0,
            range: [7],
            description: 'Teleports this unit over a short distance',
            castingDelay: 0.05 * 20,
            cooldown: 0.5 * 20,
            manaCost: [0],
            launchSound: SOUND.WARP,
            attackEffect: 'smoke',
            requiresVision: true,
          },
          {
            type: COMMAND.MAKEUNIT,
            name: 'Train Snake',
            id_string: 'train_snake',
            isCommand: true,
            unitType: 'snake',
            hotkey: KEY.W,
            targetIsPoint: false,
            targetIsUnit: false,
            isInstant: true,
            isChanneled: false,
            playLaunchSoundOnce: false,
            useAoeCursor: false,
            commandCard: 0,
            interfacePosX: 1,
            interfacePosY: 0,
            requiredLevels: [],
            learnCommandCard: 0,
            learnInterfacePosX: 0,
            learnInterfacePosY: 0,
            learnHotkey: 81,
            image: 'snake',
            attackEffectInit: 'spell',
            description: 'Cost: getField(snake.cost) Gold#BRSupply: getField(snake.supply)#BRDuration: getField(snake.buildTime) sec#BRgetField(snake.description)',
            requirementType: [
              'snakecharmer',
            ],
            requirementLevel: [
              1,
            ],
            requirementText: [
              'Requires a Snake Charmer',
            ],
            targetRequirements1: [],
            targetRequirements2: [],
            targetRequirements3: [],
            manaCost: [
              0,
            ],
            goldCost: 0,
            aoeRadius: [
              0,
            ],
            damage: [
              0,
            ],
            projectileDamage: [
              0,
            ],
            projectileAoeRadius: [
              0,
            ],
            maximizeRangeWhenCasting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            hitsSelf: true,
            targetFilters: [],
            targetFiltersExclude: [],
            effectScale: 1,
            hasAutocast: false,
            autocastDefault: false,
            autocastConditions: '',
            projectileSpeed: [
              8,
            ],
            duration: 0,
            castingDelay: 0 * 20,
            cooldown: 0 * 20,
            cooldown2: 0 * 20,
            range: [
              0,
            ],
            minRange: [-999],
            bounceDistMin: 0,
            bounceDistMax: 0,
            bouncePower: 0,
            targetCC: 0,
            animationName: '',
            causesFlameDeath: false,
            modifiers: [],
            modifiersSelf: [],
            summonedUnits: [],
            summonsUseWaypoint: false,
            summonsWaypointAMove: false,
            ignoreSupplyCheck: false,
            requiresVision: false,
          },

          {
            type: COMMAND.TELEPORT,
            isCommand: true,
            name: 'Flash',
            id_string: 'Flash',
            hotkey: 81,
            targetIsPoint: false,
            targetIsUnit: false,
            isInstant: false,
            isChanneled: false,
            playLaunchSoundOnce: false,
            useAoeCursor: false,
            commandCard: 0,
            interfacePosX: 0,
            interfacePosY: 0,
            requiredLevels: [],
            learnCommandCard: 0,
            learnInterfacePosX: 0,
            learnInterfacePosY: 0,
            learnHotkey: 81,
            image: 'teleport',
            attackEffectInit: 'spell',
            attackEffect: 'smoke',
            description: 'Teleports the Raider over a short distance (4)',
            requirementType: [],
            requirementLevel: [],
            requirementText: [],
            targetRequirements1: [],
            targetRequirements2: [],
            targetRequirements3: [],
            launchSound: 68,
            manaCost: [
              25,
            ],
            goldCost: 0,
            aoeRadius: [
              0,
            ],
            damage: [
              0,
            ],
            projectileDamage: [
              0,
            ],
            projectileAoeRadius: [
              0,
            ],
            maximizeRangeWhenCasting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            hitsSelf: true,
            targetFilters: [],
            targetFiltersExclude: [],
            effectScale: 1,
            hasAutocast: false,
            autocastDefault: false,
            autocastConditions: '',
            projectileSpeed: [
              8,
            ],
            duration: 0,
            castingDelay: 0 * 20,
            cooldown: 0 * 20,
            cooldown2: 0 * 20,
            range: [
              4,
            ],
            minRange: [-999],
            bounceDistMin: 0,
            bounceDistMax: 0,
            bouncePower: 0,
            targetCC: 0,
            animationName: '',
            causesFlameDeath: false,
            modifiers: [],
            modifiersSelf: [
              'raiderflashmana',
            ],
            summonedUnits: [],
            summonsUseWaypoint: false,
            summonsWaypointAMove: false,
            ignoreSupplyCheck: false,
            requiresVision: true,
          },
          {
            type: COMMAND.UPGRADE,
            name: 'Research Shroud',
            id_string: 'researchraidershroudupgrade',
            isCommand: true,
            hotkey: KEY.Q,
            targetIsPoint: false,
            targetIsUnit: false,
            isInstant: true,
            isChanneled: false,
            playLaunchSoundOnce: false,
            useAoeCursor: false,
            commandCard: 0,
            interfacePosX: 0,
            interfacePosY: 0,
            requiredLevels: [],
            learnCommandCard: 0,
            learnInterfacePosX: 0,
            learnInterfacePosY: 0,
            image: 'shroud',
            attackEffectInit: 'spell',
            description: 'Cost: getField(raidershroudupgrade.cost) Gold#BRDuration: getField(raidershroudupgrade.buildTime) sec#BRgetField(raidershroudupgrade.description)',
            requirementType: [],
            requirementLevel: [],
            requirementText: [],
            targetRequirements1: [],
            targetRequirements2: [],
            targetRequirements3: [],
            upgrade: 'raidershroudupgrade',
            manaCost: [
              0,
            ],
            goldCost: 0,
            aoeRadius: [
              0,
            ],
            damage: [
              0,
            ],
            projectileDamage: [
              0,
            ],
            projectileAoeRadius: [
              0,
            ],
            maximizeRangeWhenCasting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            hitsSelf: true,
            targetFilters: [],
            targetFiltersExclude: [
              'flying',
            ],
            effectScale: 1,
            hasAutocast: false,
            autocastDefault: false,
            autocastConditions: '',
            projectileSpeed: [
              8,
            ],
            duration: 0,
            castingDelay: 0 * 20,
            cooldown: 0 * 20,
            cooldown2: 0 * 20,
            range: [
              0,
            ],
            minRange: [-999],
            bounceDistMin: 0,
            bounceDistMax: 0,
            bouncePower: 0,
            targetCC: 0,
            animationName: '',
            causesFlameDeath: false,
            modifiers: [],
            modifiersSelf: [],
            summonedUnits: [],
            summonsUseWaypoint: false,
            summonsWaypointAMove: false,
            ignoreSupplyCheck: false,
            requiresVision: false,
          },
          {
            type: COMMAND.UNIVERSAL,
            name: 'Shroud',
            id_string: 'Shroud',
            isCommand: true,
            hotkey: 87,
            targetIsPoint: true,
            targetIsUnit: false,
            isInstant: false,
            isChanneled: false,
            playLaunchSoundOnce: false,
            useAoeCursor: true,
            commandCard: 0,
            interfacePosX: 1,
            interfacePosY: 0,
            requiredLevels: [],
            learnCommandCard: 0,
            learnInterfacePosX: 0,
            learnInterfacePosY: 0,
            learnHotkey: 81,
            image: 'shroud',
            attackEffectInit: 'spell',
            attackEffect: 'smoke',
            description: 'Creates a shroud that reduces the range of all units under it to melee for 15 seconds.',
            requirementType: [
              'raidershroudupgrade',
            ],
            requirementLevel: [
              1,
            ],
            requirementText: [
              'Shroud must be researched.',
            ],
            targetRequirements1: [],
            targetRequirements2: [],
            targetRequirements3: [],
            launchSound: 68,
            manaCost: [
              30,
            ],
            goldCost: 0,
            aoeRadius: [
              2.7,
            ],
            damage: [
              0,
            ],
            projectileDamage: [
              0,
            ],
            projectileAoeRadius: [
              0,
            ],
            maximizeRangeWhenCasting: false,
            hitsFriendly: false,
            hitsEnemy: true,
            hitsSelf: true,
            targetFilters: [],
            targetFiltersExclude: [],
            effectScale: 1,
            hasAutocast: false,
            autocastDefault: false,
            autocastConditions: '',
            projectileSpeed: [
              8,
            ],
            duration: 0,
            castingDelay: 0.05 * 20,
            cooldown: 0.05 * 20,
            cooldown2: 0 * 20,
            range: [
              6,
            ],
            minRange: [-999],
            bounceDistMin: 0,
            bounceDistMax: 0,
            bouncePower: 0,
            targetCC: 0,
            animationName: '',
            causesFlameDeath: false,
            modifiers: [],
            modifiersSelf: [],
            summonedUnits: [
              'shroudfield',
            ],
            summonsUseWaypoint: false,
            summonsWaypointAMove: false,
            ignoreSupplyCheck: false,
            requiresVision: true,
          },
          {
            type: COMMAND.MAKEUNIT,
            name: 'Train Raider',
            id_string: 'train_raider',
            isCommand: true,
            image: 'raider',
            unitType: 'raider',
            hotkey: 69,
            targetIsPoint: false,
            targetIsUnit: false,
            isInstant: true,
            isChanneled: false,
            playLaunchSoundOnce: false,
            useAoeCursor: false,
            commandCard: 0,
            interfacePosX: 2,
            interfacePosY: 0,
            requiredLevels: [],
            learnCommandCard: 0,
            learnInterfacePosX: 0,
            learnInterfacePosY: 0,
            learnHotkey: 81,
            attackEffectInit: 'spell',
            description: 'Cost: getField(raider.cost) Gold#BRSupply: getField(raider.supply)#BRDuration: getField(raider.buildTime) sec#BRgetField(raider.description)',
            requirementType: [],
            requirementLevel: [],
            requirementText: [],
            targetRequirements1: [],
            targetRequirements2: [],
            targetRequirements3: [],
            manaCost: [
              0,
            ],
            goldCost: 0,
            aoeRadius: [
              0,
            ],
            damage: [
              0,
            ],
            projectileDamage: [
              0,
            ],
            projectileAoeRadius: [
              0,
            ],
            maximizeRangeWhenCasting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            hitsSelf: true,
            targetFilters: [],
            targetFiltersExclude: [],
            effectScale: 1,
            hasAutocast: false,
            autocastDefault: false,
            autocastConditions: '',
            projectileSpeed: [
              8,
            ],
            duration: 0,
            castingDelay: 0 * 20,
            cooldown: 0 * 20,
            cooldown2: 0 * 20,
            range: [
              0,
            ],
            minRange: [-999],
            bounceDistMin: 0,
            bounceDistMax: 0,
            bouncePower: 0,
            targetCC: 0,
            animationName: '',
            causesFlameDeath: false,
            modifiers: [],
            modifiersSelf: [],
            summonedUnits: [],
            summonsUseWaypoint: false,
            summonsWaypointAMove: false,
            ignoreSupplyCheck: false,
            requiresVision: false,
          },

          {
            type: COMMAND.MAKEBUILDING,
            unitType: 'snakecharmer',
            image: 'buildings_snake',
            hotkey: KEY.A,
            name: 'Build Snake Charmer',
            id_string: 'buildsnakecharmer',
            description: 'Cost: getField(snakecharmer.cost) Gold#BRDuration: getField(snakecharmer.buildTime) sec#BRgetField(snakecharmer.description)',
            requirementText: ['Requires a Wolves Den'],
            requirementType: ['wolvesden'],
            requirementLevel: [1],
            targetIsPoint: true,
            commandCard: 3,
            interfacePosX: 0,
            interfacePosY: 1,
          },

          {
            type: COMMAND.MAKEBUILDING,
            name: 'Build Armory',
            id_string: 'buildarmory',
            isCommand: true,
            unitType: 'armory',
            hotkey: KEY.R,
            targetIsPoint: true,
            targetIsUnit: false,
            isInstant: false,
            isChanneled: false,
            playLaunchSoundOnce: false,
            useAoeCursor: false,
            commandCard: 2,
            interfacePosX: 3,
            interfacePosY: 0,
            requiredLevels: [],
            learnCommandCard: 0,
            learnInterfacePosX: 0,
            learnInterfacePosY: 0,
            learnHotkey: 81,
            image: 'armory',
            attackEffectInit: 'spell',
            description: 'Cost: getField(armory.cost) Gold#BRDuration: getField(armory.buildTime) sec#BRgetField(armory.description)',
            requirementType: [
              'barracks',
            ],
            requirementLevel: [
              1,
            ],
            requirementText: [
              'Requires a Barracks',
            ],
            targetRequirements1: [],
            targetRequirements2: [],
            targetRequirements3: [],
            manaCost: [
              0,
            ],
            goldCost: 0,
            aoeRadius: [
              0,
            ],
            damage: [
              0,
            ],
            projectileDamage: [
              0,
            ],
            projectileAoeRadius: [
              0,
            ],
            maximizeRangeWhenCasting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            hitsSelf: true,
            targetFilters: [],
            targetFiltersExclude: [],
            effectScale: 1,
            hasAutocast: false,
            autocastDefault: false,
            autocastConditions: '',
            projectileSpeed: [
              8,
            ],
            duration: 0,
            castingDelay: 0 * 20,
            cooldown: 0 * 20,
            cooldown2: 0 * 20,
            range: [
              0,
            ],
            minRange: [-999],
            bounceDistMin: 0,
            bounceDistMax: 0,
            bouncePower: 0,
            targetCC: 0,
            animationName: '',
            causesFlameDeath: false,
            modifiers: [],
            modifiersSelf: [],
            summonedUnits: [],
            summonsUseWaypoint: false,
            summonsWaypointAMove: false,
            ignoreSupplyCheck: false,
            requiresVision: false,
          },
          {
            type: COMMAND.MAKEUNIT,
            name: 'Construct Gatling Gun',
            id_string: 'construct_gatling',
            isCommand: true,
            image: 'gatling_gun',
            unitType: 'gatlinggun',
            hotkey: 87,
            targetIsPoint: false,
            targetIsUnit: false,
            isInstant: true,
            isChanneled: false,
            playLaunchSoundOnce: false,
            useAoeCursor: false,
            commandCard: 0,
            interfacePosX: 1,
            interfacePosY: 0,
            requiredLevels: [],
            learnCommandCard: 0,
            learnInterfacePosX: 0,
            learnInterfacePosY: 0,
            learnHotkey: 81,
            attackEffectInit: 'spell',
            description: 'Cost: getField(gatlinggun.cost) Gold#BRSupply: getField(gatlinggun.supply)#BRDuration: getField(gatlinggun.buildTime) sec#BRgetField(gatlinggun.description)',
            requirementType: [],
            requirementLevel: [],
            requirementText: [],
            targetRequirements1: [],
            targetRequirements2: [],
            targetRequirements3: [],
            manaCost: [
              0,
            ],
            goldCost: 0,
            aoeRadius: [
              0,
            ],
            damage: [
              0,
            ],
            projectileDamage: [
              0,
            ],
            projectileAoeRadius: [
              0,
            ],
            maximizeRangeWhenCasting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            hitsSelf: true,
            targetFilters: [],
            targetFiltersExclude: [],
            effectScale: 1,
            hasAutocast: false,
            autocastDefault: false,
            autocastConditions: '',
            projectileSpeed: [
              8,
            ],
            duration: 0,
            castingDelay: 0 * 20,
            cooldown: 0 * 20,
            cooldown2: 0 * 20,
            range: [
              0,
            ],
            minRange: [-999],
            bounceDistMin: 0,
            bounceDistMax: 0,
            bouncePower: 0,
            targetCC: 0,
            animationName: '',
            causesFlameDeath: false,
            modifiers: [],
            modifiersSelf: [],
            summonedUnits: [],
            summonsUseWaypoint: false,
            summonsWaypointAMove: false,
            ignoreSupplyCheck: false,
            requiresVision: false,
          },
          {
            type: COMMAND.UNIVERSAL,
            name: 'Drop Caltrops',
            id_string: 'dropcaltrops',
            isCommand: true,
            unitType: 'worker',
            hotkey: 81,
            targetIsPoint: false,
            targetIsUnit: false,
            isInstant: true,
            isChanneled: false,
            playLaunchSoundOnce: false,
            useAoeCursor: false,
            commandCard: 0,
            interfacePosX: 0,
            interfacePosY: 0,
            requiredLevels: [],
            learnCommandCard: 0,
            learnInterfacePosX: 0,
            learnInterfacePosY: 0,
            learnHotkey: 81,
            image: 'caltropg',
            attackEffectInit: 'spell',
            attackEffect: null,
            description: 'Cost: getField(dropcaltrops.goldCost)#BRCooldown: getField(dropcaltrops.cooldown2)#BRDrops a caltrop on the ground.',
            requirementType: [
              'advancedworkshop',
            ],
            requirementLevel: [
              1,
            ],
            requirementText: [
              'Requires an Advanced Workshop',
            ],
            targetRequirements1: [],
            targetRequirements2: [],
            targetRequirements3: [],
            launchSound: SOUND.CALTROP,
            manaCost: [
              10,
            ],
            goldCost: 5,
            aoeRadius: [
              0,
            ],
            damage: [
              0,
            ],
            projectileDamage: [
              0,
            ],
            projectileAoeRadius: [
              0,
            ],
            maximizeRangeWhenCasting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            hitsSelf: true,
            targetFilters: [],
            targetFiltersExclude: [],
            effectScale: 1,
            hasAutocast: false,
            autocastDefault: false,
            autocastConditions: '',
            projectileSpeed: [
              8,
            ],
            duration: 0,
            castingDelay: 0 * 20,
            cooldown: 0 * 20,
            cooldown2: 6 * 20,
            range: [
              0,
            ],
            minRange: [-999],
            bounceDistMin: 0,
            bounceDistMax: 0,
            bouncePower: 0,
            targetCC: 0,
            animationName: '',
            causesFlameDeath: false,
            modifiers: [],
            modifiersSelf: [
              'speedbuffgat',
            ],
            summonedUnits: [
              'caltrop',
            ],
            summonsUseWaypoint: false,
            summonsWaypointAMove: false,
            ignoreSupplyCheck: false,
            requiresVision: false,
          },
          {
            type: COMMAND.UPGRADE,
            name: 'Research Spoked Wheel',
            id_string: 'spokedwheel_cmd',
            isCommand: true,
            hotkey: 68,
            targetIsPoint: false,
            targetIsUnit: false,
            isInstant: true,
            isChanneled: false,
            playLaunchSoundOnce: false,
            useAoeCursor: false,
            commandCard: 0,
            interfacePosX: 0,
            interfacePosY: 1,
            requiredLevels: [],
            learnCommandCard: 0,
            learnInterfacePosX: 0,
            learnInterfacePosY: 0,
            image: 'mechSpeedUpg',
            attackEffectInit: 'spell',
            description: 'Cost: getField(spokedwheel_upgrade.cost) Gold#BRDuration: getField(spokedwheel_upgrade.buildTime) sec#BRgetField(spokedwheel_upgrade.description)',
            requirementType: [],
            requirementLevel: [],
            requirementText: [],
            targetRequirements1: [],
            targetRequirements2: [],
            targetRequirements3: [],
            upgrade: 'spokedwheel_upgrade',
            manaCost: [
              0,
            ],
            goldCost: 0,
            aoeRadius: [
              0,
            ],
            damage: [
              0,
            ],
            projectileDamage: [
              0,
            ],
            projectileAoeRadius: [
              0,
            ],
            maximizeRangeWhenCasting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            hitsSelf: true,
            targetFilters: [],
            targetFiltersExclude: [],
            effectScale: 1,
            hasAutocast: false,
            autocastDefault: false,
            autocastConditions: '',
            projectileSpeed: [
              8,
            ],
            duration: 0,
            castingDelay: 0 * 20,
            cooldown: 0 * 20,
            cooldown2: 0 * 20,
            range: [
              0,
            ],
            minRange: [-999],
            bounceDistMin: 0,
            bounceDistMax: 0,
            bouncePower: 0,
            targetCC: 0,
            animationName: '',
            causesFlameDeath: false,
            modifiers: [],
            modifiersSelf: [],
            summonedUnits: [],
            summonsUseWaypoint: false,
            summonsWaypointAMove: false,
            ignoreSupplyCheck: false,
            requiresVision: false,
          },
          {
            type: COMMAND.UPGRADE,
            name: 'Research Bird Detection',
            id_string: 'bird_detection_cmd',
            isCommand: true,
            hotkey: 83,
            targetIsPoint: false,
            targetIsUnit: false,
            isInstant: true,
            isChanneled: false,
            playLaunchSoundOnce: false,
            useAoeCursor: false,
            commandCard: 0,
            interfacePosX: 1,
            interfacePosY: 1,
            requiredLevels: [],
            learnCommandCard: 0,
            learnInterfacePosX: 0,
            learnInterfacePosY: 0,
            image: 'eye',
            attackEffectInit: 'spell',
            description: 'Cost: getField(birddetection.cost) Gold#BRDuration: getField(birddetection.buildTime) sec#BRgetField(birddetection.description)',
            requirementType: [
              'house',
            ],
            requirementLevel: [
              1,
            ],
            requirementText: [
              'Requires a House',
            ],
            targetRequirements1: [],
            targetRequirements2: [],
            targetRequirements3: [],
            upgrade: 'birddetection',
            manaCost: [
              0,
            ],
            goldCost: 0,
            aoeRadius: [
              0,
            ],
            damage: [
              0,
            ],
            projectileDamage: [
              0,
            ],
            projectileAoeRadius: [
              0,
            ],
            maximizeRangeWhenCasting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            hitsSelf: true,
            targetFilters: [],
            targetFiltersExclude: [],
            effectScale: 1,
            hasAutocast: false,
            autocastDefault: false,
            autocastConditions: '',
            projectileSpeed: [
              8,
            ],
            duration: 0,
            castingDelay: 0 * 20,
            cooldown: 0 * 20,
            cooldown2: 0 * 20,
            range: [
              0,
            ],
            minRange: [-999],
            bounceDistMin: 0,
            bounceDistMax: 0,
            bouncePower: 0,
            targetCC: 0,
            animationName: '',
            causesFlameDeath: false,
            modifiers: [],
            modifiersSelf: [],
            summonedUnits: [],
            summonsUseWaypoint: false,
            summonsWaypointAMove: false,
            ignoreSupplyCheck: false,
            requiresVision: false,
          },
          {
            type: COMMAND.MAKEUNIT,
            name: 'Construct Gyrocraft',
            id_string: 'construct_gyrocraft',
            isCommand: true,
            image: 'gyrocopter',
            unitType: 'gyrocraft',
            hotkey: KEY.Q,
            targetIsPoint: false,
            targetIsUnit: false,
            isInstant: true,
            isChanneled: false,
            playLaunchSoundOnce: false,
            useAoeCursor: false,
            commandCard: 0,
            interfacePosX: 0,
            interfacePosY: 0,
            requiredLevels: [],
            learnCommandCard: 0,
            learnInterfacePosX: 0,
            learnInterfacePosY: 0,
            learnHotkey: 69,
            attackEffectInit: 'spell',
            description: 'Cost: getField(gyrocraft.cost) Gold#BRSupply: getField(gyrocraft.supply)#BRDuration: getField(gyrocraft.buildTime) sec#BRgetField(gyrocraft.description)',
            requirementType: [],
            requirementLevel: [],
            requirementText: [],
            targetRequirements1: [],
            targetRequirements2: [],
            targetRequirements3: [],
            manaCost: [
              0,
            ],
            goldCost: 0,
            aoeRadius: [
              0,
            ],
            damage: [
              0,
            ],
            projectileDamage: [
              0,
            ],
            projectileAoeRadius: [
              0,
            ],
            maximizeRangeWhenCasting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            hitsSelf: true,
            targetFilters: [],
            targetFiltersExclude: [],
            effectScale: 1,
            hasAutocast: false,
            autocastDefault: false,
            autocastConditions: '',
            projectileSpeed: [
              8,
            ],
            duration: 0,
            castingDelay: 0 * 20,
            cooldown: 0 * 20,
            cooldown2: 0 * 20,
            range: [
              0,
            ],
            minRange: [-999],
            bounceDistMin: 0,
            bounceDistMax: 0,
            bouncePower: 0,
            targetCC: 0,
            animationName: '',
            causesFlameDeath: false,
            modifiers: [],
            modifiersSelf: [],
            summonedUnits: [],
            summonsUseWaypoint: false,
            summonsWaypointAMove: false,
            ignoreSupplyCheck: false,
            requiresVision: false,
          },
          {
            type: COMMAND.MAKEBUILDING,
            name: 'Build Mill',
            id_string: 'buildmill',
            isCommand: true,
            unitType: 'mill',
            hotkey: KEY.E,
            targetIsPoint: true,
            targetIsUnit: false,
            isInstant: false,
            isChanneled: false,
            playLaunchSoundOnce: false,
            useAoeCursor: false,
            commandCard: 4,
            interfacePosX: 2,
            interfacePosY: 0,
            requiredLevels: [],
            learnCommandCard: 0,
            learnInterfacePosX: 0,
            learnInterfacePosY: 0,
            learnHotkey: 83,
            image: 'mill',
            attackEffectInit: 'spell',
            description: 'Cost: getField(mill.cost) Gold#BRDuration: getField(mill.buildTime) sec#BRgetField(mill.description)',
            requirementType: [
              'workshop',
            ],
            requirementLevel: [
              1,
            ],
            requirementText: [
              'Requires a workshop',
            ],
            targetRequirements1: [],
            targetRequirements2: [],
            targetRequirements3: [],
            manaCost: [
              0,
            ],
            goldCost: 0,
            aoeRadius: [
              0,
            ],
            damage: [
              0,
            ],
            projectileDamage: [
              0,
            ],
            projectileAoeRadius: [
              0,
            ],
            maximizeRangeWhenCasting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            hitsSelf: true,
            targetFilters: [],
            targetFiltersExclude: [],
            effectScale: 1,
            hasAutocast: false,
            autocastDefault: false,
            autocastConditions: '',
            projectileSpeed: [
              8,
            ],
            duration: 0,
            castingDelay: 0 * 20,
            cooldown: 0 * 20,
            cooldown2: 0 * 20,
            range: [
              0,
            ],
            minRange: [-999],
            bounceDistMin: 0,
            bounceDistMax: 0,
            bouncePower: 0,
            targetCC: 0,
            animationName: '',
            causesFlameDeath: false,
            modifiers: [],
            modifiersSelf: [],
            summonedUnits: [],
            summonsUseWaypoint: false,
            summonsWaypointAMove: false,
            ignoreSupplyCheck: false,
            requiresVision: false,
          },
          {
            type: COMMAND.UNIVERSAL,
            name: 'Sprint',
            id_string: 'sprint',
            isCommand: true,
            hotkey: 81,
            targetIsPoint: false,
            targetIsUnit: false,
            isInstant: true,
            isChanneled: false,
            playLaunchSoundOnce: false,
            useAoeCursor: false,
            commandCard: 0,
            interfacePosX: 0,
            interfacePosY: 0,
            requiredLevels: [],
            learnCommandCard: 0,
            learnInterfacePosX: 0,
            learnInterfacePosY: 0,
            learnHotkey: 81,
            image: 'beastSpeedUpg',
            attackEffectInit: 'smoke',
            attackEffect: null,
            description: 'Cooldown: getField(sprint.cooldown2)#BRThe wolf sprints, temporaily running faster until getting tired and running slower.',
            requirementType: [
              'sprint_upgrade',
            ],
            requirementLevel: [
              1,
            ],
            requirementText: [
              'Research in the snake charmer.',
            ],
            targetRequirements1: [],
            targetRequirements2: [],
            targetRequirements3: [],
            launchSound: 49,
            manaCost: [
              0,
            ],
            goldCost: 0,
            aoeRadius: [
              0,
            ],
            damage: [
              0,
            ],
            projectileDamage: [
              0,
            ],
            projectileAoeRadius: [
              0,
            ],
            maximizeRangeWhenCasting: false,
            hitsFriendly: false,
            hitsEnemy: false,
            hitsSelf: true,
            targetFilters: [],
            targetFiltersExclude: [],
            effectScale: 1,
            hasAutocast: false,
            autocastDefault: false,
            autocastConditions: '',
            projectileSpeed: [
              0,
            ],
            duration: 0,
            castingDelay: 0 * 20,
            cooldown: 0 * 20,
            cooldown2: 40 * 20,
            range: [
              0,
            ],
            minRange: [-999],
            bounceDistMin: 0,
            bounceDistMax: 0,
            bouncePower: 0,
            targetCC: 0,
            animationName: '',
            causesFlameDeath: false,
            modifiers: [
              'speeddebuff',
            ],
            modifiersSelf: [
              'speedbuff',
              'speeddebuff',
            ],
            summonedUnits: [],
            summonsUseWaypoint: false,
            summonsWaypointAMove: false,
            ignoreSupplyCheck: false,
            requiresVision: false,
          },
          {
            type: COMMAND.UPGRADE,
            name: 'Research Wolf Sprint',
            id_string: 'research_sprint',
            isCommand: true,
            hotkey: 81,
            targetIsPoint: false,
            targetIsUnit: false,
            isInstant: true,
            isChanneled: false,
            playLaunchSoundOnce: false,
            useAoeCursor: false,
            commandCard: 0,
            interfacePosX: 0,
            interfacePosY: 0,
            requiredLevels: [],
            learnCommandCard: 0,
            learnInterfacePosX: 0,
            learnInterfacePosY: 0,
            image: 'beastSpeedUpg',
            attackEffectInit: 'spell',
            description: 'Cost: getField(sprint_upgrade.cost) Gold#BRDuration: getField(sprint_upgrade.buildTime) sec#BRgetField(sprint_upgrade.description)',
            requirementType: [
              'fortress',
            ],
            requirementLevel: [
              1,
            ],
            requirementText: [
              'Requires a fortress.',
            ],
            targetRequirements1: [],
            targetRequirements2: [],
            targetRequirements3: [],
            upgrade: 'sprint_upgrade',
            manaCost: [
              0,
            ],
            goldCost: 0,
            aoeRadius: [
              0,
            ],
            damage: [
              0,
            ],
            projectileDamage: [
              0,
            ],
            projectileAoeRadius: [
              0,
            ],
            maximizeRangeWhenCasting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            hitsSelf: true,
            targetFilters: [],
            targetFiltersExclude: [],
            effectScale: 1,
            hasAutocast: false,
            autocastDefault: false,
            autocastConditions: '',
            projectileSpeed: [
              8,
            ],
            duration: 0,
            castingDelay: 0 * 20,
            cooldown: 0 * 20,
            cooldown2: 0 * 20,
            range: [
              0,
            ],
            minRange: [-999],
            bounceDistMin: 0,
            bounceDistMax: 0,
            bouncePower: 0,
            targetCC: 0,
            animationName: '',
            causesFlameDeath: false,
            modifiers: [],
            modifiersSelf: [],
            summonedUnits: [],
            summonsUseWaypoint: false,
            summonsWaypointAMove: false,
            ignoreSupplyCheck: false,
            requiresVision: false,
          },
          {
            type: COMMAND.UNIVERSAL,
            name: 'Explosive Shot',
            id_string: 'explosiveshot',
            isCommand: true,
            hotkey: KEY.Q,
            targetIsPoint: false,
            targetIsUnit: true,
            isInstant: false,
            isChanneled: false,
            playLaunchSoundOnce: false,
            useAoeCursor: false,
            commandCard: 0,
            interfacePosX: 0,
            interfacePosY: 0,
            requiredLevels: [],
            learnCommandCard: 0,
            learnInterfacePosX: 0,
            learnInterfacePosY: 0,
            learnHotkey: 81,
            image: 'flakUpg',
            attackEffectInit: 'spell',
            attackEffect: 'flamestrike',
            description: 'Cooldown: getField(aoeshot.cooldown2)#BRDamage: getField(aoeshot.damage)#BRSelect a flying target to shot a projectile that deals AOE damage.',
            requirementType: [
              'upgballistaexplosives',
            ],
            requirementLevel: [
              1,
            ],
            requirementText: [
              'Requires Ballista Black Powder research',
            ],
            targetRequirements1: [
              'isFlying',
            ],
            targetRequirements2: [],
            targetRequirements3: [],
            launchSound: 20,
            manaCost: [
              0,
            ],
            goldCost: 0,
            aoeRadius: [
              1.5,
            ],
            damage: [
              45,
            ],
            projectileDamage: [
              0,
            ],
            projectileAoeRadius: [
              0,
            ],
            maximizeRangeWhenCasting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            hitsSelf: false,
            targetFilters: [
              'flying',
            ],
            targetFiltersExclude: [],
            effectScale: 1,
            hasAutocast: false,
            autocastDefault: false,
            autocastConditions: '',
            projectileSpeed: [
              8,
            ],
            duration: 0,
            castingDelay: 0 * 20,
            cooldown: 0 * 20,
            cooldown2: 10 * 20,
            range: [
              8,
            ],
            minRange: [-999],
            bounceDistMin: 0,
            bounceDistMax: 0,
            bouncePower: 0,
            targetCC: 0,
            animationName: '',
            causesFlameDeath: false,
            modifiers: [],
            modifiersSelf: [],
            summonedUnits: [],
            summonsUseWaypoint: false,
            summonsWaypointAMove: false,
            ignoreSupplyCheck: false,
            requiresVision: false,
          },
        ];

        var RampTilesEgyptData = [

          new TileType({
            name: 'South West',
            img: { x: 582, y: 422, w: 22, h: 76 },
            sizeX: 1,
            sizeY: 3,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'South East',
            img: { x: 626, y: 422, w: 24, h: 76 },
            sizeX: 1,
            sizeY: 3,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'South Floor',
            img: { x: 603, y: 420, w: 16, h: 78 },
            sizeX: 1,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'South Floor 2',
            img: { x: 608, y: 341, w: 16, h: 78 },
            sizeX: 1,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'South Floor 3',
            img: { x: 625, y: 341, w: 16, h: 78 },
            sizeX: 1,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'West Top',
            img: { x: 653, y: 445, w: 54, h: 47 },
            sizeX: 3,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'West Bottom',
            img: { x: 712, y: 448, w: 52, h: 47 },
            sizeX: 3,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'West Floor',
            img: { x: 655, y: 393, w: 55, h: 52 },
            sizeX: 3,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'West Floor 2',
            img: { x: 711, y: 393, w: 55, h: 52 },
            sizeX: 3,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'West Floor 3',
            img: { x: 655, y: 327, w: 55, h: 52 },
            sizeX: 3,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'East Top',
            img: { x: 730, y: 275, w: 54, h: 45 },
            sizeX: 3,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'East Bottom',
            img: { x: 673, y: 279, w: 52, h: 43 },
            sizeX: 3,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'East Floor',
            img: { x: 722, y: 327, w: 50, h: 53 },
            sizeX: 3,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'East Floor 2',
            img: { x: 672, y: 221, w: 50, h: 53 },
            sizeX: 3,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'East Floor 3',
            img: { x: 727, y: 221, w: 50, h: 53 },
            sizeX: 3,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'North Left',
            img: { x: 460, y: 359, w: 23, h: 51 },
            sizeX: 1,
            sizeY: 3,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'North Right',
            img: { x: 492, y: 359, w: 21, h: 51 },
            sizeX: 1,
            sizeY: 3,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'North Floor',
            img: { x: 513, y: 360, w: 16, h: 23 },
            sizeX: 1,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'North Floor 2',
            img: { x: 513, y: 386, w: 16, h: 23 },
            sizeX: 1,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'North Floor 3',
            img: { x: 530, y: 386, w: 16, h: 23 },
            sizeX: 1,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

        ];

        /**
         * Dependency on DataCore for SOUND
         */
        var UnitData = [
          {
            name: 'Worker',
            id_string: 'worker',
            hp: 120,
            dmg: 8,
            repairRate: 12 / 20,
            repairIneffiency: 0.25,
            isHuman: true,
            supply: 1,
            movementSpeed: 2.6 / 20,
            weaponCooldown: 1 * 20,
            weaponDelay: 0.3 * 20,
            armor: 0,
            range: 0.2,
            size: 0.85,
            vision: 8,
            repairCost: 2.5 / 20,
            circleSize: 0.43,
            circleOffset: 0.125,
            commands: {
              stop: 'stop',
              holdposition: 'holdposition',
              attack: 'attack',
              move: 'move',
              moveto: 'moveto',
              amove: 'amove',
              mine: 'mine',
              repair: 'repair',
              buildcastle: 'buildcastle',
              buildbarracks: 'buildbarracks',
              buildwatchtower: 'buildwatchtower',
              buildhouse: 'buildhouse',
              buildmagesguild: 'buildmagesguild',
              buildworkshop: 'buildworkshop',
              buildforge: 'buildforge',
              mech_buildings: 'mech_buildings',
              builddragonslair: 'builddragonslair',
              buildwolvesden: 'buildwolvesden',
              buildanimaltestinglab: 'buildanimaltestinglab',
              buildadvancedworkshop: 'buildadvancedworkshop',
              buildchurch: 'buildchurch',
              buildmill: 'buildmill',
              buildarmory: 'buildarmory',
              buildsnakecharmer: 'buildsnakecharmer',
              basic_buildings: 'basic_buildings',
              human_buildings: 'human_buildings',
              beast_buildings: 'beast_buildings',
              back_basic: 'back_basic',
              back_humans: 'back_humans',
              back_beast: 'back_beast',
              back_mech: 'back_mech',
            },
            buildTime: 27 * 20,
            cost: 50,
            healthbarOffset: 0.95,
            healthbarWidth: 0.7,
            img: 'worker',
            description: 'Workers gather gold and construct buildings. They can also fight, but are not very good at it.',
            tabPriority: 10,
            drawOffsetY: 12.5,
            meleeHitSound: 28,
            meleeHitVolume: 0.6,
            painSound: 1,
            painSoundVolume: 0.4,
            painSound2: 55,
            painSoundVolume2: 1,
            deathSound: 2,
            isBiological: true,
            cargoUse: 1,
            isPassive: true,
            bodyPower: 0.8,
          },
          {
            name: 'Soldier',
            id_string: 'soldier',
            hp: 220,
            armor: 2,
            movementSpeed: 2.5875 / 20,
            dmg: 18,
            tabPriority: 6,
            isHuman: true,
            supply: 2,
            weaponCooldown: 1.15 * 20,
            weaponDelay: 0.25 * 20,
            armor: 1,
            range: 0.2,
            size: 0.95,
            vision: 8,
            circleSize: 0.43,
            circleOffset: 0,
            commands: {
              stop: 'stop',
              holdposition: 'holdposition',
              attack: 'attack',
              move: 'move',
              moveto: 'moveto',
              amove: 'amove',
            },
            buildTime: 25 * 20,
            cost: 80,
            healthbarOffset: 1.1,
            healthbarWidth: 0.7,
            img: 'soldier',
            description: 'Soldiers are basic melee combat units.',
            tabPriority: 7,
            drawOffsetY: 10,
            meleeHitSound: 10,
            meleeHitVolume: 1,
            painSound: 1,
            painSoundVolume: 0.4,
            painSound2: 55,
            painSoundVolume2: 1,
            yesSound: 101,
            yesSoundVolume: 1,
            readySound: 101,
            readySoundVolume: 1,
            deathSound: 2,
            isBiological: true,
            cargoUse: 2,
          },
          {
            name: 'Archer',
            id_string: 'archer',
            hp: 160,
            movementSpeed: 2.52 / 20,
            dmg: 12,
            buildTime: 22 * 20,
            isHuman: true,
            supply: 2,
            weaponCooldown: 1.4 * 20,
            weaponDelay: 0.1 * 20,
            armor: 0,
            range: 5,
            size: 0.95,
            vision: 8,
            projectileSpeed: 12,
            projectileStartHeight: 0.25,
            attackLaunchSound: 3,
            circleSize: 0.43,
            circleOffset: 0,
            commands: {
              stop: 'stop',
              holdposition: 'holdposition',
              attack: 'attack',
              move: 'move',
              moveto: 'moveto',
              amove: 'amove',
            },
            cost: 80,
            healthbarOffset: 1.45,
            healthbarWidth: 0.7,
            img: 'archer',
            description: 'Archers are weaker than Soldiers, but can shoot over distance.',
            projectileLen: 0.2,
            tabPriority: 6,
            drawOffsetY: 10,
            painSound: 1,
            painSoundVolume: 0.4,
            painSound2: 55,
            painSoundVolume2: 1,
            yesSound: 91,
            yesSoundVolume: 1,
            readySound: 90,
            readySoundVolume: 1,
            deathSound: 2,
            bodyPower: 0.8,
            isBiological: true,
            canAttackFlying: true,
            cargoUse: 2,
            attackEffect: 'arrow',
          },
          {
            name: 'Raider',
            id_string: 'raider',
            hp: 165,
            startHp: 0,
            mana: 50,
            startMana: 25,
            hpRegenerationRate: 1 / 20,
            manaRegenerationRate: 0.9375 / 20,
            armor: 0,
            supply: 2,
            supplyProvided: 0,
            movementSpeed: 3.2 / 20,
            weaponCooldown: 2.79 * 20,
            weaponDelay: 0.25 * 20,
            dmg: 30,
            dmgModifierAttributes: [
              'isBiological',
              'isMechanical',
            ],
            dmgModifierAddition: [
              14,
              16,
            ],
            dmgModifierMultiplier: [
              1,
              1,
            ],
            lifesteal: 0,
            armorPenetration: 0,
            percDmg: 0,
            dmgCap: 1,
            bouncePower: 0,
            bounceDistMin: 0,
            bounceDistMax: 0,
            range: 0.2,
            minRange: -999,
            aoeRadius: 0,
            attackPrio: 10,
            size: 0.95,
            imageScale: 1,
            vision: 8,
            repairRate: 0 / 20,
            projectileSpeed: 8,
            projectileLen: 0.2,
            attackLaunchSound: 0,
            circleSize: 0.55,
            circleOffset: 0,
            buildTime: 32 * 20,
            cost: 110,
            healthbarOffset: 1.1,
            healthbarWidth: 0.7,
            selectionOffsetY: 0,
            img: 'raider',
            description: 'Raiders are fast melee combat units with several abilities.',
            experienceLevels: [],
            experience: 0,
            modifiersPerLevel: [],
            experienceRange: 9,
            tabPriority: 13,
            drawOffsetY: 10,
            attackEffect: null,
            painSound: 1,
            painSoundVolume: 0.4,
            painSound2: 55,
            painSoundVolume2: 1,
            deathSound: 2,
            yesSound: 100,
            yesSoundVolume: 0.9,
            readySound: 100,
            readySoundVolume: 0.9,
            bodyPower: 0.8,
            dustCreationChance: 1 / 20,
            visionHeightBonus: 0,
            animSpeed: 1.5,
            oscillationAmplitude: 0,
            height: 0.3,
            acceleration: 0,
            angularVelocity: 0,
            commands: {
              stop: 'stop',
              holdposition: 'holdposition',
              attack: 'attack',
              move: 'move',
              moveto: 'moveto',
              amove: 'amove',
              Flash: 'Flash',
              Shroud: 'Shroud',
            },
            cargoUse: 2,
            cargoSpace: 0,
            projectileStartHeight: 0,
            power: 0,
            lifetime: 0,
            goldReward: 0,
            limit: 0,
            modifiers: [],
            modifiersSelf: [
              'killflash',
            ],
            spawnModifiers: [
              'raiderfix',
            ],
            hoverText: '',
            canHaveWaypoint: false,
            isPassive: false,
            causesFlameDeath: false,
            shootingReveals: false,
            shootWhileMoving: false,
            hitscan: false,
            maximizeRangeWhenShooting: false,
            hitsFriendly: false,
            hitsEnemy: true,
            canAttackGround: true,
            canAttackFlying: false,
            isHeatSeeking: true,
            ignoreEnemyHitscan: false,
            controllable: true,
            hasDetection: false,
            expOnlyFromOwnKills: false,
            alliesGetExperience: false,
            alliesGetGold: false,
            isReflectingProjectiles: false,
            isBlockingProjectiles: false,
            takeDamageOnBlock: false,
            preventsLoss: false,
            flying: false,
            uniqueAndHeroic: false,
            isMechanical: false,
            isUndead: false,
            isBiological: true,
            isBeast: false,
            isHuman: false,
            noShow: false,
            noCollision: false,
            isInvisible: false,
            isInvincible: false,
            spawnWithAMove: false,
          },
          {
            name: 'Mage',
            id_string: 'mage',
            hp: 160,
            supply: 3,
            mana: 100,
            startMana: 50,
            manaRegenerationRate: 1 / 20,
            movementSpeed: 2.3 / 20,
            weaponCooldown: 2 * 20,
            weaponDelay: 0.2 * 20,
            dmg: 10,
            armor: 0,
            range: 5,
            size: 0.95,
            vision: 8,
            projectileSpeed: 10,
            projectileStartHeight: 0.5,
            attackLaunchSound: 22,
            circleSize: 0.43,
            circleOffset: 0.125,
            commands: {
              stop: 'stop',
              holdposition: 'holdposition',
              attack: 'attack',
              move: 'move',
              moveto: 'moveto',
              amove: 'amove',
              summonslowfield: 'summonslowfield',
              fireball: 'fireball',
            },
            buildTime: 35 * 20,
            cost: 125,
            healthbarOffset: 1.25,
            healthbarWidth: 0.7,
            img: 'mage',
            description: 'Mages can cast several spells.',
            tabPriority: 15,
            drawOffsetY: 12,
            painSound: 1,
            painSoundVolume: 0.4,
            painSound2: 55,
            painSoundVolume2: 1,
            yesSound: 98,
            yesSoundVolume: 1,
            readySound: 97,
            readySoundVolume: 1,
            deathSound: 2,
            isBiological: true,
            canAttackFlying: true,
            cargoUse: 2,
            bodyPower: 0.8,
            attackEffect: 'mageAttack',
            isHuman: true,
          },
          {
            name: 'Priest',
            id_string: 'priest',
            hp: 160,
            supply: 3,
            mana: 100,
            startMana: 50,
            manaRegenerationRate: 0.8 / 20,
            movementSpeed: 2.3 / 20,
            weaponCooldown: 2 * 20,
            weaponDelay: 0.2 * 20,
            dmg: 10,
            armor: 0,
            range: 5,
            size: 0.95,
            vision: 8,
            projectileSpeed: 10,
            attackLaunchSound: 22,
            circleSize: 0.43,
            circleOffset: -0.05,
            commands: {
              stop: 'stop',
              holdposition: 'holdposition',
              attack: 'attack',
              move: 'move',
              moveto: 'moveto',
              amove: 'amove',
              summonhealingward: 'summonhealingward',
              invisibilityspell: 'invisibilityspell',
            },
            buildTime: 30 * 20,
            cost: 100,
            healthbarOffset: 1.2,
            healthbarWidth: 0.7,
            img: 'priest',
            description: 'Priests can cast several spells.',
            tabPriority: 14,
            drawOffsetY: 9,
            painSound: 1,
            painSoundVolume: 0.4,
            painSound2: 55,
            painSoundVolume2: 1,
            deathSound: 2,
            yesSound: 99,
            yesSoundVolume: 1,
            readySound: 99,
            readySoundVolume: 1,
            isBiological: true,
            canAttackFlying: true,
            cargoUse: 2,
            bodyPower: 0.8,
            attackEffect: 'mageAttack',
            isHuman: true,
          },
          {
            name: 'Wolf',
            id_string: 'wolf',
            hp: 160,
            hpRegenerationRate: 1 / 20,
            supply: 2,
            movementSpeed: 3.45 / 20,
            weaponCooldown: 1.15 * 20,
            weaponDelay: 0.25 * 20,
            dmg: 10,
            armor: 0,
            range: 0.2,
            size: 0.85,
            imageScale: 0.89,
            vision: 8,
            circleSize: 0.47,
            circleOffset: -0.1,
            spawnWithAMove: true,
            commands: {
              stop: 'stop',
              holdposition: 'holdposition',
              attack: 'attack',
              move: 'move',
              moveto: 'moveto',
              amove: 'amove',
              sprint: 'sprint',
            },
            buildTime: 17 * 20,
            cost: 45,
            healthbarOffset: 1.4,
            healthbarWidth: 0.7,
            img: 'wolf',
            description: 'Wolves are fast melee units.',
            tabPriority: 6,
            drawOffsetY: 7,
            meleeHitSound: 46,
            meleeHitVolume: 0.7,
            painSound: 47,
            painSoundVolume: 0.8,
            painSound2: 55,
            painSoundVolume2: 1,
            yesSound: 43,
            yesSoundVolume: 1,
            deathSound: 45,
            readySound: 44,
            readySoundVolume: 1,
            isBiological: true,
            bodyPower: 0.5,
            cargoUse: 1,
            isBeast: true,
            lifesteal: 0.01,
          },
          {
            name: 'Bird',
            id_string: 'bird',
            hp: 75,
            hpRegenerationRate: 0.5 / 20,
            supply: 1,
            movementSpeed: 3 / 20,
            armor: 0,
            size: 0.95,
            vision: 10,
            circleSize: 0.6,
            circleOffset: -2.9,
            commands: {
              stop: 'stop',
              holdposition: 'holdposition',
              move: 'move',
              moveto: 'moveto',
            },
            buildTime: 20 * 20,
            cost: 75,
            healthbarOffset: 3.8,
            healthbarWidth: 0.8,
            selectionOffsetY: 3,
            img: 'bird',
            description: 'Birds are fast flying units that can be used for scouting.',
            tabPriority: 4,
            drawOffsetY: 10,
            painSound: 55,
            painSoundVolume: 0.7,
            deathSound: 71,
            yesSound: 70,
            yesSoundVolume: 1,
            readySound: 69,
            readySoundVolume: 1,
            dustCreationChance: -1 / 20,
            flying: true,
            isBiological: true,
            isBeast: true,
            visionHeightBonus: 1,
            animSpeed: 3,
            oscillationAmplitude: 0.05,
            height: 3.3,
            acceleration: 0.05,
            angularVelocity: 0.2,
            removeAfterDeadAnimation: true,
            deathAnimationSpeed: 0.5,
            bodyPower: 0.25,
            slamSound: 72,
          },
          {
            name: 'Snake',
            id_string: 'snake',
            hp: 90,
            startHp: 0,
            mana: 0,
            startMana: 0,
            hpRegenerationRate: 0.5 / 20,
            armor: 0,
            supply: 2,
            supplyProvided: 0,
            movementSpeed: 2.99 / 20,
            weaponCooldown: 0.67 * 20,
            weaponDelay: 0.15 * 20,
            dmg: 7,
            dmgModifierAttributes: [
              'flying',
            ],
            dmgModifierAddition: [-1.5],
            dmgModifierMultiplier: [
              1,
            ],
            lifesteal: 0,
            armorPenetration: 0,
            percDmg: 0,
            dmgCap: 1,
            bouncePower: 0,
            bounceDistMin: 0,
            bounceDistMax: 0,
            range: 3,
            minRange: -999,
            aoeRadius: 0,
            attackPrio: 10,
            size: 0.95,
            imageScale: 0.55,
            vision: 8,
            repairRate: 0 / 20,
            projectileSpeed: 8,
            projectileLen: 0.2,
            attackLaunchSound: 22,
            circleSize: 0.43,
            circleOffset: 0.125,
            buildTime: 19 * 20,
            cost: 50,
            healthbarOffset: 1,
            healthbarWidth: 0.7,
            selectionOffsetY: 0,
            img: 'snake',
            description: 'Snakes are vulnerable but quick ranged beasts.',
            experienceLevels: [],
            experience: 0,
            modifiersPerLevel: [],
            experienceRange: 9,
            tabPriority: 6,
            drawOffsetY: 45,
            attackEffect: 'mageAttack',
            painSound: 61,
            painSoundVolume: 0.5,
            painSound2: 55,
            painSoundVolume2: 1,
            deathSound: 59,
            yesSound: 60,
            yesSoundVolume: 0.8,
            readySound: 59,
            readySoundVolume: 0.9,
            bodyPower: 0.8,
            dustCreationChance: 1 / 20,
            visionHeightBonus: 0,
            animSpeed: 1,
            oscillationAmplitude: 0,
            height: 0.3,
            acceleration: 0,
            angularVelocity: 0,
            commands: {
              stop: 'stop',
              holdposition: 'holdposition',
              attack: 'attack',
              move: 'move',
              moveto: 'moveto',
              amove: 'amove',
            },
            cargoUse: 1,
            cargoSpace: 0,
            projectileStartHeight: 0,
            power: 0,
            lifetime: 0,
            goldReward: 0,
            limit: 0,
            modifiers: [],
            modifiersSelf: [],
            spawnModifiers: [],
            hoverText: '',
            canHaveWaypoint: false,
            isPassive: false,
            causesFlameDeath: false,
            shootingReveals: false,
            shootWhileMoving: false,
            hitscan: false,
            maximizeRangeWhenShooting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            canAttackGround: true,
            canAttackFlying: true,
            isHeatSeeking: true,
            ignoreEnemyHitscan: false,
            controllable: true,
            hasDetection: false,
            expOnlyFromOwnKills: false,
            alliesGetExperience: false,
            alliesGetGold: false,
            isReflectingProjectiles: false,
            isBlockingProjectiles: false,
            takeDamageOnBlock: false,
            preventsLoss: false,
            flying: false,
            uniqueAndHeroic: false,
            isMechanical: false,
            isUndead: false,
            isBiological: true,
            isBeast: true,
            isHuman: false,
            noShow: false,
            noCollision: false,
            isInvisible: false,
            isInvincible: false,
            spawnWithAMove: false,
          },
          {
            name: 'Dragon',
            id_string: 'dragon',
            hp: 265,
            hpRegenerationRate: 0.8 / 20,
            supply: 4,
            movementSpeed: 3.52 / 20,
            weaponCooldown: 1.65 * 20,
            weaponDelay: 0.05 * 20,
            dmg: 14,
            armor: 1,
            range: 4.5,
            aoeRadius: 0.2,
            size: 2.9,
            vision: 10,
            projectileSpeed: 6,
            attackLaunchSound: 41,
            circleSize: 1.8,
            circleOffset: -3,
            commands: {
              stop: 'stop',
              holdposition: 'holdposition',
              attack: 'attack',
              move: 'move',
              moveto: 'moveto',
              amove: 'amove',
            },
            buildTime: 30 * 20,
            cost: 145,
            healthbarOffset: 5.5,
            healthbarWidth: 1.6,
            selectionOffsetY: 3,
            img: 'dragon',
            description: 'Dragons are big, flying units.',
            tabPriority: 6,
            drawOffsetY: 34,
            painSound: 55,
            painSoundVolume: 1,
            deathSound: 39,
            yesSound: 37,
            yesSoundVolume: 1,
            readySound: 38,
            readySoundVolume: 1,
            dustCreationChance: -1 / 20,
            flying: true,
            isBiological: true,
            isBeast: true,
            visionHeightBonus: 2,
            animSpeed: 3,
            projectileStartHeight: 3,
            oscillationAmplitude: 0.15,
            canAttackFlying: true,
            height: 3.3,
            acceleration: 0.03,
            angularVelocity: 0.0,
            removeAfterDeadAnimation: true,
            shootingReveals: true,
            causesFlameDeath: true,
            attackEffect: 'dragonAttack',
          },
          {
            name: 'Werewolf',
            id_string: 'werewolf',
            hp: 440,
            supply: 6,
            hpRegenerationRate: 1.8 / 20,
            movementSpeed: 2.52 / 20,
            weaponCooldown: 2 * 20,
            weaponDelay: 0 * 20,
            dmg: 40,
            armor: 4,
            range: 1.0,
            size: 1.75,
            imageScale: 0.9,
            vision: 8,
            circleSize: 0.93,
            circleOffset: 0,
            commands: {
              stop: 'stop',
              holdposition: 'holdposition',
              attack: 'attack',
              move: 'move',
              moveto: 'moveto',
              amove: 'amove',
              smash: 'smash',
            },
            buildTime: 40 * 20,
            cost: 225,
            healthbarOffset: 2.6,
            healthbarWidth: 1,
            img: 'werewolf',
            description: 'Werewolves are very strong melee units.',
            tabPriority: 6,
            drawOffsetY: 21,
            painSound: 47,
            painSoundVolume: 0.5,
            painSound2: 55,
            painSoundVolume2: 1,
            meleeHitSound: 51,
            meleeHitVolume: 1,
            yesSound: 53,
            yesSoundVolume: 1,
            deathSound: 52,
            readySound: 54,
            readySoundVolume: 1,
            isBiological: true,
            isBeast: true,
            cargoUse: 4,
            animSpeed: 3,
            bodyPower: 2.5,
            deathAnimationSpeed: 0.2,
            power: 2,
          },
          {
            name: 'Gatling Gun',
            id_string: 'gatlinggun',
            hp: 175,
            startHp: 0,
            mana: 30,
            startMana: 10,
            hpRegenerationRate: 0 / 20,
            manaRegenerationRate: 0.13 / 20,
            armor: 0,
            supply: 3,
            supplyProvided: 0,
            movementSpeed: 2.9 / 20,
            weaponCooldown: 1.07 * 20,
            weaponDelay: 0.05 * 20,
            dmg: 13,
            dmgModifierAttributes: [],
            dmgModifierAddition: [],
            dmgModifierMultiplier: [],
            lifesteal: 0,
            armorPenetration: 5,
            percDmg: 0,
            dmgCap: 1,
            bouncePower: 0,
            bounceDistMin: 0,
            bounceDistMax: 0,
            range: 3,
            minRange: -999,
            aoeRadius: 0,
            attackPrio: 10,
            size: 1.01,
            imageScale: 0.9,
            vision: 8,
            repairRate: 0 / 20,
            projectileSpeed: 14,
            projectileLen: 0.4,
            attackLaunchSound: 25,
            circleSize: 0.7,
            circleOffset: 0,
            buildTime: 26 * 20,
            cost: 95,
            healthbarOffset: 1.1,
            healthbarWidth: 1,
            selectionOffsetY: 0,
            img: 'gatling_gun',
            description: 'Gatling guns are quick and strong mechanical units',
            experienceLevels: [],
            experience: 0,
            modifiersPerLevel: [],
            experienceRange: 9,
            tabPriority: 7,
            drawOffsetY: 19,
            attackEffect: 'arrow',
            painSound: 24,
            painSoundVolume: 1,
            painSound2: 0,
            painSoundVolume2: 1,
            deathSound: 29,
            yesSound: 95,
            yesSoundVolume: 0.9,
            readySound: 95,
            readySoundVolume: 0.9,
            bodyPower: 2,
            dustCreationChance: 2 / 20,
            visionHeightBonus: 0,
            animSpeed: 1.5,
            oscillationAmplitude: 0,
            height: 0.3,
            acceleration: 0,
            angularVelocity: 0,
            commands: {
              stop: 'stop',
              holdposition: 'holdposition',
              attack: 'attack',
              move: 'move',
              moveto: 'moveto',
              amove: 'amove',
              dropcaltrops: 'dropcaltrops',
            },
            cargoUse: 2,
            cargoSpace: 0,
            projectileStartHeight: 0.1,
            power: 2,
            lifetime: 0,
            goldReward: 0,
            limit: 0,
            modifiers: [],
            modifiersSelf: [],
            spawnModifiers: [],
            hoverText: '',
            canHaveWaypoint: false,
            isPassive: false,
            causesFlameDeath: false,
            shootingReveals: false,
            shootWhileMoving: false,
            hitscan: false,
            maximizeRangeWhenShooting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            canAttackGround: true,
            canAttackFlying: false,
            isHeatSeeking: true,
            ignoreEnemyHitscan: false,
            controllable: true,
            hasDetection: false,
            expOnlyFromOwnKills: false,
            alliesGetExperience: false,
            alliesGetGold: false,
            isReflectingProjectiles: false,
            isBlockingProjectiles: false,
            takeDamageOnBlock: false,
            preventsLoss: false,
            flying: false,
            uniqueAndHeroic: false,
            isMechanical: true,
            isUndead: false,
            isBiological: false,
            isBeast: false,
            isHuman: false,
            noShow: false,
            noCollision: false,
            isInvisible: false,
            isInvincible: false,
            spawnWithAMove: false,
          },
          {
            name: 'Catapult',
            id_string: 'catapult',
            hp: 220,
            supply: 3,
            movementSpeed: 2 / 20,
            weaponCooldown: 3 * 20,
            weaponDelay: 0.65 * 20,
            dmg: 58,
            armor: 2,
            range: 10,
            minRange: 4.5,
            aoeRadius: 0.5,
            size: 1.5,
            vision: 8,
            projectileSpeed: 8.8,
            attackLaunchSound: 25,
            bounceDistMin: 2,
            bounceDistMax: 4.5,
            circleSize: 0.88,
            circleOffset: 0,
            commands: {
              stop: 'stop',
              holdposition: 'holdposition',
              attack: 'attack',
              move: 'move',
              moveto: 'moveto',
              amove: 'amove',
              attackground: 'attackground',
            },
            buildTime: 30 * 20,
            isHeatSeeking: false,
            cost: 125,
            healthbarOffset: 1.3,
            healthbarWidth: 1,
            img: 'catapult',
            description: 'Catapults can sling powerful rocks from a great distance, but cannot defend themselves against close-range enemies.',
            tabPriority: 9,
            drawOffsetY: 13,
            painSound: 24,
            painSoundVolume: 1,
            yesSound: 94,
            yesSoundVolume: 1,
            readySound: 94,
            readySoundVolume: 1,
            deathSound: 29,
            bodyPower: 2,
            power: 2,
            isMechanical: true,
            dustCreationChance: 2 / 20,
            cargoUse: 4,
            attackEffect: 'launchedRock',
          },
          {
            name: 'Airship',
            id_string: 'airship',
            hp: 220,
            supply: 2,
            movementSpeed: 3.4 / 20,
            weaponCooldown: 1.65 * 20,
            weaponDelay: 0.05 * 20,
            dmg: 0,
            armor: 0,
            range: 0,
            size: 3.28,
            imageScale: 0.8,
            vision: 10,
            projectileSpeed: 6,
            attackLaunchSound: 41,
            circleSize: 1.8,
            circleOffset: -2.5,
            commands: {
              stop: 'stop',
              holdposition: 'holdposition',
              move: 'move',
              moveto: 'moveto',
              loadin: 'loadin',
              unload: 'unload',
              directunload: 'directunload',
            },
            buildTime: 32 * 20,
            cost: 100,
            healthbarOffset: 5.3,
            healthbarWidth: 1.6,
            selectionOffsetY: 3,
            img: 'airship',
            description: 'Airships can transport your ground units.',
            tabPriority: 1,
            drawOffsetY: 34,
            painSound: 24,
            painSoundVolume: 1,
            yesSound: 89,
            yesSoundVolume: 1,
            readySound: 89,
            readySoundVolume: 1,
            deathSound: 29,
            dustCreationChance: -1 / 20,
            flying: true,
            isMechanical: true,
            isBiological: false,
            visionHeightBonus: 2,
            animSpeed: 2,
            oscillationAmplitude: 0.07,
            height: 3.3,
            acceleration: 0.05,
            angularVelocity: 0.0,
            removeAfterDeadAnimation: true,
            cargoSpace: 8,
            deathAnimationSpeed: 0.3,
            isPassive: true,
            onDamageModifiers: [],
          },
          {
            name: 'Gyrocraft',
            id_string: 'gyrocraft',
            hp: 175,
            startHp: 0,
            mana: 0,
            startMana: 0,
            hpRegenerationRate: 0 / 20,
            manaRegenerationRate: 0.13 / 20,
            armor: 0,
            supply: 3,
            supplyProvided: 0,
            movementSpeed: 4 / 20,
            weaponCooldown: 1.5 * 20,
            weaponDelay: 0.05 * 20,
            dmg: 12,
            dmgModifierAttributes: [],
            dmgModifierAddition: [],
            dmgModifierMultiplier: [],
            lifesteal: 0,
            armorPenetration: 0,
            percDmg: 0,
            dmgCap: 1,
            bouncePower: 0,
            bounceDistMin: 0,
            bounceDistMax: 0,
            range: 2.5,
            minRange: -999,
            aoeRadius: 0,
            attackPrio: 10,
            size: 1.65,
            imageScale: 0.95,
            vision: 9,
            repairRate: 0 / 20,
            projectileSpeed: 14,
            projectileLen: 0.4,
            attackLaunchSound: 25,
            circleSize: 1,
            circleOffset: -1.95,
            buildTime: 30 * 20,
            cost: 110,
            healthbarOffset: 3.6,
            healthbarWidth: 1,
            selectionOffsetY: 1.7,
            img: 'gyrocopter',
            description: 'Gyrocrafts are speedy flying mechanical units.',
            experienceLevels: [],
            experience: 0,
            modifiersPerLevel: [],
            experienceRange: 9,
            tabPriority: 6,
            drawOffsetY: 20,
            attackEffect: 'arrow',
            painSound: 103,
            painSoundVolume: 1,
            painSound2: 0,
            painSoundVolume2: 1,
            deathSound: 29,
            yesSound: 102,
            yesSoundVolume: 0.9,
            readySound: 96,
            readySoundVolume: 0.9,
            bodyPower: 2,
            dustCreationChance: 2 / 20,
            visionHeightBonus: 2,
            animSpeed: 1.3,
            oscillationAmplitude: 0.12,
            height: 2,
            acceleration: 0.06,
            angularVelocity: 0,
            commands: {
              stop: 'stop',
              holdposition: 'holdposition',
              attack: 'attack',
              move: 'move',
              moveto: 'moveto',
              amove: 'amove',
            },
            cargoUse: -1,
            cargoSpace: 0,
            projectileStartHeight: 4,
            power: 2,
            lifetime: 0,
            goldReward: 0,
            limit: 0,
            modifiers: [],
            modifiersSelf: [],
            spawnModifiers: [],
            hoverText: '',
            canHaveWaypoint: false,
            isPassive: false,
            causesFlameDeath: false,
            shootingReveals: true,
            shootWhileMoving: false,
            hitscan: false,
            maximizeRangeWhenShooting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            canAttackGround: true,
            canAttackFlying: true,
            isHeatSeeking: true,
            ignoreEnemyHitscan: false,
            controllable: true,
            hasDetection: false,
            expOnlyFromOwnKills: false,
            alliesGetExperience: false,
            alliesGetGold: false,
            isReflectingProjectiles: false,
            isBlockingProjectiles: false,
            takeDamageOnBlock: false,
            preventsLoss: false,
            flying: true,
            uniqueAndHeroic: false,
            isMechanical: true,
            isUndead: false,
            isBiological: false,
            isBeast: false,
            isHuman: false,
            noShow: false,
            noCollision: false,
            isInvisible: false,
            isInvincible: false,
            spawnWithAMove: false,
          },
          {
            name: 'Ballista',
            id_string: 'ballista',
            hp: 250,
            supply: 4,
            movementSpeed: 2.1275 / 20,
            weaponCooldown: 2.5 * 20,
            weaponDelay: 0.3 * 20,
            dmg: 45,
            armor: 4,
            range: 6,
            size: 1.7,
            vision: 8,
            projectileSpeed: 14,
            attackLaunchSound: 25,
            circleSize: 1.1,
            circleOffset: 0,
            commands: {
              stop: 'stop',
              holdposition: 'holdposition',
              attack: 'attack',
              move: 'move',
              moveto: 'moveto',
              amove: 'amove',
              explosiveshot: 'explosiveshot',
            },
            buildTime: 32 * 20,
            cost: 150,
            healthbarOffset: 1.8,
            healthbarWidth: 1,
            img: 'ballista',
            description: 'Ballistas are slow but strong anti air units.',
            tabPriority: 8,
            drawOffsetY: 20,
            painSound: 24,
            painSoundVolume: 1,
            yesSound: 92,
            yesSoundVolume: 1,
            readySound: 92,
            readySoundVolume: 1,
            deathSound: 29,
            bodyPower: 2,
            isMechanical: true,
            isBiological: false,
            dustCreationChance: 2 / 20,
            cargoUse: 4,
            canAttackFlying: true,
            canAttackGround: false,
            attackEffect: 'ballista',
            projectileStartHeight: 1,
            power: 2,
          },
          {
            name: 'Skeleton',
            id_string: 'skeleton',
            hp: 230,
            supply: 0,
            movementSpeed: 2.07 / 20,
            weaponCooldown: 1.25 * 20,
            weaponDelay: 0.25 * 20,
            dmg: 18,
            armor: 0,
            range: 0.2,
            size: 0.95,
            vision: 8,
            circleSize: 0.43,
            circleOffset: 0.125,
            commands: {
              stop: 'stop',
              holdposition: 'holdposition',
              attack: 'attack',
              move: 'move',
              moveto: 'moveto',
              amove: 'amove',
            },
            buildTime: 23 * 20,
            cost: 0,
            healthbarOffset: 1,
            healthbarWidth: 0.7,
            img: 'skeleton',
            description: 'Skeletons are basic melee combat units. They are undead, that means they take damage from healing spells.',
            tabPriority: 7,
            drawOffsetY: 6,
            meleeHitSound: 10,
            meleeHitVolume: 1,
            painSound: 61,
            painSoundVolume: 0.5,
            painSound2: 55,
            painSoundVolume2: 1,
            yesSound: 60,
            yesSoundVolume: 0.8,
            deathSound: 59,
            readySound: 59,
            cargoUse: 2,
            lifetime: 700,
            isBiological: false,
            isUndead: true,
            summonTime: 40,
          },
          {
            name: 'Healing Ward',
            id_string: 'healingward',
            hp: 50,
            supply: 0,
            movementSpeed: 0 / 20,
            armor: 2,
            size: 0.85,
            vision: 7,
            circleSize: 0.6,
            circleOffset: 0,
            commands: {},
            buildTime: 45 * 20,
            cost: 0,
            healthbarOffset: 1.75,
            healthbarWidth: 0.7,
            img: 'totem',
            description: 'Healing Wards heal nearby allied non-undead units and damage enemy undead units.',
            tabPriority: 4,
            drawOffsetY: 7.5,
            painSound: 24,
            painSoundVolume: 1,
            deathSound: 29,
            dustCreationChance: -1 / 20,
            animSpeed: 5,
            deathAnimationSpeed: 0.3,
            spawnModifiers: [
              'healaura',
              'healauradmg',
            ],
            lifetime: 225,
            attackPrio: 6,
            idleFrames: [
              0,
              1,
              2,
              3,
              2,
              1,
            ],
            summonTime: 16,
            noMoveWhenHit: true,
            power: 2,
            isBiological: false,
          },
          {
            name: 'Slowing Field',
            id_string: 'slowingfield',
            hp: 999999,
            supply: 0,
            movementSpeed: 0 / 20,
            armor: 2,
            size: 0.85,
            vision: -1,
            circleSize: 0.6,
            circleOffset: 0,
            commands: {},
            buildTime: 45 * 20,
            cost: 0,
            healthbarOffset: 1.75,
            healthbarWidth: 0.7,
            img: 'totem',
            description: 'Creates an aura that slows down the movement speed of ground units.',
            tabPriority: 2,
            drawOffsetY: 7.5,
            dustCreationChance: -1 / 20,
            animSpeed: 5,
            isInvincible: true,
            noShow: true,
            noCollision: true,
            deathAnimationSpeed: 0.3,
            spawnModifiers: [
              'slowfield',
            ],
            lifetime: 500,
            attackPrio: 6,
            idleFrames: [
              0,
              1,
              2,
              3,
              2,
              1,
            ],
            summonTime: 16,
            noMoveWhenHit: true,
            power: 2,
          },
          {
            name: 'Shroud Field',
            id_string: 'shroudfield',
            hp: 999999,
            startHp: 0,
            mana: 0,
            startMana: 0,
            hpRegenerationRate: 0 / 20,
            manaRegenerationRate: 0 / 20,
            armor: 0,
            supply: 0,
            supplyProvided: 0,
            movementSpeed: 0 / 20,
            weaponCooldown: 1 * 20,
            weaponDelay: 1 * 20,
            dmg: 10,
            dmgModifierAttributes: [],
            dmgModifierAddition: [],
            dmgModifierMultiplier: [],
            lifesteal: 0,
            armorPenetration: 0,
            percDmg: 0,
            dmgCap: 1,
            bouncePower: 0,
            bounceDistMin: 0,
            bounceDistMax: 0,
            range: 0.2,
            minRange: -999,
            aoeRadius: 0,
            attackPrio: 6,
            size: 0.01,
            imageScale: 1,
            vision: -1,
            repairRate: 0 / 20,
            projectileSpeed: 8,
            projectileLen: 0.2,
            attackLaunchSound: 0,
            circleSize: 0.02,
            circleOffset: 0,
            buildTime: 45 * 20,
            cost: 0,
            healthbarOffset: 0.2,
            healthbarWidth: 0.5,
            selectionOffsetY: 0,
            img: 'shroud',
            description: 'Creates an aura that reduces all units under it to melee range.',
            experienceLevels: [],
            experience: 0,
            modifiersPerLevel: [],
            experienceRange: 9,
            tabPriority: 4,
            drawOffsetY: 46,
            attackEffect: null,
            painSound: 0,
            painSoundVolume: 1,
            painSound2: 0,
            painSoundVolume2: 1,
            deathSound: 0,
            yesSound: 14,
            yesSoundVolume: 0.6,
            readySound: 13,
            readySoundVolume: 0.9,
            bodyPower: 0.8,
            dustCreationChance: -1 / 20,
            visionHeightBonus: 0,
            animSpeed: 6,
            oscillationAmplitude: 0,
            height: 0.3,
            acceleration: 0,
            angularVelocity: 0,
            commands: {},
            cargoUse: -1,
            cargoSpace: 0,
            projectileStartHeight: 0,
            power: 2,
            lifetime: 300,
            goldReward: 0,
            limit: 0,
            modifiers: [],
            modifiersSelf: [],
            spawnModifiers: [
              'raidershroudaura',
            ],
            hoverText: '',
            canHaveWaypoint: false,
            isPassive: false,
            causesFlameDeath: false,
            shootingReveals: false,
            shootWhileMoving: false,
            hitscan: false,
            maximizeRangeWhenShooting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            canAttackGround: true,
            canAttackFlying: false,
            isHeatSeeking: true,
            ignoreEnemyHitscan: false,
            controllable: false,
            hasDetection: false,
            expOnlyFromOwnKills: false,
            alliesGetExperience: false,
            alliesGetGold: false,
            isReflectingProjectiles: false,
            isBlockingProjectiles: false,
            takeDamageOnBlock: false,
            preventsLoss: false,
            flying: true,
            uniqueAndHeroic: false,
            isMechanical: false,
            isUndead: false,
            isBiological: true,
            isBeast: false,
            isHuman: false,
            noShow: false,
            noCollision: true,
            isInvisible: false,
            isInvincible: true,
            spawnWithAMove: false,
          },
          {
            name: 'Caltrop',
            id_string: 'caltrop',
            hp: 12,
            startHp: 0,
            mana: 0,
            startMana: 0,
            hpRegenerationRate: 0 / 20,
            manaRegenerationRate: 0 / 20,
            armor: 4,
            supply: 0,
            supplyProvided: 0,
            movementSpeed: 0 / 20,
            weaponCooldown: 5 * 20,
            weaponDelay: 0 * 20,
            dmg: 0,
            dmgModifierAttributes: [],
            dmgModifierAddition: [],
            dmgModifierMultiplier: [],
            lifesteal: 0,
            armorPenetration: 0,
            percDmg: 0,
            dmgCap: 1,
            bouncePower: 0,
            bounceDistMin: 0,
            bounceDistMax: 0,
            range: 0.3,
            minRange: -999,
            aoeRadius: 0,
            attackPrio: 10,
            size: 1,
            imageScale: 1.0,
            vision: 0.1,
            repairRate: 0 / 20,
            projectileSpeed: 8,
            projectileLen: 0.2,
            attackLaunchSound: 0,
            circleSize: 0.43,
            circleOffset: 0,
            buildTime: 25 * 20,
            cost: 0,
            healthbarOffset: 1.1,
            healthbarWidth: 0.4,
            selectionOffsetY: 0,
            img: 'caltropg',
            description: 'Caltrops snare enemy units that walk over them, slowing them down.',
            experienceLevels: [],
            experience: 0,
            modifiersPerLevel: [],
            experienceRange: 9,
            tabPriority: 4,
            drawOffsetY: 10,
            attackEffect: null,
            painSound: 1,
            painSoundVolume: 0.4,
            painSound2: 55,
            painSoundVolume2: 1,
            deathSound: 2,
            yesSound: 93,
            yesSoundVolume: 0.6,
            readySound: 93,
            readySoundVolume: 0.9,
            bodyPower: 0.8,
            dustCreationChance: 1 / 20,
            visionHeightBonus: 0,
            animSpeed: 1.5,
            oscillationAmplitude: 0,
            height: 0.3,
            acceleration: 0,
            angularVelocity: 0,
            commands: {
              stop: 'stop',
              attack: 'attack',
              amove: 'amove',
            },
            cargoUse: -1,
            cargoSpace: 0,
            projectileStartHeight: 0,
            power: 2,
            lifetime: 0,
            goldReward: 0,
            limit: 0,
            modifiers: [
              'trapped',
            ],
            modifiersSelf: [
              'revealself',
            ],
            spawnModifiers: [],
            hoverText: '',
            canHaveWaypoint: false,
            isPassive: false,
            causesFlameDeath: false,
            shootingReveals: false,
            shootWhileMoving: false,
            hitscan: false,
            maximizeRangeWhenShooting: false,
            hitsFriendly: true,
            hitsEnemy: true,
            canAttackGround: true,
            canAttackFlying: false,
            isHeatSeeking: true,
            ignoreEnemyHitscan: false,
            controllable: false,
            hasDetection: false,
            expOnlyFromOwnKills: false,
            alliesGetExperience: false,
            alliesGetGold: false,
            isReflectingProjectiles: false,
            isBlockingProjectiles: false,
            takeDamageOnBlock: false,
            preventsLoss: false,
            flying: false,
            uniqueAndHeroic: false,
            isMechanical: true,
            isUndead: false,
            isBiological: false,
            isBeast: false,
            isHuman: false,
            noShow: false,
            noCollision: true,
            isInvisible: true,
            isInvincible: false,
            spawnWithAMove: false,
          },
        ];

        var CliffsData = [

          new TileType({
            name: 'North',
            img: { x: 2, y: 418, w: 22, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'West',
            img: { x: 24, y: 418, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'East',
            img: { x: 44, y: 418, w: 16, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'South',
            img: { x: 62, y: 418, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(88, 80, 68)',
          }),

          new TileType({
            name: 'SW',
            img: { x: 85, y: 416, w: 22, h: 42 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'SE',
            img: { x: 110, y: 416, w: 22, h: 42 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'NW',
            img: { x: 135, y: 418, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'NE',
            img: { x: 157, y: 418, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'SW2',
            img: { x: 2, y: 460, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'SE2',
            img: { x: 25, y: 460, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'NW2',
            img: { x: 53, y: 460, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'NE2',
            img: { x: 75, y: 460, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'Universal',
            img: { x: 372, y: 168, w: 22, h: 46 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

        ];

        var GraveCliffData = [

          new TileType({
            name: 'North',
            img: { x: 390 + 380, y: 418, w: 22, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'West',
            img: { x: 409 + 380, y: 413, w: 24, h: 47 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'East',
            img: { x: 434 + 380, y: 413, w: 18, h: 47 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'South',
            img: { x: 453 + 380, y: 418, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(88, 80, 68)',
          }),

          new TileType({
            name: 'SW',
            img: { x: 473 + 380, y: 416, w: 22, h: 42 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'SE',
            img: { x: 496 + 380, y: 416, w: 25, h: 42 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'NW',
            img: { x: 523 + 380, y: 418, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'NE',
            img: { x: 543 + 380, y: 418, w: 24, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'SW2',
            img: { x: 390 + 380, y: 460, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'SE2',
            img: { x: 413 + 380, y: 460, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'NW2',
            img: { x: 439 + 380, y: 460, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'NE2',
            img: { x: 463 + 380, y: 460, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'Universal',
            img: { x: 397 + 380, y: 168, w: 22, h: 46 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

        ];

        var RampTilesGraveData = [

          new TileType({
            name: 'South West',
            img: { x: 582 + 380, y: 422, w: 22, h: 76 },
            sizeX: 1,
            sizeY: 3,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'South East',
            img: { x: 626 + 380, y: 422, w: 24, h: 76 },
            sizeX: 1,
            sizeY: 3,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'South Floor',
            img: { x: 603 + 380, y: 420, w: 16, h: 78 },
            sizeX: 1,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'South Floor 2',
            img: { x: 608 + 380, y: 341, w: 16, h: 78 },
            sizeX: 1,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'South Floor 3',
            img: { x: 625 + 380, y: 341, w: 16, h: 78 },
            sizeX: 1,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'West Top',
            img: { x: 653 + 380, y: 445, w: 54, h: 47 },
            sizeX: 3,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'West Bottom',
            img: { x: 712 + 380, y: 448, w: 52, h: 47 },
            sizeX: 3,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'West Floor',
            img: { x: 655 + 380, y: 393, w: 55, h: 52 },
            sizeX: 3,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'West Floor 2',
            img: { x: 711 + 380, y: 393, w: 55, h: 52 },
            sizeX: 3,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'West Floor 3',
            img: { x: 655 + 380, y: 327, w: 55, h: 52 },
            sizeX: 3,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'East Top',
            img: { x: 730 + 380, y: 275, w: 54, h: 45 },
            sizeX: 3,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'East Bottom',
            img: { x: 673 + 380, y: 279, w: 52, h: 43 },
            sizeX: 3,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'East Floor',
            img: { x: 722 + 380, y: 327, w: 50, h: 53 },
            sizeX: 3,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'East Floor 2',
            img: { x: 672 + 380, y: 221, w: 50, h: 53 },
            sizeX: 3,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'East Floor 3',
            img: { x: 727 + 380, y: 221, w: 50, h: 53 },
            sizeX: 3,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'North Left',
            img: { x: 460 + 380, y: 359, w: 23, h: 51 },
            sizeX: 1,
            sizeY: 3,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'North Right',
            img: { x: 492 + 380, y: 359, w: 21, h: 51 },
            sizeX: 1,
            sizeY: 3,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'North Floor',
            img: { x: 513 + 380, y: 360, w: 16, h: 23 },
            sizeX: 1,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'North Floor 2',
            img: { x: 513 + 380, y: 386, w: 16, h: 23 },
            sizeX: 1,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'North Floor 3',
            img: { x: 530 + 380, y: 386, w: 16, h: 23 },
            sizeX: 1,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

        ];

        var UpgradesData = [
          {
            isUpgrade: true,
            name: 'Research Shroud ',
            id_string: 'raidershroudupgrade',
            buildTime: 72 * 20,
            cost: 100,
            maxLevel: 1,
            description: 'Allows your Raiders to cast Shroud.',
            image: 'soot',
            effectsTypes: [],
            effectsFields: [],
            effectsModifications: [],
            effectsModsMultiplier: [],
            noParallelResearch: false,
          },

          {
            isUpgrade: true,
            name: 'Spoked Wheel',
            id_string: 'spokedwheel_upgrade',
            buildTime: 36 * 20,
            cost: 100,
            maxLevel: 1,
            description: 'Improves the movement speed of the Gatling Gun.',
            image: 'mechSpeedUpg',
            effectsTypes: [
              'gatlinggun',
            ],
            effectsFields: [
              'movementSpeed',
            ],
            effectsModifications: [
              0.15 / 20,
            ],
            effectsModsMultiplier: [
              1,
            ],
            noParallelResearch: false,
          },

          {
            isUpgrade: true,
            name: 'Bird Detection',
            id_string: 'birddetection',
            buildTime: 54 * 20,
            cost: 100,
            maxLevel: 1,
            description: 'Allows your Birds to see invisible units.',
            image: 'eye',
            effectsTypes: [
              'bird',
            ],
            effectsFields: [
              'hasDetection',
            ],
            effectsModifications: [
              1,
            ],
            effectsModsMultiplier: [
              1,
            ],
            noParallelResearch: false,
          },
          {
            isUpgrade: true,
            name: 'Research Sprint',
            id_string: 'sprint_upgrade',
            buildTime: 60 * 20,
            cost: 150,
            maxLevel: 1,
            description: 'Allows your wolves to sprint.',
            image: 'beastSpeedUpg',
            effectsTypes: [],
            effectsFields: [],
            effectsModifications: [],
            effectsModsMultiplier: [],
            noParallelResearch: false,
          },

          {
            name: 'Damage',
            id_string: 'upgattack',
            cost: 150,
            buildTime: 90 * 20,
            maxLevel: 5,
            effectsTypes: [
              'worker',
              'soldier',
              'archer',
              'mage',
              'priest',
              'raider',
              'upgattack',
              'upgattack',
            ],
            effectsFields: [
              'dmg',
              'dmg',
              'dmg',
              'dmg',
              'dmg',
              'dmg',
              'buildTime',
              'cost',
            ],
            effectsModifications: [
              1,
              1,
              1,
              1,
              1,
              3,
              20 * 20,
              50,
            ],
            effectsModsMultiplier: [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
            ],
            description: 'Increases the attack damage of your human units.',
            image: 'attackUpg',
          },

          {
            name: 'Armor',
            id_string: 'upgarmor',
            cost: 150,
            buildTime: 90 * 20,
            maxLevel: 5,
            effectsTypes: [
              'worker',
              'soldier',
              'archer',
              'mage',
              'priest',
              'raider',
              'upgarmor',
              'upgarmor',
            ],
            effectsFields: [
              'armor',
              'armor',
              'armor',
              'armor',
              'armor',
              'armor',
              'buildTime',
              'cost',
            ],
            effectsModifications: [
              1,
              1,
              1,
              1,
              1,
              1,
              20 * 20,
              50,
            ],
            effectsModsMultiplier: [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
            ],
            description: 'Increases the armor of your human units.',
            image: 'armorUpg',
          },

          {
            name: 'Research Fireball',
            id_string: 'upgfireball',
            cost: 100,
            buildTime: 80 * 20,
            maxLevel: 1,
            description: 'Allows your Mages to cast Fireball.',
            isUpgrade: true,
            effectsTypes: [],
            effectsFields: [],
            effectsModifications: [],
            effectsModsMultiplier: [],
            image: 'flamestrike',
          },

          {
            name: 'Research Heal',
            id_string: 'upgheal',
            cost: 100,
            buildTime: 72 * 20,
            maxLevel: 1,
            description: 'Allows your Priests to cast Heal.',
            effectsTypes: [
              'upginvis',
              'upghealingward',
            ],
            effectsFields: [
              'cost',
              'cost',
            ],
            effectsModifications: [
              200,
              200,
            ],
            effectsModsMultiplier: [
              1,
              1,
            ],
            image: 'heal',
          },

          {
            name: 'Beast Attack',
            id_string: 'upgbeastattack',
            cost: 150,
            buildTime: 90 * 20,
            maxLevel: 5,
            effectsTypes: [
              'dragon',
              'wolf',
              'werewolf',
              'snake',
              'bird',
              'upgbeastattack',
              'upgbeastattack',
            ],
            effectsFields: [
              'dmg',
              'dmg',
              'dmg',
              'dmg',
              'dmg',
              'buildTime',
              'cost',
            ],
            effectsModifications: [
              1,
              1,
              2,
              1,
              0,
              20 * 20,
              50,
            ],
            effectsModsMultiplier: [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
            ],
            description: 'Increases the attack damage of your beast units.',
            image: 'dragonAttUpg',
          },

          {
            name: 'Beast Defense',
            id_string: 'upgbeastdefense',
            cost: 150,
            buildTime: 90 * 20,
            maxLevel: 5,
            effectsTypes: [
              'dragon',
              'wolf',
              'werewolf',
              'snake',
              'bird',
              'upgbeastdefense',
              'upgbeastdefense',
            ],
            effectsFields: [
              'armor',
              'armor',
              'armor',
              'armor',
              'armor',
              'buildTime',
              'cost',
            ],
            effectsModifications: [
              1,
              1,
              1,
              1,
              1,
              20 * 20,
              50,
            ],
            effectsModsMultiplier: [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
            ],
            description: 'Increases the armor of your beast units.',
            image: 'dragonDefUpg',
          },

          {
            name: 'Tower Upgrade',
            id_string: 'upgtower',
            cost: 225,
            buildTime: 54 * 20,
            maxLevel: 1,
            effectsTypes: [
              'watchtower',
              'watchtower',
              'watchtower',
              'watchtower2',
              'watchtower2',
              'watchtower2',
            ],
            effectsFields: [
              'armor',
              'dmg',
              'range',
              'armor',
              'dmg',
              'range',
            ],
            effectsModifications: [
              2,
              2,
              1,
              2,
              2,
              1,
            ],
            effectsModsMultiplier: [
              1,
              1,
              1,
              1,
              1,
              1,
            ],
            description: 'Increases the armor, damage and range of your towers.',
            image: 'towerUpg',
          },

          {
            name: 'Speed',
            id_string: 'upgspeed',
            cost: 140,
            buildTime: 90 * 20,
            maxLevel: 5,
            effectsTypes: [
              'soldier',
              'archer',
              'mage',
              'priest',
              'upgspeed',
              'upgspeed',
            ],
            effectsFields: [
              'movementSpeed',
              'movementSpeed',
              'movementSpeed',
              'movementSpeed',
              'buildTime',
              'cost',
              'buildTime',
              'cost',
              'buildTime',
              'cost',
              'buildTime',
              'cost',
            ],
            effectsModifications: [
              0.25 / 20,
              0.25 / 20,
              0.2 / 20,
              0.2 / 20,
              20 * 20,
              60,
              20 * 20,
              60,
              20 * 20,
              60,
              20 * 20,
              60,
            ],
            effectsModsMultiplier: [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
            ],
            description: 'Increases the movement speed of your human units.',
            image: 'speedUpg',
          },

          {
            name: 'Beast Speed',
            id_string: 'upgbeastspeed',
            cost: 140,
            buildTime: 90 * 20,
            maxLevel: 5,
            effectsTypes: [
              'dragon',
              'wolf',
              'werewolf',
              'upgbeastspeed',
              'upgbeastspeed',
            ],
            effectsFields: [
              'movementSpeed',
              'movementSpeed',
              'movementSpeed',
              'buildTime',
              'cost',
              'buildTime',
              'cost',
              'buildTime',
              'cost',
              'buildTime',
              'cost',
            ],
            effectsModifications: [
              0.3 / 20,
              0.3 / 20,
              0.25 / 20,
              20 * 20,
              60,
              20 * 20,
              60,
              20 * 20,
              60,
              20 * 20,
              60,
            ],
            effectsModsMultiplier: [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
            ],
            description: 'Increases the movement speed of your beast units.',
            image: 'beastSpeedUpg',
          },

          {
            name: 'Mech Attack',
            id_string: 'upgmechattack',
            cost: 150,
            buildTime: 90 * 20,
            maxLevel: 5,
            effectsTypes: [
              'catapult',
              'ballista',
              'gatlinggun',
              'gyrocraft',
              'upgmechattack',
              'upgmechattack',
            ],
            effectsFields: [
              'dmg',
              'dmg',
              'dmg',
              'dmg',
              'buildTime',
              'cost',
            ],
            effectsModifications: [
              3,
              3,
              2,
              1.5,
              20 * 20,
              50,
            ],
            effectsModsMultiplier: [
              1,
              1,
              1,
              1,
              1,
              1,
            ],
            description: 'Increases the attack damage of your mechanical units.',
            image: 'mechAttUpg',
          },

          {
            name: 'Mech Defense',
            id_string: 'upgmechdefense',
            cost: 150,
            buildTime: 90 * 20,
            maxLevel: 5,
            effectsTypes: [
              'catapult',
              'ballista',
              'gatlinggun',
              'gyrocraft',
              'airship',
              'upgmechdefense',
              'upgmechdefense',
            ],
            effectsFields: [
              'armor',
              'armor',
              'armor',
              'armor',
              'armor',
              'buildTime',
              'cost',
            ],
            effectsModifications: [
              1,
              1.5,
              1,
              1,
              1,
              20 * 20,
              50,
            ],
            effectsModsMultiplier: [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
            ],
            description: 'Increases the armor of your mechanical units.',
            image: 'mechDefUpg',
          },

          {
            name: 'Mech Speed',
            id_string: 'upgmechspeed',
            cost: 125,
            buildTime: 90 * 20,
            maxLevel: 5,
            effectsTypes: [
              'catapult',
              'airship',
              'ballista',
              'upgmechspeed',
              'upgmechspeed',
            ],
            effectsFields: [
              'movementSpeed',
              'movementSpeed',
              'movementSpeed',
              'buildTime',
              'cost',
              'buildTime',
              'cost',
              'buildTime',
              'cost',
              'buildTime',
              'cost',
            ],
            effectsModifications: [
              0.15 / 20,
              0.25 / 20,
              0.15 / 20,
              20 * 20,
              50,
              20 * 20,
              50,
              20 * 20,
              50,
              20 * 20,
              50,
            ],
            effectsModsMultiplier: [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
            ],
            description: 'Increases the movement speed of your mechanical units.',
            image: 'mechSpeedUpg',
          },

          {
            name: 'Ballista Black Powder',
            id_string: 'upgballistaexplosives',
            cost: 100,
            buildTime: 45 * 20,
            maxLevel: 1,
            effectsTypes: [
              'ballista',
            ],
            effectsFields: [
              'aoeRadius',
            ],
            effectsModifications: [
              0.3,
            ],
            effectsModsMultiplier: [
              1,
            ],
            description: 'Adds splash damage to the default Ballista attack and gives them a powerful anti-air ability.',
            image: 'flakUpg',
          },

          {
            name: 'Research Shockwave',
            id_string: 'upgshockwave',
            cost: 100,
            buildTime: 90 * 20,
            maxLevel: 1,
            description: 'Allows your Mages to cast Shockwave.',
            effectsTypes: [
              'upgheal',
              'upgfireball',
            ],
            effectsFields: [
              'cost',
              'cost',
            ],
            effectsModifications: [
              200,
              200,
            ],
            effectsModsMultiplier: [
              1,
              1,
            ],
            image: 'shockwave',
          },

          {
            name: 'Mech Range',
            id_string: 'upgmechrange',
            cost: 125,
            buildTime: 90 * 20,
            maxLevel: 5,
            effectsTypes: [
              'catapult',
              'ballista',
              'upgmechrange',
              'upgmechrange',
            ],
            effectsFields: [
              'range',
              'range',
              'buildTime',
              'cost',
              'buildTime',
              'cost',
              'buildTime',
              'cost',
              'buildTime',
              'cost',
            ],
            effectsModifications: [
              1,
              1,
              20 * 20,
              50,
              20 * 20,
              50,
              20 * 20,
              50,
              20 * 20,
              50,
            ],
            effectsModsMultiplier: [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
            ],
            description: 'Increases the range of your ranged mechanical units. Has no influence on melee units.',
            image: 'mechRangeUpg',
          },

          {
            name: 'Archer Range',
            id_string: 'upgrange',
            cost: 140,
            buildTime: 90 * 20,
            maxLevel: 1,
            effectsTypes: [
              'archer',
            ],
            effectsFields: [
              'range',
            ],
            effectsModifications: [
              1,
            ],
            effectsModsMultiplier: [
              1,
            ],
            description: 'Increases the range of your archers.',
            image: 'rangeUpg',
          },

          {
            name: 'Beast Range',
            id_string: 'upgbeastrange',
            cost: 140,
            buildTime: 90 * 20,
            maxLevel: 5,
            effectsTypes: [
              'dragon',
              'upgbeastrange',
              'upgbeastrange',
            ],
            effectsFields: [
              'range',
              'buildTime',
              'cost',
              'buildTime',
              'cost',
              'buildTime',
              'cost',
              'buildTime',
              'cost',
            ],
            effectsModifications: [
              1,
              20 * 20,
              60,
              20 * 20,
              60,
              20 * 20,
              60,
              20 * 20,
              60,
            ],
            effectsModsMultiplier: [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
            ],
            description: 'Increases the range of your ranged beast units. Has no influence on melee units.',
            image: 'beastRangeUpg',
          },

          {
            name: 'Research Invisibility',
            id_string: 'upginvis',
            cost: 200,
            buildTime: 60 * 20,
            maxLevel: 1,
            description: 'Allows your Priests to cast Invisibility.',
            effectsTypes: [
              'upgheal',
              'upghealingward',
            ],
            effectsFields: [
              'cost',
              'cost',
            ],
            effectsModifications: [
              200,
              200,
            ],
            effectsModsMultiplier: [
              1,
              1,
            ],
            image: 'invisibility',
          },

          {
            name: 'Research Summon Skeleton',
            id_string: 'upgskeleton',
            cost: 100,
            buildTime: 72 * 20,
            maxLevel: 1,
            description: 'Allows your Mages to summon skeletons.',
            effectsTypes: [
              'upgslowfield',
              'upgfireball',
            ],
            effectsFields: [
              'cost',
              'cost',
            ],
            effectsModifications: [
              200,
              200,
            ],
            effectsModsMultiplier: [
              1,
              1,
            ],
            image: 'skeleton',
          },

          {
            name: 'Research Summon Healing Ward',
            id_string: 'upghealingward',
            cost: 100,
            buildTime: 72 * 20,
            maxLevel: 1,
            description: 'Allows your Priests to summon a Healing Ward.',
            effectsTypes: [
              'upgheal',
              'upginvis',
            ],
            effectsFields: [
              'cost',
              'cost',
            ],
            effectsModifications: [
              200,
              200,
            ],
            effectsModsMultiplier: [
              1,
              1,
            ],
            image: 'heal',
          },

          {
            name: 'Research Slow Field',
            id_string: 'upgslowfield',
            cost: 100,
            buildTime: 72 * 20,
            maxLevel: 1,
            description: 'Allows your Mages to create a Slow Field.',
            effectsTypes: [
              'upgfireball',
              'upgskeleton',
            ],
            effectsFields: [
              'cost',
              'cost',
            ],
            effectsModifications: [
              200,
              200,
            ],
            effectsModsMultiplier: [
              1,
              1,
            ],
            image: 'slowfield',
          },

          {
            name: 'Airship Telescope Extension',
            id_string: 'upgtelescope',
            cost: 100,
            buildTime: 54 * 20,
            maxLevel: 1,
            description: 'Allows your Airships to see invisible units.',
            effectsTypes: [
              'airship',
            ],
            effectsFields: [
              'hasDetection',
            ],
            effectsModifications: [
              1,
            ],
            effectsModsMultiplier: [
              1,
            ],
            image: 'telescope',
          },
        ];

        var CliffsEgyptData = [

          new TileType({
            name: 'North',
            img: { x: 390, y: 418, w: 22, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'West',
            img: { x: 411, y: 413, w: 22, h: 47 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'East',
            img: { x: 433, y: 413, w: 16, h: 47 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'South',
            img: { x: 450, y: 418, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(88, 80, 68)',
          }),

          new TileType({
            name: 'SW',
            img: { x: 473, y: 416, w: 22, h: 42 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'SE',
            img: { x: 498, y: 416, w: 22, h: 42 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'NW',
            img: { x: 523, y: 418, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'NE',
            img: { x: 544, y: 418, w: 22, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'SW2',
            img: { x: 390, y: 460, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'SE2',
            img: { x: 413, y: 460, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'NW2',
            img: { x: 439, y: 460, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'NE2',
            img: { x: 463, y: 460, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

          new TileType({
            name: 'Universal',
            img: { x: 397, y: 168, w: 22, h: 46 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            minimap_color: 'rgb(72, 60, 56)',
          }),

        ];

        var Modifiers = [

          {
            name: 'InvisibilityBuff',
            id_string: 'invisibility',
            image: 'invisibility',
            description: 'This unit is invisible#BRLasts getField(invisibility.duration) sec',
            duration: 40 * 20,
            fields: ['isInvisible', 'dmg'],
            modifications: [1, 2],
            modificationsMultiplier: [1, 1],
          },

          {
            name: 'dmgBuff',
            id_string: 'dmgbuff',
            image: 'attackUpg',
            description: 'This unit gets a dmg buff#BRLasts getField(dmgbuff.duration) sec',
            duration: 20 * 20,
            fields: ['dmg'],
            modifications: [5],
            modificationsMultiplier: [1],
          },

          {
            name: 'Healed',
            id_string: 'healed',
            image: 'heal',
            description: 'This unit is getting healed',
            duration: 2 * 20,
            fields: ['hpRegenerationRate'],
            modifications: [5 / 20],
            modificationsMultiplier: [1],
          },

          {
            name: 'Damaged',
            id_string: 'healeddmg',
            image: 'skeleton',
            description: 'This unit is getting damaged',
            duration: 2 * 20,
            fields: ['hpRegenerationRate'],
            modifications: [-4 / 20],
            modificationsMultiplier: [1],
          },

          {
            name: 'Heal Aura',
            id_string: 'healaura',
            description: 'Heals nearby alled non-undead units',
            duration: 0,
            auraModifiers: ['healed'],
            auraRange: [1.8],
            auraTargetFilters: ['isBiological'],
            auraTargetFiltersExclude: ['isUndead'],
            auraHitsFriendly: true,
            auraHitsEnemy: false,
            auraHitsSelf: false,
            effects: ['aura'],
            auraColor: { red: 150, green: 250, blue: 180, alpha: 0.2 },
            sound: SOUND.AURA_HEAL,
            volume: 0.2,
          },

          {
            name: 'Heal Aura Dmg',
            id_string: 'healauradmg',
            description: 'Heals nearby enemy undead units',
            duration: 0,
            auraModifiers: ['healeddmg'],
            auraHitsFriendly: false,
            auraHitsEnemy: true,
            auraHitsSelf: false,
            auraRange: [3],
            auraTargetFilters: ['isBiological', 'isUndead'],
          },

          {
            name: 'Slow Field',
            id_string: 'slowfield',
            description: 'Slows nearby enemy units.',
            duration: 0,
            auraModifiers: ['slowed'],
            auraHitsFriendly: false,
            auraHitsEnemy: true,
            effects: ['aura'],
            auraColor: { red: 70, green: 100, blue: 190, alpha: 0.2 },
            particleMode: 2,
            density: 40,
            auraRange: [4.0],
          },

          {
            name: 'Slowed',
            id_string: 'slowed',
            image: 'slowfield',
            description: 'This unit is getting slowed',
            duration: 1.1 * 20,
            fields: ['movementSpeed'],
            modifications: [0],
            modificationsMultiplier: [0.5],
          },

          {
            name: 'Slowed',
            id_string: 'slowed25',
            image: 'slowfield',
            description: 'This unit is getting slowed by 25%',
            duration: 1.1 * 20,
            fields: ['movementSpeed'],
            modifications: [0],
            modificationsMultiplier: [0.75],
          },

          {
            'isModifier': true,
            'name': 'Raider Fix',
            'id_string': 'raiderfix',
            'description': 'This unit is invisible#BRLasts getField(invisibility.duration) sec',
            'image': null,
            'duration': -20,
            'fields': [
              'weaponCooldown',
            ],
            'modifications': [
              -55.599999999999994,
            ],
            'modificationsMultiplier': [
              1,
            ],
            'maxStack': 1,
            'auraModifiers': [],
            'auraRange': [],
            'auraHitsFriendly': true,
            'auraHitsAllied': true,
            'auraHitsEnemy': true,
            'auraHitsSelf': true,
            'auraTargetFilters': [],
            'auraTargetFiltersExclude': [],
            'disabledCommands': [],
            'changeUnitImg': false,
            'unitImg': null,
            'changeAttackEffect': false,
            'attackEffect': null,
            'effects': [],
            'sound': 0,
            'volume': 1,
            'killModifiers': [],
          },
          {
            'isModifier': true,
            'name': 'Raider Flash',
            'id_string': 'raiderflashmana',
            'description': 'Flash mana cost',
            'image': 'raider',
            'duration': 2,
            'fields': [
              'manaRegenerationRate',
            ],
            'modifications': [
              -24.440625,
            ],
            'modificationsMultiplier': [
              1,
            ],
            'maxStack': 1,
            'auraModifiers': [],
            'auraRange': [],
            'auraHitsFriendly': true,
            'auraHitsAllied': true,
            'auraHitsEnemy': true,
            'auraHitsSelf': true,
            'auraTargetFilters': [],
            'auraTargetFiltersExclude': [],
            'disabledCommands': [],
            'changeUnitImg': false,
            'unitImg': null,
            'changeAttackEffect': false,
            'attackEffect': null,
            'effects': [],
            'sound': 0,
            'volume': 1,
            'killModifiers': [],
          },
          {
            'isModifier': true,
            'name': 'Rallied',
            'id_string': 'rallied',
            'description': 'This unit has been Rallied; it has increased speed and armor.',
            'image': 'shockwave',
            'duration': 160,
            'fields': [
              'movementSpeed',
              'armor',
              'imageScale',
            ],
            'modifications': [
              0.025,
              2,
              0,
            ],
            'modificationsMultiplier': [
              1,
              1,
              1.3,
            ],
            'maxStack': 1,
            'auraModifiers': [],
            'auraRange': [],
            'auraHitsFriendly': true,
            'auraHitsAllied': true,
            'auraHitsEnemy': true,
            'auraHitsSelf': true,
            'auraTargetFilters': [],
            'auraTargetFiltersExclude': [],
            'disabledCommands': [],
            'changeUnitImg': false,
            'unitImg': null,
            'changeAttackEffect': false,
            'attackEffect': null,
            'effects': [],
            'sound': 0,
            'volume': 1,
            'killModifiers': [],
          },
          {
            'isModifier': true,
            'name': 'Trapped',
            'id_string': 'trapped',
            'description': 'This units foot is severly injured',
            'image': 'heal',
            'duration': 5 * 20,
            'fields': [
              'movementSpeed',
            ],
            'modifications': [
              0,
            ],
            'modificationsMultiplier': [
              0.1,
            ],
            'maxStack': 1,
            'auraModifiers': [],
            'auraRange': [],
            'auraHitsFriendly': false,
            'auraHitsAllied': true,
            'auraHitsEnemy': true,
            'auraHitsSelf': true,
            'auraTargetFilters': [],
            'auraTargetFiltersExclude': [],
            'disabledCommands': [],
            'changeUnitImg': false,
            'unitImg': null,
            'changeAttackEffect': false,
            'attackEffect': null,
            'effects': [],
            'sound': 0,
            'volume': 1,
            'killModifiers': [],
          },
          {
            'isModifier': true,
            'name': 'Reveal Self',
            'id_string': 'revealself',
            'description': 'This units foot is severly injured',
            'image': null,
            'duration': 40,
            'fields': [
              'isInvisible',
              'hpRegenerationRate',
              'isInvincible',
            ],
            'modifications': [
              -1,
              -0.4,
              1,
            ],
            'modificationsMultiplier': [
              1,
              1,
              1,
            ],
            'maxStack': 1,
            'auraModifiers': [],
            'auraRange': [],
            'auraHitsFriendly': false,
            'auraHitsAllied': true,
            'auraHitsEnemy': true,
            'auraHitsSelf': true,
            'auraTargetFilters': [],
            'auraTargetFiltersExclude': [],
            'disabledCommands': [],
            'changeUnitImg': false,
            'unitImg': null,
            'changeAttackEffect': false,
            'attackEffect': null,
            'effects': [],
            'sound': 0,
            'volume': 1,
            'killModifiers': [],
          },
          {
            'isModifier': true,
            'name': 'Kill Flash',
            'id_string': 'killflash',
            'description': 'Raider cant attack',
            'image': null,
            'duration': 57,
            'fields': [
              'weaponCooldown',
            ],
            'modifications': [
              55.99999999999999,
            ],
            'modificationsMultiplier': [
              1,
            ],
            'maxStack': 1,
            'auraModifiers': [],
            'auraRange': [],
            'auraHitsFriendly': true,
            'auraHitsAllied': true,
            'auraHitsEnemy': true,
            'auraHitsSelf': true,
            'auraTargetFilters': [],
            'auraTargetFiltersExclude': [],
            'disabledCommands': [],
            'changeUnitImg': false,
            'unitImg': null,
            'changeAttackEffect': false,
            'attackEffect': null,
            'effects': [],
            'sound': 0,
            'volume': 1,
            'killModifiers': [
              'raiderflashmana',
            ],
          },
          {
            'isModifier': true,
            'name': 'speedBuff',
            'id_string': 'speedbuff',
            'description': 'This unit gets a speed buff#BRLasts getField(dmgbuff.duration) sec',
            'image': 'beastSpeedUpg',
            'duration': 8 * 20,
            'fields': [
              'movementSpeed',
            ],
            'modifications': [
              0.05,
            ],
            'modificationsMultiplier': [
              1,
            ],
            'maxStack': 1,
            'auraModifiers': [],
            'auraRange': [],
            'auraHitsFriendly': true,
            'auraHitsAllied': true,
            'auraHitsEnemy': true,
            'auraHitsSelf': true,
            'auraTargetFilters': [],
            'auraTargetFiltersExclude': [],
            'disabledCommands': [],
            'changeUnitImg': false,
            'unitImg': null,
            'changeAttackEffect': false,
            'attackEffect': null,
            'effects': [],
            'sound': 0,
            'volume': 1,
            'killModifiers': [],
          },
          {
            'isModifier': true,
            'name': 'speedDebuff',
            'id_string': 'speeddebuff',
            'description': 'This unit gets a speed decreasef#BRLasts getField(dmgbuff.duration) sec',
            'image': null,
            'duration': 13 * 20,
            'fields': [
              'movementSpeed',
            ],
            'modifications': [
              -0.017499999999999998,
            ],
            'modificationsMultiplier': [
              1,
            ],
            'maxStack': 1,
            'auraModifiers': [],
            'auraRange': [],
            'auraHitsFriendly': true,
            'auraHitsAllied': true,
            'auraHitsEnemy': true,
            'auraHitsSelf': true,
            'auraTargetFilters': [],
            'auraTargetFiltersExclude': [],
            'disabledCommands': [],
            'changeUnitImg': false,
            'unitImg': null,
            'changeAttackEffect': false,
            'attackEffect': null,
            'effects': [],
            'sound': 0,
            'volume': 1,
            'killModifiers': [],
          },
          {
            'isModifier': true,
            'name': 'Shrouded',
            'id_string': 'raidershrouded',
            'description': 'This unit is under a Shroud, and has reduced range.',
            'image': 'shroud',
            'duration': 22,
            'fields': [
              'range',
            ],
            'modifications': [
              0.2,
            ],
            'modificationsMultiplier': [
              0,
            ],
            'maxStack': 1,
            'auraModifiers': [],
            'auraRange': [],
            'auraHitsFriendly': true,
            'auraHitsAllied': true,
            'auraHitsEnemy': true,
            'auraHitsSelf': true,
            'auraTargetFilters': [],
            'auraTargetFiltersExclude': [],
            'disabledCommands': [],
            'changeUnitImg': false,
            'unitImg': null,
            'changeAttackEffect': false,
            'attackEffect': null,
            'effects': [],
            'sound': 0,
            'volume': 1,
            'killModifiers': [],
          },
          {
            'isModifier': true,
            'name': 'Shroud Aura',
            'id_string': 'raidershroudaura',
            'description': 'Shrouds nearby units.',
            'image': null,
            'duration': 0,
            'fields': [],
            'modifications': [],
            'modificationsMultiplier': [],
            'maxStack': 1,
            'auraModifiers': [
              'raidershrouded',
            ],
            'auraRange': [
              2,
            ],
            'auraHitsFriendly': true,
            'auraHitsAllied': true,
            'auraHitsEnemy': true,
            'auraHitsSelf': true,
            'auraTargetFilters': [],
            'auraTargetFiltersExclude': [
              'isMechanical',
            ],
            'disabledCommands': [],
            'changeUnitImg': false,
            'unitImg': null,
            'changeAttackEffect': false,
            'attackEffect': null,
            'effects': [],
            'sound': 0,
            'volume': 1,
            'killModifiers': [],
          },
          {
            'isModifier': true,
            'name': 'Speed Buff Gatling',
            'id_string': 'speedbuffgat',
            'description': 'This unit gets a speed buff#BRLasts getField(dmgbuff.duration) sec',
            'image': 'mechSpeedUpg',
            'duration': 30,
            'fields': [
              'movementSpeed',
            ],
            'modifications': [
              0.0425,
            ],
            'modificationsMultiplier': [
              1,
            ],
            'maxStack': 1,
            'auraModifiers': [],
            'auraRange': [],
            'auraHitsFriendly': true,
            'auraHitsAllied': true,
            'auraHitsEnemy': true,
            'auraHitsSelf': true,
            'auraTargetFilters': [],
            'auraTargetFiltersExclude': [],
            'disabledCommands': [],
            'changeUnitImg': false,
            'unitImg': null,
            'changeAttackEffect': false,
            'attackEffect': null,
            'effects': [],
            'sound': 0,
            'volume': 1,
            'killModifiers': [],
          },
        ];

        var RampTileData = [

          new TileType({
            name: 'South West',
            img: { x: 194, y: 422, w: 22, h: 76 },
            sizeX: 1,
            sizeY: 3,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'South East',
            img: { x: 238, y: 422, w: 24, h: 76 },
            sizeX: 1,
            sizeY: 3,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'South Floor',
            img: { x: 217, y: 420, w: 16, h: 78 },
            sizeX: 1,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'South Floor 2',
            img: { x: 220, y: 341, w: 16, h: 78 },
            sizeX: 1,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'South Floor 3',
            img: { x: 237, y: 341, w: 16, h: 78 },
            sizeX: 1,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'West Top',
            img: { x: 265, y: 445, w: 54, h: 47 },
            sizeX: 3,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'West Bottom',
            img: { x: 324, y: 448, w: 52, h: 46 },
            sizeX: 3,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'West Floor',
            img: { x: 267, y: 393, w: 55, h: 52 },
            sizeX: 3,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'West Floor 2',
            img: { x: 323, y: 393, w: 55, h: 52 },
            sizeX: 3,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'West Floor 3',
            img: { x: 267, y: 327, w: 55, h: 52 },
            sizeX: 3,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'East Top',
            img: { x: 342, y: 275, w: 54, h: 45 },
            sizeX: 3,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'East Bottom',
            img: { x: 285, y: 279, w: 52, h: 43 },
            sizeX: 3,
            sizeY: 1,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'East Floor',
            img: { x: 334, y: 327, w: 50, h: 53 },
            sizeX: 3,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'East Floor 2',
            img: { x: 284, y: 221, w: 50, h: 53 },
            sizeX: 3,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'East Floor 3',
            img: { x: 339, y: 221, w: 50, h: 53 },
            sizeX: 3,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'North Left',
            img: { x: 72, y: 359, w: 23, h: 51 },
            sizeX: 1,
            sizeY: 3,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'North Right',
            img: { x: 104, y: 359, w: 23, h: 51 },
            sizeX: 1,
            sizeY: 3,
            blocking: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'North Floor',
            img: { x: 127, y: 360, w: 16, h: 23 },
            sizeX: 1,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'North Floor 2',
            img: { x: 127, y: 386, w: 16, h: 23 },
            sizeX: 1,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

          new TileType({
            name: 'North Floor 3',
            img: { x: 144, y: 386, w: 16, h: 23 },
            sizeX: 1,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
            isCliff: true,
            isRamp: true,
          }),

        ];

        var CliffsWinterData = [

          new TileType({
            name: 'North',
            img: { x: 2, y: 418, w: 22, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
          }),

          new TileType({
            name: 'West',
            img: { x: 24, y: 418, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
          }),

          new TileType({
            name: 'East',
            img: { x: 44, y: 418, w: 16, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
          }),

          new TileType({
            name: 'South',
            img: { x: 98, y: 460, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
          }),

          new TileType({
            name: 'SW',
            img: { x: 85, y: 416, w: 22, h: 42 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
          }),

          new TileType({
            name: 'SE',
            img: { x: 110, y: 416, w: 22, h: 42 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
          }),

          new TileType({
            name: 'NW',
            img: { x: 162, y: 456, w: 16, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
          }),

          new TileType({
            name: 'NE',
            img: { x: 180, y: 456, w: 16, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
          }),

          new TileType({
            name: 'SW2',
            img: { x: 2, y: 460, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
          }),

          new TileType({
            name: 'SE2',
            img: { x: 25, y: 460, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
          }),

          new TileType({
            name: 'NW2',
            img: { x: 120, y: 460, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
          }),

          new TileType({
            name: 'NE2',
            img: { x: 142, y: 460, w: 20, h: 40 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
          }),

          new TileType({
            name: 'Universal',
            img: { x: 347, y: 168, w: 22, h: 46 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            isCliff: true,
          }),

        ];

        var TileTypes = [

          new TileType({
            name: 'Tree 1',
            img: { x: 164, y: 41, w: 28, h: 50 },
            sizeX: 1,
            sizeY: 1,
            isTree: true,
            blocking: true,
          }),

          new TileType({
            name: 'Tree 2',
            img: { x: 0, y: 91, w: 28, h: 50 },
            sizeX: 1,
            sizeY: 1,
            isTree: true,
            blocking: true,
          }),

          new TileType({
            name: 'Tree 3',
            img: { x: 68, y: 91, w: 28, h: 50 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
          }),

          new TileType({
            name: 'Tree 4',
            img: { x: 136, y: 91, w: 28, h: 50 },
            sizeX: 1,
            sizeY: 1,
            isTree: true,
            blocking: true,
          }),

          new TileType({
            name: 'Tree 5',
            img: { x: 108, y: 207, w: 17, h: 30 },
            sizeX: 1,
            sizeY: 1,
            isTree: true,
            blocking: true,
          }),

          new TileType({
            name: 'Tree 6',
            img: { x: 132, y: 188, w: 38, h: 50 },
            sizeX: 2,
            sizeY: 2,
            isTree: true,
            blocking: true,
          }),

          new TileType({
            name: 'Tree 7',
            img: { x: 174, y: 188, w: 35, h: 50 },
            sizeX: 2,
            sizeY: 2,
            isTree: true,
            blocking: true,
          }),

          new TileType({
            name: 'Tree 8',
            img: { x: 188, y: 244, w: 64, h: 64 },
            sizeX: 3,
            sizeY: 3,
            isTree: true,
            blocking: true,
          }),

          new TileType({
            name: 'Tree 9',
            img: { x: 3, y: 300, w: 42, h: 50 },
            sizeX: 2,
            sizeY: 2,
            isTree: true,
            blocking: true,
          }),

          new TileType({
            name: 'Tree 10',
            img: { x: 39, y: 248, w: 52, h: 50 },
            sizeX: 2,
            sizeY: 2,
            isTree: true,
            blocking: true,
          }),

          new TileType({
            name: 'Tree 11',
            img: { x: 48, y: 301, w: 52, h: 45 },
            sizeX: 2,
            sizeY: 2,
            blocking: true,
          }),

          new TileType({
            name: 'Tree 12',
            img: { x: 105, y: 303, w: 42, h: 50 },
            sizeX: 2,
            sizeY: 2,
            isTree: true,
            blocking: true,
          }),

          new TileType({
            name: 'Tree 13',
            img: { x: 150, y: 313, w: 66, h: 65 },
            sizeX: 3,
            sizeY: 3,
            isTree: true,
            blocking: true,
          }),

          new TileType({
            name: 'Cactus',
            img: { x: 284, y: 27, w: 18, h: 26 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
          }),

          new TileType({
            name: 'Cactus 2',
            img: { x: 284, y: 55, w: 18, h: 26 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
          }),

          new TileType({
            name: 'Cactus 3',
            img: { x: 362, y: 119, w: 37, h: 45 },
            sizeX: 2,
            sizeY: 2,
            blocking: true,
          }),

          new TileType({
            name: 'Grave Stone 1',
            img: { x: 795, y: 275, w: 20, h: 30 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            noRandomOffset: true,
          }),

          new TileType({
            name: 'Grave Stone 2',
            img: { x: 817, y: 276, w: 20, h: 29 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            noRandomOffset: true,
          }),

          new TileType({
            name: 'Grave Stone 3',
            img: { x: 839, y: 276, w: 20, h: 29 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            noRandomOffset: true,
          }),

          new TileType({
            name: 'Grave Stone 4',
            img: { x: 861, y: 286, w: 18, h: 19 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            noRandomOffset: true,
          }),

          new TileType({
            name: 'Grave Stone 5',
            img: { x: 787, y: 306, w: 54, h: 45 },
            sizeX: 3,
            sizeY: 1,
            blocking: true,
            noRandomOffset: true,
          }),

          new TileType({
            name: 'Grave Stone 6',
            img: { x: 843, y: 322, w: 68, h: 29 },
            sizeX: 4,
            sizeY: 1,
            blocking: true,
            noRandomOffset: true,
          }),

          new TileType({
            name: 'Grave Stone 7',
            img: { x: 916, y: 317, w: 38, h: 59 },
            sizeX: 2,
            sizeY: 1,
            blocking: true,
            noRandomOffset: true,
          }),

          new TileType({
            name: 'Egypt Tile 1',
            img: { x: 251, y: 25, w: 28, h: 56 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
          }),

          new TileType({
            name: 'Palm',
            img: { x: 306, y: 23, w: 57, h: 71 },
            sizeX: 1,
            sizeY: 1,
            isTree: true,
            blocking: true,
          }),

          new TileType({
            name: 'Tree 14',
            img: { x: 45, y: 348, w: 26, h: 25 },
            sizeX: 1,
            sizeY: 1,
            isTree: true,
            blocking: true,
          }),

          new TileType({
            name: 'Tree 15',
            img: { x: 491, y: 58, w: 23, h: 60 },
            sizeX: 1,
            sizeY: 1,
            isTree: true,
            blocking: true,
          }),

          new TileType({
            name: 'Stone 1',
            img: { x: 0, y: 35, w: 28, h: 50 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
          }),

          new TileType({
            name: 'Stone 2',
            img: { x: 28, y: 32, w: 40, h: 60 },
            sizeX: 2,
            sizeY: 2,
            blocking: true,
          }),

          new TileType({
            name: 'Stone 3',
            img: { x: 68, y: 35, w: 28, h: 50 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
          }),

          new TileType({
            name: 'Stone 4',
            img: { x: 96, y: 35, w: 40, h: 60 },
            sizeX: 2,
            sizeY: 2,
            blocking: true,
          }),

          new TileType({
            name: 'Stone 5',
            img: { x: 136, y: 32, w: 28, h: 50 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
          }),

          new TileType({
            name: 'Stone 10',
            img: { x: 44, y: 376, w: 18, h: 20 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
          }),

          new TileType({
            name: 'Stone 16',
            img: { x: 94, y: 252, w: 36, h: 45 },
            sizeX: 2,
            sizeY: 2,
            blocking: true,
          }),

          new TileType({
            name: 'Stone 17',
            img: { x: 130, y: 252, w: 40, h: 45 },
            sizeX: 2,
            sizeY: 2,
            blocking: true,
          }),

          new TileType({
            name: 'Stone 18',
            img: { x: 567, y: 50, w: 26, h: 31 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
          }),

          new TileType({
            name: 'Wall',
            img: { x: 192, y: 2, w: 60, h: 78 },
            sizeX: 2,
            sizeY: 2,
            blocking: true,
            noRandomOffset: true,
          }),

          new TileType({
            name: 'Wall 2',
            img: { x: 192, y: 80, w: 60, h: 80 },
            sizeX: 2,
            sizeY: 2,
            blocking: true,
            noRandomOffset: true,
          }),

          new TileType({
            name: 'Wall 3',
            img: { x: 0, y: 160, w: 60, h: 80 },
            sizeX: 2,
            sizeY: 2,
            blocking: true,
            noRandomOffset: true,
          }),

          new TileType({
            name: 'Wall 4',
            img: { x: 60, y: 160, w: 28, h: 50 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
            noRandomOffset: true,
          }),

          new TileType({
            name: 'Wall 5',
            img: { x: 2, y: 354, w: 40, h: 56 },
            sizeX: 2,
            sizeY: 2,
            blocking: true,
            noRandomOffset: true,
          }),

          new TileType({
            name: 'Wall 6',
            img: { x: 518, y: 54, w: 21, h: 63 },
            sizeX: 1,
            sizeY: 3,
            blocking: true,
            noRandomOffset: true,
          }),

          new TileType({
            name: 'Wall 7',
            img: { x: 542, y: 54, w: 21, h: 63 },
            sizeX: 1,
            sizeY: 3,
            blocking: true,
            noRandomOffset: true,
          }),

          new TileType({
            name: 'Wall 8',
            img: { x: 490, y: 121, w: 53, h: 23 },
            sizeX: 3,
            sizeY: 1,
            blocking: true,
            noRandomOffset: true,
          }),

          new TileType({
            name: 'Wall 9',
            img: { x: 491, y: 147, w: 37, h: 45 },
            sizeX: 2,
            sizeY: 2,
            blocking: true,
            noRandomOffset: true,
          }),

          new TileType({
            name: 'Invisible Pathing Blocker',
            img: { x: 875, y: 0, w: 16, h: 16 },
            imgEditor: { x: 858, y: 0, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: true,
          }),

          new TileType({
            name: 'Invisible Pathing Blocker 2x2',
            img: { x: 892, y: 0, w: 32, h: 32 },
            imgEditor: { x: 858, y: 17, w: 32, h: 32 },
            sizeX: 2,
            sizeY: 2,
            blocking: true,
          }),

          new TileType({
            name: 'Flower 2',
            img: { x: 0, y: 0, w: 11, h: 12 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Flower 3',
            img: { x: 11, y: 0, w: 7, h: 6 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Flower 4',
            img: { x: 18, y: 0, w: 11, h: 12 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Flower 5',
            img: { x: 29, y: 0, w: 12, h: 11 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Stone 6',
            img: { x: 181, y: 16, w: 6, h: 6 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Stone 7',
            img: { x: 164, y: 35, w: 6, h: 6 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Stone 8',
            img: { x: 170, y: 35, w: 10, h: 6 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Stone 9',
            img: { x: 180, y: 35, w: 10, h: 6 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Grass d 5',
            img: { x: 41, y: 0, w: 21, h: 15 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Grass d 6',
            img: { x: 62, y: 0, w: 12, h: 10 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Grass d 7',
            img: { x: 74, y: 0, w: 6, h: 9 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Grass d 8',
            img: { x: 80, y: 0, w: 6, h: 9 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Grass d 9',
            img: { x: 86, y: 0, w: 6, h: 9 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Leaf 1',
            img: { x: 176, y: 16, w: 5, h: 7 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Leaf 2',
            img: { x: 188, y: 0, w: 4, h: 7 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Plant 1',
            img: { x: 176, y: 23, w: 13, h: 12 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Wood 1',
            img: { x: 88, y: 160, w: 26, h: 15 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),


          // Grounds
          new TileType({
            name: 'Grass 1',
            img: { x: 92, y: 0, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Grass 2',
            img: { x: 108, y: 0, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Grass 3',
            img: { x: 124, y: 0, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Grass 4',
            img: { x: 140, y: 0, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Grass 5',
            img: { x: 156, y: 0, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Grass 21',
            img: { x: 295, y: 0, w: 17, h: 19 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Grass 22',
            img: { x: 252, y: 0, w: 34, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Water P Big',
            img: { x: 622, y: 0, w: 58, h: 47 },
            sizeX: 3,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Water P Small',
            img: { x: 568, y: 83, w: 18, h: 18 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Water P Big Dark',
            img: { x: 695, y: 51, w: 58, h: 47 },
            sizeX: 3,
            sizeY: 3,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Water P Small Dark',
            img: { x: 568, y: 104, w: 18, h: 18 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            ignoreGrid: true,
            isGround: true,
          }),

          new TileType({
            name: 'Ground n 1',
            img: { x: 32, y: 16, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Ground n 2',
            img: { x: 48, y: 16, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Ground n 3',
            img: { x: 64, y: 16, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Ground n 4',
            img: { x: 80, y: 16, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Ground n 5',
            img: { x: 96, y: 16, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Ground n 6',
            img: { x: 112, y: 16, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Ground n 7',
            img: { x: 128, y: 16, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Ground n 8',
            img: { x: 144, y: 16, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Ground n 9',
            img: { x: 32, y: 16, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),


          new TileType({
            name: 'Ground n 10',
            img: { x: 160, y: 16, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
          }),


          new TileType({
            name: 'Ground e 1',
            img: { x: 32, y: 16, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Ground e 2',
            img: { x: 48, y: 16, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Ground e 3',
            img: { x: 64, y: 16, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Snow 1',
            img: { x: 0, y: 245, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Snow 2',
            img: { x: 16, y: 245, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Snow 3',
            img: { x: 0, y: 261, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Snow 4',
            img: { x: 16, y: 261, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Egypt Ground 1',
            img: { x: 484, y: 477, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Egypt Ground 2',
            img: { x: 500, y: 477, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Egypt Ground 3',
            img: { x: 516, y: 477, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Egypt Ground 4',
            img: { x: 532, y: 477, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Egypt Ground 5',
            img: { x: 548, y: 477, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Egypt Ground 6',
            img: { x: 484, y: 477, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Grave Ground 1',
            img: { x: 484 + 380, y: 477, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Grave Ground 2',
            img: { x: 500 + 380, y: 477 + 4, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Grave Ground 3',
            img: { x: 516 + 380, y: 477 + 4, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Grave Ground 4',
            img: { x: 532 + 380, y: 477, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Grave Ground 5',
            img: { x: 548 + 380, y: 477 + 4, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Grave Ground 6',
            img: { x: 484 + 380, y: 477, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isDefault: true,
            isGround: true,
          }),

          new TileType({
            name: 'Dirt 1',
            img: { x: 235, y: 166, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Dirt 2',
            img: { x: 241, y: 184, w: 10, h: 9 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Dirt 3',
            img: { x: 240, y: 195, w: 11, h: 10 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Dirt 4',
            img: { x: 236, y: 206, w: 15, h: 15 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Dirt 5',
            img: { x: 235, y: 223, w: 16, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Dirt 6',
            img: { x: 339, y: 0, w: 14, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Dirt 7',
            img: { x: 355, y: 0, w: 13, h: 17 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Dirt 8',
            img: { x: 369, y: 0, w: 18, h: 14 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Dirt 9',
            img: { x: 387, y: 0, w: 19, h: 11 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Big Dirt 1',
            img: { x: 412, y: 1, w: 54, h: 54 },
            sizeX: 3,
            sizeY: 3,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Big Dirt 2',
            img: { x: 467, y: 0, w: 55, h: 54 },
            sizeX: 3,
            sizeY: 3,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Big Dirt 3',
            img: { x: 374, y: 56, w: 54, h: 56 },
            sizeX: 3,
            sizeY: 3,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Big Dirt 4',
            img: { x: 431, y: 57, w: 54, h: 55 },
            sizeX: 3,
            sizeY: 3,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Big Dirt 5',
            img: { x: 423, y: 114, w: 64, h: 63 },
            sizeX: 3,
            sizeY: 3,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Big Dirt 6',
            img: { x: 422, y: 178, w: 64, h: 62 },
            sizeX: 3,
            sizeY: 3,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Snow Ground 1',
            img: { x: 760, y: 0, w: 71, h: 63 },
            sizeX: 4,
            sizeY: 4,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Snow Ground 2',
            img: { x: 835, y: 0, w: 20, h: 16 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Stone Tile 1',
            img: { x: 683, y: 0, w: 14, h: 14 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Stone Tile 2',
            img: { x: 697, y: 0, w: 14, h: 14 },
            sizeX: 1,
            sizeY: 1,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Stone Tile 3',
            img: { x: 683, y: 14, w: 30, h: 30 },
            sizeX: 2,
            sizeY: 2,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Stone Tile 4',
            img: { x: 713, y: 0, w: 46, h: 46 },
            sizeX: 3,
            sizeY: 3,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

          new TileType({
            name: 'Stone Tile 5',
            img: { x: 596, y: 50, w: 94, h: 94 },
            sizeX: 6,
            sizeY: 6,
            blocking: false,
            isGround: true,
            ignoreGrid: true,
            isTexture: true,
          }),

        ];

        // Units
        var basicUnitTypes = UnitData;

        // Buildings
        var basicBuildingTypes = buildingData;

        // Tiles
        var tileTypes = TileTypes;

        // Cliffs
        var cliffs = CliffsData;

        // Cliffs Winter
        var cliffs_winter = CliffsWinterData;

        var egypt_cliffs = CliffsEgyptData;

        var grave_cliffs = GraveCliffData;

        var ramp_tiles = RampTileData;

        var ramp_tiles_egypt = RampTilesEgyptData;

        var ramp_tiles_grave = RampTilesGraveData;

        // Upgrades
        var basicUpgrades = UpgradesData;

        // Commands
        var basicCommands = commands;

        // Modifiers
        var basicModifiers = Modifiers;

        // Setup hotkeys for basic commands
        if (!IS_LOGIC) {
          const specialCommands = ['attack', 'stop', 'holdposition', 'cancel'];

          // Map from unit/building name to a Set containing the names of the units/buildings they are grouped with
          const groups = {};
          // Map from command ID to the name of one of its users
          const commandToUser = {};

          // Create groups of units and buildings that have commands in common
          // Exclude specialCommands and commands that don't have hotkeys
          basicCommands
            .filter((c) => specialCommands.indexOf(c.id_string) < 0)
            .filter((c) => 'hotkey' in c)
            .forEach((c) => {
              // Check which units / buildings use this command
              const usesCommand = (type) => c.id_string in type.commands;
              const unitCommandUsers = basicUnitTypes.filter((u) => usesCommand(u)).map((u) => u.name);
              const buildingCommandUsers = basicBuildingTypes.filter((u) => usesCommand(u)).map((u) => u.name);

              // Change this code if there is an ability shared between units and buildings
              // Currently the hotkey code is structured assuming there are none
              assert(unitCommandUsers.length == 0 || buildingCommandUsers.length == 0);
              if (unitCommandUsers.length == 0 && buildingCommandUsers.length == 0) {
                return;
              }

              const users = unitCommandUsers.length > 0 ? unitCommandUsers : buildingCommandUsers;
              commandToUser[c.id_string] = users[0];

              // Create a combined group that merges all of users and their existing groups
              let combinedSet = new Set();
              users.forEach((u) => combinedSet = new Set([...combinedSet, ...tryGet(groups, u, new Set([u]))]));
              users.forEach((u) => groups[u] = combinedSet);
            });

          // Maps from group name to HotkeyGroup
          const unitHotkeyGroups = {};
          const buildingHotkeyGroups = {};
          // Create HotkeyGroups with HotkeySettings and insert them into unitHotkeyGroups and buildingHotkeyGroups
          for (const cmdID in commandToUser) {
            const command = basicCommands.find((c) => c.id_string == cmdID);
            const cmdUser = commandToUser[cmdID];
            const isUnit = !!basicUnitTypes.find((u) => u.name == cmdUser);

            const groupName = Array.from(groups[cmdUser]).sort().join(' / ');
            const commands = isUnit ? unitHotkeyGroups : buildingHotkeyGroups;

            if (!commands[groupName]) {
              commands[groupName] = new HotkeyGroup(groupName);
            }
            commands[groupName].addChild(new HotkeySetting(command.name, command.hotkey, cmdID));
          }

          const unitHotkeys = new HotkeyGroup('Units', true);
          const buildingHotkeys = new HotkeyGroup('Buildings', true);

          // Insert the groups created earlier into unitHotkeys and buildingHotkeys
          for (const [commands, hotkeys] of [[unitHotkeyGroups, unitHotkeys], [buildingHotkeyGroups, buildingHotkeys]]) {
            for (const groupName in commands) {
              hotkeys.addChild(commands[groupName]);
            }
          }

          // Add the special commands to their own group
          const commonCommandHotkeys = new HotkeyGroup('Common Commands');
          const getCommonCommandHotkeySetting = (id) => {
            const command = basicCommands.find((c) => c.id_string == id);
            return new HotkeySetting(command.name, command.hotkey, id);
          };
          specialCommands.forEach((id) => commonCommandHotkeys.addChild(getCommonCommandHotkeySetting(id)));

          Hotkeys.registerHotkeyGroup(commonCommandHotkeys);
          Hotkeys.registerHotkeyGroup(unitHotkeys);
          Hotkeys.registerHotkeyGroup(buildingHotkeys);

          // Insert the user's custom hotkeys into the basic commands whenever the hotkeys change
          Hotkeys.onHotkeysChanged('COMMANDS', () => {
            const setHotkey = (hotkey) => {
              const command = basicCommands.find((c) => c.id_string == hotkey.id);
              command.hotkey = hotkey.value;

              // Set the hotkey ingame if there is a game running
              if (game?.commands) {
                const gameCommand = game.commands.find((c) => c.getBasicType() == command);
                if (gameCommand) {
                  gameCommand.updateHotkey(hotkey.value);
                }
              }
            };

            for (const commands of [unitHotkeyGroups, buildingHotkeyGroups]) {
              for (const groupName in commands) {
                commands[groupName].forEach((hotkey) => setHotkey(hotkey));
              }
            }
            commonCommandHotkeys.forEach((hotkey) => setHotkey(hotkey));
          });
        }

        // cliff data
        var cliffTable = [

          { arr: ['*', 1, '*', 0, 0, 0, 0, 0], cliffIndex: 0 },
          { arr: ['*', 0, 0, 1, 0, '*', 0, 0], cliffIndex: 1 },
          { arr: [0, 0, '*', 0, 1, 0, 0, '*'], cliffIndex: 2 },
          { arr: [0, 0, 0, 0, 0, '*', 1, '*'], cliffIndex: 3 },
          { arr: [0, 0, 1, 0, 0, 0, 0, 0], cliffIndex: 4 },
          { arr: [1, 0, 0, 0, 0, 0, 0, 0], cliffIndex: 5 },
          { arr: [0, 0, 0, 0, 0, 0, 0, 1], cliffIndex: 6 },
          { arr: [0, 0, 0, 0, 0, 1, 0, 0], cliffIndex: 7 },
          { arr: ['*', 1, 1, 0, 1, 0, 0, '*'], cliffIndex: 8 },
          { arr: [1, 1, '*', 1, 0, '*', 0, 0], cliffIndex: 9 },
          { arr: ['*', 0, 0, 1, 0, 1, 1, '*'], cliffIndex: 10 },
          { arr: [0, 0, '*', 0, 1, '*', 1, 1], cliffIndex: 11 },

        ];

        // 8 nb's
        var nbCoords = [
          { x: -1, y: -1 },
          { x: 0, y: -1 },
          { x: 1, y: -1 },
          { x: -1, y: 0 },
          { x: 1, y: 0 },
          { x: -1, y: 1 },
          { x: 0, y: 1 },
          { x: 1, y: 1 },
        ];

        // 8 nb's with center field
        var nbCoords2 = [
          { x: -1, y: -1 },
          { x: 0, y: -1 },
          { x: 1, y: -1 },
          { x: -1, y: 0 },
          { x: 0, y: 0 },
          { x: 1, y: 0 },
          { x: -1, y: 1 },
          { x: 0, y: 1 },
          { x: 1, y: 1 },
        ];

        var bucketTable = {
          '-1-1': { remove: [{ x: 1, y: -1 }, { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 0, y: 1 }, { x: -1, y: 1 }], add: [{ x: -1, y: 1 }, { x: -1, y: 0 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }] },
          '0-1': { remove: [{ x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }], add: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }] },
          '1-1': { remove: [{ x: -1, y: -1 }, { x: -1, y: 0 }, { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }], add: [{ x: 1, y: 1 }, { x: 1, y: 0 }, { x: 1, y: -1 }, { x: 0, y: -1 }, { x: -1, y: -1 }] },
          '-10': { remove: [{ x: 1, y: -1 }, { x: 1, y: 0 }, { x: 1, y: 1 }], add: [{ x: -1, y: -1 }, { x: -1, y: 0 }, { x: -1, y: 1 }] },
          '10': { remove: [{ x: -1, y: -1 }, { x: -1, y: 0 }, { x: -1, y: 1 }], add: [{ x: 1, y: -1 }, { x: 1, y: 0 }, { x: 1, y: 1 }] },
          '-11': { remove: [{ x: 1, y: 1 }, { x: 1, y: 0 }, { x: 1, y: -1 }, { x: 0, y: -1 }, { x: -1, y: -1 }], add: [{ x: -1, y: -1 }, { x: -1, y: 0 }, { x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }] },
          '01': { remove: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }], add: [{ x: -1, y: 1 }, { x: 0, y: 1 }, { x: 1, y: 1 }] },
          '11': { remove: [{ x: -1, y: 1 }, { x: -1, y: 0 }, { x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }], add: [{ x: 1, y: -1 }, { x: 1, y: 0 }, { x: 1, y: 1 }, { x: 0, y: 1 }, { x: -1, y: 1 }] },
        };

        var reversePairs = [
          [{ x: 0, y: -1 }, { x: 0, y: 1 }],
          [{ x: 1, y: 0 }, { x: -1, y: 0 }],
        ];

        var rampMaps = [
          { h: [1, 1, 1, 0, 0, 0, 0, 0, 0], rampId: 0, clippingPoint: { x: -1, y: 0 } },
          { h: [0, 0, 1, 0, 0, 1, 0, 0, 1], rampId: 1, clippingPoint: { x: -2, y: -1 } },
          { h: [1, 0, 0, 1, 0, 0, 1, 0, 0], rampId: 2, clippingPoint: { x: 0, y: -1 } },
          { h: [0, 0, 0, 0, 0, 0, 1, 1, 1], rampId: 3, clippingPoint: { x: -1, y: -2 } },
        ];

        /*
         * Ramps
         * those x, y, addX values and so on work the following: when map is created and ramp field is found, for every cliff there will be
         * x incremented by the x value and y by the y value until reached the last field still contained by the ramp, then once addX and addY will be added
         * and the field that is reached now will be used to place the cliff tile.
         * for the texture: initX and initY will be applied until reached the last field, then the texture will be applied for every loopX and loopY until the last ramp field reached
         */
        var ramps = [

          {
            map: [{ x: 0, y: 0, cliff: true }, { x: 1, y: 0, cliff: true }, { x: 2, y: 0, cliff: true }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 0, y: 2 }, { x: 1, y: 2 }, { x: 2, y: 2 }],
            vec: { x: 0, y: 1 },
            code: 'S',
            cliffs: [{ x: -1, y: -1, cliff: ramp_tiles[0] }, { x: 1, y: -1, cliff: ramp_tiles[1] }],
            texture: { tiles: [ramp_tiles[2], ramp_tiles[3], ramp_tiles[4]], initX: -1, initY: -1, loopX: 1, loopY: 0, drawX: 0.5, drawY: -0.3 },
            noRamps: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: 3, y: -1 }, { x: -1, y: 3 }, { x: 0, y: 3 }, { x: 1, y: 3 }, { x: 2, y: 3 }, { x: 3, y: 3 }],
            onlyThisRamp: [{ x: -1, y: 0 }, { x: -1, y: 1 }, { x: -1, y: 2 }, { x: 3, y: 0 }, { x: 3, y: 1 }, { x: 3, y: 2 }],
            sameLevel: [{ x: 0, y: 3 }, { x: 1, y: 3 }, { x: 2, y: 3 }],
          },

          {
            map: [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 0, cliff: true }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1, cliff: true }, { x: 0, y: 2 }, { x: 1, y: 2 }, { x: 2, y: 2, cliff: true }],
            vec: { x: -1, y: 0 },
            code: 'W',
            cliffs: [{ x: -1, y: -1, cliff: ramp_tiles[5] }, { x: -1, y: 1, cliff: ramp_tiles[6] }],
            texture: { tiles: [ramp_tiles[7], ramp_tiles[8], ramp_tiles[9]], initX: -1, initY: -1, loopX: 0, loopY: 1, drawX: 0.3, drawY: -0.2 },
            noRamps: [{ x: -1, y: -1 }, { x: -1, y: 0 }, { x: -1, y: 1 }, { x: -1, y: 2 }, { x: -1, y: 3 }, { x: 3, y: -1 }, { x: 3, y: 0 }, { x: 3, y: 1 }, { x: 3, y: 2 }, { x: 3, y: 3 }],
            onlyThisRamp: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: 0, y: 3 }, { x: 1, y: 3 }, { x: 2, y: 3 }],
            sameLevel: [{ x: -1, y: 0 }, { x: -1, y: 1 }, { x: -1, y: 2 }],
          },

          {
            map: [{ x: 0, y: 0, cliff: true }, { x: 1, y: 0 }, { x: 2, y: 0 }, { x: 0, y: 1, cliff: true }, { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 0, y: 2, cliff: true }, { x: 1, y: 2 }, { x: 2, y: 2 }],
            vec: { x: 1, y: 0 },
            code: 'E',
            cliffs: [{ x: -1, y: -1, cliff: ramp_tiles[10] }, { x: -1, y: 1, cliff: ramp_tiles[11] }],
            texture: { tiles: [ramp_tiles[12], ramp_tiles[13], ramp_tiles[14]], initX: -1, initY: -1, loopX: 0, loopY: 1, drawX: 0.5, drawY: -0.2 },
            noRamps: [{ x: -1, y: -1 }, { x: -1, y: 0 }, { x: -1, y: 1 }, { x: -1, y: 2 }, { x: -1, y: 3 }, { x: 3, y: -1 }, { x: 3, y: 0 }, { x: 3, y: 1 }, { x: 3, y: 2 }, { x: 3, y: 3 }],
            onlyThisRamp: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: 0, y: 3 }, { x: 1, y: 3 }, { x: 2, y: 3 }],
            sameLevel: [{ x: 3, y: 0 }, { x: 3, y: 1 }, { x: 3, y: 2 }],
          },

          {
            map: [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 0, y: 2, cliff: true }, { x: 1, y: 2, cliff: true }, { x: 2, y: 2, cliff: true }],
            vec: { x: 0, y: -1 },
            code: 'N',
            cliffs: [{ x: -1, y: -1, cliff: ramp_tiles[15] }, { x: 1, y: -1, cliff: ramp_tiles[16] }],
            texture: { tiles: [ramp_tiles[17], ramp_tiles[18], ramp_tiles[19]], initX: -1, initY: -1, loopX: 1, loopY: 0, drawX: 0.5, drawY: -0.2 },
            noRamps: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: 3, y: -1 }, { x: -1, y: 3 }, { x: 0, y: 3 }, { x: 1, y: 3 }, { x: 2, y: 3 }, { x: 3, y: 3 }],
            onlyThisRamp: [{ x: -1, y: 0 }, { x: -1, y: 1 }, { x: -1, y: 2 }, { x: 3, y: 0 }, { x: 3, y: 1 }, { x: 3, y: 2 }],
            sameLevel: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }],

          },

        ];

        var ramps_egypt = [

          {
            map: [{ x: 0, y: 0, cliff: true }, { x: 1, y: 0, cliff: true }, { x: 2, y: 0, cliff: true }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 0, y: 2 }, { x: 1, y: 2 }, { x: 2, y: 2 }],
            vec: { x: 0, y: 1 },
            code: 'S',
            cliffs: [{ x: -1, y: -1, cliff: ramp_tiles_egypt[0] }, { x: 1, y: -1, cliff: ramp_tiles_egypt[1] }],
            texture: { tiles: [ramp_tiles_egypt[2], ramp_tiles_egypt[3], ramp_tiles_egypt[4]], initX: -1, initY: -1, loopX: 1, loopY: 0, drawX: 0.5, drawY: -0.3 },
            noRamps: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: 3, y: -1 }, { x: -1, y: 3 }, { x: 0, y: 3 }, { x: 1, y: 3 }, { x: 2, y: 3 }, { x: 3, y: 3 }],
            onlyThisRamp: [{ x: -1, y: 0 }, { x: -1, y: 1 }, { x: -1, y: 2 }, { x: 3, y: 0 }, { x: 3, y: 1 }, { x: 3, y: 2 }],
            sameLevel: [{ x: 0, y: 3 }, { x: 1, y: 3 }, { x: 2, y: 3 }],
          },

          {
            map: [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 0, cliff: true }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1, cliff: true }, { x: 0, y: 2 }, { x: 1, y: 2 }, { x: 2, y: 2, cliff: true }],
            vec: { x: -1, y: 0 },
            code: 'W',
            cliffs: [{ x: -1, y: -1, cliff: ramp_tiles_egypt[5] }, { x: -1, y: 1, cliff: ramp_tiles_egypt[6] }],
            texture: { tiles: [ramp_tiles_egypt[7], ramp_tiles_egypt[8], ramp_tiles_egypt[9]], initX: -1, initY: -1, loopX: 0, loopY: 1, drawX: 0.3, drawY: -0.2 },
            noRamps: [{ x: -1, y: -1 }, { x: -1, y: 0 }, { x: -1, y: 1 }, { x: -1, y: 2 }, { x: -1, y: 3 }, { x: 3, y: -1 }, { x: 3, y: 0 }, { x: 3, y: 1 }, { x: 3, y: 2 }, { x: 3, y: 3 }],
            onlyThisRamp: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: 0, y: 3 }, { x: 1, y: 3 }, { x: 2, y: 3 }],
            sameLevel: [{ x: -1, y: 0 }, { x: -1, y: 1 }, { x: -1, y: 2 }],
          },

          {
            map: [{ x: 0, y: 0, cliff: true }, { x: 1, y: 0 }, { x: 2, y: 0 }, { x: 0, y: 1, cliff: true }, { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 0, y: 2, cliff: true }, { x: 1, y: 2 }, { x: 2, y: 2 }],
            vec: { x: 1, y: 0 },
            code: 'E',
            cliffs: [{ x: -1, y: -1, cliff: ramp_tiles_egypt[10] }, { x: -1, y: 1, cliff: ramp_tiles_egypt[11] }],
            texture: { tiles: [ramp_tiles_egypt[12], ramp_tiles_egypt[13], ramp_tiles_egypt[14]], initX: -1, initY: -1, loopX: 0, loopY: 1, drawX: 0.5, drawY: -0.2 },
            noRamps: [{ x: -1, y: -1 }, { x: -1, y: 0 }, { x: -1, y: 1 }, { x: -1, y: 2 }, { x: -1, y: 3 }, { x: 3, y: -1 }, { x: 3, y: 0 }, { x: 3, y: 1 }, { x: 3, y: 2 }, { x: 3, y: 3 }],
            onlyThisRamp: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: 0, y: 3 }, { x: 1, y: 3 }, { x: 2, y: 3 }],
            sameLevel: [{ x: 3, y: 0 }, { x: 3, y: 1 }, { x: 3, y: 2 }],
          },

          {
            map: [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 0, y: 2, cliff: true }, { x: 1, y: 2, cliff: true }, { x: 2, y: 2, cliff: true }],
            vec: { x: 0, y: -1 },
            code: 'N',
            cliffs: [{ x: -1, y: -1, cliff: ramp_tiles_egypt[15] }, { x: 1, y: -1, cliff: ramp_tiles_egypt[16] }],
            texture: { tiles: [ramp_tiles_egypt[17], ramp_tiles_egypt[18], ramp_tiles_egypt[19]], initX: -1, initY: -1, loopX: 1, loopY: 0, drawX: 0.5, drawY: -0.2 },
            noRamps: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: 3, y: -1 }, { x: -1, y: 3 }, { x: 0, y: 3 }, { x: 1, y: 3 }, { x: 2, y: 3 }, { x: 3, y: 3 }],
            onlyThisRamp: [{ x: -1, y: 0 }, { x: -1, y: 1 }, { x: -1, y: 2 }, { x: 3, y: 0 }, { x: 3, y: 1 }, { x: 3, y: 2 }],
            sameLevel: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }],
          },

        ];

        var ramps_grave = [

          {
            map: [{ x: 0, y: 0, cliff: true }, { x: 1, y: 0, cliff: true }, { x: 2, y: 0, cliff: true }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 0, y: 2 }, { x: 1, y: 2 }, { x: 2, y: 2 }],
            vec: { x: 0, y: 1 },
            code: 'S',
            cliffs: [{ x: -1, y: -1, cliff: ramp_tiles_grave[0] }, { x: 1, y: -1, cliff: ramp_tiles_grave[1] }],
            texture: { tiles: [ramp_tiles_grave[2], ramp_tiles_grave[3], ramp_tiles_grave[4]], initX: -1, initY: -1, loopX: 1, loopY: 0, drawX: 0.5, drawY: -0.3 },
            noRamps: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: 3, y: -1 }, { x: -1, y: 3 }, { x: 0, y: 3 }, { x: 1, y: 3 }, { x: 2, y: 3 }, { x: 3, y: 3 }],
            onlyThisRamp: [{ x: -1, y: 0 }, { x: -1, y: 1 }, { x: -1, y: 2 }, { x: 3, y: 0 }, { x: 3, y: 1 }, { x: 3, y: 2 }],
            sameLevel: [{ x: 0, y: 3 }, { x: 1, y: 3 }, { x: 2, y: 3 }],
          },

          {
            map: [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 0, cliff: true }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1, cliff: true }, { x: 0, y: 2 }, { x: 1, y: 2 }, { x: 2, y: 2, cliff: true }],
            vec: { x: -1, y: 0 },
            code: 'W',
            cliffs: [{ x: -1, y: -1, cliff: ramp_tiles_grave[5] }, { x: -1, y: 1, cliff: ramp_tiles_grave[6] }],
            texture: { tiles: [ramp_tiles_grave[7], ramp_tiles_grave[8], ramp_tiles_grave[9]], initX: -1, initY: -1, loopX: 0, loopY: 1, drawX: 0.3, drawY: -0.2 },
            noRamps: [{ x: -1, y: -1 }, { x: -1, y: 0 }, { x: -1, y: 1 }, { x: -1, y: 2 }, { x: -1, y: 3 }, { x: 3, y: -1 }, { x: 3, y: 0 }, { x: 3, y: 1 }, { x: 3, y: 2 }, { x: 3, y: 3 }],
            onlyThisRamp: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: 0, y: 3 }, { x: 1, y: 3 }, { x: 2, y: 3 }],
            sameLevel: [{ x: -1, y: 0 }, { x: -1, y: 1 }, { x: -1, y: 2 }],
          },

          {
            map: [{ x: 0, y: 0, cliff: true }, { x: 1, y: 0 }, { x: 2, y: 0 }, { x: 0, y: 1, cliff: true }, { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 0, y: 2, cliff: true }, { x: 1, y: 2 }, { x: 2, y: 2 }],
            vec: { x: 1, y: 0 },
            code: 'E',
            cliffs: [{ x: -1, y: -1, cliff: ramp_tiles_grave[10] }, { x: -1, y: 1, cliff: ramp_tiles_grave[11] }],
            texture: { tiles: [ramp_tiles_grave[12], ramp_tiles_grave[13], ramp_tiles_grave[14]], initX: -1, initY: -1, loopX: 0, loopY: 1, drawX: 0.5, drawY: -0.2 },
            noRamps: [{ x: -1, y: -1 }, { x: -1, y: 0 }, { x: -1, y: 1 }, { x: -1, y: 2 }, { x: -1, y: 3 }, { x: 3, y: -1 }, { x: 3, y: 0 }, { x: 3, y: 1 }, { x: 3, y: 2 }, { x: 3, y: 3 }],
            onlyThisRamp: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: 0, y: 3 }, { x: 1, y: 3 }, { x: 2, y: 3 }],
            sameLevel: [{ x: 3, y: 0 }, { x: 3, y: 1 }, { x: 3, y: 2 }],
          },

          {
            map: [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 0, y: 2, cliff: true }, { x: 1, y: 2, cliff: true }, { x: 2, y: 2, cliff: true }],
            vec: { x: 0, y: -1 },
            code: 'N',
            cliffs: [{ x: -1, y: -1, cliff: ramp_tiles_grave[15] }, { x: 1, y: -1, cliff: ramp_tiles_grave[16] }],
            texture: { tiles: [ramp_tiles_grave[17], ramp_tiles_grave[18], ramp_tiles_grave[19]], initX: -1, initY: -1, loopX: 1, loopY: 0, drawX: 0.5, drawY: -0.2 },
            noRamps: [{ x: -1, y: -1 }, { x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }, { x: 3, y: -1 }, { x: -1, y: 3 }, { x: 0, y: 3 }, { x: 1, y: 3 }, { x: 2, y: 3 }, { x: 3, y: 3 }],
            onlyThisRamp: [{ x: -1, y: 0 }, { x: -1, y: 1 }, { x: -1, y: 2 }, { x: 3, y: 0 }, { x: 3, y: 1 }, { x: 3, y: 2 }],
            sameLevel: [{ x: 0, y: -1 }, { x: 1, y: -1 }, { x: 2, y: -1 }],
          },

        ];


        // Map Themes
        var mapThemes = [

          {
            name: 'Grass',
            defaultTiles: ['Ground n 6', 'Ground n 7', 'Ground n 8', 'Ground n 5', 'Ground n 1', 'Ground n 2', 'Ground n 3', 'Ground n 4'],
            particleColor: 'rgba(255, 255, 100, 0.4)',
            countDots: 150,
            line_red: 255,
            line_green: 255,
            line_blue: 255,
            cliffs: cliffs,
            ramps: ramps,
            arrowColor: 'white',
          },

          {
            name: 'Snow',
            defaultTiles: ['Snow 1', 'Snow 2', 'Snow 3', 'Snow 4'],
            particleColor: 'rgba(255, 255, 255, 0.8)',
            countDots: 200,
            alpha: 0.8,
            line_red: 0,
            line_green: 255,
            line_blue: 0,
            cliffs: cliffs_winter,
            ramps: ramps,
            arrowColor: 'black',
          },

          {
            name: 'Egypt',
            defaultTiles: ['Egypt Ground 1', 'Egypt Ground 2', 'Egypt Ground 3', 'Egypt Ground 4', 'Egypt Ground 5', 'Egypt Ground 6'],
            particleColor: 'rgba(255, 255, 100, 0.8)',
            countDots: 0,
            line_red: 255,
            line_green: 255,
            line_blue: 255,
            cliffs: egypt_cliffs,
            ramps: ramps_egypt,
            arrowColor: 'white',
          },

          {
            name: 'Graveyard',
            defaultTiles: ['Grave Ground 1', 'Grave Ground 2', 'Grave Ground 3', 'Grave Ground 4', 'Grave Ground 5', 'Grave Ground 6'],
            particleColor: 'rgba(255, 255, 255, 0.8)',
            countDots: 100,
            line_red: 0,
            line_green: 255,
            line_blue: 0,
            cliffs: grave_cliffs,
            ramps: ramps_grave,
            arrowColor: 'white',
          },

        ];


        var list_attack_effects = {
          none: null,
          arrow: 'arrow',
          mageAttack: 'mageAttack',
          launchedRock: 'launchedRock',
          dragonAttack: 'dragonAttack',
          ballistaAttack: 'ballista',
          flamestrike: 'flamestrike',
          heal: 'heal',
          smoke: 'smoke',
          aura: 'aura',
          spell: 'spell',
        };


        var unit_fields = [

          {
            name: 'name',
            type: 'string',
            max_len: 30,
            min_len: 1,
            description: 'The units name',
            default_: 'new_unit',
            logic: true,
          },

          {
            name: 'hp',
            type: 'integer',
            min_val: 1,
            max_val: 99999999,
            description: 'The max amount of hit points this unit has.',
            default_: 100,
            logic: true,
          },

          {
            name: 'startHp',
            type: 'integer',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of hit points this unit has when it spanws. 0 for max.',
            default_: 0,
            logic: true,
          },

          {
            name: 'mana',
            type: 'integer',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of mana this unit has.',
            default_: 0,
            logic: true,
          },

          {
            name: 'startMana',
            type: 'integer',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of starting mana this unit has.',
            default_: 0,
            logic: true,
          },

          {
            name: 'hpRegenerationRate',
            type: 'float',
            min_val: -99999999,
            max_val: 99999999,
            description: 'The amount of hit points this unit regenerates per sec.',
            default_: 0,
            logic: true,
            displayScale: 20,
          },

          {
            name: 'manaRegenerationRate',
            type: 'float',
            min_val: -99999999,
            max_val: 99999999,
            description: 'The amount of mana this unit regenerates per sec.',
            default_: 0,
            logic: true,
            displayScale: 20,
          },

          {
            name: 'armor',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The armor this unit has. 1 armor reduces all incoming damage by 1.',
            default_: 0,
            logic: true,
          },

          {
            name: 'supply',
            type: 'integer',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of supply this unit uses.',
            default_: 1,
            logic: true,
          },

          {
            name: 'supplyProvided',
            type: 'integer',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of supply this unit prodives.',
            default_: 0,
            logic: true,
          },

          {
            name: 'movementSpeed',
            type: 'float',
            min_val: 0,
            max_val: 6.0,
            description: 'The movement speed of the unit.',
            default_: 0.1,
            logic: true,
            displayScale: 20,
          },

          {
            name: 'weaponCooldown',
            type: 'float',
            min_val: 0.1,
            max_val: 99999999,
            description: 'The time it takes for this unit to fire again when it just fired.',
            default_: 20,
            logic: true,
            displayScale: 1 / 20,
          },

          {
            name: 'weaponDelay',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The time it takes for this unit to actually fire when an attack is initiated.',
            default_: 20,
            logic: true,
            displayScale: 1 / 20,
          },

          {
            name: 'dmg',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The damage this unit does with one attack.',
            default_: 10,
            logic: true,
          },

          {
            name: 'dmgModifierAttributes',
            type: 'selection',
            description: 'The filter that target unit has to meet for the damage modifiers to be applied',
            isArray: true,
            values: targetFilters1,
            default_: 'isHuman',
            default2_: [],
            logic: true,
            group: 'dmgModifiers',
            subName: 'filter',
            groupDescription: 'The unit can have different damage for different types of units, for example it can do +3 damage vs mechanical units, or it can do +50% vs flying units.',
          },

          {
            name: 'dmgModifierAddition',
            type: 'float',
            min_val: -999999,
            max_val: 9999999,
            description: 'This value will be added to the damage value, if it meets the filter atribute.',
            default_: 0,
            default2_: [],
            isArray: true,
            logic: true,
            group: 'dmgModifiers',
            subName: 'add',
            groupDescription: 'The unit can have different damage for different types of units, for example it can do +3 damage vs mechanical units, or it can do +50% vs flying units.',
          },

          {
            name: 'dmgModifierMultiplier',
            type: 'float',
            min_val: -999999,
            max_val: 9999999,
            description: 'The damage value will be multiplied with this value, if it meets the filter atributes.',
            default_: 1,
            default2_: [],
            isArray: true,
            logic: true,
            group: 'dmgModifiers',
            subName: 'multiply',
            groupDescription: 'The unit can have different damage for different types of units, for example it can do +3 damage vs mechanical units, or it can do +50% vs flying units.',
          },

          {
            name: 'lifesteal',
            type: 'float',
            min_val: -99999999,
            max_val: 99999999,
            description: 'The % of the damage this unit gets as HP when dealing dmg (0.5 means it gets half the dmg it deals as HP).',
            default_: 0,
            logic: true,
          },

          {
            name: 'armorPenetration',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of armor this unit ignores when dealing damage.',
            default_: 0,
            logic: true,
          },

          {
            name: 'percDmg',
            type: 'float',
            min_val: -1,
            max_val: 1,
            description: 'The percentual damage this unit does. For example 0.2 means it does 20% (of target max hp) dmg.',
            default_: 0,
            logic: true,
          },

          {
            name: 'dmgCap',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The min possible value this units damage can be after applying the defenders armor. If you set this to 2 for example, the damage will always be at least 2, even if the defenders armor would reduce to less than 2 normally.',
            default_: 1,
            logic: true,
          },

          {
            name: 'bouncePower',
            type: 'float',
            min_val: 0.0,
            max_val: 99.0,
            description: 'If this is set to higher than 0, this unit will smash target units back when attacking them. It only affects units with power less than this bouncePower.',
            default_: 0,
            logic: true,
          },

          {
            name: 'bounceDistMin',
            type: 'float',
            min_val: 0.0,
            max_val: 99.0,
            description: 'The min range of how far this unit smashes target units back.',
            default_: 0,
            logic: true,
          },

          {
            name: 'bounceDistMax',
            type: 'float',
            min_val: 0.0,
            max_val: 99.0,
            description: 'The max range of how far this unit smashes target units back.',
            default_: 0,
            logic: true,
          },

          {
            name: 'range',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The attack range of this unit.',
            default_: 0.2,
            logic: true,
          },

          {
            name: 'minRange',
            type: 'float',
            min_val: -999,
            max_val: 999,
            description: 'The minimum attack range of this unit. Other units close that this can not be attacked. Set to -1 for no min attack range',
            default_: -999,
            logic: true,
          },

          {
            name: 'aoeRadius',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'If this is bigger than 0, the unit will deal aoe damage (= area of effect). That means not only the target unit takes damage, but all units in range of the target unit.',
            default_: 0,
            logic: true,
          },

          {
            name: 'attackPrio',
            type: 'float',
            min_val: -99999,
            max_val: 999999,
            description: 'Units with higher attack prios get attacked first.',
            default_: 10,
            logic: true,
          },

          {
            name: 'size',
            type: 'float',
            min_val: 0,
            max_val: 12.0,
            description: 'The size of the unit (= diameter). This determines when a unit collides with other units or map objects. Ground units with a size bigger than 2 might cause pathing problems.',
            default_: 0.9,
            logic: true,
          },

          {
            name: 'imageScale',
            type: 'float',
            min_val: 0.1,
            max_val: 10,
            description: 'If you put another value than 1, the image will be scaled, so the unit becomes bigger or smaller (only visual, no gameplay effect).',
            default_: 1,
          },

          {
            name: 'vision',
            type: 'float',
            min_val: -1,
            max_val: 360, // 256 is the max map size, multiplied by the sqrt of 2 (1.414) to get the diagonal
            description: 'The vision range of the unit.',
            default_: 7,
            logic: true,
          },

          {
            name: 'repairRate',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of HP this unit restores when repairing (per sec).',
            default_: 0,
            logic: true,
            displayScale: 20,
          },

          {
            name: 'repairIneffiency',
            type: 'float',
            min_val: 0,
            max_val: 1,
            description: 'Inefficiency per additional repairer e.g if set to 0.25, the second repairer will repair at a rate of 75% of the first, and third of a rate of 56%, etc',
            default_: 0,
            logic: true,
          },

          {
            name: 'repairCost',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of gold it costs when repairing (per sec).',
            default_: 0,
            logic: true,
            displayScale: 20,
          },

          {
            name: 'projectileSpeed',
            type: 'float',
            min_val: 0.02,
            max_val: 99999999,
            description: 'Only relevant if this is a ranged unit. The speed which the projectile travels.',
            default_: 8,
            logic: true,
          },

          {
            name: 'projectileLen',
            type: 'float',
            min_val: 0.02,
            max_val: 10,
            description: 'Only relevant if this is a ranged unit with basic arrow projectiles. The length of the projectile.',
            default_: 0.2,
          },

          {
            name: 'attackLaunchSound',
            type: 'selection',
            values: SOUND,
            description: 'The sound that plays when this unit attacks.',
            default_: SOUND.NONE,
            logic: true,
          },

          {
            name: 'circleSize',
            type: 'float',
            min_val: 0.02,
            max_val: 20,
            description: 'The size of the selection circle of this unit.',
            default_: 0.43,
          },

          {
            name: 'circleOffset',
            type: 'float',
            min_val: -99,
            max_val: 99,
            description: 'The y offset of the cirle of this unit (only a visual thing).',
            default_: 0.125,
          },

          {
            name: 'buildTime',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The time it takes to build this unit.',
            default_: 30,
            logic: true,
            displayScale: 1 / 20,
          },

          {
            name: 'cost',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of gold it costs to build this unit.',
            default_: 100,
            logic: true,
          },

          {
            name: 'healthbarOffset',
            type: 'float',
            min_val: -99,
            max_val: 99,
            description: 'The y offset of the health bar (only a visual thing).',
            default_: 0.95,
          },

          {
            name: 'healthbarWidth',
            type: 'float',
            min_val: 0.1,
            max_val: 99,
            description: 'The width of the health bar.',
            default_: 0.69,
          },

          {
            name: 'selectionOffsetY',
            type: 'float',
            min_val: -99,
            max_val: 99,
            description: 'The y offset of where the unit should be selected.',
            default_: 0,
          },

          {
            name: 'img',
            type: 'selection',
            values: lists.imgs,
            description: 'The unit\'s image.',
            default_: lists.imgs.soldier,
            special: 'imgPreview',
          },

          {
            name: 'description',
            type: 'string',
            max_len: 300,
            min_len: 0,
            description: 'The description of the unit.',
            default_: '',
          },

          {
            name: 'experienceLevels',
            type: 'integer',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of experience this unit needs to reach higher levels. Each value represents a level. The first value is the exp needed to reach lvl 2, the 2nd value the exp to reach lvl 3 and so on.',
            default_: 0,
            default2_: [],
            logic: true,
            isArray: true,
          },

          {
            name: 'experience',
            type: 'integer',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of experience this unit gives when it gets killed.',
            default_: 0,
            logic: true,
          },

          {
            name: 'modifiersPerLevel',
            type: 'selection',
            values: lists.modifiers,
            description: 'A list of modifiers that will be applied to this unit each time it levels up. For example you can make a modifier, that gives +1 damage and +10 HP and link it here, so the unit will get +1 dmg and +10 HP each time it levels up.',
            default_: null,
            default2_: [],
            isArray: true,
            logic: true,
          },

          {
            name: 'experienceRange',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The range in which this unit collects experience from enemy dying units.',
            default_: 9.0,
            logic: true,
          },

          {
            name: 'tabPriority',
            type: 'float',
            min_val: -99,
            max_val: 99,
            description: 'Buttons of units with higher tab priorities will be displayed first. When selecting two different unit types and both have special abilities, then the buttons of the unit with higher tab priority will be displayed.',
            default_: 5,
          },

          {
            name: 'drawOffsetY',
            type: 'float',
            min_val: -99,
            max_val: 99,
            description: 'Y offset of the unit when drawn.',
            default_: 6,
          },

          {
            name: 'attackEffect',
            type: 'selection',
            description: 'The effect, that shows when this unit is attacking (only relevant for ranged units).',
            values: list_attack_effects,
            default_: null,
            logic: true,
          },

          {
            name: 'painSound',
            type: 'selection',
            values: SOUND,
            description: 'A number of sounds that will be played when this unit gets hit.',
            default_: SOUND.NONE,
            logic: true,
          },

          {
            name: 'painSoundVolume',
            type: 'float',
            max_val: 1,
            min_val: 0,
            description: 'Volume 1 => 100%',
            default_: 1,
            logic: true,
          },

          {
            name: 'painSound2',
            type: 'selection',
            values: SOUND,
            description: 'A 2nd pain sound, in case 2 are needed.',
            default_: SOUND.NONE,
            logic: true,
          },

          {
            name: 'painSoundVolume2',
            type: 'float',
            max_val: 1,
            min_val: 0,
            description: 'Volume 1 => 100%',
            default_: 1,
            logic: true,
          },

          {
            name: 'deathSound',
            type: 'selection',
            values: SOUND,
            description: 'The sound that will be played when this unit dies.',
            default_: SOUND.NONE,
            logic: true,
          },

          {
            name: 'yesSound',
            type: 'selection',
            values: SOUND,
            description: 'The sound that will be played when this unit gets an order.',
            default_: SOUND.YES,
            logic: true,
          },


          {
            name: 'yesSoundVolume',
            type: 'float',
            max_val: 1,
            min_val: 0,
            description: 'Volume 1 => 100%',
            default_: 0.6,
            logic: true,
          },

          {
            name: 'readySound',
            type: 'selection',
            values: SOUND,
            description: 'The sound that will be played when this unit spawns.',
            default_: SOUND.READY,
            logic: true,
          },

          {
            name: 'readySoundVolume',
            type: 'float',
            max_val: 1,
            min_val: 0,
            description: 'The sound that will be played when this unit spawns.',
            default_: 0.9,
            logic: true,
          },

          {
            name: 'bodyPower',
            type: 'float',
            min_val: -99,
            max_val: 99,
            description: 'This represents the power that a target unit will be pushed when killed by this unit. A higher value means a unit killed by this unit will be pushed back very far when killed.',
            default_: 0.8,
            logic: true,
          },

          {
            name: 'dustCreationChance',
            type: 'float',
            min_val: -20,
            max_val: 5,
            description: 'The average dust particles this unit creates per sec. Put -1 for no dust creation at all (for example for flying units).',
            default_: 0.05,
            displayScale: 20,
          },

          {
            name: 'visionHeightBonus',
            type: 'integer',
            min_val: 0,
            max_val: 99,
            description: 'Usually units can not look at higher grounds. With this value set they can look up X cliff levels. A unit being on height level 1 and having a visionHeightBonus of 1 can see height level 2, but not 3.',
            default_: 0,
            logic: true,
          },

          {
            name: 'animSpeed',
            type: 'float',
            min_val: 0.1,
            max_val: 99,
            description: 'The speed in which the animations for this unit will be played.',
            default_: 1.5,
          },

          {
            name: 'oscillationAmplitude',
            type: 'float',
            min_val: 0,
            max_val: 99,
            description: 'The determined how fast a unit is moved up and down (only visual, no gameplay effect). Usually you want this only for flying units. To not have this effect, set to 0',
            default_: 0,
          },

          {
            name: 'height',
            type: 'float',
            min_val: -99,
            max_val: 99,
            description: 'This is only a visual thing. This value will be used when this unit gets shot with a projectile. The projectile will hit at a higher point when the height value is higher.',
            default_: 0.3,
          },

          {
            name: 'acceleration',
            type: 'float',
            min_val: 0,
            max_val: 99,
            description: 'Units with an acceleration dont start moving at their full speed. They also need some time to stop or change directions. Usually this is used for flying units. Set this to 0, if you dont want any acceleration.',
            default_: 0,
            logic: true,
          },

          {
            name: 'angularVelocity',
            type: 'float',
            min_val: 0,
            max_val: 1,
            description: 'Units with an angular velocity take curves instead of immediately changing their angle when moving and changing their direction. Set this to 0, if you dont want any acceleration.',
            default_: 0,
            logic: true,
          },

          {
            name: 'commands',
            type: 'commands',
            isObject: true,
            description: 'Here are all the abilites stored, that this unit can execute.',
            logic: true,
          },

          {
            name: 'cargoUse',
            type: 'integer',
            min_val: -1,
            max_val: 100,
            description: 'How much space in a transport unit this unit takes. Cargo space -1 means this unit is not loadable',
            default_: -1,
            logic: true,
          },

          {
            name: 'cargoSpace',
            type: 'integer',
            min_val: 0,
            max_val: 99999,
            description: 'How much space this unit can carry.',
            default_: 0,
            logic: true,
          },

          {
            name: 'projectileStartHeight',
            type: 'float',
            min_val: -99,
            max_val: 99,
            description: 'The (only visual) height of projectiles that this unit shoots.',
            default_: 0,
          },

          {
            name: 'power',
            type: 'float',
            min_val: 0,
            max_val: 99,
            description: 'The smash effect has a bouncePower value. If that value is higher than this units power value, then it gets smashed back.',
            default_: 0,
            logic: true,
          },

          {
            name: 'lifetime',
            type: 'float',
            min_val: 0,
            max_val: 999999,
            description: 'When this is bigger than 0, the unit will only live for a certain amount of time.',
            default_: 0,
            logic: true,
            displayScale: 1 / 20,
          },

          {
            name: 'goldReward',
            type: 'integer',
            min_val: -999999,
            max_val: 999999,
            description: 'If this is bigger than 0, a player who kills this unit will get gold rewarded according to this value.',
            default_: 0,
            logic: true,
          },

          {
            name: 'limit',
            type: 'integer',
            min_val: 0,
            max_val: 999999,
            description: 'Set this to a number bigger than 0 to limit the amount of instances of this building a player can make.',
            default_: 0,
            logic: true,
          },

          {
            name: 'modifiers',
            type: 'selection',
            isArray: true,
            values: lists.modifiers,
            description: 'Modifiers this unit applies to other units when attacking them.',
            default_: null,
            default2_: [],
            logic: true,
          },

          {
            name: 'modifiersSelf',
            type: 'selection',
            isArray: true,
            values: lists.modifiers,
            description: 'Modifiers this unit applies to ITSELF when attacking (other units).',
            default_: null,
            default2_: [],
            logic: true,
          },

          {
            name: 'onDamageModifiers',
            type: 'selection',
            isArray: true,
            values: lists.modifiers,
            description: 'Modifiers this unit applies to ITSELF when after taking damage',
            default_: null,
            default2_: [],
            logic: true,
          },

          {
            name: 'spawnModifiers',
            type: 'selection',
            isArray: true,
            values: lists.modifiers,
            description: 'The modifiers this unit gets when it spawns.',
            default_: null,
            default2_: [],
            logic: true,
          },

          {
            name: 'hoverText',
            type: 'string',
            min_len: 0,
            max_len: 1000,
            description: 'If you enter a text here, it will be displayed instead of the owners\' name when hovering this unit.',
            default_: '',
          },

          {
            name: 'canHaveWaypoint',
            type: 'bool',
            description: 'If this is true, this unit can set a waypoint (waypoints are used to tell spawning units where to go, so this usually makes sense if this unit can produce units)',
            default_: false,
            logic: true,
          },

          {
            name: 'isPassive',
            type: 'bool',
            description: 'Passive units dont attack on their own.',
            default_: false,
            logic: true,
          },

          {
            name: 'causesFlameDeath',
            type: 'bool',
            description: 'If this is true, then units killed by this unit will burn for some seconds (only visual, no gameplay effect).',
            default_: false,
          },

          {
            name: 'shootingReveals',
            type: 'bool',
            description: 'If this is true, then this unit will be visible for a short amount of time for the other player when it attacks.',
            default_: false,
            logic: true,
          },

          {
            name: 'shootWhileMoving',
            type: 'bool',
            description: 'Determines if this unit can attack while it moves.',
            default_: false,
            logic: true,
          },

          {
            name: 'hitscan',
            type: 'bool',
            description: 'Units that use hitscan, can not shoot through other units or obstacles, but need to have free space between them and their target in order to be able to shoot it. Their projectiles also can be intercepted if something moves in their way.',
            default_: false,
            logic: true,
          },

          {
            name: 'maximizeRangeWhenShooting',
            type: 'bool',
            description: 'Always shoot at max range. Only works on not heatseeking units. Makes sense on hitscan units.',
            default_: false,
            logic: true,
          },

          {
            name: 'hitsFriendly',
            type: 'bool',
            description: 'Determines if this unit attack affects friendly units (only relevant on aoe abilities).',
            default_: true,
            logic: true,
          },

          {
            name: 'hitsEnemy',
            type: 'bool',
            description: 'Determines if this unit attack affects enemy units (only relevant on aoe abilities).',
            default_: true,
            logic: true,
          },

          {
            name: 'canAttackGround',
            type: 'bool',
            description: 'Is the unit able to attack ground units ?',
            default_: true,
            logic: true,
          },

          {
            name: 'canAttackFlying',
            type: 'bool',
            description: 'Determines if this unit can attack flying units.',
            default_: false,
            logic: true,
          },

          {
            name: 'isHeatSeeking',
            type: 'bool',
            description: 'If this is false, hits by this unit can miss and will hit where the target unit was, what the attack was started.',
            default_: true,
            logic: true,
          },

          {
            name: 'ignoreEnemyHitscan',
            type: 'bool',
            description: 'If this is true, the unit will be shootable for enemy units, that use hitscan, even if something is in the way. Makes sense for example on air units.',
            default_: false,
            logic: true,
          },

          {
            name: 'controllable',
            type: 'bool',
            description: 'If this is false, the unit can not be controlled by the player.',
            default_: true,
            logic: true,
          },

          {
            name: 'hasDetection',
            type: 'bool',
            description: 'If its true, this unit can detect invisible units.',
            default_: false,
            logic: true,
          },

          {
            name: 'expOnlyFromOwnKills',
            type: 'bool',
            description: 'If true, this unit gets only experience when it actually kills a unit itself, but not when its just in range when an enemy unit is killed by another allied unit.',
            default_: false,
            logic: true,
          },

          {
            name: 'alliesGetExperience',
            type: 'bool',
            description: 'If true, allied units get experience when killing this unit.',
            default_: false,
            logic: true,
          },

          {
            name: 'alliesGetGold',
            type: 'bool',
            description: 'If true, allied units get gold reward when killing this unit.',
            default_: false,
            logic: true,
          },

          {
            name: 'isReflectingProjectiles',
            type: 'bool',
            description: 'If this is true, this unit reflects projectiles that would hit it otherwise. Only affects projectiles that deal damage while flying.',
            default_: false,
            logic: true,
          },

          {
            name: 'isBlockingProjectiles',
            type: 'bool',
            description: 'If this is true, this unit blocks (kills) projectiles that would hit it otherwise. Only affects projectiles that deal damage while flying.',
            default_: false,
            logic: true,
          },

          {
            name: 'takeDamageOnBlock',
            type: 'bool',
            description: 'If this unit blocks or reflects a projectile, this field determines if it is taking damage from the projectile.',
            default_: false,
            logic: true,
          },

          {
            name: 'preventsLoss',
            type: 'bool',
            description: 'If a player has no buildings or units that prevent losing, he will be eliminated.',
            default_: false,
            logic: true,
          },

          {
            name: 'flying',
            type: 'bool',
            description: 'Make an educated guess.',
            default_: false,
            logic: true,
          },

          {
            name: 'uniqueAndHeroic',
            type: 'bool',
            description: 'Units that are unique &amp; heroic only exist once and can be revived when they die.',
            default_: false,
            logic: true,
          },

          {
            name: 'isMechanical',
            type: 'bool',
            description: 'Mechanical units can be repaired and not healed.',
            default_: false,
            logic: true,
          },

          {
            name: 'isUndead',
            type: 'bool',
            description: 'Undead units take damage from healing spells.',
            default_: false,
            logic: true,
          },

          {
            name: 'isBiological',
            type: 'bool',
            description: 'Classification for unit types. Does not have any active effects but there can be abilities that only work for certain unit types. For example the \'Heal\' spell only works with biological units.',
            default_: true,
            logic: true,
          },

          {
            name: 'isBeast',
            type: 'bool',
            description: 'Classification for unit types. Does not have any active effects but there can be abilities that only work for certain unit types. For example the \'Heal\' spell only works with biological units.',
            default_: false,
            logic: true,
          },

          {
            name: 'isHuman',
            type: 'bool',
            description: 'Classification for unit types. Does not have any active effects but there can be abilities that only work for certain unit types. For example the \'Heal\' spell only works with biological units.',
            default_: false,
            logic: true,
          },

          {
            name: 'noShow',
            type: 'bool',
            description: 'If this is true, the unit will not be drawn.',
            default_: false,
            logic: true,
          },

          {
            name: 'noCollision',
            type: 'bool',
            description: 'If this is true, the unit will not collide with anything.',
            default_: false,
            logic: true,
          },

          {
            name: 'isInvisible',
            type: 'bool',
            description: 'Invisible units can only be attacked when detected.',
            default_: false,
            logic: true,
          },

          {
            name: 'isInvincible',
            type: 'bool',
            description: 'If this is true, the unit can not be attacked or damaged.',
            default_: false,
            logic: true,
          },

          {
            name: 'spawnWithAMove',
            type: 'bool',
            description: 'If this is true, units this unit produces will use AMove command when spawning to walk to the waypoint instead of normal move.',
            default_: false,
            logic: true,
          },

        ];


        var building_fields = [

          {
            name: 'name',
            type: 'string',
            max_len: 30,
            min_len: 1,
            description: 'The buildings name',
            default_: 'new_building',
            logic: true,
          },

          {
            name: 'hp',
            type: 'integer',
            min_val: 1,
            max_val: 99999999,
            description: 'The max amount of hit points this building has.',
            default_: 500,
            logic: true,
          },

          {
            name: 'mana',
            type: 'integer',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of mana this unit has.',
            default_: 0,
            logic: true,
          },

          {
            name: 'startMana',
            type: 'integer',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of starting mana this unit has.',
            default_: 0,
            logic: true,
          },

          {
            name: 'hpRegenerationRate',
            type: 'float',
            min_val: -99999999,
            max_val: 99999999,
            description: 'The amount of hit points this building regenerates per sec.',
            default_: 0,
            logic: true,
            displayScale: 20,
          },

          {
            name: 'manaRegenerationRate',
            type: 'float',
            min_val: -99999999,
            max_val: 99999999,
            description: 'The amount of mana this unit regenerates per sec.',
            default_: 0,
            logic: true,
            displayScale: 20,
          },

          {
            name: 'armor',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The armor this building has. 1 armor reduces all incoming damage by 1.',
            default_: 1,
            logic: true,
          },

          {
            name: 'supply',
            type: 'integer',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of supply this unit uses.',
            default_: 0,
            logic: true,
          },

          {
            name: 'supplyProvided',
            type: 'integer',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of supply this unit provides.',
            default_: 0,
            logic: true,
          },

          {
            name: 'weaponCooldown',
            type: 'float',
            min_val: 0.1,
            max_val: 99999999,
            description: 'The time it takes for this building to fire again when it just fired.',
            default_: 20,
            logic: true,
            displayScale: 1 / 20,
          },

          {
            name: 'weaponDelay',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The time it takes for this building to actually fire when an attack is initiated.',
            default_: 20,
            logic: true,
            displayScale: 1 / 20,
          },

          {
            name: 'dmg',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The damage this building does with one attack.',
            default_: 10,
            logic: true,
          },

          {
            name: 'dmgModifierAttributes',
            type: 'selection',
            description: 'The filter that target unit has to meet for the damage modifiers to be applied',
            isArray: true,
            values: targetFilters1,
            default_: 'isHuman',
            default2_: [],
            logic: true,
            group: 'dmgModifiers',
            subName: 'filter',
            groupDescription: 'The unit can have different damage for different types of units, for example it can do +3 damage vs mechanical units, or it can do +50% vs flying units.',
          },

          {
            name: 'dmgModifierAddition',
            type: 'float',
            min_val: -999999,
            max_val: 9999999,
            description: 'This value will be added to the damage value, if it meets the filter atribute.',
            default_: 0,
            default2_: [],
            isArray: true,
            logic: true,
            group: 'dmgModifiers',
            subName: 'add',
            groupDescription: 'The unit can have different damage for different types of units, for example it can do +3 damage vs mechanical units, or it can do +50% vs flying units.',
          },

          {
            name: 'dmgModifierMultiplier',
            type: 'float',
            min_val: -999999,
            max_val: 9999999,
            description: 'The damage value will be multiplied with this value, if it meets the filter atributes.',
            default_: 1,
            default2_: [],
            isArray: true,
            logic: true,
            group: 'dmgModifiers',
            subName: 'multiply',
            groupDescription: 'The unit can have different damage for different types of units, for example it can do +3 damage vs mechanical units, or it can do +50% vs flying units.',
          },

          {
            name: 'lifesteal',
            type: 'float',
            min_val: -99999999,
            max_val: 99999999,
            description: 'The % of the damage this unit gets as HP when dealing dmg (0.5 means it gets half the dmg it deals as HP).',
            default_: 0,
            logic: true,
          },

          {
            name: 'armorPenetration',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of armor this unit ignores when dealing damage.',
            default_: 0,
            logic: true,
          },

          {
            name: 'percDmg',
            type: 'float',
            min_val: -1,
            max_val: 1,
            description: 'The percentual damage this unit does. For example 0.2 means it does 20% (of target max hp) dmg.',
            default_: 0,
            logic: true,
          },

          {
            name: 'dmgCap',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The min possible value this units damage can be after applying the defenders armor. If you set this to 2 for example, the damage will always be at least 2, even if the defenders armor would reduce to less than 2 normally.',
            default_: 1,
            logic: true,
          },

          {
            name: 'range',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The attack range of this building.',
            default_: 0.2,
            logic: true,
          },

          {
            name: 'minRange',
            type: 'float',
            min_val: -999,
            max_val: 999,
            description: 'The minimum attack range of this unit. Other units close that this can not be attacked. Set to -1 for no min attack range',
            default_: -999,
            logic: true,
          },

          {
            name: 'aoeRadius',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'If this is bigger than 0, the building will deal aoe damage (= area of effect). That means not only the target unit takes damage, but all units in range of the target unit.',
            default_: 0,
            logic: true,
          },

          {
            name: 'bouncePower',
            type: 'float',
            min_val: 0.0,
            max_val: 99.0,
            description: 'If this is set to higher than 0, this unit will smash target units back when attacking them. It only affects units with power less than this bouncePower.',
            default_: 0,
            logic: true,
          },

          {
            name: 'bounceDistMin',
            type: 'float',
            min_val: 0.0,
            max_val: 99.0,
            description: 'The min range of how far this unit smashes target units back.',
            default_: 0,
            logic: true,
          },

          {
            name: 'bounceDistMax',
            type: 'float',
            min_val: 0.0,
            max_val: 99.0,
            description: 'The max range of how far this unit smashes target units back.',
            default_: 0,
            logic: true,
          },

          {
            name: 'attackPrio',
            type: 'float',
            min_val: -99999,
            max_val: 999999,
            description: 'Units with higher attack prios get attacked first.',
            default_: 5,
            logic: true,
          },

          {
            name: 'vision',
            type: 'float',
            min_val: -1,
            max_val: 20,
            description: 'The vision range of the building.',
            default_: 7,
            logic: true,
          },

          {
            name: 'projectileSpeed',
            type: 'float',
            min_val: 0.02,
            max_val: 99999999,
            description: 'Only relevant if this is a ranged building. The speed which the projectile travels.',
            default_: 8,
            logic: true,
          },

          {
            name: 'projectileLen',
            type: 'float',
            min_val: 0.02,
            max_val: 10,
            description: 'Only relevant if this is a ranged building with basic arrow projectiles. The length of the projectile.',
            default_: 0.2,
          },

          {
            name: 'attackLaunchSound',
            type: 'selection',
            values: SOUND,
            description: 'The sound that plays when this building fires.',
            default_: SOUND.NONE,
            logic: true,
          },

          {
            name: 'attackEffect',
            type: 'selection',
            description: 'The effect, that shows when this unit is attacking (only relevant for ranged units).',
            values: list_attack_effects,
            default_: null,
            logic: true,
          },

          {
            name: 'projectileStartHeight',
            type: 'float',
            min_val: -99,
            max_val: 99,
            description: 'The (only visual) height of projectiles that this unit shoots.',
            default_: 0,
          },

          {
            name: 'circleSize',
            type: 'float',
            min_val: 0.02,
            max_val: 20,
            description: 'The size of the selection circle of this building.',
            default_: 2.2,
          },

          {
            name: 'imageScale',
            type: 'float',
            min_val: 0.1,
            max_val: 10,
            description: 'If you put another value than 1, the image will be scaled, so the building becomes bigger or smaller (only visual, no gameplay effect).',
            default_: 1,
          },

          {
            name: 'circleOffset',
            type: 'float',
            min_val: -99,
            max_val: 99,
            description: 'The y offset of the cirle of this building (only a visual thing).',
            default_: 0.125,
          },

          {
            name: 'buildTime',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The time it takes to build this building.',
            default_: 50,
            logic: true,
            displayScale: 1 / 20,
          },

          {
            name: 'goldPerDelivery',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The amout of gold a player gets per delivery, when mining from this building.',
            default_: 5,
            logic: true,
          },

          {
            name: 'cost',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of gold it costs to build this unit.',
            default_: 150,
            logic: true,
          },

          {
            name: 'costIncrease',
            type: 'float',
            min_val: -99999999,
            max_val: 99999999,
            description: 'The amount of gold-cost-increase for this building. So the building gets more expensive the more you have.',
            default_: 150,
            logic: true,
          },

          {
            name: 'costIncreaseGroup',
            type: 'selection',
            values: lists.unitTypes,
            default_: null,
            default2_: [],
            logic: true,
            isArray: true,
            description: 'If this building has a costIncrese value, you put here all buildings, that increase this buildings cost.',
          },

          {
            name: 'healthbarOffset',
            type: 'float',
            min_val: -99,
            max_val: 99,
            description: 'The y offset of the health bar (only a visual thing).',
            default_: 0.95,
          },

          {
            name: 'healthbarWidth',
            type: 'float',
            min_val: 0.1,
            max_val: 99,
            description: 'The width of the health bar.',
            default_: 1.7,
          },

          {
            name: 'selectionOffsetY',
            type: 'float',
            min_val: -99,
            max_val: 99,
            description: 'The y offset of where the building should be selected.',
            default_: 0,
          },

          {
            name: 'img',
            type: 'selection',
            values: lists.imgs,
            description: 'The buildings image.',
            default_: lists.imgs.castle,
            special: 'imgPreview',
          },

          {
            name: 'description',
            type: 'string',
            max_len: 300,
            min_len: 0,
            description: 'The description of the building.',
            default_: '',
          },

          {
            name: 'tabPriority',
            type: 'float',
            min_val: -99,
            max_val: 99,
            description: 'Buttons of building with higher tab priorities will be displayed first. When selecting two different types and both have special abilities, then the buttons of the building with higher tab priority will be displayed.',
            default_: 5,
          },

          {
            name: 'drawOffsetY',
            type: 'float',
            min_val: -99,
            max_val: 99,
            description: 'Y offset of the building when drawn.',
            default_: 6,
          },

          {
            name: 'size',
            type: 'integer',
            min_val: 1,
            max_val: 5,
            description: 'The size of the building (in fields). 3 means the building will be 3x3 fields (squares).',
            default_: 1,
            logic: true,
          },

          {
            name: 'repairRate',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of HP this unit restores when repairing (per sec).',
            default_: 0,
            logic: true,
            displayScale: 20,
          },

          {
            name: 'startGold',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'Only relevant for mines. The amount of gold, this building holds.',
            default_: 0,
            logic: true,
          },

          {
            name: 'timeToMine',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'Only relevant for mines or gold-taking buildings. The time it takes for a worker to grab / bring gold.',
            default_: 20,
            logic: true,
          },

          {
            name: 'miningEfficiencyCoefficient',
            type: 'float',
            min_val: 0,
            max_val: 10,
            description: 'Only relevant for mines or gold-taking buildings. This determines how fast workers mine after the first one. If this is set to 0.5 for example, a worker only mines at 50% speed when theres already another worker working on this mine. A third worker only works at 25% speed and so on.',
            default_: 0.5,
            logic: true,
          },

          {
            name: 'minMiningRate',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The absolute min rate workers will be mining at this building. The miningEfficiencyCoefficient value will make additional workers mine less effective, but they will never mine slower than minMiningRate.',
            default_: 0.1,
            logic: true,
          },

          {
            name: 'maxWorkers',
            type: 'integer',
            min_val: 0,
            max_val: 99,
            description: 'The max amount of workers that can work on this building.',
            default_: 6,
            logic: true,
          },

          {
            name: 'limit',
            type: 'integer',
            min_val: 0,
            max_val: 999999,
            description: 'Set this to a number bigger than 0 to limit the amount of instances of this building a player can make.',
            default_: 0,
            logic: true,
          },

          {
            name: 'visionHeightBonus',
            type: 'integer',
            min_val: 0,
            max_val: 99,
            description: 'Usually units can not look at higher grounds. With this value set they can look up X cliff levels. A unit being on height level 1 and having a visionHeightBonus of 1 can see height level 2, but not 3.',
            default_: 0,
            logic: true,
          },

          {
            name: 'commands',
            type: 'commands',
            isObject: true,
            description: 'Here are all the abilites stored, that this building can execute.',
            logic: true,
          },

          {
            name: 'lifetime',
            type: 'float',
            min_val: 0,
            max_val: 999999,
            description: 'When this is bigger than 0, the unit will only live for a certain amount of time.',
            default_: 0,
            logic: true,
            displayScale: 1 / 20,
          },

          {
            name: 'goldReward',
            type: 'integer',
            min_val: -999999,
            max_val: 999999,
            description: 'If this is not 0, a player who kills this unit will get gold rewarded according to this value.',
            default_: 0,
            logic: true,
          },

          {
            name: 'maxUnitsToRepair',
            type: 'integer',
            min_val: 0,
            max_val: 999999,
            description: 'Here you can determine, how many unit can repair this unit at a time.',
            default_: 1,
            logic: true,
          },

          {
            name: 'modifiers',
            type: 'selection',
            isArray: true,
            values: lists.modifiers,
            description: 'Modifiers this unit applies to other units when attacking them.',
            default_: null,
            default2_: [],
            logic: true,
          },

          {
            name: 'modifiersSelf',
            type: 'selection',
            isArray: true,
            values: lists.modifiers,
            description: 'Modifiers this unit applies to ITSELF when attacking (other units).',
            default_: null,
            default2_: [],
            logic: true,
          },

          {
            name: 'onDamageModifiers',
            type: 'selection',
            isArray: true,
            values: lists.modifiers,
            description: 'Modifiers this unit applies to ITSELF when after taking damage',
            default_: null,
            default2_: [],
            logic: true,
          },

          {
            name: 'spawnModifiers',
            type: 'selection',
            isArray: true,
            values: lists.modifiers,
            description: 'The modifiers this unit gets when it spawns.',
            default_: null,
            default2_: [],
            logic: true,
          },

          {
            name: 'deathSound',
            type: 'selection',
            values: SOUND,
            description: 'The sound that gets played when this building is destroyed.',
            default_: SOUND.BUILDING_DEATH,
          },

          {
            name: 'clickSound',
            type: 'selection',
            values: SOUND,
            description: 'The sound that gets played when this building gets selected.',
            default_: null,
          },

          {
            name: 'clickSoundVolume',
            type: 'float',
            min_val: 0,
            max_val: 1.0,
            description: 'The volume of the sound that gets played when this building gets selected.',
            default_: 1.0,
          },

          {
            name: 'hoverText',
            type: 'string',
            min_len: 0,
            max_len: 1000,
            description: 'If you enter a text here, it will be displayed instead of the owners\' name when hovering this building.',
            default_: '',
          },

          {
            name: 'canHaveWaypoint',
            type: 'bool',
            description: 'If this is true, this unit can set a waypoint (waypoints are used to tell spawning units where to go, so this usually makes sense if this unit can produce units)',
            default_: false,
            logic: true,
          },

          {
            name: 'causesFlameDeath',
            type: 'bool',
            description: 'If this is true, then units killed by this unit will burn for some seconds (only visual, no gameplay effect).',
            default_: false,
          },

          {
            name: 'hitscan',
            type: 'bool',
            description: 'Units that use hitscan, can not shoot through other units or obstacles, but need to have free space between them and their target in order to be able to shoot it. Their projectiles also can be intercepted if something moves in their way.',
            default_: false,
            logic: true,
          },

          {
            name: 'maximizeRangeWhenShooting',
            type: 'bool',
            description: 'Always shoot at max range. Only works on not heatseeking units. Makes sense on hitscan units.',
            default_: false,
            logic: true,
          },

          {
            name: 'hitsFriendly',
            type: 'bool',
            description: 'Determines if this unit attack affects friendly units (only relevant on aoe abilities).',
            default_: true,
            logic: true,
          },

          {
            name: 'hitsEnemy',
            type: 'bool',
            description: 'Determines if this unit attack affects enemy units (only relevant on aoe abilities).',
            default_: true,
            logic: true,
          },

          {
            name: 'canAttackGround',
            type: 'bool',
            description: 'Is the building able to attack ground units ?',
            default_: true,
            logic: true,
          },

          {
            name: 'canAttackFlying',
            type: 'bool',
            description: 'Determines if this building can attack flying units.',
            default_: false,
            logic: true,
          },

          {
            name: 'isHeatSeeking',
            type: 'bool',
            description: 'If this is false, hits by this unit can miss and will hit where the target unit was, what the attack was started.',
            default_: true,
            logic: true,
          },

          {
            name: 'ignoreEnemyHitscan',
            type: 'bool',
            description: 'If this is true, the unit will be shootable for enemy units, that use hitscan, even if something is in the way. Makes sense for example on air units.',
            default_: false,
            logic: true,
          },

          {
            name: 'controllable',
            type: 'bool',
            description: 'If this is false, the unit can not be controlled by the player.',
            default_: true,
            logic: true,
          },

          {
            name: 'hasDetection',
            type: 'bool',
            description: 'If its true, this unit can detect invisible units.',
            default_: false,
            logic: true,
          },

          {
            name: 'expOnlyFromOwnKills',
            type: 'bool',
            description: 'If true, this unit gets only experience when it actually kills a unit itself, but not when its just in range when an enemy unit is killed by another allied unit.',
            default_: false,
            logic: true,
          },

          {
            name: 'alliesGetExperience',
            type: 'bool',
            description: 'If true, allied units get experience when killing this unit.',
            default_: false,
            logic: true,
          },

          {
            name: 'alliesGetGold',
            type: 'bool',
            description: 'If true, allied units get gold reward when killing this unit.',
            default_: false,
            logic: true,
          },

          {
            name: 'isReflectingProjectiles',
            type: 'bool',
            description: 'If this is true, this unit reflects projectiles that would hit it otherwise. Only affects projectiles that deal damage while flying.',
            default_: false,
            logic: true,
          },

          {
            name: 'isBlockingProjectiles',
            type: 'bool',
            description: 'If this is true, this unit blocks (kills) projectiles that would hit it otherwise. Only affects projectiles that deal damage while flying.',
            default_: false,
            logic: true,
          },

          {
            name: 'takeDamageOnBlock',
            type: 'bool',
            description: 'If this unit blocks or reflects a projectile, this field determines if it is taking damage from the projectile.',
            default_: false,
            logic: true,
          },

          {
            name: 'isInvincible',
            type: 'bool',
            description: 'If this is true, the building can not be attacked or damaged.',
            default_: false,
            logic: true,
          },

          {
            name: 'isInvisible',
            type: 'bool',
            description: 'Invisible units can only be attacked when detected.',
            default_: false,
            logic: true,
          },

          {
            name: 'alwaysNeutral',
            type: 'bool',
            description: 'Determines if this building is always neutral (can not be owned by a player).',
            default_: false,
            logic: true,
          },

          {
            name: 'takesGold',
            type: 'bool',
            description: 'Determines if this building can be used to return gold by workers.',
            default_: false,
            logic: true,
          },

          {
            name: 'spawnWithAMove',
            type: 'bool',
            description: 'If this is true, units this unit produces will use AMove command when spawning to walk to the waypoint instead of normal move.',
            default_: false,
            logic: true,
          },

          {
            name: 'preventsReveal',
            type: 'bool',
            description: 'If a player has no buildings that prevent revealing, he will be revealed. That means all his buildings become visible to other players.',
            default_: true,
            logic: true,
          },

          {
            name: 'preventsLoss',
            type: 'bool',
            description: 'If a player has no buildings or units that prevent losing, he will be eliminated.',
            default_: true,
            logic: true,
          },

          {
            name: 'isMechanical',
            type: 'bool',
            description: 'Mechanical units (and all buildings) can be repaired and not healed.',
            default_: false,
            logic: true,
          },

          {
            name: 'isUndead',
            type: 'bool',
            description: 'Undead units take damage from healing spells.',
            default_: false,
            logic: true,
          },

          {
            name: 'isBiological',
            type: 'bool',
            description: 'Classification for unit types. Does not have any active effects but there can be abilities that only work for certain unit types. For example the \'Heal\' spell only works with biological units.',
            default_: false,
            logic: true,
          },

          {
            name: 'isBeast',
            type: 'bool',
            description: 'Classification for unit types. Does not have any active effects but there can be abilities that only work for certain unit types. For example the \'Heal\' spell only works with biological units.',
            default_: false,
            logic: true,
          },

          {
            name: 'isHuman',
            type: 'bool',
            description: 'Classification for unit types. Does not have any active effects but there can be abilities that only work for certain unit types. For example the \'Heal\' spell only works with biological units.',
            default_: false,
            logic: true,
          },

          {
            name: 'noShow',
            type: 'bool',
            description: 'If this is true, the unit will not be drawn.',
            default_: false,
            logic: true,
          },

        ];


        var ability_fields = [

          {
            name: 'name',
            type: 'string',
            max_len: 30,
            min_len: 1,
            description: 'The abilities name',
            default_: 'new_ability',
            logic: true,
          },

          {
            name: 'type',
            type: 'selection',
            values: EDITOR_COMMANDS,
            all_values: COMMAND,
            description: 'The abilities type (determines what the basic function of the ability is)',
            default_: EDITOR_COMMANDS.UNIVERSAL,
            descriptions: commandTypeDescriptions,
            logic: true,
          },

          {
            name: 'unitType',
            type: 'selection',
            values: lists.unitTypes,
            description: 'The unit type or building type that this ability produces.',
            default_: null,
            logic: true,
          },

          {
            name: 'hotkey',
            type: 'selection',
            values: KEY,
            description: 'The abilities hotkey',
            default_: KEY.Q,
          },

          {
            name: 'targetIsPoint',
            type: 'bool',
            description: 'Determines if the target is a point.',
            default_: false,
            logic: true,
          },

          {
            name: 'targetIsUnit',
            type: 'bool',
            description: 'Determines if the target is a unit.',
            default_: false,
            logic: true,
          },

          {
            name: 'isInstant',
            type: 'bool',
            description: 'Determines if this order is instant (no target).',
            default_: false,
            logic: true,
          },

          {
            name: 'isChanneled',
            type: 'bool',
            description: 'Channeled spells are being cast repediately until the caster is being ordered a different order (or doesnt have enough mana anymore) instead of only once like normal spells.',
            default_: false,
            logic: true,
          },

          {
            name: 'playLaunchSoundOnce',
            type: 'bool',
            description: 'When this spell is channeled, you can choose to play the launch sound only once while channeling.',
            default_: false,
            logic: true,
          },

          {
            name: 'useAoeCursor',
            type: 'bool',
            description: 'Determines if the mouse cursor becomes an aoe indicator when searching a target for this ability (only works / makes sense for ranged abilities with aoe damage).',
            default_: false,
          },

          {
            name: 'cursor',
            type: 'selection',
            values: Cursors,
            all_values: Cursors,
            description: 'The cursor displayed when the user selects the ability.',
            default_: Cursors.DEFAULT,
          },

          {
            name: 'commandCard',
            type: 'integer',
            min_val: 0,
            max_val: 99,
            description: 'Which command card the button will be. 0 is the default one, 1 is the 1st sub command card (for example for workers all the make building commands are on sub command cards).',
            default_: 0,
          },

          {
            name: 'interfacePosX',
            type: 'integer',
            min_val: 0,
            max_val: 4,
            description: 'The x pos of the button on the command card (0 is very left, 4 is very right).',
            default_: 0,
          },

          {
            name: 'interfacePosY',
            type: 'integer',
            min_val: 0,
            max_val: 1,
            description: 'The y pos of the button on the command card (0 is top row, 1 is bottom row).',
            default_: 0,
          },

          {
            name: 'requiredLevels',
            type: 'integer',
            min_val: 0,
            max_val: 999999,
            isArray: true,
            description: 'If you want the ability to be learnable, you can put here one one more levels, that the unit needs to reach before it can learn this ability (only makes sense if you put the ability on a unit that can have levels of course). Put more values for multi level abilities, the first value will be the unit level required for ability lvl 1, the 2nd value the unit level required for ability lvl 2 and so on ...',
            default_: 0,
            default2_: [],
            logic: true,
          },

          {
            name: 'learnCommandCard',
            type: 'integer',
            min_val: 0,
            max_val: 99,
            description: 'Which command card the learn button will be. 0 is the default one, 1 is the 1st sub command card (for example for workers all the make building commands are on sub command cards). This is required when this ability has to be learned first, where you want the button for learning it to be.',
            default_: 0,
          },

          {
            name: 'learnInterfacePosX',
            type: 'integer',
            min_val: 0,
            max_val: 4,
            description: 'The x pos of the learn button on the command card (0 is very left, 4 is very right). This is required when this ability has to be learned first, where you want the button for learning it to be.',
            default_: 0,
          },

          {
            name: 'learnInterfacePosY',
            type: 'integer',
            min_val: 0,
            max_val: 1,
            description: 'The y pos of the learn button on the command card (0 is top row, 1 is bottom row). This is required when this ability has to be learned first, where you want the button for learning it to be.',
            default_: 0,
          },

          {
            name: 'learnHotkey',
            type: 'selection',
            values: KEY,
            description: 'The abilities hotkey',
            default_: KEY.Q,
          },

          {
            name: 'image',
            type: 'selection',
            values: lists.imgs,
            description: 'The abilities image (that shows on the button)',
            default_: lists.imgs.stop,
            special: 'imgPreview',
          },

          {
            name: 'dance_img',
            type: 'selection',
            values: ['dance1', 'dance2'],
            description: 'The animation played when this dance command is used.',
            default_: 'dance1',
          },

          {
            name: 'attackEffectInit',
            type: 'selection',
            values: list_attack_effects,
            description: 'The graphic effect that appears when start using this ability.',
            default_: list_attack_effects.spell,
            logic: true,
          },

          {
            name: 'attackEffect',
            type: 'selection',
            description: 'The graphic effect, that shows when this ability is used.',
            values: list_attack_effects,
            default_: null,
            logic: true,
          },

          {
            name: 'description',
            type: 'string',
            max_len: 500,
            min_len: 0,
            description: 'The abilities description',
            default_: '',
          },

          {
            name: 'requirementType',
            type: 'selection',
            isArray: true,
            values: lists.buildingsUpgrades,
            description: 'The building or research type for the requirement. Put Barracks here for example, then put 1 for level, that will make this ability require at least 1 barracks.',
            default_: lists.buildingsUpgrades.house,
            default2_: [],
            logic: true,
            group: 'requirements',
            subName: 'type',
            groupDescription: 'Here you can put tech requirements, like for example a specific upgrade or a specific building is required to use this ability.',
          },

          {
            name: 'requirementLevel',
            type: 'integer',
            isArray: true,
            min_val: 0,
            max_val: 9999,
            description: 'The level that the required building / research has to be.',
            default_: 1,
            default2_: [],
            logic: true,
            group: 'requirements',
            subName: 'level',
            groupDescription: 'Here you can put tech requirements, like for example a specific upgrade or a specific building is required to use this ability.',
          },

          {
            name: 'requirementText',
            type: 'string',
            isArray: true,
            max_len: 300,
            min_len: 0,
            description: 'The description for failed requirement mets.',
            default_: '',
            default2_: [],
            logic: true,
            group: 'requirements',
            subName: 'text',
            groupDescription: 'Here you can put tech requirements, like for example a specific upgrade or a specific building is required to use this ability.',
          },

          {
            name: 'targetRequirements1',
            type: 'selection',
            isArray: true,
            values: targetRequirements,
            description: 'The requirements the target has to fit. If you put multiple requirements into one field, only one of them has to fit.',
            default_: targetRequirements.isBiological,
            default2_: [],
            logic: true,
          },

          {
            name: 'targetRequirements2',
            type: 'selection',
            isArray: true,
            values: targetRequirements,
            description: 'The requirements the target has to fit. If you put multiple requirements into one field, only one of them has to fit.',
            default_: targetRequirements.isBiological,
            default2_: [],
            logic: true,
          },

          {
            name: 'targetRequirements3',
            type: 'selection',
            isArray: true,
            values: targetRequirements,
            description: 'The requirements the target has to fit. If you put multiple requirements into one field, only one of them has to fit.',
            default_: targetRequirements.isBiological,
            default2_: [],
            logic: true,
          },

          {
            name: 'launchSound',
            type: 'selection',
            values: SOUND,
            description: 'The sound that plays when the ability starts.',
            default_: SOUND.NONE,
            logic: true,
          },

          {
            name: 'upgrade',
            type: 'selection',
            values: lists.upgrades,
            description: 'The upgrade that will be researched.',
            default_: null,
            logic: true,
          },

          {
            name: 'improvedBuilding',
            type: 'selection',
            values: lists.buildingTypes,
            description: 'The building that the building will be upgraded to.',
            default_: null,
            logic: true,
          },

          {
            name: 'manaCost',
            type: 'integer',
            min_val: -9999,
            max_val: 9999,
            description: 'The mana cost of this ability. Put multiple values if you want to create a multiple level ability. First value will be level 1, 2nd level 2 and so on ...',
            default_: 0,
            default2_: [0],
            logic: true,
            isArray: true,
          },

          {
            name: 'goldCost',
            type: 'integer',
            min_val: -9999,
            max_val: 9999,
            description: 'The gold cost of this ability.',
            default_: 0,
            logic: true,
          },

          {
            name: 'chat_str',
            type: 'string',
            max_len: 30,
            min_len: 0,
            description: 'The chat string that will trigger this ability. An empty string means this ability cannot be triggered by a chat.',
            default_: '',
            hide: true,
          },

          {
            name: 'aoeRadius',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'If this is bigger than 0, the ability will deal aoe damage (= area of effect). That means not only the target unit takes damage, but all units in range of the target unit. Put multiple values if you want to create a multiple level ability. First value will be level 1, 2nd level 2 and so on ...',
            default_: 0,
            default2_: [0],
            logic: true,
            isArray: true,
          },

          {
            name: 'damage',
            type: 'float',
            min_val: -99999999,
            max_val: 99999999,
            description: 'The damage this ability does. Put multiple values if you want to create a multiple level ability. First value will be level 1, 2nd level 2 and so on ...',
            default_: 0,
            default2_: [0],
            logic: true,
            isArray: true,
          },

          {
            name: 'projectileDamage',
            type: 'float',
            min_val: -99999999,
            max_val: 99999999,
            description: 'The damage the projectile does while flying. Damage will be dealt every 1 / 20 sec. So if you put 2 here, the projectile will deal 40 dmg per sec. Put multiple values if you want to create a multiple level ability. First value will be level 1, 2nd level 2 and so on ...',
            default_: 0,
            default2_: [0],
            logic: true,
            isArray: true,
          },

          {
            name: 'projectileAoeRadius',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The aoe radius in which the projectile does damage while flying. Put multiple values if you want to create a multiple level ability. First value will be level 1, 2nd level 2 and so on ...',
            default_: 0,
            default2_: [0],
            isArray: true,
            logic: true,
          },

          {
            name: 'maximizeRangeWhenCasting',
            type: 'bool',
            description: 'If this is true, the spell gets cast at full range even when the target point is closer than max range. You usually want this for spells that have damaging projectiles, because the projectile should fly as long as possible.',
            default_: false,
            logic: true,
          },

          {
            name: 'hitsFriendly',
            type: 'bool',
            description: 'Determines if this ability affects friendly units (only relevant on aoe abilities).',
            default_: true,
            logic: true,
          },

          {
            name: 'hitsEnemy',
            type: 'bool',
            description: 'Determines if this ability affects enemy units (only relevant on aoe abilities).',
            default_: true,
            logic: true,
          },

          {
            name: 'hitsSelf',
            type: 'bool',
            description: 'Determines if this ability affects the casting unit itself (only relevant on aoe abilities).',
            default_: true,
            logic: true,
          },

          {
            name: 'targetFilters',
            type: 'string',
            isArray: true,
            max_len: 50,
            min_len: 0,
            description: 'Here you can put one or more fields that the target units have to meet to be hit (for exaple flying, isBiological, isMechanical, isUnit, isBuilding, ...).',
            default_: '',
            default2_: [],
            logic: true,
          },

          {
            name: 'targetFiltersExclude',
            type: 'string',
            isArray: true,
            max_len: 50,
            min_len: 0,
            description: 'The same as targetFilters, but these filters will exclude units from being a target instead of including them.',
            default_: '',
            default2_: [],
            logic: true,
          },

          {
            name: 'effectScale',
            type: 'float',
            min_val: 0,
            max_val: 99,
            description: 'The scaling of the attack effect graphic (only graphic, no gameplay effect).',
            default_: 1,
            logic: true,
          },

          {
            name: 'hasAutocast',
            type: 'bool',
            description: 'If set to true, this ability can be set to be cast automatically.',
            default_: false,
            logic: true,
          },

          {
            name: 'autocastDefault',
            type: 'bool',
            description: 'If set to true, autocast is enabled by default (only makes sense, if hasAutocast is enabled, of course).',
            default_: false,
            logic: true,
          },

          {
            name: 'autocastConditions',
            realTimeCompile: true,
            type: 'string',
            max_len: 100,
            min_len: 0,
            description: 'If this ability has autocast, you can use this to tell the AI what targets to use for autocasting. Write something like hp > 10 and units that have hp bigger than 10 will be targetted. use && to combine multiple conditions with a logical AND, use || to combine multiple conditions with a logical OR. Use type.fieldname to refer to the units basic types fields. If you use hp, its the current units hp, if you use type.hp, its its basic hp. So if you use hp < type.hp for example, you get units that currently have hp less then their full hp. Use this to refer to the casting unit. For example this.owner = owner will only hit units that have the same owner as the casting unit.',
            default_: '',
            logic: true,
          },

          {
            name: 'projectileSpeed',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The speed which the projectile travels. Put multiple values if you want to create a multiple level ability. First value will be level 1, 2nd level 2 and so on ...',
            default_: 8,
            default2_: [8],
            logic: true,
            isArray: true,
          },

          {
            name: 'duration',
            type: 'float',
            min_val: 0.0,
            max_val: 99999999,
            description: 'If projectileSpeed is 0 then you can set a duration instead, that determines how long it takes for the ability to hit.',
            default_: 0,
            logic: true,
            displayScale: 1 / 20,
          },

          {
            name: 'castingDelay',
            type: 'float',
            min_val: 0.0,
            max_val: 99999999,
            description: 'When a unit starts using this ability there can be a short delay until the ability actually starts kicking in.',
            default_: 0,
            logic: true,
            displayScale: 1 / 20,
          },

          {
            name: 'cooldown',
            type: 'float',
            min_val: 0.0,
            max_val: 99999999,
            description: 'The time the unit cant do any other things after doing this ability.',
            default_: 0,
            logic: true,
            displayScale: 1 / 20,
          },

          {
            name: 'cooldown2',
            type: 'float',
            min_val: 0.0,
            max_val: 99999999,
            description: 'The time it takes for this unit to be able to do this order again after it did it.',
            default_: 0,
            logic: true,
            displayScale: 1 / 20,
          },

          {
            name: 'range',
            type: 'float',
            min_val: 0.0,
            max_val: 99999999,
            description: 'The range of the ability. Put multiple values if you want to create a multiple level ability. First value will be level 1, 2nd level 2 and so on ...',
            default_: 0,
            default2_: [0],
            logic: true,
            isArray: true,
          },

          {
            name: 'minRange',
            type: 'float',
            min_val: -999,
            max_val: 999,
            description: 'The minimum range of this ability. Set to -1 for no min range. Put multiple values if you want to create a multiple level ability. First value will be level 1, 2nd level 2 and so on ...',
            default_: -999,
            default2_: [-999],
            logic: true,
            isArray: true,
          },

          {
            name: 'bounceDistMin',
            type: 'float',
            min_val: 0.0,
            max_val: 99.0,
            description: 'The min range of how far this ability smashes target units back.',
            default_: 0,
            logic: true,
          },

          {
            name: 'bounceDistMax',
            type: 'float',
            min_val: 0.0,
            max_val: 99.0,
            description: 'The max range of how far this ability smashes target units back.',
            default_: 0,
            logic: true,
          },

          {
            name: 'bouncePower',
            type: 'float',
            min_val: 0.0,
            max_val: 99.0,
            description: 'If this is set to higher than 0, the ability will smash target units back. It only affects units with power less than this bouncePower.',
            default_: 0,
            logic: true,
          },

          {
            name: 'targetCC',
            type: 'float',
            min_val: 0,
            max_val: 99,
            description: 'Target Command Card. Determined the number of the command card that will be switched to (0 = basic command card).',
            default_: 0,
          },

          {
            name: 'animationName',
            type: 'string',
            max_len: 300,
            min_len: 0,
            description: 'Name of the animation played when executing this order. The model of the unit must have an ability of this name, otherwise it wont work.',
            default_: '',
          },

          {
            name: 'causesFlameDeath',
            type: 'bool',
            description: 'If this is true, then units killed by this ability will burn for some seconds (only visual, no gameplay effect).',
            default_: false,
            logic: true,
          },

          {
            name: 'modifiers',
            type: 'selection',
            isArray: true,
            values: lists.modifiers,
            description: 'The modifier this ability applies to target unit(s). Put multiple modifiers if you have a multiple level ability. First modifier will be used at level 1, 2nd at level 2 and so on ...',
            default_: null,
            default2_: [],
            logic: true,
          },

          {
            name: 'modifiersSelf',
            type: 'selection',
            isArray: true,
            values: lists.modifiers,
            description: 'The modifier this ability applies to the caster. Put multiple modifiers if you have a multiple level ability. First modifier will be used at level 1, 2nd at level 2 and so on ...',
            default_: null,
            default2_: [],
            logic: true,
          },

          {
            name: 'summonedUnits',
            type: 'selection',
            isArray: true,
            values: lists.unitTypes,
            description: 'Unit, that this ability summons. Put multiple units if you want to create a multiple level ability. First unit will be summoned at level 1, 2nd at level 2 and so on ...',
            default_: null,
            default2_: [],
            logic: true,
          },

          {
            name: 'summonsUseWaypoint',
            type: 'bool',
            description: 'Determines if the summoned unit(s) move to the waypoint of the summoning unit.',
            default_: false,
            logic: true,
          },

          {
            name: 'summonsWaypointAMove',
            type: 'bool',
            description: 'Determines if the summoned units move to the waypoint with attack-move instead of normal move command.',
            default_: false,
            logic: true,
          },

          {
            name: 'ignoreSupplyCheck',
            type: 'bool',
            description: 'If this is true, the summonedUnit will be summoned even if theres not enough free supply.',
            default_: false,
            logic: true,
          },

          {
            name: 'requiresVision',
            type: 'bool',
            description: 'Determines if the casting player needs to have vision at the target point in order to be able to cast this spell.',
            default_: false,
            logic: true,
          },

        ];


        var upgrade_fields = [

          {
            name: 'name',
            type: 'string',
            max_len: 30,
            min_len: 1,
            description: 'The upgrades name',
            default_: 'new_upgrade',
            logic: true,
          },

          {
            name: 'buildTime',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The time it takes to research this upgrade.',
            default_: 30,
            logic: true,
            displayScale: 1 / 20,
          },

          {
            name: 'cost',
            type: 'float',
            min_val: 0,
            max_val: 99999999,
            description: 'The amount of gold it costs to research this upgrade.',
            default_: 100,
            logic: true,
          },

          {
            name: 'maxLevel',
            type: 'integer',
            min_val: 0,
            max_val: 9999,
            description: 'The amount of levels this upgrade has.',
            default_: 1,
            logic: true,
          },

          {
            name: 'description',
            type: 'string',
            max_len: 300,
            min_len: 0,
            description: 'The description of the upgrade.',
            default_: '',
          },

          {
            name: 'image',
            type: 'selection',
            values: lists.imgs,
            description: 'The upgrades image',
            default_: null,
            special: 'imgPreview',
          },

          {
            name: 'effectsTypes',
            type: 'selection',
            isArray: true,
            values: lists.types,
            description: 'The type of the unit / building / upgrade / ability that receives the modification.',
            default_: lists.types.soldier,
            default2_: [],
            logic: true,
            group: 'modification',
            subName: 'type',
            groupDescription: 'Here you can determine which field of which units will be affected by this upgrade and how they will be affected.',
          },

          {
            name: 'effectsFields',
            type: 'string',
            max_len: 300,
            min_len: 0,
            default_: 'damage',
            default2_: [],
            isArray: true,
            description: 'Which field should be modified.',
            logic: true,
            group: 'modification',
            subName: 'field',
            groupDescription: 'Here you can determine which field of which units will be affected by this upgrade and how they will be affected.',
          },

          {
            name: 'effectsModifications',
            type: 'float',
            isArray: true,
            min_val: -99999999,
            max_val: 99999999,
            description: 'How to modify the field. Here you can put a value that will be added.',
            default_: 0.0,
            default2_: [],
            logic: true,
            group: 'modification',
            subName: 'add',
            groupDescription: 'Here you can determine which field of which units will be affected by this upgrade and how they will be affected.',
          },

          {
            name: 'effectsModsMultiplier',
            type: 'float',
            isArray: true,
            min_val: -99999999,
            max_val: 99999999,
            description: 'How to modify the field. Here you can put a value that will be multiplied.',
            default_: 1.0,
            default2_: [],
            logic: true,
            group: 'modification',
            subName: 'multiply',
            groupDescription: 'Here you can determine which field of which units will be affected by this upgrade and how they will be affected.',
          },

          {
            name: 'noParallelResearch',
            type: 'bool',
            description: 'If this is true, the next upgrade level can only be started after the last one is finished. By default, if this is not set, multiple levels can be researched at the same time.',
            default_: false,
            logic: true,
          },

        ];


        var modifiers_fields = [

          {
            name: 'name',
            type: 'string',
            max_len: 30,
            min_len: 1,
            description: 'The modifiers name',
            default_: 'new_modifier',
            logic: true,
          },

          {
            name: 'description',
            type: 'string',
            max_len: 300,
            min_len: 0,
            description: 'The description of the modifier.',
            default_: '',
          },

          {
            name: 'image',
            type: 'selection',
            values: lists.imgs,
            description: 'The modifiers image',
            default_: null,
            special: 'imgPreview',
          },

          {
            name: 'duration',
            type: 'float',
            min_val: -99999999,
            max_val: 99999999,
            description: 'The duration of the modifier. It will be removed after the duration expires. Put 0 or a negative number for endless duration.',
            default_: 60,
            logic: true,
            displayScale: 1 / 20,
          },

          {
            name: 'fields',
            type: 'string',
            max_len: 300,
            min_len: 0,
            default_: 'damage',
            default2_: [],
            isArray: true,
            description: 'The field that will be modified.',
            logic: true,
            group: 'modification',
            subName: 'field',
            groupDescription: 'Here you can determine which field will be affected by this modifier and how.',
          },

          {
            name: 'modifications',
            type: 'float',
            isArray: true,
            min_val: -99999999,
            max_val: 99999999,
            description: 'How the field will be modified. The value in here will be added to the value of the field.',
            default_: 0.0,
            default2_: [],
            logic: true,
            group: 'modification',
            subName: 'add',
            groupDescription: 'Here you can determine which field will be affected by this modifier and how.',
          },

          {
            name: 'modificationsMultiplier',
            type: 'float',
            isArray: true,
            min_val: -99999999,
            max_val: 99999999,
            description: 'How the field will be modified. The value in here will be multiplied with the value of the field.',
            default_: 1.0,
            default2_: [],
            logic: true,
            group: 'modification',
            subName: 'multiply',
            groupDescription: 'Here you can determine which field will be affected by this modifier and how.',
          },

          {
            name: 'maxStack',
            type: 'integer',
            min_val: 0,
            max_val: 9999,
            description: 'How many instances of this modifier can be on one unit. Put 0 for unlimited instancs.',
            default_: 1,
            logic: true,
          },

          {
            name: 'auraModifiers',
            type: 'selection',
            isArray: true,
            values: lists.modifiers,
            description: 'This is the modifier that gets applied. It gets applied every 1.05 sec, so if you want them to be applied constantly, you want to give them a duration of at least something like 1.1 sec.',
            default_: null,
            default2_: [],
            logic: true,
            group: 'aura',
            subName: 'modifier',
            groupDescription: 'Here you can create auras. Put a range and a modifier and the modifier will be applied to all units in range.',
          },

          {
            name: 'auraRange',
            type: 'float',
            isArray: true,
            min_val: 0,
            max_val: 999,
            description: 'Determines the range in which the modifier gets applied.',
            default_: 9,
            default2_: [],
            logic: true,
            group: 'aura',
            subName: 'range',
            groupDescription: 'Here you can create auras. Put a range and a modifier and the modifier will be applied to all units in range.',
          },

          {
            name: 'auraHitsFriendly',
            type: 'bool',
            description: 'Determines if the aura affects the casting players units.',
            default_: true,
            logic: true,
          },

          {
            name: 'auraHitsAllied',
            type: 'bool',
            description: 'Determines if the aura affects units by allied players.',
            default_: true,
            logic: true,
          },

          {
            name: 'auraHitsEnemy',
            type: 'bool',
            description: 'Determines if the aura affects enemy units.',
            default_: true,
            logic: true,
          },

          {
            name: 'auraHitsSelf',
            type: 'bool',
            description: 'Determines if the aura affects the origin unit.',
            default_: true,
            logic: true,
          },

          {
            name: 'auraTargetFilters',
            type: 'selection',
            isArray: true,
            values: targetFilters1,
            description: 'Here you can put one or more fields that the target units have to meet to be hit.',
            default_: 'isHuman',
            default2_: [],
            logic: true,
          },

          {
            name: 'auraTargetFiltersExclude',
            type: 'selection',
            isArray: true,
            values: targetFilters1,
            description: 'The same as targetFilters, but these filters will exclude units from being a target instead of including them.',
            default_: 'isHuman',
            default2_: [],
            logic: true,
          },

          {
            name: 'disabledCommands',
            type: 'selection',
            isArray: true,
            values: lists.commands,
            description: 'Abilities / commands that get disabled for the target unit while being under the influence of this modifier.',
            default_: lists.commands.flamestrike,
            default2_: [],
            logic: true,
          },

          {
            name: 'changeUnitImg',
            type: 'bool',
            description: 'Determines if this modifier changes the img of the unit.',
            default_: false,
          },

          {
            name: 'unitImg',
            type: 'selection',
            values: lists.imgs,
            description: 'Changes the units img to this img. Only works, when changeUnitImg is set.',
            default_: null,
          },

          {
            name: 'changeAttackEffect',
            type: 'bool',
            description: 'Determines if this modifier changes the attack effect of the unit (only graphic).',
            default_: false,
            logic: true,
          },

          {
            name: 'attackEffect',
            type: 'selection',
            values: list_attack_effects,
            description: 'Changes the units attack effect to this effect. Only works, when changeAttackEffect is set.',
            default_: null,
            logic: true,
          },

          {
            name: 'effects',
            type: 'selection',
            isArray: true,
            values: list_attack_effects,
            description: 'Graphic effects that will be displayed on a unit that has this modifier',
            default_: null,
            default2_: [],
          },

          {
            name: 'auraColor',
            type: 'complex',
            default_: { red: 150, green: 250, blue: 180, alpha: 0.2 },
            values: [
              { name: 'red', type: 'integer', min_val: 0, max_val: 255, description: 'The red component of the color.', default_: 150 },
              { name: 'green', type: 'integer', min_val: 0, max_val: 255, description: 'The green component of the color.', default_: 250 },
              { name: 'blue', type: 'integer', min_val: 0, max_val: 255, description: 'The blue component of the color.', default_: 180 },
              { name: 'alpha', type: 'float', min_val: 0, max_val: 1.0, description: 'The alpha component of the color.', default_: 0.2 },
            ],
            description: 'The color of the aura, if the aura effect is enabled.',
          },

          {
            name: 'sound',
            type: 'selection',
            values: SOUND,
            description: 'The sound that plays when this modifier is active (will be looped).',
            default_: SOUND.NONE,
          },

          {
            name: 'volume',
            type: 'float',
            min_val: 0,
            max_val: 1.0,
            description: 'The volume at which the sound will be played',
            default_: 1.0,
          },

          {
            name: 'killModifiers',
            type: 'selection',
            isArray: true,
            values: lists.modifiers,
            description: 'Here you can put modifiers that will be removed when this modifier gets applied.',
            default_: null,
            default2_: [],
            logic: true,
          },

        ];

        const frameStartData =
          [
            {
              name: 'x',
              type: 'integer',
              min_val: 0,
              max_val: 5000,
              description: 'The x cordinate of the part of the image where this animation starts.',
              default_: 0,
            },

            {
              name: 'y',
              type: 'integer',
              min_val: 0,
              max_val: 5000,
              description: 'The y cordinate of the part of the image where this animation starts.',
              default_: 0,
            },

            {
              name: 'w',
              type: 'integer',
              min_val: 0,
              max_val: 5000,
              description: 'The width (pixels) of the part of the image that contains this animation.',
              default_: 0,
            },

            {
              name: 'h',
              type: 'integer',
              min_val: 0,
              max_val: 5000,
              description: 'The height (pixels) of the part of the image that contains this animation.',
              default_: 0,
            },

            {
              name: 'frameWidth',
              type: 'integer',
              min_val: 0,
              max_val: 5000,
              description: 'The width (pixels) of one animation frame of this animation. The width (w) divided by the frameWidth equels the number of frames for this animation.',
              default_: 0,
            },
          ];

        var editableFrameStartData =
          [
            ...frameStartData,
            {
              name: 'frames',
              type: 'integer',
              isArray: true,
              min_val: 0,
              max_val: 5000,
              description: 'When you have multiple frames, then you can put here in which order they will be played. Each entry will last for 0.05 sec, so if you put 1, 1, 1, 2, 3 for example, then the first frame will be shown for 0.15 sec, then the 2nd frame will be shown for 0.05 sec and then the 3rd frame for 0.05 sec and then it starts all over again.',
              default_: 0,
              default2_: [],
            },
          ];

        var imgs_fields = [

          {
            name: 'name',
            type: 'string',
            max_len: 30,
            min_len: 1,
            description: 'The images name',
            default_: 'new_img',
          },

          {
            name: 'file',
            type: 'selection',
            values: customImgs,
            description: 'The source file',
            default_: null,
          },

          {
            name: '_angles',
            type: 'selection',
            values: possibleAngleCounts,
            description: '4 angle units have 4 views (top, left, right, down), 8 angle units have 8 views (top, left, right, down, top-left, top-right, down-left, down-right). 1 angle units only have one view.',
            default_: 0,
          },

          {
            name: 'idle',
            type: 'complex',
            default_: { x: 0, y: 0, w: 0, h: 0, frameWidth: 0 },
            values: frameStartData,
            description: 'The idle animation frames.',
          },

          {
            name: 'walk',
            type: 'complex',
            default_: { x: 0, y: 0, w: 0, h: 0, frameWidth: 0 },
            values: frameStartData,
            description: 'The walk animation frames.',
          },

          {
            name: 'walkGold',
            type: 'complex',
            default_: { x: 0, y: 0, w: 0, h: 0, frameWidth: 0 },
            values: frameStartData,
            description: 'The walkGold animation frames.',
          },

          {
            name: 'die',
            type: 'complex',
            default_: { x: 0, y: 0, w: 0, h: 0, frameWidth: 0 },
            values: frameStartData,
            description: 'The die animation frames.',
          },

          {
            name: 'attack',
            type: 'complex',
            default_: { x: 0, y: 0, w: 0, h: 0, frameWidth: 0 },
            values: frameStartData,
            description: 'The attack animation frames.',
          },

          {
            name: 'special1',
            type: 'complex',
            default_: { x: 0, y: 0, w: 0, h: 0, frameWidth: 0 },
            values: frameStartData,
            description: 'The special1 animation frames (can be used for casting animation for example)',
          },

          {
            name: 'img',
            type: 'complex',
            default_: { x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: [] },
            values: editableFrameStartData,
            description: 'The main image.',
          },
          {
            name: 'constructionImg',
            type: 'complex',
            default_: { x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: [] },
            values: editableFrameStartData,
            description: 'The image that is shown while the building is under construction. (only required for building images)',
          },

          {
            name: 'damagedImg',
            type: 'complex',
            default_: { x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: [] },
            values: editableFrameStartData,
            description: 'The image that is shown when the building is (heavily) damaged. (only required for building images)',
          },

          {
            name: 'busyImgs',
            type: 'complex',
            default_: { x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: [] },
            values: editableFrameStartData,
            description: 'The image that is shown when the building is busy (training a unit, researching an upgrade). (only required for building images)',
          },

          {
            name: 'busyDamagedImgs',
            type: 'complex',
            default_: { x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: [] },
            values: editableFrameStartData,
            description: 'The image that is shown when the building is damaged and busy (training a unit, researching an upgrade). (only required for building images)',
          },

          {
            name: 'upgradeImg',
            type: 'complex',
            default_: { x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: [] },
            values: editableFrameStartData,
            description: 'The image that is shown when the building is upgrading to a different building. (only required for building images)',
          },

          {
            name: 'upgradeImgDamaged',
            type: 'complex',
            default_: { x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: [] },
            values: editableFrameStartData,
            description: 'The image that is shown when the building is damaged and upgrading to a different building. (only required for building images)',
          },

          {
            name: 'imgEmpty',
            type: 'complex',
            default_: { x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: [] },
            values: editableFrameStartData,
            description: 'The image that is shown when the building used to have gold but has been mined out. (only required for building images)',
          },

        ];


        var targetFilters = [];

        for (var i = 0; i < unit_fields.length; i++) {
          if (unit_fields[i].logic) {
            targetFilters.push(unit_fields[i].name);
          }
        }

        for (var i = 0; i < building_fields.length; i++) {
          if (building_fields[i].logic && !targetFilters.contains(building_fields[i].name)) {
            targetFilters.push(building_fields[i].name);
          }
        }

        targetFilters.push();


        var list_unit_fields = {};
        for (var i = 0; i < unit_fields.length; i++) {
          list_unit_fields[unit_fields[i].name] = unit_fields[i];
        }

        var list_building_fields = {};
        for (var i = 0; i < building_fields.length; i++) {
          list_building_fields[building_fields[i].name] = building_fields[i];
        }

        var list_ability_fields = {};
        for (var i = 0; i < ability_fields.length; i++) {
          list_ability_fields[ability_fields[i].name] = ability_fields[i];
        }

        var list_upgrade_fields = {};
        for (var i = 0; i < upgrade_fields.length; i++) {
          list_upgrade_fields[upgrade_fields[i].name] = upgrade_fields[i];
        }

        var list_modifiers_fields = {};
        for (var i = 0; i < modifiers_fields.length; i++) {
          list_modifiers_fields[modifiers_fields[i].name] = modifiers_fields[i];
        }

        var list_graphic_fields = {};
        for (var i = 0; i < imgs_fields.length; i++) {
          list_graphic_fields[imgs_fields[i].name] = imgs_fields[i];
        }

        function Player(name, controller, number, team, clan, ai_name, skins_, dances) {
          this.name = name;
          this.controller = controller; // Human, remote, cpu, none
          this.gold = game ? game.getStartGold() : START_GOLD;
          this.number = number;
          this.supply = 0; // current supply
          this.lastAttackMessage = 0; // for ai
          this.team = game ? (game.teams[team] ? game.teams[team] : game.teams[0]) : null;
          this.originalTeam = this.team; // gotta be stored, cuz when the game ends, the team of a player changes to 0 (so he gets full vision), but then when the replay is saved, the team needs to be his original team in the replay file
          this.ai_name = ai_name;
          this.clan = clan; // clan name
          this.isRevealed = false;
          this.isAlive = true;

          // camera
          this.cameraX = 0;
          this.cameraY = 0;
          this.cameraWidth = 0;
          this.cameraHeight = 0;
          this.fieldSize = 1;

          // global game variables (supply, tech requirements, ...)
          this.maxSupply = 0;
          this.buildings = {}; // format: {id_string: count}
          this.buildingsUC = {}; // (under construction) format: {id_string: count}
          this.pseudoBuildings = {}; // format: {id_string: count}
          this.upgrades = {}; // format: {id_string: level}
          this.units = {}; // format: {id_string: count}
          this.production = {}; // format: {id_string: {count: count, from: startTick, to: finishTick}};
          this.upgradeMods = {}; // all modified fields from upgrades (format: {fieldName: mod} (for example {dmg: 2} for +2 dmg))

          // statistics
          this.unitKills = 0;
          this.unitDeaths = 0;
          this.buildingKills = 0;
          this.buildingDeaths = 0;
          this.apm = 0;
          this.minedGold = 0;
          this.minedGoldAtTicks = [0];
          this.currentMinedGold = 0;
          this.unspentGold = 0;
          this.goldLost = 0;

          this.lostUnitTypes = {};

          // skins n dances
          // Save the skins and dances as they appear in playerSettings for replays
          this.psSkins = skins_ ? JSON.parse(JSON.stringify(skins_)) : {};
          this.psDances = dances;

          try {
            skins_ = JSON.parse(skins_);
          } catch (e) { }
          if (skins_) {
            _.each(skins_, function (val, key) {
              for (var i = 0; i < skins.length; i++) {
                if (val == skins[i].artNr) {
                  skins_[key] = unit_imgs[skins[i].img] ? unit_imgs[skins[i].img] : null;
                }
              }
            });
          }
          this.skins = skins_;
        };

        Player.prototype.getReplayObject = function () {
          return {
            name: this.name,
            controller: this.controller,
            team: this.originalTeam.number,
            nr: this.number,
            ai_name: this.ai_name,
            clan: this.clan ? this.clan : '',
            skins: this.psSkins,
            dances: this.psDances,
          };
        };

        Player.prototype.getColor = function () {
          var arr = playerTextColors[this.number] ? playerTextColors[this.number] : playerTextColors[0];
          return 'rgb(' + arr[0] + ', ' + arr[1] + ', ' + arr[2] + ')';
        };

        Player.prototype.mineGold = function (amount) {
          this.minedGold += amount;
          this.minedGoldAtTicks[0] += amount;
        };

        Player.prototype.killProduction = function (type, finishTick) {
          if (!this.production[type.id_string]) {
            return;
          }

          if (this.production[type.id_string].to.length <= 1) {
            delete this.production[type.id_string];
            return;
          }

          for (var i = 0; i < this.production[type.id_string].to.length; i++) {
            if (this.production[type.id_string].to[i] == finishTick) {
              this.production[type.id_string].to.splice(i, 1);

              if (this.production[type.id_string].from) {
                this.production[type.id_string].from.splice(i, 1);
              }

              return;
            }
          }
        };

        Player.prototype.startProduction = function (type, finishTick) {
          if (!this.production[type.id_string]) {
            this.production[type.id_string] = finishTick.type ? { to: [finishTick] } : { from: [ticksCounter], to: [finishTick] };
          } else {
            if (finishTick.type) {
              this.production[type.id_string].to.push(finishTick);
            } else {
              this.production[type.id_string].from.push(ticksCounter);
              this.production[type.id_string].to.push(finishTick);
            }
          }
        };

        Player.prototype.unitDies = function (u) {
          this.goldLost += u.type.cost;

          if (!u.type.isUnit) {
            return;
          }

          this.lostUnitTypes[u.type.id_string] = this.lostUnitTypes[u.type.id_string] ? this.lostUnitTypes[u.type.id_string] + 1 : 1;

          if (this.units[u.type.id_string] && this.units[u.type.id_string] > 1) {
            this.units[u.type.id_string]--;
          } else {
            delete this.units[u.type.id_string];
          }
        };

        Player.prototype.unitSpawns = function (u) {
          this.units[u.type.id_string] = this.units[u.type.id_string] ? this.units[u.type.id_string] + 1 : 1;
        };

        // returns the requirement text for a certain command and certain selected units; returns false, if there is no text (= the command can be ordered)
        Player.prototype.getCommandRequirementText = function (command, units, target, learn) {
          var requirement_text = '';

          if (learn) {
            var canLearn = false;

            for (var i = 0; i < units.length; i++) {
              var requiredLevel = command.requiredLevels ? command.requiredLevels[units[i].abilityLevels[command.id]] : -1;

              if (units[i].level >= requiredLevel && units[i].level > units[i].countLearnedAbilities) {
                canLearn = true;
              }
            }

            if (!canLearn) {
              requirement_text += ' Higher level required.';
            }

            return requirement_text == '' ? false : requirement_text;
          }

          // check for lvl
          var lvl = 0;
          for (var i = 0; i < units.length; i++) {
            lvl += units[i].abilityLevels[command.id];
          }

          if (lvl == 0) {
            requirement_text += ' This ability needs to be learned first.';
          }

          // check for mana
          if (units) {
            var hasMana = false;
            for (var i = 0; i < units.length; i++) {
              if (units[i].mana >= command.getValue('manaCost', units[i])) {
                hasMana = true;
              }
            }

            if (!hasMana) {
              requirement_text += ' Not enough mana.';
            }
          }

          // check for gold
          if (command.goldCost && units && units[0].owner.gold < command.goldCost) {
            requirement_text += ' Not enough gold.';
          }

          // check if not disabled
          if (command.type != COMMAND.MOVETO && command.type != COMMAND.MOVE && command.type != COMMAND.CANCEL && command.type != COMMAND.AMOVE && command.type != COMMAND.DANCE) {
            var canOrder = false;
            for (var i = 0; i < units.length; i++) {
              if (units[i].type.commands[command.id_string] && !units[i].disabledCommands[command.id_string]) {
                canOrder = true;
              }
            }

            if (!canOrder) {
              requirement_text += ' This ability is disabled.';
            }
          }

          // limit
          if (command.unitType) {
            var limit = command.unitType.getValue('limit', this);
            if (limit) {
              var count = 0;

              if (this.buildings[command.unitType.id_string]) {
                count += this.buildings[command.unitType.id_string];
              }

              if (this.buildingsUC[command.unitType.id_string]) {
                count += this.buildingsUC[command.unitType.id_string];
              }

              if (this.pseudoBuildings[command.unitType.id_string]) {
                count += this.pseudoBuildings[command.unitType.id_string];
              }

              if (this.units[command.unitType.id_string]) {
                count += this.units[command.unitType.id_string];
              }

              if (this.production[command.unitType.id_string]) {
                count += this.production[command.unitType.id_string];
              }

              if (count >= limit) {
                requirement_text += ' You can only have ' + count + '.';
              }
            }
          }

          // check for max lvl
          if (command.upgrade && this.getUpgradeLevel(command.upgrade) + this.upgradeCountInResearch(command.upgrade) >= command.upgrade.maxLevel) {
            requirement_text += ' Max level reached.';
          }

          // if no parallel research allowed and already researching, ...
          if (command.upgrade && command.upgrade.noParallelResearch && this.upgradeCountInResearch(command.upgrade) > 0) {
            requirement_text += ' Researching at the moment.';
          }

          // check for unique unit make
          if (command.type == COMMAND.MAKEUNIT && command.unitType && command.unitType.uniqueAndHeroic && (this.units[command.unitType.id_string] > 0 || this.production[command.unitType.id_string])) {
            requirement_text += ' You can only have one.';
          }

          if (command.requirementType) {
            for (var i = 0; i < command.requirementType.length; i++) {
              var t = command.requirementType[i];
              if (!t) {
                throw Error(`Command ${command.id} requirement type ${i} was ${t}!\nFull Object:\n${JSON.stringify(command)}`);
              }
              if ((t && t.isBuilding && (this.buildings[t.id_string] ? this.buildings[t.id_string] : 0) < command.requirementLevel[i]) || (t.isUpgrade && (this.upgrades[t.id_string] ? this.upgrades[t.id_string] : 0) < command.requirementLevel[i])) {
                requirement_text += ' ' + command.requirementText[i] + '.';
              }
            }
          }

          if (target && target.type) {
            for (var k = 0; k < command.targetRequiremementsArray.length; k++) {
              var met = false;
              var text = '';

              for (var i = 0; i < command.targetRequiremementsArray[k].length; i++) {
                if (command.targetRequiremementsArray[k][i].func(target)) {
                  met = true;
                } else {
                  text += command.targetRequiremementsArray[k][i].text + ' or ';
                }
              }

              if (!met) {
                requirement_text += text.slice(0, text.length - 4) + ' ';
              }
            }
          }

          return requirement_text == '' ? false : requirement_text;
        };

        Player.prototype.getCostOfNextInstanceForBuilding = function (type) {
          if (!type.costIncrease) {
            return type.cost;
          }

          var cost = type.cost;
          if (type.costIncreaseGroup) {
            for (var i = 0; i < type.costIncreaseGroup.length; i++) {
              cost += (this.buildings[type.costIncreaseGroup[i].id_string] ? this.buildings[type.costIncreaseGroup[i].id_string] : 0) * type.costIncrease;
              cost += (this.buildingsUC[type.costIncreaseGroup[i].id_string] ? this.buildingsUC[type.costIncreaseGroup[i].id_string] : 0) * type.costIncrease;
              cost += (this.pseudoBuildings[type.costIncreaseGroup[i].id_string] ? this.pseudoBuildings[type.costIncreaseGroup[i].id_string] : 0) * type.costIncrease;
            }
          }

          return cost;
        };

        // returns a modifier for a given unit field, based on which upgrades this player has researched
        Player.prototype.getValueModifier = function (value, type, alsoUnderConstruction) {
          var mod = (this.upgradeMods[type.id_string] && this.upgradeMods[type.id_string][value]) ? this.upgradeMods[type.id_string][value] : 0;

          if (alsoUnderConstruction) {
            for (var i = 0; i < game.upgrades.length; i++) {
              var u = game.upgrades[i];
              var count = this.upgradeCountInResearch(u);

              for (var k = 0; k < u.effectsTypes.length; k++) {
                if (u.effectsFields[k] == value && u.effectsTypes[k] == type) {
                  mod += u.effectsModifications[k] * count;
                }

                if (u.effectsModsMultiplier && k in u.effectsModsMultiplier) {
                  for (var j = 0; j < count; j++) {
                    mod += type[value] * (u.effectsModsMultiplier[k] - 1);
                  }
                }
              }
            }
          }

          return mod;
        };

        Player.prototype.getUpgradeLevel = function (upg) {
          return this.upgrades[upg.id_string] ? this.upgrades[upg.id_string] : 0;
        };

        // used to get the color in which the unit selection circles are drawn
        Player.prototype.getAllyColor = function (alpha) {
          var alpha_ = alpha ? alpha : 0.9;

          // if the playing player is spectator, return the player color itself instead of the ally color
          if (PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR && playerColors[this.number - 1]) {
            var arr = playerColors[this.number - 1][4];
            return 'rgba(' + arr[0] + ', ' + arr[1] + ', ' + arr[2] + ', ' + alpha_ + ')';
          }

          // white, if this is the playing player
          if (this == PLAYING_PLAYER) {
            return 'rgba(' + game.theme.line_red + ', ' + game.theme.line_green + ', ' + game.theme.line_blue + ', ' + alpha_ + ')';
          }

          // if neutral (mine), yellow
          if (this.controller == CONTROLLER.NONE) {
            return 'rgba(255, 255, 0, ' + alpha_ + ')';
          }

          // red, if its an enemy player
          if (this.isEnemyOfPlayer(PLAYING_PLAYER)) {
            return 'rgba(224, 0, 0, ' + alpha_ + ')';
          }

          // blue, if allied player
          return 'rgba(100, 160, 255, ' + alpha_ + ')';
        };

        Player.prototype.isEnemyOfPlayer = function (player) {
          if (game.globalVars.isPassiveNeutral) {
            return this.team.number != 0 && player.team.number != 0 && this.team != player.team;
          } else {
            return this.team != player.team;
          }
        };

        Player.prototype.toString = function () {
          return this.name;
        };

        Player.prototype.upgradeCountInResearch = function (upgrade) {
          var c = 0;

          for (var i = 0; i < game.buildings.length; i++) {
            var b = game.buildings[i];
            if (b.owner == this) {
              for (var k = 0; k < BUILDING_QUEUE_LEN; k++) {
                if (b.queue && b.queue[k] == upgrade) {
                  c++;
                }
              }
            }
          }

          return c;
        };

        // parent class for all map objects (units, buildings, doodads / tiles)
        function MapObject() {
          this.lastBlinkStart = 0; // last time this unit started blinking (when clicked on it); ms gametime
          this.isActive = true; // is false, when the unit is in a gold mine for example
          this.isAlive = true;
          this.targetUnit = null;
          this.hitCycle = 0; // when attacking, this gets ++ on every tick, to check when the actual attack happens and to check for cooldown
          this.tickOfDeath = 0; // when did the unit die, used for playing dead animation
          this.nextTickToCheckForNextEnemyUnit = 0; // we save this, because we dont wanna check every tick, but only every 5 ticks or so
          this.provisionalTargetUnit = null;
          this.kills = 0;
          this.isDetectedUntil = -1;
          this.level = 1;
          this.countLearnedAbilities = 0;
          this.queueFinish = 0; // how many ticks left, until the current producing unit is finished
          this.queueStarted = false;
          this.currentBuildTime = 0;
          this.isThrowedUntil = -1;
        };

        MapObject.prototype.initAutocast = function () {
          var arr = [];

          _.each(this.type.commands, function (cmd) {
            if (cmd.hasAutocast && cmd.autocastDefault) {
              arr.push(cmd.id);
            }
          });

          return arr;
        };

        MapObject.prototype.getValue = function (value) {
          return this.type[value] + this.owner.getValueModifier(value, this.type) + (this.modifierMods[value] ? this.modifierMods[value] : 0);
        };

        MapObject.prototype.includesField = function (x, y) {
          return x >= this.x && y >= this.y && x <= this.x + this.type.sizeX - 1 && y <= this.y + this.type.sizeX - 1;
        };

        // return true if building / tile is inside a drawn box on the screen (coords relative to screen position, so we have to add camera coords)
        MapObject.prototype.isInBox = function (x1, y1, x2, y2) {
          return this.drawPos.px + this.type.sizeX / 2 >= x1 && this.drawPos.py + this.type.sizeY / 2 >= y1 && this.drawPos.px - this.type.sizeX / 2 <= x2 && this.drawPos.py - this.type.sizeY / 2 <= y2;
        };

        // return true if building / tile is inside a drawn box on the screen (coords relative to screen position, so we have to add camera coords)
        MapObject.prototype.isInBoxVisible = function (x1, y1, x2, y2) {
          return this.isInBox(x1, y1, x2, y2);
        };

        // remove the unit from the game. Most of the time, when it dies, but also when it enters a building
        MapObject.prototype.remove = function () {
          this.isActive = false;

          game.units.erease(this);
          game.buildings.erease(this);
          game.selectedUnits.erease(this);

          if (game.selectedUnits.length == 0) {
            keyManager.resetCommand();
          }

          // delete from waypoints and target unitz
          var units = game.units.concat(game.buildings);
          for (var i = 0; i < units.length; i++) {
            if (units[i].waypoint) {
              for (var k = 0; k < units[i].waypoint.length; k++) {
                if (units[i].waypoint[k] == this) {
                  units[i].waypoint.splice(k, 1);
                  k--;
                }
              }
            }

            // delete from units targetUnits
            if (units[i].targetUnit == this) {
              units[i].targetUnit = null;
            }
          }

          if (this.type.uniqueAndHeroic) {
            game.units4.push(this);
          }

          // kill all graphic effects on this unit
          for (var k = 0; k < this.effectsToDraw.length; k++) {
            this.effectsToDraw[k].tickOfDeath = ticksCounter + 40;
          }
        };

        MapObject.prototype.initHPAndMana = function () {
          var maxHP = this.getValue('hp');
          var startHP = this.getValue('startHp');
          this.hp = startHP ? startHP : maxHP;
          if (this.hp > maxHP) {
            this.hp = maxHP;
          }

          var maxMana = this.getValue('mana');
          var startMana = this.getValue('startMana');
          this.mana = startMana ? startMana : 0;
          if (this.mana > maxMana) {
            this.mana = maxMana;
          }
        };

        // start blinking the unit circle (when rightclicked)
        MapObject.prototype.blink = function () {
          this.lastBlinkStart = timestamp;
        };

        MapObject.prototype.canLoad = function () {
          return this.type.cargoSpace > 0;
        };

        MapObject.prototype.hasInQueue = function (type) {
          if (!this.queue) {
            return false;
          }

          for (var i = 0; i < this.queue.length; i++) {
            if (this.queue[i] == type) {
              return true;
            }
          }

          return false;
        };

        MapObject.prototype.setAutocast = function (order, on) {
          if (on) {
            if (!this.autocast.contains(order)) {
              this.autocast.push(order);
            }
          } else {
            this.autocast.erease(order);
          }
        };

        MapObject.prototype.hasModifierWithId = function (id) {
          for (var i = 0; i < this.modifiers.length; i++) {
            if (this.modifierMods[i].modId == id) {
              return true;
            }
          }

          return false;
        };

        MapObject.prototype.applyModifier = function (mod, originUnit) {
          var modId = parseInt(Math.random() * 99999999);

          this.modifiers.push({
            modifier: mod,
            originUnit: originUnit,
            removeAt: (mod.duration && mod.duration > 0) ? (ticksCounter + mod.getValue('duration', this.owner)) : -1,
            modId: modId,
          });

          if (mod.effects) {
            for (var i = 0; i < mod.effects.length; i++) {
              startEffect(mod.effects[i], {
                from: this,
                attachToUnit: true,
                modId: modId,
                scale: (mod.auraRange && mod.auraRange[i]) ? (mod.auraRange[i] + 1) : 0,
                auraColor: mod.auraColor,
                mode: mod.particleMode,
                density: mod.density,
              });
            }
          }

          if (mod.sound) {
            startEffect('sound', {
              from: this,
              sound: mod.sound,
              attachToUnit: true,
              volume: mod.volume,
              soundDuration: 980,
              modId: modId,
            });
          }

          this.checkUpgrades();
        };

        MapObject.prototype.removeModifier = function (index) {
          var mod = this.modifiers.splice(index, 1)[0];

          // kill expired effects
          for (var k = 0; k < this.effectsToDraw.length; k++) {
            if (this.effectsToDraw[k].tickOfDeath <= ticksCounter) {
              this.effectsToDraw.splice(k, 1);
              k--;
            }
          }

          for (var k = 0; k < this.effectsToDraw.length; k++) {
            if (this.effectsToDraw[k].modId == mod.modId) {
              this.effectsToDraw[k].tickOfDeath = ticksCounter + 40;
            }
          }

          this.checkUpgrades();
        };

        MapObject.prototype.checkUpgrades = function () {
          this.modifierMods = {};
          this.disabledCommands = {};
          var customImg = null;

          var dataFields = this.type.getDataFields();

          for (var i = 0; i < this.modifiers.length; i++) {
            var mod = this.modifiers[i].modifier;
            var dataField = dataFields[field];

            if (mod.fields) {
              for (var k = 0; k < mod.fields.length; k++) {
                if (dataFields[mod.fields[k]]) {
                  var field = mod.fields[k];
                  var dataField = dataFields[field];

                  if (dataField.type == 'float' || dataField.type == 'integer' || dataField.type == 'bool') {
                    if (mod.modificationsMultiplier && k in mod.modificationsMultiplier && (dataField.type == 'float' || dataField.type == 'integer')) {
                      this.modifierMods[field] = this.modifierMods[field] ? (this.modifierMods[field] + (mod.modificationsMultiplier[k] - 1) * this.type[field]) : ((mod.modificationsMultiplier[k] - 1) * this.type[field]);
                    }

                    if (mod.modifications && mod.modifications[k]) {
                      this.modifierMods[field] = this.modifierMods[field] ? (this.modifierMods[field] + mod.modifications[k]) : mod.modifications[k];
                    }
                  }
                }
              }
            }

            if (mod.disabledCommands) {
              for (var k = 0; k < mod.disabledCommands.length; k++) {
                this.disabledCommands[mod.disabledCommands[k].id_string] = mod.disabledCommands[k].id_string;
              }
            }

            if (mod.unitImg && mod.changeUnitImg && this.type.isUnit) {
              customImg = mod.unitImg;
            }
          };

          if (customImg) {
            this.img = customImg;
          } else {
            this.refreshImg();
          }

          var thisReference = this;
          _.each(this.modifierMods, function (mod, field) {
            var newVal = thisReference.getValue(field);
            var checkVal = checkField(dataFields[field], newVal, true);

            if (checkVal != newVal) {
              thisReference.modifierMods[field] -= newVal - checkVal;
            }
          });
        };

        // blocks / unblocks all the containing fields of this building / tile. Usually used before and after searching a path to (the center of) this building. For this, is has to not block the pathfinding.
        // Also used on creation or when killed
        MapObject.prototype.switchBlocking = function (on, dontRefreshNBs) {
          if (this.type.isUnit || !this.x || !this.y) {
            return;
          }

          // block / unblock fields
          for (var x = this.x; x < this.x + this.type.sizeX; x++) {
            for (var y = this.y; y < this.y + this.type.sizeY; y++) {
              game.blockArray[x][y] = !on;
            }
          }

          if (dontRefreshNBs) {
            return;
          }

          // refresh neightbours of blocked / unblocked fields
          for (var x = this.x - 1; x < this.x + this.type.sizeX + 1; x++) {
            for (var y = this.y - 1; y < this.y + this.type.sizeY + 1; y++) {
              game.refreshNBSOfField(game.fields[x][y]);
            }
          }

          // refresh neightbours of blocked / unblocked fields 2x2
          for (var x = Math.max(this.x - 2, 1); x < Math.min(this.x + this.type.sizeX + 2, game.x); x++) {
            for (var y = Math.max(this.y - 2, 1); y < Math.min(this.y + this.type.sizeY + 2, game.y); y++) {
              game.refreshNBSOfField2x2(game.fields2x2[x][y]);
            }
          }
        };

        MapObject.prototype.switchBlockingForTeam = function (on, team) {
          if (this.type.isUnit || !this.x || !this.y) {
            return;
          }

          // block / unblock fields
          for (var x = this.x; x < this.x + this.type.sizeX; x++) {
            for (var y = this.y; y < this.y + this.type.sizeY; y++) {
              team.blockArray[x][y] = !on;
            }
          }
        };

        MapObject.prototype.switchBlockingTotal = function (on) {
          this.switchBlocking(on);

          // switch on blocking for all the teams
          for (var i = 0; i < game.teams.length; i++) {
            this.switchBlockingForTeam(on, game.teams[i]);
          }
        };

        MapObject.prototype.getXP4NextLevel = function () {
          if (!this.type.experienceLevels || this.type.experienceLevels.length <= 0) {
            return 0;
          }

          for (var i = 0; i < this.type.experienceLevels.length; i++) {
            if (this.exp < this.type.experienceLevels[i]) {
              return this.type.experienceLevels[i];
            }
          }

          return this.type.experienceLevels[this.type.experienceLevels.length - 1];
        };

        MapObject.prototype.getPercOfCurrentLevel = function () {
          if (!this.type.experienceLevels || this.type.experienceLevels.length <= 0) {
            return 0;
          }

          for (var i = 0; i < this.type.experienceLevels.length; i++) {
            if (this.exp < this.type.experienceLevels[i]) {
              var oldExp = this.type.experienceLevels[i - 1] ? this.type.experienceLevels[i - 1] : 0;
              return (this.exp - oldExp) / (this.type.experienceLevels[i] - oldExp);
            }
          }

          return 1;
        };

        MapObject.prototype.drawExpbar = function (x, y, w, h, linwWidth) {
          var lineWidth_ = linwWidth ? linwWidth : 2;

          c.fillStyle = 'white';
          c.fillRect(x - lineWidth_, y - lineWidth_, w + lineWidth_ * 2, h + lineWidth_ * 2);

          c.fillStyle = 'rgba(125, 125, 125, 1)';

          c.fillRect(x, y, w * this.getPercOfCurrentLevel(), h);
        };

        MapObject.prototype.drawHealthbar = function (x, y, w, h, linwWidth) {
          var hpPercentage = this.hp / this.getValue('hp');

          var lineWidth_ = linwWidth ? linwWidth : 2;

          c.fillStyle = 'white';
          c.fillRect(x - lineWidth_, y - lineWidth_, w + lineWidth_ * 2, h + lineWidth_ * 2);

          if (hpPercentage <= 0.25) {
            c.fillStyle = 'rgba(255, 0, 0, 1)';
          } else if (hpPercentage <= 0.5) {
            c.fillStyle = 'rgba(255, 125, 0, 1)';
          } else {
            c.fillStyle = 'rgba(0, 150, 0, 1)';
          }

          c.fillRect(x, y, w * hpPercentage, h);
        };

        MapObject.prototype.drawManabar = function (x, y, w, h, linwWidth) {
          var lineWidth_ = linwWidth ? linwWidth : 2;

          c.fillStyle = 'white';
          c.fillRect(x - lineWidth_, y - lineWidth_, w + lineWidth_ * 2, h + lineWidth_ * 2);

          c.fillStyle = 'rgba(200, 0, 200, 1)';

          c.fillRect(x, y, w * (this.mana / this.getValue('mana')), h);
        };

        MapObject.prototype.drawLifetimebar = function (x, y, w, h, linwWidth) {
          var lineWidth_ = linwWidth ? linwWidth : 2;

          c.fillStyle = 'white';
          c.fillRect(x - lineWidth_, y - lineWidth_, w + lineWidth_ * 2, h + lineWidth_ * 2);

          c.fillStyle = 'rgba(100, 100, 100, 1)';

          c.fillRect(x, y, w * (this.lifetime / (this.type.lifetime + this.owner.getValueModifier('lifetime', this.type))), h);
        };

        MapObject.prototype.drawLoadbar = function (x, y, w, h, linwWidth) {
          var lineWidth_ = linwWidth ? linwWidth : 2;

          c.fillStyle = 'white';
          c.fillRect(x - lineWidth_, y - lineWidth_, w + lineWidth_ * 2, h + lineWidth_ * 2);

          c.fillStyle = 'rgba(35, 35, 35, 1)';

          var cargoSpace = this.getValue('cargoSpace');
          for (var i = 0; i < cargoSpace; i++) {
            c.fillRect(x + (i / cargoSpace) * w + lineWidth_ / 2, y, (1 / cargoSpace) * w - lineWidth_, h);
          }

          c.fillStyle = 'rgba(190, 190, 190, 1)';

          var cargo = 0;
          for (var i = 0; i < this.cargo.length; i++) {
            c.fillRect(x + (cargo / cargoSpace) * w + lineWidth_ / 2, y, (this.cargo[i].type.cargoUse / cargoSpace) * w - lineWidth_, h);
            cargo += this.cargo[i].type.cargoUse;
          }

          c.stroke();
        };

        MapObject.prototype.drawEye = function () {
          c.globalAlpha *= 0.8 * ((Math.sin(ticksCounter) + 1) / 2 * 0.4 + 0.8);

          x = this.drawPos.px * FIELD_SIZE - imgs.eye.img.w * SCALE_FACTOR / 2 - game.cameraX;
          y = (this.drawPos.py - this.type.healthbarOffset - 0.4) * FIELD_SIZE - game.cameraY - imgs.eye.img.h * ((SCALE_FACTOR + 1.0) / 2.0);

          c.drawImage(miscSheet[0], imgs.eye.img.x, imgs.eye.img.y, imgs.eye.img.w, imgs.eye.img.h, x, y, imgs.eye.img.w * SCALE_FACTOR, imgs.eye.img.h * SCALE_FACTOR);
        };

        // gets the tab prio of this object; higher prio's unit's commands get displayed when several units selected
        MapObject.prototype.getTabPriority = function () {
          return this.type.tabPriority + (this.isUnderConstruction ? -1 : 0);
        };

        MapObject.prototype.drawProgressBar = function (x, y, w, h, linwWidth) {
          var lineWidth_ = linwWidth ? linwWidth : 2;

          var percentage = this.queueStarted ? ((this.currentBuildTime - (this.queueFinish - ticksCounter)) / this.currentBuildTime) : 0;

          drawBar(x, y, w, h, Math.min(percentage, 1), 'rgba(0, 160, 230, 1)', lineWidth_);
        };

        MapObject.prototype.toString = function () {
          return this.type.name + ' @' + this.pos.px + ':' + this.pos.py;
        };

        // Class repreesenting a (movable) unit
        Unit.prototype = new MapObject();
        function Unit(data) {
          this.modifiers = [];
          this.modifierMods = {};
          this.disabledCommands = {};

          // basic attributes
          this.pos = new Field(data.x, data.y, true);
          this.type = data.type;
          this.owner = data.owner;

          this.id = game.global_id++;

          // everything regarding the current order
          this.order = lists.types.stop;
          this.path = null; // the current path (array of fields)
          this.target = null; // the current target; can be a field or a unit
          this.carriedGoldAmount = 0;
          this.goldMine = null; // the goldmine currently mining from
          this.lastAttackingTick = -999; // the last tick, when this unit was attacking
          this.tickOfLastWeaponFired = -999; // the last tick, when this unit was exactly doing damage
          this.targetLockingUnit = null; // when a unit starts attacking, it locks on a unit (and will continue the current attack cycle, even if this unit moves out of range)
          this.vision = this.type.vision;
          this.cargo = [];

          // order queue
          this.queueOrder = [];
          this.queueTarget = [];

          // pushing / blocking
          this.blocking = false; // can be pushed by friendly units (false when hold position for example)
          this.lastTicksPosition = this.pos.getCopy(); // we need this for example to interpolate between last ticks and this ticks position when drawing (for more smooth looking movement)
          this.drawPos = this.pos.getCopy(); // interpolation between last ticks position and this ticks position

          this.setYDrawingOffset();
          game.addObject(this);

          // adding for clipboard undo
          if (game_state == GAME.EDITOR && data.noHistory != true) {
            editor.clipboard.history.addObject(this);
          }

          this.hitOffsetPos = null; // when this unit is hit, draw pos is slightly offsettet, to demonstate the "power" of the hit
          this.hitOffsetTill = 0; // how long to draw the hit modified pos
          this.lastTickCircleEffect = 0; // last tick, when the circle blinking effect was started
          this.oscillationOffset = Math.floor(Math.random() * 100);

          this.bodyPower = 1;
          this.drawingHeight = 0;
          this.yDrawingOffset = this.pos.py;
          this.lastMiningTick = -999;
          this.tickOfLastLoadIn = -1;

          // making units stuff
          this.queue = []; // references to the unit types that are in production
          this.autocast = this.initAutocast(); // ids of abilities that are on autocast

          this.animationOffset = Math.floor(Math.random() * 100); // random offset for animation, so not all unit have the same animation state at the same time

          this.revealedToTeamUntil = new Array(MAX_PLAYERS);

          this.flameDeath = false;

          if (ticksCounter > 0 && game.lastReadySound + 20 < ticksCounter && this.owner == PLAYING_PLAYER) {
            soundManager.playSound(this.type.readySound, game.getVolumeModifier(this.drawPos) * this.type.readySoundVolume);
            game.lastReadySound = ticksCounter;
            game.lastYesSound = ticksCounter;
          }

          this.throwStart = -1;
          this.throwFrom = null;
          this.throwTo = null;

          if (this.type.lifetime) {
            this.lifetime = this.type.lifetime;
          }

          this.abilityLevels = [];
          this.lastTickAbilityUsed = [];
          for (var i = 0; i < game.commands.length; i++) {
            this.lastTickAbilityUsed[i] = -9999;
            this.abilityLevels[i] = (game.commands[i] && game.commands[i].requiredLevels && game.commands[i].requiredLevels.length > 0) ? 0 : 1;
          }

          // add to units for this player
          if (this.owner) {
            this.owner.unitSpawns(this);
          }

          this.level = (this.type.experienceLevels && this.type.experienceLevels.length > 0) ? 1 : 0;
          this.exp = 0;

          this.refreshImg();

          this.direction = Math.floor(Math.random() * this.img._angles); // direction the unit is looking in

          this.effectsToDraw = []; // if this unit has modifiers for example, that make effect, the effects are attached here

          this.initHPAndMana();
        };

        Unit.prototype.refreshImg = function () {
          this.img = (this.owner.skins && this.owner.skins[this.type.id_string]) ? this.owner.skins[this.type.id_string] : this.type.img;
        };

        Unit.prototype.hasPath = function () {
          return this.path != null;
        };

        Unit.prototype.distanceTo = function (otherUnit) {
          if (!otherUnit) {
            return 999999;
          }

          return otherUnit.type.isBuilding ? otherUnit.distanceTo(this) : this.pos.distanceTo2(otherUnit.pos) - this.type.radius - otherUnit.type.radius;
        };

        // return true if unit is inside a drawn box; gameplay coordinates
        Unit.prototype.isInBox = function (x1, y1, x2, y2) {
          return this.drawPos.px + this.type.radius >= x1 && this.drawPos.py + this.type.radius >= y1 && this.drawPos.px - this.type.radius <= x2 && this.drawPos.py - this.type.radius <= y2;
        };

        // return true if unit is inside a drawn box; gameplay coordinates
        Unit.prototype.isInBoxVisible = function (x1, y1, x2, y2) {
          return this.drawPos.px + this.type.radius >= x1 && this.drawPos.py + this.type.radius >= y1 && this.drawPos.px - this.type.radius <= x2 && this.drawPos.py - this.type.radius <= y2 + this.type.height;
        };

        Unit.prototype.getYDrawingOffset = function () {
          return this.yDrawingOffset;
        };

        Unit.prototype.setYDrawingOffset = function () {
          this.yDrawingOffset = this.pos.py + this.type.radius - (this.isAlive ? 0 : 3) + (this.type.flying ? 2 : 0);
        };

        // interpolate between last ticks and this ticks position
        Unit.prototype.updateDrawPosition = function () {
          this.drawPos = this.lastTicksPosition.addNormalizedVector(this.pos, percentageOfCurrentTickPassed * this.pos.distanceTo2(this.lastTicksPosition));

          if (this.type.flying) {
            this.drawingHeight = this.drawingHeight + Math.max(Math.min((game.getHMValue3(this.drawPos) * CLIFF_HEIGHT - this.drawingHeight), gameTimeDiff * 2), -gameTimeDiff * 2);
            this.drawPos = this.drawPos.add3(0, -this.drawingHeight);
          } else {
            this.drawPos = this.drawPos.add3(0, -game.getHMValue3(this.drawPos) * CLIFF_HEIGHT);
          }

          if (this.hitOffsetTill > timestamp && this.hitOffsetPos) {
            var t = 200 - (this.hitOffsetTill - timestamp);
            var mod = t < 50 ? t / 50 : ((150 - (t - 50)) / 150);

            this.drawPos = this.drawPos.addNormalizedVector(this.hitOffsetPos, -0.04 * mod);
          }
        };

        // draw; expects screen bounds (ingame coords)
        Unit.prototype.draw = function () {
          // if ourside if visible bounds or not visible (fogwise), return, because we dont need to draw anything
          if (!PLAYING_PLAYER.team.canSeeUnit(this) || this.getValue('noShow')) {
            return;
          }

          var frame;
          var frameWidth;
          var scale = this.getValue('imageScale') * SCALE_FACTOR;
          var img = this.img.idle;

          if (this.isThrowedUntil > ticksCounter && this.isAlive) {
            var percDone = (ticksCounter + percentageOfCurrentTickPassed - this.throwStart) / (this.isThrowedUntil - this.throwStart);
            var dist = this.throwFrom.distanceTo2(this.throwTo);
            var isDeadForHowLong = ticksCounter - this.throwStart;
            img = this.img.die ? this.img.die : this.img.idle;

            if (percDone < 0.5) {
              this.drawPos = this.throwFrom.addNormalizedVector(this.throwTo, dist * percDone * 1.5);
              this.pos = this.drawPos;
              this.drawPos = this.drawPos.add3(0, -game.getHMValue2(this.drawPos.x, this.drawPos.y) * CLIFF_HEIGHT - (-Math.pow(percDone * 4 - 1, 2) + 1) * 0.20 * dist);
            } else if (percDone < 0.75) {
              this.drawPos = this.throwFrom.addNormalizedVector(this.throwTo, 0.75 * dist + dist * (percDone - 0.5) * 0.66);
              this.pos = this.drawPos;
              this.drawPos = this.drawPos.add3(0, -game.getHMValue2(this.drawPos.x, this.drawPos.y) * CLIFF_HEIGHT - (-Math.pow(percDone * 8 - 5, 2) + 1) * 0.06 * dist);
            } else {
              this.drawPos = this.throwFrom.addNormalizedVector(this.throwTo, 0.915 * dist + dist * (percDone - 0.75) * 0.33);
              this.pos = this.drawPos;
              this.drawPos = this.drawPos.add3(0, -game.getHMValue2(this.drawPos.x, this.drawPos.y) * CLIFF_HEIGHT);
            }

            // create smoke effect when hit the ground
            if (((percDone > 0.45 && percDone < 0.55) || (percDone > 0.7 && percDone < 0.8)) && tickDiff > 0) {
              new Dust({ from: this.drawPos });
            }

            frameWidth = img.frameWidth;
            frame = (this.isThrowedUntil - ticksCounter <= 10) ? Math.floor((this.isThrowedUntil - ticksCounter) / 10 * (img.w / frameWidth)) : Math.floor(Math.min(percDone * 2, 0.99) * (img.w / frameWidth));

            var tileHeight = img.h / this.img._angles;

            // get drawing position
            var x = this.drawPos.px * FIELD_SIZE - frameWidth * scale / 2 - game.cameraX;
            var y = this.drawPos.py * FIELD_SIZE - (tileHeight - this.getValue('drawOffsetY')) * scale - game.cameraY;

            c.drawImage(this.img.file[this.owner.number], frame * frameWidth + img.x, this.direction * tileHeight + img.y, frameWidth, tileHeight, x, y, frameWidth * scale, tileHeight * scale);

            return;
          }

          // if unit is dying, play death animation
          if (!this.isAlive) {
            var percDone = (ticksCounter + percentageOfCurrentTickPassed - this.throwStart) / (this.isThrowedUntil - this.throwStart);
            var dist = this.throwFrom.distanceTo2(this.throwTo);
            var isDeadForHowLong = (ticksCounter + percentageOfCurrentTickPassed) - this.throwStart;
            img = this.img.die ? this.img.die : this.img.idle;

            if (this.type.removeAfterDeadAnimation && isDeadForHowLong > 100) {
              game.objectsToDraw.erease(this);
              return;
            }

            if (percDone < 0.5) {
              this.drawPos = this.throwFrom.addNormalizedVector(this.throwTo, dist * percDone * 1.5);
              this.drawPos = this.drawPos.add3(0, -game.getHMValue2(this.drawPos.x, this.drawPos.y) * CLIFF_HEIGHT - (-Math.pow(percDone * 4 - 1, 2) + 1) * 0.20 * dist);
            } else if (percDone < 0.75) {
              this.drawPos = this.throwFrom.addNormalizedVector(this.throwTo, 0.75 * dist + dist * (percDone - 0.5) * 0.66);
              this.drawPos = this.drawPos.add3(0, -game.getHMValue2(this.drawPos.x, this.drawPos.y) * CLIFF_HEIGHT - (-Math.pow(percDone * 8 - 5, 2) + 1) * 0.06 * dist);
            } else if (percDone < 1) {
              this.drawPos = this.throwFrom.addNormalizedVector(this.throwTo, 0.915 * dist + dist * (percDone - 0.75) * 0.33);
              this.drawPos = this.drawPos.add3(0, -game.getHMValue2(this.drawPos.x, this.drawPos.y) * CLIFF_HEIGHT);
            } else {
              this.drawPos = this.throwTo.add3(0, -game.getHMValue2(this.throwTo.x, this.throwTo.y) * CLIFF_HEIGHT);
            }

            this.pos = this.drawPos;

            // create smoke effect when hit the ground
            if (((percDone > 0.45 && percDone < 0.55) || (percDone > 0.7 && percDone < 0.8)) && tickDiff > 0) {
              new Dust({ from: this.drawPos });
            }

            frameWidth = img.frameWidth;
            frame = Math.floor(Math.min(isDeadForHowLong * this.type.deathAnimationSpeed, img.w / frameWidth - 1));

            var tileHeight = img.h / this.img._angles;

            // get drawing position
            var x = this.drawPos.px * FIELD_SIZE - frameWidth * scale / 2 - game.cameraX;
            var y = this.drawPos.py * FIELD_SIZE - (tileHeight - this.getValue('drawOffsetY')) * scale - game.cameraY;

            // if dead animation is done playing and this unit type has to be removed after dead animation done playing
            if (this.type.removeAfterDeadAnimation && Math.floor(isDeadForHowLong * this.type.deathAnimationSpeed) == img.w / frameWidth && tickDiff) {
              // create some random smoke effects
              if (this.type.size > 2) {
                for (var i = 0; i < 10; i++) {
                  new Dust({
                    from: this.drawPos.add2(Math.random() * Math.PI * 2, Math.random() * this.type.size / 2),
                    scale: (Math.random() * 1.33 + 0.5) * this.drawPos,
                  });
                }
              }

              // create side smoke effects (big dust clouds that go sideways)
              for (var i = 0; i < Math.PI * 2; i += Math.random() * 1.5) {
                new Dust({
                  from: this.drawPos,
                  scale: (Math.random() * 1.66 + 0.5) * this.size,
                  ageScale: 0.66 * this.size,
                  vz: 0.01,
                  xFunction: function (age) {
                    return ((-1) / (age + 0.3) + 3) * this.x_ * this.size_;
                  },
                  yFunction: function (age) {
                    return ((-1) / (age + 0.3) + 3) * this.y_ * this.size_;
                  },
                  x_: Math.cos(i),
                  y_: Math.sin(i),
                  size_: this.size / 3,
                });
              }

              // play hit ground sound
              soundManager.playSound(this.type.slamSound ? this.type.slamSound : SOUND.FALL, game.getVolumeModifier(this.pos));
            }

            // fading out
            if (this.type.removeAfterDeadAnimation) {
              c.globalAlpha = Math.min(Math.max(1 + (img.w / frameWidth - isDeadForHowLong * this.type.deathAnimationSpeed) / 16, 0), 1);
            } else {
              c.globalAlpha = isDeadForHowLong > 35 ? Math.max(55 - isDeadForHowLong, 0) / 20 : 1;
            }

            c.drawImage(this.img.file[this.owner.number], frame * frameWidth + img.x, this.direction * tileHeight + img.y, frameWidth, tileHeight, x, y, frameWidth * scale, tileHeight * scale);

            if (this.flameDeath) {
              if (c.globalAlpha > 0.5) {
                // create random flames
                for (var i = 0; i < tickDiff; i++) {
                  if (Math.random() < 0.07) {
                    new Sprite({
                      from: this.drawPos.add3(0, -0.3).add2(Math.random() * Math.PI * 2, 0.1),
                      img: imgs['fire' + (Math.floor(Math.random() * 4) + 1)],
                      scaleFunction: function (age) {
                        return 1.25 + age * 0.8;
                      },
                      alphaFunction: function (age) {
                        return 0.5;
                      },
                    });
                  }
                }

                // create random zmoke
                for (var i = 0; i < tickDiff; i++) {
                  if (Math.random() < 0.1) {
                    new Dust({ from: this.drawPos, scale: 1 + Math.random(), ageScale: 2 + Math.random() });
                  }
                }
              }
            }

            c.globalAlpha = 1;

            // eventually remove unit from the game
            if (isDeadForHowLong > 100) {
              game.objectsToDraw.erease(this);
            }

            return;
          }

          var angle = 999;
          var isAttacking = (this.lastAttackingTick + 6 >= ticksCounter || (this.order && this.order.type == COMMAND.REPAIR) || this.lastMiningTick + 1 >= ticksCounter) || (this.order && this.order.animationName);

          if (this.order && this.order.type == COMMAND.DANCE) {
            img = this.img[this.order.dance_img] ? this.img[this.order.dance_img] : this.img.idle;
            frameWidth = img.frameWidth;
            frame = Math.floor(ticksCounter / 3) % (img.w / frameWidth);
          } else if (this.forcedAnimation && this.img[this.forcedAnimation] && this.forcedAnimationStop >= ticksCounter && this.forcedAnimationStart >= 0) {
            img = this.img[this.forcedAnimation];
            frameWidth = img.frameWidth;
            angle = 0;
            frame = Math.min(Math.max(Math.floor((ticksCounter - this.forcedAnimationStart) / (this.forcedAnimationStop - this.forcedAnimationStart) * (img.w / frameWidth)), 0), img.w / frameWidth - 1);
          }

          // if walk
          else if ((!this.lastTicksPosition.equals(this.pos) || (this.type.flying && !isAttacking)) && !(this.type.flying && isAttacking)) {
            img = (this.carriedGoldAmount && this.img.walkGold) ? this.img.walkGold : (this.img.walk ? this.img.walk : this.img.idle);
            frameWidth = img.frameWidth;

            if (!this.lastTicksPosition.equals(this.pos)) {
              angle = this.lastTicksPosition.getAngleTo(this.pos);
            }

            frame = Math.floor(((ticksCounter + this.animationOffset + this.oscillationOffset) / this.type.animSpeed + (this.hitOffsetTill > timestamp ? 1 : 0)) % (img.w / frameWidth));

            // dust effect
            if (tickDiff > 0 && Math.random() < this.type.dustCreationChance) {
              new Dust({ from: this.drawPos.add3(0, 0.2) });
            }
          }

          // if attack
          else if (isAttacking) {
            img = (this.order && this.order.animationName && this.img[this.order.animationName]) ? this.img[this.order.animationName] : (this.img.attack ? this.img.attack : this.img.idle);

            if (this.targetUnit || this.target) {
              angle = this.pos.getAngleTo(this.targetUnit ? this.targetUnit.pos : this.target);
            }

            frameWidth = img.frameWidth;

            var weaponDelay = (this.order && this.order.castingDelay) ? this.order.getValue('castingDelay', this) : this.type.weaponDelay;
            var cooldown = (this.order && this.order.cooldown) ? this.order.cooldown : this.type.weaponCooldown;

            if (this.type.flying) {
              frame = Math.floor(((ticksCounter + this.oscillationOffset) / this.type.animSpeed) % (img.w / frameWidth));
            } else if (ticksCounter - this.tickOfLastWeaponFired <= cooldown + 1) // if weapon has been fired recently and is cooldowning now
            {
              frame = Math.floor(((ticksCounter - this.tickOfLastWeaponFired + weaponDelay) % cooldown) / cooldown * (img.w / frameWidth));
            } else {
              frame = Math.floor((this.hitCycle % cooldown) / cooldown * (img.w / frameWidth));
            }
          }

          // if idle
          else {
            frameWidth = img.frameWidth;
            frame = this.type.idleFrames ? this.type.idleFrames[Math.min(Math.floor(ticksCounter / 4 + this.pos.py * 123241) % this.type.idleFrames.length, parseInt(img.w / frameWidth))] : (Math.max((Math.floor((ticksCounter + this.animationOffset) / 5) % (img.w / frameWidth + 20)) - 20, 0));
          }

          if (angle != 999) // if a new angle has been calculated, calculate the new direction from it
          {
            angle += angle < -Math.PI ? Math.PI * 2 : 0;
            angle -= angle > Math.PI ? Math.PI * 2 : 0;

            if (this.img._angles == 8) {
              if (angle >= Math.PI * 3 / 8 && angle <= Math.PI * 5 / 8) {
                this.direction = 0;
              } else if (angle <= -Math.PI * 3 / 8 && angle >= -Math.PI * 5 / 8) {
                this.direction = 3;
              } else if (angle >= Math.PI * 7 / 8 || angle <= -Math.PI * 7 / 8) {
                this.direction = 1;
              } else if ((angle <= Math.PI * 1 / 8 && angle >= 0) || (angle >= -Math.PI * 1 / 8 && angle <= 0)) {
                this.direction = 2;
              } else if (angle <= Math.PI * 7 / 8 && angle >= Math.PI * 5 / 8) {
                this.direction = 4;
              } else if (angle <= Math.PI * 3 / 8 && angle >= Math.PI * 1 / 8) {
                this.direction = 5;
              } else if (angle >= -Math.PI * 7 / 8 && angle <= -Math.PI * 5 / 8) {
                this.direction = 6;
              } else {
                this.direction = 7;
              }
            } else if (this.img._angles == 1) {
              this.direction = 0;
            } else {
              if (angle >= Math.PI / 4 && angle <= Math.PI * 3 / 4) {
                this.direction = 0;
              } else if (angle <= -Math.PI / 4 && angle >= -Math.PI * 3 / 4) {
                this.direction = 3;
              } else if (angle >= Math.PI * 3 / 4 || angle <= -Math.PI * 3 / 4) {
                this.direction = 1;
              } else {
                this.direction = 2;
              }
            }
          }

          var tileHeight = (this.order && this.order.type == COMMAND.DANCE) ? img.h : (img.h / this.img._angles);

          // get drawing position
          var x = this.drawPos.px * FIELD_SIZE - frameWidth / 2 * scale - game.cameraX;
          var y = this.drawPos.py * FIELD_SIZE - (tileHeight - this.getValue('drawOffsetY')) * scale - game.cameraY;

          // if flying, calculate oscillation frquency height
          if (this.type.flying && this.img.walk) {
            var countFrames = this.img.walk.w / this.img.walk.frameWidth;
            y += Math.sin(((((ticksCounter + this.oscillationOffset + percentageOfCurrentTickPassed + 3.8 * this.type.animSpeed) / this.type.animSpeed) % countFrames) / countFrames) * Math.PI * 2) * FIELD_SIZE * this.type.oscillationAmplitude;
          }

          // invis alpha
          if (this.getValue('isInvisible')) {
            c.globalAlpha = (this.isDetectedUntil >= ticksCounter || !this.owner.isEnemyOfPlayer(PLAYING_PLAYER)) ? 0.5 : 0.07;
          } else {
            c.globalAlpha = 1;
          }

          if (this.order && this.order.type == COMMAND.DANCE) {
            this.direction = 0;
          }

          // unit image itself
          c.drawImage(this.img.file[this.owner.number], frame * frameWidth + img.x, this.direction * tileHeight + img.y, frameWidth, tileHeight, x, y, frameWidth * scale, tileHeight * scale);

          if (this.getValue('hasDetection')) {
            this.drawEye();
          }

          c.globalAlpha = 1;

          //debugs
          if (globalLWGDebug && show_unit_details && !network_game) {
            c.fillStyle = "rgba(0, 0, 0, 1)";
            c.fillText(this.order.name, this.drawPos.px * FIELD_SIZE - game.cameraX - FIELD_SIZE / 3, (this.drawPos.py - this.type.healthbarOffset) * FIELD_SIZE - game.cameraY - 12);

            // show detailed path to next target
            /*if(this.path)
            {
              c.strokeStyle = "yellow";
              c.beginPath();
              c.moveTo(this.drawPos.px * FIELD_SIZE - game.cameraX, this.drawPos.py * FIELD_SIZE - game.cameraY);
              c.lineTo(this.path.px * FIELD_SIZE - game.cameraX, this.path.py * FIELD_SIZE - game.cameraY);
              c.stroke();
            }*/
          }
        };

        Unit.prototype.popQueueFront = function () {
          if (this.queue) {
            this.owner.killProduction(this.queue[0], this.queueFinish);

            // update queue
            for (var k = 0; k < BUILDING_QUEUE_LEN - 1; k++) {
              this.queue[k] = this.queue[k + 1];
            }
            this.queue[BUILDING_QUEUE_LEN - 1] = null;

            // if more units in queue, set build time according to their build time, else 0
            if (this.queue[0]) {
              this.queueFinish = this.queue[0].getValue('buildTime', this.owner) + ticksCounter;
              this.currentBuildTime = this.queueFinish - ticksCounter;
              // this.owner.startProduction(this.queue[0], this.queueFinish);
            }

            this.queueStarted = false;
          }
        };

        Building.prototype = new MapObject();

        // Class for Building, expects a json object with several paramters
        function Building(data) {
          _.extend(this, data);

          // mines always belong to player 0 (neutral)
          if (this.type.alwaysNeutral) {
            this.owner = game.players[0];
          }

          this.isUnderConstruction = this.buildFirst ? true : false;
          this.buildTicksLeft = 0; // when under construction, when does it finish
          this.seenBy = new Array(MAX_PLAYERS + 1); // contains a value, determing in which state this building has been seen by player [index] the last time he saw it
          this.seenByAsBuildingType = new Array(MAX_PLAYERS + 1); // buildings can transform, so here the building type is stored in which this building has been seen by player [index]

          this.workload = [0];
          this.workload_total = 0;
          this.countWorkingWorkers = 0;
          this.lastCountWorkingWorkers = 0;

          this.vision = this.buildFirst ? 3 : this.type.vision;

          // neutral buildings are always seen by all players
          if (this.owner.controller == CONTROLLER.NONE && !this.isDummy) {
            for (var i = 0; i < this.seenBy.length; i++) {
              this.seenBy[i] = BUILDING_STATE.NORMAL;
            }

            // switch on blocking for all the teams
            for (var i = 0; i < game.teams.length; i++) {
              this.switchBlockingForTeam(true, game.teams[i]);
            }
          }

          // team 0 always sees everything
          if (game_state == GAME.EDITOR) {
            this.seenBy[0] = BUILDING_STATE.NORMAL;
          }

          // making units stuff
          this.queue = []; // references to the unit types that are in production
          this.autocast = this.initAutocast(); // ids of abilities that are on autocast

          this.abilityLevels = new Array(game.commands.length);
          this.lastTickAbilityUsed = new Array(game.commands.length);
          for (var i = 0; i < game.commands.length; i++) {
            this.lastTickAbilityUsed[i] = -9999;
            this.abilityLevels[i] = (game.commands[i] && game.commands[i].requiredLevels && game.commands[i].requiredLevels.length > 0) ? 0 : 1;
          }

          this.pos = new Field(this.x - 1 + this.type.size / 2, this.y - 1 + this.type.size / 2, true); // the position of a building (or doodad) = center
          this.drawPos = this.pos.add3(0, -game.getHMValue2(this.x, this.y) * CLIFF_HEIGHT); // all map object need a draw pos. Its not gameplay relevant, but only used for drawing. For units this is interpolated between this and last ticks real pos, so the movement is smooth. For buildings and doodads ist just static

          // in case of gold mine, store gold value
          if (this.type.startGold) {
            this.gold = this.type.startGold;
          }

          // dummys are used, when you place a building and the transparent building is drawn while the worker moves to the location
          if (!this.isDummy) {
            this.switchBlocking(true, this.dontRefreshNBs); // mark the fields in the grid as blocked
            this.id = game.global_id++; // ids are used to identify the building in network games

            if (this.type.lifetime) {
              this.lifetime = this.type.lifetime;
            }
          }

          this.yDrawingOffset = this.pos.py + this.type.size / 2;
          game.addObject(this);

          // editor clipboard for undo
          if (game_state == GAME.EDITOR && data.noHistory != true) {
            editor.clipboard.history.addObject(this);
          }

          this.modifiers = [];
          this.modifierMods = {};

          // if building is beeing constructed (when made in game and not on map load)
          if (this.buildFirst) {
            this.buildTicksLeft = this.getValue('buildTime');
            this.hp *= BUILDING_START_HP_PERCENTAGE;

            if (PLAYING_PLAYER.team.canSeeUnit(this)) {
              this.massSmoke();
              soundManager.playSound(SOUND.BUILD, game.getVolumeModifier(this.pos) * 0.5);
            }

            this.owner.startProduction(this.type, this);
          }

          this.borderLeft = this.drawPos.px - this.type.size / 2;
          this.borderRight = this.drawPos.px + this.type.size / 2;
          this.borderTop = this.drawPos.py - this.type.size / 2;
          this.borderBottom = this.drawPos.py + this.type.size / 2;

          this.lastRepairedTick = -1; // if this building is under construction, this is set to the current tick, when the constucting worker (whos technically repairing it), gets updated; all other repairing workers will use repair stats then in stead of construction stats

          this.targetsQueue = [];
          this.disabledCommands = {};

          this.effectsToDraw = []; // if this unit has modifiers for example, that make effect, the effects are attached here

          this.initHPAndMana();
        };

        Building.prototype.refreshImg = function () {
          this.img = this.type.img;
        };

        Building.prototype.massSmoke = function () {
          for (var i = 0; i < 12; i++) {
            new Dust({ from: this.drawPos.add2(Math.random() * Math.PI * 2, this.type.size / 1.5) });
          }
        };

        // return true if building / tile is inside a drawn box on the screen
        Building.prototype.isInBox = function (x1, y1, x2, y2) {
          return this.borderRight >= x1 && this.borderBottom >= y1 && this.borderLeft <= x2 && this.borderTop <= y2;
        };

        Building.prototype.getWorkload = function () {
          return Math.min(Math.ceil((this.workload_total / 400) * 100), 100);
        };

        // determines the z index when drawing; when building is dying atm, return a lower z index, so the building does not overlap with the explosion effect
        Building.prototype.getYDrawingOffset = function () {
          return this.yDrawingOffset;
        };

        Building.prototype.draw = function () {
          // if ourside of visible bounds, return, because we dont need to draw anything
          if ((!this.seenBy[PLAYING_PLAYER.team.number] && !this.isDummy) || this.getValue('noShow')) {
            return;
          }

          c.globalAlpha = this.isDummy ? 0.4 : 1;

          var state = this.seenBy[PLAYING_PLAYER.team.number];
          var canSeeNow = PLAYING_PLAYER.team.canSeeUnit(this, true);
          var img = this.seenByAsBuildingType[PLAYING_PLAYER.team.number] ? this.seenByAsBuildingType[PLAYING_PLAYER.team.number].img : this.type.img;
          var scale = this.getValue('imageScale') * SCALE_FACTOR;
          var x = 0;
          var y = 0;
          var w = 0;
          var h = 0;

          if (state == BUILDING_STATE.UNDER_CONSTRUCTION && img.constructionImg) {
            var frame = img.constructionImg.frame ? Math.min(img.constructionImg.frame[ticksCounter % img.constructionImg.frame.length], parseInt(img.constructionImg.w / img.constructionImg.frameWidth) - 1) : 0;
            x = img.constructionImg.x + frame * img.constructionImg.frameWidth;
            y = img.constructionImg.y;
            w = img.constructionImg.frameWidth;
            h = img.constructionImg.h;
          } else if (state == BUILDING_STATE.DEAD) {
            return;
          } else if (state == BUILDING_STATE.BUSY && img.busyImgs) {
            var frame = (canSeeNow && img.busyImgs.frames) ? Math.min(img.busyImgs.frames[ticksCounter % img.busyImgs.frames.length], parseInt(img.busyImgs.w / img.busyImgs.frameWidth) - 1) : 0;
            x = img.busyImgs.x + frame * img.busyImgs.frameWidth;
            y = img.busyImgs.y;
            w = img.busyImgs.frameWidth;
            h = img.busyImgs.h;
          } else if (state == BUILDING_STATE.BUSY_DAMAGED && img.busyDamagedImgs) {
            var frame = (canSeeNow && img.busyDamagedImgs.frames) ? Math.min(img.busyDamagedImgs.frames[ticksCounter % img.busyDamagedImgs.frames.length], parseInt(img.busyDamagedImgs.w / img.busyDamagedImgs.frameWidth) - 1) : 0;
            x = img.busyDamagedImgs.x + frame * img.busyDamagedImgs.frameWidth;
            y = img.busyDamagedImgs.y;
            w = img.busyDamagedImgs.frameWidth;
            h = img.busyDamagedImgs.h;
          } else if (state == BUILDING_STATE.UPGRADING && img.upgradeImg) {
            var frame = img.upgradeImg.frames ? Math.min(img.upgradeImg.frames[ticksCounter % img.upgradeImg.frames.length], parseInt(img.upgradeImg.w / img.upgradeImg.frameWidth) - 1) : 0;
            x = img.upgradeImg.x + frame * img.upgradeImg.frameWidth;
            y = img.upgradeImg.y;
            w = img.upgradeImg.frameWidth;
            h = img.upgradeImg.h;
          } else if (state == BUILDING_STATE.UPGRADING_DAMAGED && img.upgradeImgDamaged) {
            var frame = img.upgradeImgDamaged.frames ? Math.min(img.upgradeImgDamaged.frames[ticksCounter % img.upgradeImgDamaged.frames.length], parseInt(img.upgradeImgDamaged.w / img.upgradeImgDamaged.frameWidth) - 1) : 0;
            x = img.upgradeImgDamaged.x + frame * img.upgradeImgDamaged.frameWidth;
            y = img.upgradeImgDamaged.y;
            w = img.upgradeImgDamaged.frameWidth;
            h = img.upgradeImgDamaged.h;
          } else if (state == BUILDING_STATE.DAMAGED && img.damagedImg) {
            var frame = img.damagedImg.frames ? Math.min(img.damagedImg.frames[ticksCounter % img.damagedImg.frames.length], parseInt(img.damagedImg.w / img.damagedImg.frameWidth) - 1) : 0;
            x = img.damagedImg.x + frame * img.damagedImg.frameWidth;
            y = img.damagedImg.y;
            w = img.damagedImg.frameWidth;
            h = img.damagedImg.h;
          }

          // if mine and empty
          else if (state == BUILDING_STATE.EMPTY && img.imgEmpty) {
            var frame = img.imgEmpty.frames ? Math.min(img.imgEmpty.frames[ticksCounter % img.imgEmpty.frames.length], parseInt(img.imgEmpty.w / img.imgEmpty.frameWidth) - 1) : 0;
            x = img.imgEmpty.x + frame * img.imgEmpty.frameWidth;
            y = img.imgEmpty.y;
            w = img.imgEmpty.frameWidth;
            h = img.imgEmpty.h;
          } else // normal
          {
            var frame = img.img.frames ? Math.min(img.img.frames[ticksCounter % img.img.frames.length], parseInt(img.img.w / img.img.frameWidth) - 1) : 0;
            x = img.img.x + frame * img.img.frameWidth;
            y = img.img.y;
            w = img.img.frameWidth;
            h = img.img.h;
          }

          if ((state == BUILDING_STATE.BUSY || state == BUILDING_STATE.BUSY_DAMAGED) && canSeeNow && this.type.busySmokeEffectLocationX && tickDiff > 0 && ticksCounter % 10 == 0) {
            new Dust({ from: this.drawPos.add3(this.type.busySmokeEffectLocationX, this.type.busySmokeEffectLocationY), scale: 2, ageScale: 2, height: this.type.busySmokeEffectLocationZ });
          }

          var target_x = this.drawPos.px * FIELD_SIZE - w * scale / 2 - game.cameraX;
          var target_y = (this.drawPos.py + this.type.size / 2) * FIELD_SIZE - h * scale - game.cameraY;

          // invis alpha
          if (this.getValue('isInvisible')) {
            c.globalAlpha = (this.isDetectedUntil >= ticksCounter || !this.owner.isEnemyOfPlayer(PLAYING_PLAYER)) ? 0.5 : 0.07;
          }

          c.drawImage(img.file[this.owner.number], x, y, w, h, target_x, target_y, w * scale, h * scale);

          if (!this.isDummy && this.getValue('hasDetection') && !this.isUnderConstruction) {
            this.drawEye();
          }

          c.globalAlpha = 1;

          if (this.isDummy) {
            return;
          }

          // create dust effects randomly if under construction
          if ((this.lastRepairedTick + 1 >= ticksCounter || state == BUILDING_STATE.UPGRADING || state == BUILDING_STATE.UPGRADING_DAMAGED) && canSeeNow) {
            for (var i = 0; i < tickDiff; i++) {
              if (Math.random() < 0.15) {
                new Dust({ from: this.drawPos.add2(Math.random() * Math.PI * 2, Math.random() * this.type.size / 1.7).add3(0, 3), scale: Math.random() + 1.5, height: 3 });
              }
            }
          }
        };

        Building.prototype.popQueueFront = function () {
          if (this.queue) {
            this.owner.killProduction(this.queue[0], this.queueFinish);

            // update queue
            for (var k = 0; k < BUILDING_QUEUE_LEN - 1; k++) {
              this.queue[k] = this.queue[k + 1];
            }
            this.queue[BUILDING_QUEUE_LEN - 1] = null;

            // if more units in queue, set build time according to their build time, else 0
            if (this.queue[0]) {
              this.queueFinish = this.queue[0].getValue('buildTime', this.owner) + ticksCounter;
              this.currentBuildTime = this.queueFinish - ticksCounter;
              // this.owner.startProduction(this.queue[0], this.queueFinish);
            }

            this.queueStarted = false;
          }
        };

        var searchColors = new Array(11);
        // searchColors = new Array(18);

        // Player Colors (the search colors will get replaced with those)
        var playerColors = [

          [ // (player 1, red)
            [35, 1, 1],
            [66, 1, 1],
            [67, 11, 8],
            [113, 38, 27],
            [138, 50, 37],
            [161, 60, 46],
            [174, 72, 72],
            [90, 24, 24],
            [123, 45, 45],
            [188, 101, 101],
            [125, 65, 65],
            [185, 25, 25],
          ],

          [ // (player 2, blue)
            [1, 5, 35],
            [1, 7, 66],
            [9, 15, 145],
            [38, 45, 194],
            [54, 61, 212],
            [86, 93, 238],
            [72, 84, 174],
            [24, 24, 90],
            [45, 45, 123],
            [101, 101, 188],
            [65, 65, 125],
            [25, 25, 150],
          ],

          [ // (player 3, green)
            [1, 35, 1],
            [3, 66, 1],
            [19, 77, 10],
            [36, 116, 23],
            [51, 143, 36],
            [69, 169, 53],
            [86, 174, 72],
            [24, 90, 24],
            [45, 123, 45],
            [101, 188, 101],
            [65, 135, 65],
            [0, 200, 0],
          ],

          [ // (player 4, white)
            [30, 30, 30],
            [50, 50, 50],
            [92, 92, 92],
            [187, 187, 187],
            [217, 217, 217],
            [239, 239, 239],
            [225, 225, 225],
            [80, 80, 80],
            [150, 150, 150],
            [200, 200, 200],
            [205, 205, 205],
            [255, 255, 255],
          ],

          [ // (player 5, black)
            [1, 1, 1],
            [5, 5, 5],
            [19, 19, 19],
            [36, 36, 36],
            [51, 51, 51],
            [69, 69, 69],
            [86, 86, 86],
            [24, 24, 24],
            [45, 45, 45],
            [101, 101, 101],
            [65, 65, 65],
            [0, 0, 0],
          ],

          [ // (player 6, yellow)
            [35, 35, 1],
            [66, 66, 1],
            [77, 77, 10],
            [116, 116, 23],
            [143, 143, 36],
            [169, 169, 53],
            [174, 174, 72],
            [90, 90, 24],
            [123, 123, 45],
            [188, 188, 101],
            [135, 135, 65],
            [200, 200, 0],
          ],
        ];

        var playerTextColors = [
          [204, 204, 204],
          [255, 100, 100],
          [153, 153, 255],
          [153, 255, 153],
          [255, 255, 255],
          [100, 100, 100],
          [255, 255, 100],
        ];

        var building_imgs = {

          castle: {
            img: { x: 0, y: 0, w: 76, h: 92, frameWidth: 76 },
            constructionImg: { x: 80, y: 13, w: 75, h: 78, frameWidth: 76 },
            damagedImg: { x: 158, y: 0, w: 76, h: 92, frameWidth: 76 },
            busyImgs: { x: 235, y: 0, w: 152, h: 92, frameWidth: 76, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
            busyDamagedImgs: { x: 188, y: 378, w: 152, h: 92, frameWidth: 76, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
            upgradeImg: { x: 2, y: 596, w: 76, h: 92, frameWidth: 76 },
            upgradeImgDamaged: { x: 80, y: 596, w: 76, h: 92, frameWidth: 76 },
          },

          barracks: {
            img: { x: 539, y: 160, w: 61, h: 79, frameWidth: 61 },
            constructionImg: { x: 417, y: 174, w: 60, h: 64, frameWidth: 60 },
            damagedImg: { x: 478, y: 160, w: 61, h: 79, frameWidth: 61 },
            busyImgs: { x: 478, y: 318, w: 122, h: 79, frameWidth: 61, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
            busyDamagedImgs: { x: 478, y: 239, w: 122, h: 79, frameWidth: 61, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
          },

          watchtower: {
            img: { x: 2, y: 190, w: 43, h: 71, frameWidth: 43 },
            constructionImg: { x: 46, y: 216, w: 43, h: 46, frameWidth: 43 },
            damagedImg: { x: 90, y: 191, w: 43, h: 71, frameWidth: 43 },
          },

          house: {
            img: { x: 538, y: 0, w: 62, h: 73, frameWidth: 62 },
            constructionImg: { x: 478, y: 17, w: 58, h: 56, frameWidth: 62 },
            damagedImg: { x: 417, y: 3, w: 59, h: 69, frameWidth: 62 },
          },

          mine: {
            img: { x: 3, y: 265, w: 60, h: 82, frameWidth: 60 },
            imgEmpty: { x: 127, y: 265, w: 60, h: 82, frameWidth: 60 },
          },

          mages_guild: {
            img: { x: 1, y: 353, w: 60, h: 76, frameWidth: 60 },
            constructionImg: { x: 63, y: 369, w: 58, h: 60, frameWidth: 58 },
            damagedImg: { x: 123, y: 354, w: 60, h: 76, frameWidth: 60 },
            busyImgs: { x: 1, y: 434, w: 120, h: 76, frameWidth: 60, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
            busyDamagedImgs: { x: 1, y: 514, w: 120, h: 76, frameWidth: 60, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
          },

          workshop: {
            img: { x: 4, y: 94, w: 72, h: 92, frameWidth: 72 },
            constructionImg: { x: 77, y: 101, w: 77, h: 85, frameWidth: 77 },
            damagedImg: { x: 157, y: 93, w: 72, h: 92, frameWidth: 72 },
            busyImgs: { x: 237, y: 93, w: 144, h: 92, frameWidth: 72, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
            busyDamagedImgs: { x: 196, y: 283, w: 144, h: 92, frameWidth: 72, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
          },

          forge: {
            img: { x: 548, y: 81, w: 84, h: 76, frameWidth: 84 },
            constructionImg: { x: 482, y: 90, w: 66, h: 69, frameWidth: 66 },
            damagedImg: { x: 395, y: 82, w: 84, h: 76, frameWidth: 84 },
            busyImgs: { x: 431, y: 404, w: 168, h: 76, frameWidth: 84, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
            busyDamagedImgs: { x: 135, y: 190, w: 168, h: 76, frameWidth: 84, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
          },

          start_location: {
            img: { x: 351, y: 405, w: 66, h: 55, frameWidth: 66 },
          },

          fortress: {
            img: { x: 128, y: 480, w: 76, h: 110, frameWidth: 76 },
            damagedImg: { x: 204, y: 480, w: 76, h: 110, frameWidth: 76 },
            busyImgs: { x: 280, y: 480, w: 152, h: 110, frameWidth: 76, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
            busyDamagedImgs: { x: 432, y: 480, w: 152, h: 110, frameWidth: 76, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
          },

          dragons_lair: {
            img: { x: 228, y: 595, w: 62, h: 93, frameWidth: 62 },
            constructionImg: { x: 169, y: 644, w: 52, h: 44, frameWidth: 52 },
            damagedImg: { x: 295, y: 595, w: 62, h: 93, frameWidth: 62 },
            busyImgs: { x: 363, y: 595, w: 62, h: 93, frameWidth: 62, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
            busyDamagedImgs: { x: 432, y: 595, w: 62, h: 93, frameWidth: 62, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
          },

          wolves_den: {
            img: { x: 3, y: 697, w: 65, h: 65, frameWidth: 65 },
            constructionImg: { x: 71, y: 697, w: 65, h: 65, frameWidth: 65 },
            damagedImg: { x: 277, y: 697, w: 65, h: 65, frameWidth: 65 },
            busyImgs: { x: 139, y: 697, w: 130, h: 65, frameWidth: 65, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
            busyDamagedImgs: { x: 347, y: 697, w: 130, h: 65, frameWidth: 65, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
            upgradeImg: { x: 417, y: 866, w: 65, h: 72, frameWidth: 65 },
            upgradeImgDamaged: { x: 485, y: 866, w: 65, h: 72, frameWidth: 65 },
          },

          animal_testing_lab: {
            img: { x: 5, y: 770, w: 77, h: 86, frameWidth: 77 },
            constructionImg: { x: 87, y: 777, w: 70, h: 79, frameWidth: 70 },
            damagedImg: { x: 317, y: 770, w: 77, h: 86, frameWidth: 77 },
            busyImgs: { x: 160, y: 770, w: 154, h: 86, frameWidth: 77, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
            busyDamagedImgs: { x: 395, y: 770, w: 154, h: 86, frameWidth: 77, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
          },

          adv_workshop: {
            img: { x: 640, y: 2, w: 84, h: 126, frameWidth: 84 },
            constructionImg: { x: 641, y: 265, w: 84, h: 82, frameWidth: 84 },
            damagedImg: { x: 640, y: 133, w: 84, h: 126, frameWidth: 84 },
            busyImgs: { x: 640, y: 2, w: 252, h: 126, frameWidth: 84, frames: [0, 0, 0, 1, 1, 1, 2, 2, 2] },
            busyDamagedImgs: { x: 640, y: 133, w: 252, h: 126, frameWidth: 84, frames: [0, 0, 0, 1, 1, 1, 2, 2, 2] },
          },

          werewolves_den: {
            img: { x: 3, y: 866, w: 65, h: 72, frameWidth: 65 },
            damagedImg: { x: 208, y: 866, w: 65, h: 72, frameWidth: 65 },
            busyImgs: { x: 71, y: 866, w: 130, h: 72, frameWidth: 65, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
            busyDamagedImgs: { x: 277, y: 866, w: 130, h: 72, frameWidth: 65, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
          },

          church: {
            img: { x: 4, y: 943, w: 74, h: 103, frameWidth: 74 },
            constructionImg: { x: 472, y: 965, w: 78, h: 81, frameWidth: 78 },
            damagedImg: { x: 82, y: 943, w: 74, h: 103, frameWidth: 74 },
            busyImgs: { x: 159, y: 943, w: 148, h: 103, frameWidth: 74, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
            busyDamagedImgs: { x: 316, y: 943, w: 148, h: 103, frameWidth: 74, frames: [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1] },
          },
        };

        const sleep = (t) => new Promise((resolve) => setTimeout(resolve, t));

        async function retry(f, period, timeout) {
          do {
            try {
              f();
              return;
            } catch (e) { }
            await sleep(period);
            timeout -= period;
          } while (timeout > 0);
        }

        function is(val) {
          return !(val === undefined || val === null);
        }

        let topZIndex = 1000;
        function fadeIn(jQueryElement) {
          if (jQueryElement[0].style.display == 'inline') {
            return;
          }

          jQueryElement[0].style.display = 'inline';
          jQueryElement[0].style.zIndex = topZIndex++;

          jQueryElement.css({
            opacity: 0,
            top: (parseInt(jQueryElement.css('top')) - 30) + 'px',
          }).animate({
            opacity: 1,
            top: (parseInt(jQueryElement.css('top')) + 30) + 'px',
          }, 200);
        }

        function fadeOut(jQueryElement) {
          if (jQueryElement[0].style.display == 'none') {
            return;
          }

          jQueryElement[0].style.display = 'inline';

          jQueryElement.css({
            opacity: 1,
          }).animate({
            opacity: 0,
            top: (parseInt(jQueryElement.css('top')) + 30) + 'px',
          }, 200, function () {
            jQueryElement.css({
              display: 'none',
              top: (parseInt(jQueryElement.css('top')) - 30) + 'px',
            });
          });

          if (jQueryElement.attr('id') == 'infoWindow2') {
            fadeOut($('#darkScreenDiv'));
          }
        }

        function addClickSound(callback) {
          return () => {
            callback(); soundManager.playSound(SOUND.CLICK);
          };
        }

        function addZipSound(callback) {
          return () => {
            callback(); soundManager.playSound(SOUND.ZIP, 0.3);
          };
        }

        function generateButton(htmlID, htmlClass, title, clickHandler, text) {
          const builder = new HTMLBuilder();
          builder.add('<button');
          if (!htmlID) {
            htmlID = uniqueID('btn');
          }
          builder.add(` id='${htmlID}'`);
          if (htmlClass) {
            builder.add(` class='${htmlClass}'`);
          }
          if (title) {
            builder.add(` title='${title}'`);
          }
          if (clickHandler) {
            builder.addHook(() => $(`#${htmlID}`).click(clickHandler));
          }
          builder.add('>');
          if (text) {
            builder.add(text);
          }
          return builder.add('</button>');
        }

        // Takes either an HTML element or an HTMLBuilder and adds it to the currently active chat window
        // which is either the main lobby chat or a game lobby chat
        function addToChatWindow(p) {
          const chatWindowSelector = LobbyPlayerManager.active ? '#lobbyGameChatTextArea' : '#lobbyChatTextArea';

          if (p && p.insertInto) {
            const chatID = uniqueID('chat');
            $(chatWindowSelector).append(`<span id='${chatID}'></span>`);
            p.insertInto(`#${chatID}`);
            if (LobbyPlayerManager.active) {
              soundManager.playSound(SOUND.ZIP3, 0.7);
            }
          } else {
            $(chatWindowSelector)[0].appendChild(p);
          }

          const chatWindow = $(chatWindowSelector)[0];
          if (chatWindow.scrollTop + chatWindow.offsetHeight >= chatWindow.scrollHeight - 250) {
            chatWindow.scrollTop = chatWindow.scrollHeight;
          }
        }

        // calculate the build time in ticks for all unit types and upgrade types
        function calculateTypesTickValues() {
          var types_ = game.buildingTypes.concat(game.unitTypes);
          for (var i = 0; i < types_.length; i++) {
            var t = types_[i];
            t.radius = t.size / 2;

            // if unit
            if (t.movementSpeed >= 0) {
              // calculate circle offsets depending on the radius (is used to check if a unit collides with a static object)
              t.circleOffsets = [];
              for (k = 0; k < checkAngles.length; k++) {
                var field = new Field(checkAngles[k][0], checkAngles[k][1], true).normalize(t.radius);
                t.circleOffsets.push([field.px, field.py]);
              }
            }

            if (t.size) {
              t.sizeX = t.size;
              t.sizeY = t.size;
            }
          }
        }


        var fogMaskAlpha = [
          0.75,
          0.5,
          0,
        ];

        var darkFogMaskAlpha = [
          1,
          0.6,
          0,
        ];


        AUTH_LEVEL = Object.freeze({
          NONE: 0,
          GUEST: 1,
          PLAYER: 2,
          MOD: 3,
          ADMIN: 4,
        });

        var auth_level_css_classes = [
          '',
          'playerLinkGuest',
          'playerLinkRegistered',
          'playerLinkMod',
          'playerLinkAdmin',
        ];

        var clan_member_role_names = [
          '',
          'moderator',
          'admin',
        ];

        var GAME = Object.freeze({
          LOGIN: 0,
          REGISTER: 1,
          PLAYING: 3,
          SKIRMISH: 4, // AI
          EDITOR: 5,
          LOBBY: 6,
          RECOVERY: 8,
          ACCEPT_AGB: 9,
        });

        var game_speeds = [
          { caption: '1/2x', tick_time: 100 },
          { caption: '1x', tick_time: 50 },
          { caption: '2x', tick_time: 25 },
          { caption: '4x', tick_time: 13 },
          { caption: '8x', tick_time: 6 },
          { caption: '16x', tick_time: 3 },
        ];

        var game_state = GAME.LOGIN;

        // TODO: replace this with a non-polling solution
        const onGameStateChange = (() => {
          const callbacks = [];
          let prevGameState = null;

          setInterval(() => {
            if (prevGameState != game_state) {
              callbacks.forEach((callback) => callback(game_state));
            }
            prevGameState = game_state;
          }, 100);

          return (callback) => callbacks.push(callback);
        })();

        function addChatMsg(sender, msg, emotes) {
          const builder = new HTMLBuilder();
          const el = PlayersList.players[sender];
          const escapedMsg = (sender == 'Server') ? msg : kappa(escapeHtml(msg), emotes);

          if (escapedMsg && escapedMsg.length > 0) {
            builder.add('<p>');
            builder.add(`<span class='time'>${getFormattedTime()} &nbsp;</span>`);
            if (el) {
              builder.add(network.getClanLink(el));
            }
            builder.add(network.getPlayerLink(el ? el : { name: sender, authLevel: AUTH_LEVEL.GUEST }, false));
            builder.add(`<span>: ${escapedMsg}</span>`);
            builder.add('</p>');

            addToChatWindow(builder);
          }
        }

        function pauseGame() {
          if (!network_game) {
            game_paused = !game_paused;
            interface_.addMessage(game_paused ? 'Game paused' : 'Game unpaused', 'yellow', imgs.attentionmarkYellow);
            soundManager.playSound(SOUND.POSITIVE);
            worker.postMessage({ what: 'setPause', val: game_paused });
          } else {
            network.send('request-pause');
          }
        }

        function typeNameIsUnique(name) {
          var found = false;

          _.each(lists.types, function (type) {
            if (type.name == name) {
              found = true;
            }
          });

          return !found;
        }

        function graphicNameIsUnique(name) {
          var found = false;

          _.each(lists.imgs, function (type) {
            if (type && type.name == name) {
              found = true;
            }
          });

          return !found;
        }

        function getImageFunctionName(func) {
          var returnVal = '';

          _.each(lists.imgs, function (imgFunc, key) {
            if (func == imgFunc) {
              returnVal = key;
            }
          });

          return returnVal;
        }

        function arraysAreSame(a1, a2, values) {
          if (a1 == a2) {
            return true;
          }

          if (!a2) {
            a2 = [];
          }

          if (!a1) {
            a1 = [];
          }

          if (Object.prototype.toString.call(a1) != Object.prototype.toString.call(a2)) {
            return false;
          }

          if (Object.prototype.toString.call(a1) === '[object Array]' && a1.length == a2.length) // both are array, compare elemnt by element
          {
            for (var j = 0; j < a1.length; j++) {
              if (a1[j] != ((values && (typeof a2[j] == 'string') && values[a2[j]]) ? values[a2[j]] : a2[j])) {
                return false;
              }
            }

            return true;
          }

          return false;
        }

        function objectsAreSame(o1, o2, values) {
          var isSame = true;

          if (o1 == o2 || !o1 && !o2) {
            return true;
          }

          if ((o1 && !o2) || (!o1 && o2)) {
            return false;
          }

          _.each(o1, function (val, key) {
            if (((values && (typeof val == 'string') && values[val]) ? values[val] : val) != ((values && (typeof o2[key] == 'string') && values[o2[key]]) ? values[o2[key]] : o2[key])) {
              isSame = false;
            }
          });

          _.each(o2, function (val, key) {
            if (((values && (typeof val == 'string') && values[val]) ? values[val] : val) != ((values && (typeof o1[key] == 'string') && values[o1[key]]) ? values[o1[key]] : o1[key])) {
              isSame = false;
            }
          });

          return isSame;
        }

        function getBuildingImgNameFromImgObject(o) {
          var returnVal = null;

          _.each(building_imgs, function (val, key) {
            if (o == val) {
              returnVal = key;
            }
          });

          return returnVal;
        }

        function isObject(o) {
          return typeof o === 'object' && o !== null;
        }

        function copyObject(o) {
          var o2 = {};
          _.each(o, function (val, key) {
            o2[key] = val;
          });
          return o2;
        }

        function setReplaySpeed(index) {
          replaySpeedIndex = Math.max(Math.min(index, game_speeds.length - 1), 0);
          TICK_TIME = game_speeds[replaySpeedIndex].tick_time;
          $('#replayShowSpeed').html(game_speeds[replaySpeedIndex].caption);
          worker.postMessage({ what: 'setTickTime', tickTime: TICK_TIME });
        }

        function getRainTimeFromSeed(seed) {
          var rng = new RNG(seed);
          var rainTime = [];
          var t_ = rng.getNr(-1, 15);
          var lastPoint = t_;
          var start = true;

          while (t_ < 300) {
            t_ += start ? rng.getNr(1, 7) : rng.getNr(2, 16);

            if (start) {
              rainTime.push({ start: lastPoint, end: t_ });
            }

            start = !start;
            lastPoint = t_;
          }

          return rainTime;
        }

        function RNG(seed) {
          this.m = 0x80000000; // 2**31;
          this.a = 1103515245;
          this.c = 12345;
          this.state = seed ? seed : Math.floor(Math.random() * (this.m - 1));
        }

        RNG.prototype.getNr = function (min, max) {
          this.state = (this.a * this.state + this.c) % this.m;

          var rangeSize = max - min;
          var randomUnder1 = this.state / this.m;
          return min + randomUnder1 * rangeSize;
        };

        const lcgVolume = LocalConfig.registerValue('lcgVolume', DEFAULT_VOLUME);
        function littlechatgame(log_) {
          var lcg_canvas = document.createElement('canvas');
          var lcg_context = lcg_canvas.getContext('2d');
          lcg_canvas.width = $('#lobbyChatTextArea').width() - 20;
          lcg_canvas.height = 90;

          lcg = log_;
          lcg.currentPhase = -1;
          lcg.army = [];
          lcg.startTime = Date.now() + 2000;
          lcg.canvas = lcg_canvas;
          lcg.ticksCounter = -1;
          lcg.actualPhase = -1;

          game = new Game();
          game.loadMap({
            'name': 'unnamed',
            'x': 30,
            'y': 10,
            'units': [],
            'buildings': [],
            'tiles': [],
            'defaultTiles': ['Ground n 6'],
            'unitData':
            {
              'dragon':
              {
                'imageScale': 0.7,
                'height': 1.5,
                'projectileSpeed': 12,
              },

              'ballista':
              {
                'imageScale': 0.8,
              },

              'catapult':
              {
                'projectileSpeed': 12,
                'imageScale': 0.8,
              },

              'fireball':
              {
                'projectileSpeed': 9,
                // },

                // "gyrocraft":
                // {
                // 	"imageScale": 0.1,
                // 	"height": 1.5
              },
            },
          }, null, null, null, false, true);

          lcg_context.font = 'bold 32px LCDSOlid';
          drawText(lcg_context, log_.players[0], game.players[1].getColor(), 'bold 32px LCDSolid', 10, 30);
          var w1 = lcg_context.measureText(log_.players[0]).width;
          drawText(lcg_context, 'vs', 'white', 'bold 32px LCDSolid', 10 + w1 + 10, 30);
          var w2 = lcg_context.measureText('vs').width;
          drawText(lcg_context, log_.players[1], game.players[2].getColor(), 'bold 32px LCDSolid', 10 + w1 + w2 + 20, 30);

          soundManager.playSound(SOUND.BATTLE_FANFARE, lcgVolume.get());

          // vision
          for (var x = 0; x < 30; x++) {
            for (var y = 0; y < 10; y++) {
              PLAYING_PLAYER.team.mask[x][y] = 2;
            }
          }

          var players = [
            new Player('pl1', CONTROLLER.COMPUTER, 1),
            new Player('pl2', CONTROLLER.COMPUTER, 2),
          ];

          var pos = 3;

          for (var i = 0; i < log_.armies[0].length; i++) {
            lcg.army.push(new Unit({
              x: pos++,
              y: 3.2,
              type: log_.armies[0][i] == 'Gatlinggun' ? 'Gatling Gun'.toUnitType() : log_.armies[0][i].toUnitType(),
              owner: players[0],
            }));
          }

          for (var i = log_.armies[1].length - 1; i >= 0; i--) {
            lcg.army.push(new Unit({
              x: pos++,
              y: 3.2,
              type: log_.armies[1][i] == 'Gatlinggun' ? 'Gatling Gun'.toUnitType() : log_.armies[1][i].toUnitType(),
              owner: players[1],
            }));
          }

          addToChatWindow(lcg_canvas);

          clearInterval(lcg_interval);

          lcg_interval = setInterval(function () {
            var timeNow = Date.now();

            if (game_state != GAME.LOBBY) {
              clearInterval(lcg_interval);
              return;
            }

            if (lcg.startTime > timeNow) {
              return;
            }

            var age = timeNow - lcg.startTime;
            var phaseAge = age % 1500;
            var phaseStartTime = timeNow - phaseAge;
            var phaseAgeInTicks = Math.floor(phaseAge / 50);
            var phase = Math.floor(age / 1500);
            ticksCounter = Math.floor(age / 1000 * 20);
            percentageOfCurrentTickPassed = (age % 50) / 50;
            var phaseType = lcg.actualPhase % 3;
            tickDiff = 0;

            // if not die phase, set units that have been thrown to target pos, because it might not have happened correctly, if the screen was inactive during throwing
            if (phaseType != 1) {
              for (var i = 0; i < lcg.army.length; i++) {
                if (lcg.army[i].setToPos) {
                  lcg.army[i].pos = lcg.army[i].setToPos;
                  lcg.army[i].lastTicksPosition = lcg.army[i].setToPos;
                  lcg.army[i].drawPos = lcg.army[i].setToPos;
                  delete lcg.army[i].setToPos;
                }
              }
            }

            // update
            if (phase != lcg.currentPhase) {
              lcg.currentPhase = phase;

              for (var i = 0; i < lcg.army.length; i++) {
                lcg.army[i].order = lists.types.stop;
                lcg.army[i].lastAttackingTick = -999;
                lcg.army[i].lastTicksPosition = lcg.army[i].pos;
              }

              var arr = [];
              while (arr.length == 0) {
                lcg.actualPhase++;
                arr = lcg.replay[lcg.actualPhase];

                if (!arr) // battle over
                {
                  if (lcg.hasBeenDrawn) {
                    clearInterval(lcg_interval);
                    lcg_context.font = 'bold 32px LCDSOlid';

                    if (lcg.winner == 0) {
                      drawText(lcg_context, 'draw', 'white', 'bold 32px LCDSolid', 200, 60);
                    } else {
                      drawText(lcg_context, lcg.players[lcg.winner - 1] + ' wins', game.players[lcg.winner].getColor(), 'bold 32px LCDSolid', 200, 60);
                    }

                    return;
                  } else {
                    arr = [0];
                  }
                }
              }

              phaseType = lcg.actualPhase % 3;

              if (phaseType == 0) // attack phase
              {
                for (var i = 0; i < arr.length; i++) {
                  if (arr[i].indexOf && arr[i].indexOf('A') >= 0) // attack
                  {
                    var split = arr[i].split('A');

                    var u1 = game.getUnitById(split[0]);
                    var u2 = game.getUnitById(split[1]);

                    u1.targetUnit = u2;
                    u1.order = lists.types.attack;
                    u1.lastAttackingTick = ticksCounter;
                    u1.tickOfLastWeaponFired = ticksCounter + u1.type.weaponDelay;
                  } else if (arr[i].indexOf && arr[i].indexOf('S') >= 0) // smash
                  {
                    var split = arr[i].split('S');

                    var u1 = game.getUnitById(split[0]);
                    var u2 = game.getUnitById(split[1]);

                    u1.targetUnit = u2;
                    u1.order = lists.types.smash;
                    u1.lastAttackingTick = ticksCounter;
                    u1.tickOfLastWeaponFired = ticksCounter + u1.type.weaponDelay;
                  } else if (arr[i].indexOf && arr[i].indexOf('H') >= 0) // heal
                  {
                    var split = arr[i].split('H');

                    var u1 = game.getUnitById(split[0]);
                    var u2 = game.getUnitById(split[1]);

                    u1.targetUnit = u2;
                    u1.order = lists.types.heal;
                    u1.lastAttackingTick = ticksCounter;
                    u1.tickOfLastWeaponFired = ticksCounter + u1.type.weaponDelay;
                  } else if (arr[i].indexOf && arr[i].indexOf('F') >= 0) // fireball
                  {
                    var split = arr[i].split('F');

                    var u1 = game.getUnitById(split[0]);
                    var u2 = game.getUnitById(split[1]);

                    u1.targetUnit = u2;
                    u1.order = lists.types.attack;
                    u1.lastAttackingTick = ticksCounter;
                    u1.tickOfLastWeaponFired = ticksCounter + u1.type.weaponDelay;

                    new Flamestrike({
                      from: u1,
                      to: new Field(parseInt(split[2]), u1.pos.py, true),
                      speed: 3,
                      noFinalBlow: true,
                      scale: 1,
                    });

                    soundManager.playSound(SOUND.FIREBALL, lcgVolume.get());
                  }
                }
              }

              if (phaseType == 1) // die phase
              {
                for (var i = 0; i < arr.length; i++) {
                  if (arr[i].indexOf && arr[i].indexOf('X') >= 0) // get smashed
                  {
                    var u1 = game.getUnitById(arr[i].split('X')[0]);

                    u1.isThrowedUntil = ticksCounter + 15;
                    u1.throwStart = ticksCounter;
                    u1.throwFrom = u1.pos.getCopy();
                    u1.throwTo = new Field(parseInt(arr[i].split('X')[1]), u1.pos.py, true);
                    u1.lastTicksPosition = u1.throwTo.getCopy();
                    u1.setToPos = u1.throwTo.getCopy();
                    u1.targetPos_ = u1.throwTo.getCopy();
                    u1.target = u1.throwTo.getCopy();
                  } else if (arr[i].indexOf && arr[i].indexOf('Z') >= 0) // flash
                  {
                    soundManager.playSound(SOUND.WARP, lcgVolume.get());
                    var u1 = game.getUnitById(arr[i].split('Z')[0]);

                    u1.targetPos_ = new Field(parseInt(arr[i].split('Z')[1]), u1.pos.py, true);
                    u1.setToPos = u1.targetPos_.getCopy();
                    u1.originPos_ = u1.pos.getCopy();
                    u1.target = u1.targetPos_.getCopy();
                    u1.moveStartTime_ = phaseStartTime;
                    u1.order = lists.types.TELEPORT;
                  } else // die
                  {
                    var u1 = game.getUnitById(arr[i]);

                    u1.isAlive = false;
                    u1.throwStart = ticksCounter;
                    u1.isThrowedUntil = ticksCounter + 25;
                    u1.throwFrom = u1.pos;
                    u1.throwTo = u1.pos;

                    if (u1.type.deathSound) {
                      soundManager.playSound(u1.type.deathSound, lcgVolume.get());
                    }
                  }
                }
              }

              if (phaseType == 2) // move phase
              {
                for (var i = 0; i < arr.length; i++) {
                  if (arr[i].indexOf && arr[i].indexOf('M') >= 0) {
                    var u1 = game.getUnitById(arr[i].split('M')[0]);

                    u1.targetPos_ = new Field(arr[i].split('M')[1], u1.pos.py, true);
                    u1.originPos_ = u1.pos.getCopy();
                    u1.target = u1.targetPos_;
                    u1.moveStartTime_ = phaseStartTime;
                    u1.order = lists.types.move;
                  }
                }
              }
            }

            if (lcg.ticksCounter != ticksCounter) {
              lcg.ticksCounter = ticksCounter;
              tickDiff = 1;

              for (var i = 0; i < lcg.army.length; i++) {
                var u = lcg.army[i];

                if (phaseType == 0) // attack phase
                {
                  if ((u.order == lists.types.attack || u.order == lists.types.smash) && phaseAgeInTicks < u.type.weaponCooldown - 5) {
                    u.hitCycle++;
                    u.lastAttackingTick = ticksCounter;

                    if (u.tickOfLastWeaponFired == ticksCounter) {
                      if (u.type.attackEffect) // create projectile (if ranged)
                      {
                        startEffect(u.type.attackEffect, {
                          from: u,
                          to: u.targetUnit,
                          speed: u.type.projectileSpeed / 2,
                        });
                      }

                      if (u.type.meleeHitSound) {
                        soundManager.playSound(u.type.meleeHitSound, lcgVolume.get());
                      }

                      if (u.type.attackLaunchSound) {
                        soundManager.playSound(u.type.attackLaunchSound, lcgVolume.get());
                      }

                      if (u.targetUnit.type.painSound) {
                        soundManager.playSound(u.targetUnit.type.painSound, lcgVolume.get());
                      }
                    }
                  }

                  if (u.tickOfLastWeaponFired == ticksCounter && u.order == lists.types.heal) {
                    startEffect('heal', {
                      originPos: u.pos,
                      from: u.targetUnit,
                    });

                    soundManager.playSound(SOUND.HEAL, lcgVolume.get());
                  }
                }

                if (u.targetPos_ && u.pos.distanceTo2(u.targetPos_) > 0.03) {
                  if (u.order == lists.types.TELEPORT) {
                    u.lastTicksPosition = u.pos;
                    u.pos = u.originPos_.addNormalizedVector(u.targetPos_, (Math.min(timeNow - u.moveStartTime_, 1) / 1) * u.originPos_.distanceTo2(u.targetPos_));
                  } else {
                    u.lastTicksPosition = u.pos;
                    u.pos = u.originPos_.addNormalizedVector(u.targetPos_, (Math.min(timeNow - u.moveStartTime_, 1500) / 1500) * u.originPos_.distanceTo2(u.targetPos_));
                  }
                } else {
                  u.lastTicksPosition = u.pos;
                }
              }
            }

            lcg.canvas.style.width = '95%';
            lcg.canvas.width = lcg.canvas.width;
            SCALE_FACTOR = 1.5;
            FIELD_SIZE = 16 * SCALE_FACTOR;
            c = lcg.canvas.getContext('2d');
            lcg.hasBeenDrawn = true;

            // draw
            for (var i = 0; i < lcg.army.length; i++) {
              lcg.army[i].updateDrawPosition();
              lcg.army[i].draw();
            }

            // draw effectz
            var objs = game.objectsToDraw.slice();
            for (var i = 0; i < objs.length; i++) {
              if (objs[i].isEffect) {
                objs[i].draw(0, 0, 0, 0, lcgVolume.get());

                if (objs[i].isExpired()) {
                  if (objs[i].to && objs[i].to.type && objs[i].to.type.painSound) {
                    soundManager.playSound(objs[i].to.type.painSound, lcgVolume.get());
                  }

                  if (objs[i].to && objs[i].to.type && objs[i].to.type.painSound2) {
                    soundManager.playSound(objs[i].to.type.painSound2, lcgVolume.get());
                  }

                  if (objs[i].constructor == LaunchedRock) {
                    soundManager.playSound(SOUND.CATA_IMPACT, lcgVolume.get());
                  }

                  game.objectsToDraw.erease(objs[i]);
                }
              }
            }

            var ageFactor = Math.min(age / 1000, 1);
            lcg_context.font = 'bold ' + (31 - ageFactor * 13) + 'px LCDSOlid';
            drawText(lcg_context, log_.players[0], game.players[1].getColor(), 'bold ' + (31 - ageFactor * 13) + 'px LCDSolid', 10, 30 - ageFactor * 9);
            var w1 = lcg_context.measureText(log_.players[0]).width;
            drawText(lcg_context, 'vs', 'white', 'bold ' + (31 - ageFactor * 13) + 'px LCDSolid', 10 + w1 + (10 - ageFactor * 4), 30 - ageFactor * 9);
            var w2 = lcg_context.measureText('vs').width;
            drawText(lcg_context, log_.players[1], game.players[2].getColor(), 'bold ' + (31 - ageFactor * 13) + 'px LCDSolid', 10 + w1 + w2 + (20 - ageFactor * 8), 30 - ageFactor * 9);

            c = originalC;
          }, 10);
        };

        function escapeHtml(text) {
          return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
        };

        // Subsitute chat messages
        function kappa(text, permissions) {
          // replace ish
          if ((new RegExp('\u5350|\u534D', 'g')).test(text)) {
            return '';
          }

          permissions = permissions ? hex32ToBin(permissions) : null;

          // console.dir(permissions);
          var em = emotes.concat(_emotes2);

          // ?
          for (var i = 0; i < em.length; i++) {
            if (!em[i].dbPos || (permissions && em[i].dbPos <= permissions.length && permissions.substr(permissions.length - em[i].dbPos, 1) == '1')) {
              text = text.replace(new RegExp(em[i].text, 'g'), '#<<#<>#<' + i + '#<<#<>#');
            }
          }

          // Own name highlighting
          text = text.replace(new RegExp(networkPlayerName, 'gi'), '<span class=\'highlighted2\'>' + networkPlayerName + '</span>');

          // emotes
          for (var i = 0; i < em.length; i++) {
            // console.dir(em[i]);
            if (!em[i].dbPos || (permissions && em[i].dbPos <= permissions.length && permissions.substr(permissions.length - em[i].dbPos, 1) == '1')) {
              text = text.replace(new RegExp('#<<#<>#<' + i + '#<<#<>#', 'g'), '<img class=\'kappa\' src=\'imgs/emotes/' + em[i].img + '\' />');
            }
          }

          return text;
        };

        function soundFaceOut() {
          if (soundManager.buildingClickSound[0] && soundManager.buildingClickSound[0].fadeOut) {
            var newVolume = soundManager.buildingClickSound[0].sound.volume - soundManager.buildingClickSound[0].maxVolume / 11;

            if (newVolume <= 0) {
              soundManager.buildingClickSound[0].sound.pause();
              soundManager.buildingClickSound[0].sound.volume = 0;
              soundManager.buildingClickSound[0].sound.currentTime = 0;
              soundManager.buildingClickSound.splice(0, 1);
            } else {
              soundManager.buildingClickSound[0].sound.volume = newVolume;
              setTimeout(soundFaceOut, 50);
            }
          }
        }

        function levelUp(splitMsg) {
          var xp1 = getXPRequiredForLvl(splitMsg[1]);
          var xp2 = getXPRequiredForLvl(parseInt(splitMsg[1]) + 1);

          const builder = new HTMLBuilder();

          builder.add('<img style=\'height: 200px;\' src=\'imgs/level-up.png\' /><br />');
          builder.add('<span style=\'font-size: 30px;\'>You reached level ');
          builder.add(`<span class='greenfont' style='font-size: 42px;'>${splitMsg[1]}</span></span><br /><br />`);

          builder.add('<div class=\'xpBarContainer\' style=\'width: 200px; height: 30px; margin: 0 auto; position: relative;\'>');
          builder.add(`<div class='xpBar' style='width: ${(((splitMsg[2] - xp1) / (xp2 - xp1)) * 200)}px; height: 30px'></div>`);
          builder.add('<div style=\'position: absolute; top: 0px; width: 100%; margin: 0 auto; font-size: 22px; height: 30px; line-height: 30px\'>');
          builder.add(`${splitMsg[2]} / ${xp2}</div></div>`);
          if (splitMsg[3] > 0) {
            builder.add(`<div id='goldRewardONLvlUp' title='You received ${splitMsg[3]} gold as a reward'>`);
            builder.add(`+${splitMsg[3]} `);
            builder.add('<img src=\'imgs/gold2.png\' class=\'pixelated\' style=\'height: 32px;\' /></div>');
          }

          storedAchievements.push({
            builder: builder,
            sound: SOUND.ARCHIVEMENT3,
          });

          showAchievement();
          AccountInfo.gold += parseInt(splitMsg[3]);

          for (var i = 4; i < splitMsg.length; i++) {
            unlockEmote(splitMsg[i]);
          }
        };
        // TODO: Review this
        function alphabetizePlayers(p_dict) {
          // Grabs all players, separates by authLevel/Premium status, then alphabetizes them

          gst_arr = [];
          acc_arr = [];
          pre_arr = [];
          mod_arr = [];
          dev_arr = [];
          alpha_arr = [];
          new_dict = {};

          /* Separate players by their authLevel and Premium Status:
            authLevel 1 = Guest
            authLevel 2 = Normal Account
            authLevel 2 w/ Premium = Premium
            authLevel 3 = Moderator
            authLevel 4 = Developer
          */

          for (let auth in p_dict) {
            if (p_dict[auth].authLevel == '1') {
              gst_arr.push(p_dict[auth].name.toLowerCase());
            } else if ((p_dict[auth].authLevel == '2') && (p_dict[auth].premium != true)) {
              acc_arr.push(p_dict[auth].name.toLowerCase());
            } else if ((p_dict[auth].authLevel == '2') && (p_dict[auth].premium == true)) {
              pre_arr.push(p_dict[auth].name.toLowerCase());
            } else if (p_dict[auth].authLevel == '3') {
              mod_arr.push(p_dict[auth].name.toLowerCase());
            } else if (p_dict[auth].authLevel == '4') {
              dev_arr.push(p_dict[auth].name.toLowerCase());
            }
          }

          gst_arr.sort();
          acc_arr.sort();
          pre_arr.sort();
          mod_arr.sort();
          dev_arr.sort();

          var omega_arr = alpha_arr.concat(dev_arr, mod_arr, pre_arr, acc_arr, gst_arr);

          for (let name in omega_arr) {
            for (let p in p_dict) {
              if (omega_arr[name] == p_dict[p].name.toLowerCase()) {
                new_dict[name] = p_dict[p];
              }
            }
          }

          return new_dict;
        }

        function secToDate(sec) {
          var str = '';

          if (sec > 60 * 60 * 24) {
            str += parseInt(sec / (60 * 60 * 24)) + ' days, ';
            sec = sec % (60 * 60 * 24);
          }

          if (sec > 60 * 60) {
            str += parseInt(sec / (60 * 60)) + ' hours, ';
            sec = sec % (60 * 60);
          }

          str += Math.ceil(sec / 60) + ' min';

          return str;
        }

        function unlockEmote(artNr, newPremiumTime) {
          var arch_ = emotes.concat(skins, dances, goldPacks, specials, _emotes2);
          for (var i = 0; i < arch_.length; i++) {
            if (arch_[i].artNr == artNr) {
              fadeOut($('#playerInfoWindow'));

              var text = '';
              var img = '';
              var text2 = '';

              if (arch_[i].type == 'skins') {
                var img = unit_imgs[arch_[i].img];

                var w = img.idle.frameWidth;
                var h = img.idle.h / img._angles;

                if (w > h) {
                  h = 160 * (h / w);
                  w = 160;
                } else {
                  w = 160 * (w / h);
                  h = 160;
                }

                var w2 = img.file[1].width * (w / img.idle.frameWidth);
                var h2 = img.file[1].height * (h / (img.idle.h / img._angles));
                var x = img.idle.x * (w2 / img.file[1].width);
                var y = img.idle.y * (h2 / img.file[1].height);

                text = 'Skin <span class=\'greenfont\'> ' + arch_[i].name + '</span> unlocked';
                img = '<div style=\'width: ' + w + 'px; height: ' + h + 'px; overflow: hidden; position: relative; margin: 0 auto;\'><img class=\'pixelated\' style=\'position: absolute; left: ' + -x + 'px; top: ' + -y + 'px; width: ' + w2 + 'px; height: ' + h2 + 'px;\' src=\'' + (img.file[1].toDataURL ? img.file[1].toDataURL() : img.file[1].src) + '\' /></div>';
                text2 = 'Select this skin from the \'Skins and Dances\' menu to use it. Works in multiplayer games only.';
              } else if (arch_[i].type == 'dances') {
                var img = unit_imgs[arch_[i].img];

                var w = img.idle.frameWidth;
                var h = img.idle.h / img._angles;

                if (w > h) {
                  h = 160 * (h / w);
                  w = 160;
                } else {
                  w = 160 * (w / h);
                  h = 160;
                }

                var w2 = img.file[1].width * (w / img.idle.frameWidth);
                var h2 = img.file[1].height * (h / (img.idle.h / img._angles));
                var x = img.idle.x * (w2 / img.file[1].width);
                var y = img.idle.y * (h2 / img.file[1].height);

                text = 'Dance <span class=\'greenfont\'> ' + arch_[i].name + '</span> unlocked';
                img = '<div style=\'width: ' + w + 'px; height: ' + h + 'px; overflow: hidden; position: relative; margin: 0 auto;\'><img class=\'pixelated\' style=\'position: absolute; left: ' + -x + 'px; top: ' + -y + 'px; width: ' + w2 + 'px; height: ' + h2 + 'px;\' src=\'' + (img.file[1].toDataURL ? img.file[1].toDataURL() : img.file[1].src) + '\' /></div>';
                text2 = 'In a multiplayer game, select one or more units of this type and type \'' + arch_[i].chat_str + '\' in chat to make them dance.';
              } else if (arch_[i].type == 'emotes') {
                text = (arch_[i].hidd ? '<span class=\'hidden_item\'>Hidden</span> ' : '') + 'Emote <span class=\'greenfont\'> ' + arch_[i].name + '</span> unlocked';
                img = '<img class=\'pixelated\' style=\'height: 160px;\' src=\'imgs/emotes/' + arch_[i].img + '\' />';
                text2 = 'Type \'' + arch_[i].text + '\' in lobby chat to use this emote.';
              } else if (arch_[i].type == 'gold') {
                text = 'Received <span class=\'yellowfont\' style=\'font-size: 40px;\'> ' + arch_[i].reward + '</span> gold';
                img = '<img class=\'pixelated\' style=\'height: 160px;\' src=\'imgs/gold2.png\' />';
                AccountInfo.gold += parseInt(arch_[i].reward);
              } else if (arch_[i].type == 'special') {
                if (arch_[i].type_2 == 'premium') {
                  text = 'Premium account unlocked';
                  img = '<img class=\'pixelated\' style=\'height: 160px;\' src=\'imgs/emotes/' + arch_[i].img + '\' />';
                  AccountInfo.premiumExpiry = newPremiumTime;
                }
              }

              storedAchievements.push({
                text: img + '<br /><br /><br /><br /><br /><span style=\'font-size: 30px;\'>' + text + '</span><div style=\'margin-top: 20px;\'>' + text2 + '</div>',
                sound: SOUND.ARCHIVEMENT,
              });

              showAchievement();

              return;
            }
          }
        };

        function unlockAchivement(index) {
          var a = achivements[index];

          if (!a) {
            return;
          }

          storedAchievements.push({
            text: '<img class=\'pixelated\' style=\'height: 135px;\' src=\'imgs/achivements/' + a.img + '\' /><br /><br /><br /><div style=\'font-size: 24px;\'>Achievement <span class=\'ach_name\'> ' + a.name + '</span> unlocked</div><div class=\'achivement_text\'>(' + a.text + ')</div><br /><div id=\'ach_lowline\' title=\'The amount of gold you get for this achievement\'><span>Reward:</span> <span id=\'reward_amount\'>' + a.reward + '</span> <img class=\'pixelated\' style=\'width: 48px;\' src=\'imgs/gold2.png\'/></div>',
            sound: SOUND.ARCHIVEMENT,
          });

          AccountInfo.gold += a.reward;
          showAchievement();
        };

        function showAchievement() {
          if ($('#infoWindow2').css('display') == 'none' && storedAchievements.length > 0 && game_state != GAME.PLAYING) {
            var a = storedAchievements.splice(0, 1)[0];
            // TODO: deprecate text member of storedAchievements
            displayInfoMsgDarkBG(a.builder || a.text);
            soundManager.playSound(a.sound);
          }
        };

        function showAchievementsWindow(ach_str) {
          uimanager.playerInfoWindow.setTitle('<font style=\'color: rgb(255, 248, 57);\'>Achievements</font>');

          var str = '';

          for (var i = 0; i < achivements.length; i++) {
            var a = achivements[i];
            var rewardStr = a.reward ? `(reward: ${a.reward} gold)` : '';
            str += '<div class=\'achivement_div ' + (checkDBPos(a.dbPos, ach_str) ? '' : 'achivement_img_locked') + `' title='${a.text} ${rewardStr}'>`;
            str += '<img class=\'pixelated\' style=\'height: 108px;\' src=\'imgs/achivements/' + a.img + '\' /><p ' + (checkDBPos(a.dbPos, ach_str) ? '' : 'class=\'greyfont\'') + '>' + a.name + '</p></div>';
          }

          $('#addScrollableSubDivTextArea').html(str);
          fadeIn($('#playerInfoWindow'));
        };


        function checkDBPos(pos, dbEntry) {
          return dbEntry.length >= pos && dbEntry.substr(dbEntry.length - pos, 1) == '1';
        };

        function animateDances(offsets, maxs, xs, ys) {
          setTimeout(function () {
            if ($('#dance_img_0').is(':visible')) {
              for (var i = 0; i < offsets.length; i++) {
                var offset = parseFloat($('#dance_img_' + i)[0].style.marginLeft) - offsets[i];

                if (offset < (-maxs[i] + offsets[i] / 2)) {
                  offset = 0;
                }

                $('#dance_img_' + i)[0].style.marginLeft = (offset - xs[i]) + 'px';
                $('#dance_img_' + i)[0].style.marginTop = -ys[i] + 'px';
              }

              animateDances(offsets, maxs, xs, ys);
            }
          }, 150);
        };

        function hex32ToBin(s) {
          var returnVal = '';

          for (var i = s.length - 1; i >= 0; i--) {
            var char_ = s.substr(i, 1);
            var val = !isNaN(char_) ? parseInt(char_) : char_.charCodeAt(0) - 'A'.charCodeAt(0) + 10;

            for (var k = 1; k <= 5; k++) {
              var modulu = val % Math.pow(2, k);
              returnVal = (modulu == 0 ? '0' : '1') + returnVal;
              val -= modulu;
            }
          }

          return returnVal;
        };

        function showImprint() {
          soundManager.playSound(SOUND.CLICK);
          $('#addScrollableSubDivTextArea2').html('<br /><br /><div style=\'margin-left: 30px;\'>littlewargame.com<br /><br />Owner:<br />Addicting Games, Inc.<br />15332 Antioch Street Los Angeles<br /> Suite 200<br /> California 90272<br /> USA</br>email: chris@addictinggames.com</div>');
          fadeIn($('#playerInfoWindow2'));
          uimanager.playerInfoWindow2.setTitle('<font style=\'color: rgb(255, 248, 57);\'>Imprint</font>');
        };

        function getItemFromArtNr(artNr) {
          var arr = emotes.concat(skins, dances, goldPacks, specials, _emotes2);

          for (var i = 0; i < arr.length; i++) {
            if (arr[i].artNr == artNr) {
              return arr[i];
            }
          }

          return null;
        };

        function onSubmit(e) {
          if (!$('#check1').prop('checked')) {
            displayInfoMsg('You have to accept the text');
            e.preventDefault();
            return false;
          }

          if (!$('#check2').prop('checked')) {
            displayInfoMsg('You have to accept the terms and conditions');
            e.preventDefault();
            return false;
          }

          var radioVal = $('input[name="legal_radio"]:checked').val();

          if (!radioVal) {
            displayInfoMsg('You have to select a cancellation policy option');
            e.preventDefault();
            return false;
          }

          $('#buy_form_item_number')[0].value = $('#original_value')[0].value + '_' + radioVal;

          setTimeout(function () {
            $('#addScrollableSubDivTextArea').html('<div style=\'width: 100%; text-align: center; margin-top: 200px; font-size: 30px;\'>Waiting while payment is being handled ...</div>');
          }, 1000);

          return true;
        };

        function showAGB() {
          $.ajax({
            dataType: 'text',
            url: 'agb.html',
          }).done(function (data) {
            soundManager.playSound(SOUND.CLICK);
            uimanager.playerInfoWindow2.setTitle('<font style=\'color: rgb(255, 248, 57);\'>Terms and conditions</font>');
            $('#addScrollableSubDivTextArea2').html('<div style=\'font-size: 14px;\'>' + data + '</div>');
            fadeIn($('#playerInfoWindow2'));
            $('#addScrollableSubDivTextArea2')[0].scrollTop = 0;
          });
        };

        function showWRE() {
          $.ajax({
            dataType: 'text',
            url: 'wre.html',
          }).done(function (data) {
            soundManager.playSound(SOUND.CLICK);
            uimanager.playerInfoWindow2.setTitle('<font style=\'color: rgb(255, 248, 57);\'>Cancellation policy</font>');
            $('#addScrollableSubDivTextArea2').html('<div style=\'font-size: 14px;\'>' + data + '</div>');
            fadeIn($('#playerInfoWindow2'));
            $('#addScrollableSubDivTextArea2')[0].scrollTop = 0;
          });
        };

        function showDSE() {
          $.ajax({
            dataType: 'text',
            url: 'dse.html',
          }).done(function (data) {
            soundManager.playSound(SOUND.CLICK);
            uimanager.playerInfoWindow2.setTitle('<font style=\'color: rgb(255, 248, 57);\'>Privacy Policy</font>');
            $('#addScrollableSubDivTextArea2').html('<div style=\'font-size: 14px;\'>' + data + '</div>');
            fadeIn($('#playerInfoWindow2'));
            $('#addScrollableSubDivTextArea2')[0].scrollTop = 0;
          });
        };

        // validates if a username is correct
        function validatePlayerName(name) {
          return name.length > 2 && name.length < 21 && name.match(/[A-Za-z0-9\-\_]*/) == name;
        };

        function killFaqMsg0() {
          soundManager.playSound(SOUND.CLICK);
          displayConfirmPrompt(
            'Hide this message? You will still be able to read the FAQs by clicking the FAQ button in the options window.',
            killFaqMsg,
            () => { },
          );
        };

        // TODO: remove this
        const hideFAQ = LocalConfig.registerValue('hide_faq', false);
        function killFaqMsg() {
          soundManager.playSound(SOUND.CLICK);
          $('#faqContainer').remove();
          hideFAQ.set(true);
          fadeOut($('#infoWindow'));
        };

        const hideTutorials = LocalConfig.registerValue('hide_tutorials', false);
        function killTutorialButton() {
          soundManager.playSound(SOUND.CLICK);
          $('#tutorialButtonSpan').remove();
          hideTutorials.set(true);
        };

        function testMap() {
          mapData = game.export_(false); // save map data, so after ending test game, we can go back to the editor and reload the start map state
          mapData.img = getImageFromMap(game.export_(true));
          uimanager.showLoadingScreen(mapData); // show loading screen

          setTimeout(function () {
            game_state = GAME.PLAYING;
            game = new Game();
            game.loadMap(mapData);

            worker.postMessage({
              what: 'start-game',
              fromEditor: true,
              map: mapData,
              network_game: network_game,
              game_state: game_state,
              networkPlayerName: networkPlayerName,
              aiRandomizer: Math.ceil(Math.random() * 100000),
            });
          }, 50);

          game.playingFromEditor = true;
        }

        // is called, when a user enters values in the x/y-size inputs of the new map window in the editor, checks if theyre valid and makes then, if not
        function checkNewMapInputs() {
          var x = parseInt($('#newMapSizeX')[0].value);
          var y = parseInt($('#newMapSizeY')[0].value);

          if (!x || !y) {
            displayInfoMsg('Please enter valid numbers.');
            if (!x) {
              $('#newMapSizeX')[0].value = MIN_MAP_SIZE;
            }
            if (!y) {
              $('#newMapSizeY')[0].value = MIN_MAP_SIZE;
            }
            return false;
          }
          if (x < MIN_MAP_SIZE || y < MIN_MAP_SIZE || x > MAX_MAP_SIZE || y > MAX_MAP_SIZE) {
            displayInfoMsg(`Invalid map size, must be between ${MIN_MAP_SIZE}x${MIN_MAP_SIZE} and ${MAX_MAP_SIZE}x${MAX_MAP_SIZE}.`);
            if (x < MIN_MAP_SIZE) {
              $('#newMapSizeX')[0].value = MIN_MAP_SIZE;
            }
            if (y < MIN_MAP_SIZE) {
              $('#newMapSizeY')[0].value = MIN_MAP_SIZE;
            }
            if (x > MAX_MAP_SIZE) {
              $('#newMapSizeX')[0].value = MAX_MAP_SIZE;
            }
            if (y > MAX_MAP_SIZE) {
              $('#newMapSizeY')[0].value = MAX_MAP_SIZE;
            }
            return false;
          }

          $('#newMapSizeX')[0].value = x;
          $('#newMapSizeY')[0].value = y;
          return true;
        };

        var onDrag = function (e, ui) {
          var fiftyPercent = ui.helper.css('marginLeft').replace('px', '') < 0;

          var left = ui.position.left - (fiftyPercent ? (ui.helper.width() / 2) : 0);

          if (left < 10) {
            ui.position.left = 10 + (fiftyPercent ? (ui.helper.width() / 2) : 0);
          }

          if (ui.position.top < 10) {
            ui.position.top = 10;
          }

          if (left + ui.helper.width() > WIDTH - 10) {
            ui.position.left = WIDTH - 10 - ui.helper.width() / (fiftyPercent ? 2 : 1);
          }

          if (ui.position.top + ui.helper.height() > HEIGHT - 10) {
            ui.position.top = HEIGHT - 10 - ui.helper.height();
          }
        };

        function drawCircle(x, y, size, color, fillColor, yScale, lineWidth) {
          var yScale_ = yScale ? yScale : 0.7;
          c.lineWidth = 0.75 * SCALE_FACTOR * (lineWidth ? lineWidth : 1);
          c.beginPath();
          c.ellipse(x, y, size, size * yScale_, 0, 2 * Math.PI, false);

          if (color) {
            c.strokeStyle = color;
            c.stroke();
          }

          if (fillColor) {
            c.fillStyle = fillColor;
            c.fill();
          }
        };

        function drawBar(x, y, w, h, percentage, color, lineWidth) {
          var lineWidth_ = lineWidth ? Math.floor(lineWidth) : 2;

          c.fillStyle = 'white';
          c.fillRect(x - lineWidth_, y - lineWidth_, w + lineWidth_ * 2, h + lineWidth_ * 2);
          c.fillStyle = color;
          c.fillRect(x, y, w * percentage, h);
        };

        function getPlNfo(player) {
          soundManager.playSound(SOUND.CLICK);
          network.send(JSON.stringify({ message: 'get-player-info', properties: { username: player } }));
        };

        function getLgNfo(nr) {
          soundManager.playSound(SOUND.CLICK);
          network.send(JSON.stringify({ message: 'get-league', properties: { leagueId: nr } }));
        };

        function getLeagueLink(rank, addName, scale, noLink) {
          const builder = new HTMLBuilder();
          scale = scale || 1;

          // Add link
          if (!noLink) {
            const linkID = uniqueID('leagueLink');
            builder.add(`<a class='league-link' id='${linkID}' href='#'>`);
            builder.addHook(() => $(`#${linkID}`).click(() => getLgNfo(rank)));
          }

          // Set offset
          const offset = -10 * scale;
          builder.add(`<span class='league-span pixelated' style='background-position: -${(rank * 41 * scale)}px ${offset}px; `);

          // Set scale
          builder.add(`background-size: ${4 * 200}%; width: ${scale * 41}px; height: ${scale * 41}px;'></span>`);

          if (addName) {
            builder.add(` <span class='underline' style='float: right; margin-top: 15%;'>${leagueNames[rank]}</span>`);
          }
          if (!noLink) {
            builder.add('</a>');
          }

          return builder;
        };

        function bingMsg(msg, noSound) {
          if (game_state == GAME.PLAYING) {
            return;
          }

          if (!noSound) {
            soundManager.playSound(SOUND.BING2, 0.65);
          }

          $('#bingMessageWindow').html('<p>' + msg + '</p>');
          $('#bingMessageWindow').fadeIn(1000);

          setTimeout(function () {
            $('#bingMessageWindow').fadeOut(1000);
          }, 4000);
        };

        function editPersonalText() {
          var b = $('#profileTextButton');

          if (b.html() == 'edit') {
            $('#personalTextDiv').html('<textarea maxlength=\'500\' id=\'personalTextTextArea\'>' + $('#personalTextDiv').html().replace(/<br\s*[\/]?>/gi, '\n') + '</textarea>');
            b.html('save');
          } else {
            network.send('update-profile-text<<$' + $('#personalTextTextArea')[0].value);
            $('#personalTextDiv').html(escapeHtml($('#personalTextTextArea')[0].value).replace(/(?:\r\n|\r|\n)/g, '<br />'));
            b.html('edit');
          }

          soundManager.playSound(SOUND.CLICK);
        }

        function importGraphic() {
          // create new input and simulate a click on it and set function (we have to make a new one, so onchange works when the same replay is loaded 2 times in a row)
          fileInput = document.createElement('input');
          fileInput.type = 'file';
          fileInput.click();

          fileInput.onchange = function () {
            var file = fileInput.files[0];
            if (file) {
              var reader = new FileReader();
              reader.readAsDataURL(file);
              reader.onload = function (e) {
                var i = 1;
                var name = 'newimg' + i;
                while (customImgs[name]) {
                  i++;
                  name = 'newimg' + i;
                }

                var newImg = new Image();
                newImg.src = e.currentTarget.result;

                newImg.onload = function () {
                  customImgs[name] = [newImg].concat(ImageTransformer.replaceColors(newImg, searchColors, playerColors));
                  refreshCustomImgs();
                };
              };
            }
          };

          soundManager.playSound(SOUND.CLICK);
        };

        function refreshCustomImgs() {
          const builder = new HTMLBuilder();

          for (key in customImgs) {
            if (!unit_imgs[key] && !building_imgs[key] && key != 'buildingSheet' && key != 'tileSheet' && key != 'miscSheet') {
              const imgSrc = customImgs[key][0].toDataURL ? customImgs[key][0].toDataURL() : customImgs[key][0].src;
              builder.add(`<div class='customImgPrv' title='${key}'><img src='${imgSrc}' />`);

              const killImgButtonID = uniqueID('killImage');
              builder.add(`<br /><button id='${killImgButtonID}'>x</button> <input type='text' value='${key}' /></div>`);
              builder.addHook(() => $(`#${killImgButtonID}`).click(() => killCustomImg(key)));
            }
          }

          builder.insertInto('#customGraphicsDiv');
        };

        function saveCustomGraphics() {
          var divs = $('.customImgPrv').toArray();

          for (var i = 0; i < divs.length; i++) {
            var newName = $(divs[i]).children('input').toArray()[0].value;
            var oldName = divs[i].title;

            if (newName != divs[i].title) {
              if (newName.length > 20 || newName.length < 3 || newName.match(/[A-Za-z0-9]*/) != newName) {
                displayInfoMsg(newName + ' is not a valid name (3 - 20 chars, letters and numbers only)!');
                return;
              }

              if (customImgs[newName]) {
                displayInfoMsg(newName + ' is already used!');
                return;
              }

              customImgs[newName] = customImgs[oldName];

              delete customImgs[oldName];
            }
          }

          fadeOut($('#customGraphicsWindow'));
          soundManager.playSound(SOUND.CLICK);
        };

        function killCustomImg(key) {
          if (!unit_imgs[key] && !building_imgs[key] && customImgs[key]) {
            for (var i = 0; i < game.graphics.length; i++) {
              if (game.graphics[i].file == customImgs[key]) {
                game.graphics[i].file = miscSheet;
              }
            }

            delete customImgs[key];
          }

          refreshCustomImgs();

          soundManager.playSound(SOUND.CLICK);
        };

        function reallyBan(player) {
          soundManager.playSound(SOUND.CLICK);
          displayInfoMsg(new HTMLBuilder()
            .add(`Ban ${player} for how many hours? (0 is permanent)<br><br>`)
            .add('<input type=\'text\' id=\'time2Ban\' value =\'0\' /><br><br>')
            .add('Reason for ban: <input type=\'text\' id=\'reason4Ban\'/><br><br>')
            .add('<button id=\'confirmBanButton\'>Ban</button>')
            .addHook(() => $('#confirmBanButton').click(addClickSound(() => {
              let confirmed = true;
              if ($('#time2Ban').val() == '0') {
                confirmed = confirm('Permanently ban this player?');
              }
              if (confirmed) {
                network.send(`ban<<$${player}<<$${$('#time2Ban').val()}<<$${$('#reason4Ban').val()}`);
              }
            }))));
        };

        function getPlayerNameArrayFromPlayerSettingsArrayObject(o) {
          var arr = [];
          for (var i = 0; i < o.length; i++) {
            arr.push(o[i].name);
          }
          return arr;
        };

        function getFormattedTime() {
          // get time (hh:mm)
          var timeObject = new Date();
          var minutes = timeObject.getMinutes();
          minutes = minutes < 10 ? '0' + minutes : minutes;
          return timeObject.getHours() + ':' + minutes;
        };

        // Prints the duration as HH:MM:SS, excluding HH if inapplicable
        function getFormattedDuration(millis) {
          let seconds = Math.floor(millis / 1000);
          const hours = Math.floor(seconds / 3600);
          seconds -= hours * 3600;
          const minutes = Math.floor(seconds / 60);
          seconds -= minutes * 60;

          const paddedHours = String(hours).padStart(2, '0');
          const paddedMinutes = String(minutes).padStart(2, '0');
          const paddedSeconds = String(seconds).padStart(2, '0');
          if (hours > 0) {
            return `${paddedHours}:${paddedMinutes}:${paddedSeconds}`;
          } else {
            return `${paddedMinutes}:${paddedSeconds}`;
          }
        }

        function toggleFullscreen(element) {
          if (element.requestFullScreenWithKeys) {
            if (!document.fullScreen) {
              element.requestFullScreenWithKeys();
            } else {
              document.exitFullScreen();
            }
          }

          if (element.requestFullScreen) {
            if (!document.fullScreen) {
              element.requestFullscreen();
            } else {
              document.exitFullScreen();
            }
          } else if (element.mozRequestFullScreen) {
            if (!document.mozFullScreen) {
              element.mozRequestFullScreen();
            } else {
              document.mozCancelFullScreen();
            }
          } else if (element.webkitRequestFullScreen) {
            if (!document.webkitIsFullScreen) {
              element.webkitRequestFullScreen(element.ALLOW_KEYBOARD_INPUT);
            } else {
              document.webkitCancelFullScreen();
            }
          }

          resize();
        };

        function createExplosion(x, y, size) {
          var pos = new Field(x, y);

          for (var i = 0; i < 15; i++) {
            new Sprite({
              from: pos.add2(Math.random() * Math.PI * 2, Math.random()),
              img: imgs.particle.img,
              scaleFunction: i < 10 ? function () {
                return 4;
              } : function () {
                return 6;
              },
              age: 1.3 + Math.random(),
              r1: Math.random() * 0.4,
              r2: Math.random() * 5 - 3,
              r3: Math.random() * 5 - 3,
              zFunction: function (age) {
                return Math.min(Math.pow(age * 1.6 - 1.5 + this.r1, 2) - 2.2, 0);
              },
              xFunction: function (age) {
                return Math.sqrt(age) * this.r2;
              },
              yFunction: function (age) {
                return Math.sqrt(age) * this.r3;
              },
            });
          }

          new Dust({ from: pos, scale: size + Math.random(), ageScale: 2 + Math.random() });

          for (var i = 0; i <= 2; i++) {
            new Dust({ from: pos.add3(Math.random() - 0.5, 0), scale: size + Math.random(), ageScale: 2 + Math.random(), height: Math.random() });
          }

          // create big fire and smoke effects
          for (var i = 0; i <= 2; i++) {
            setTimeout(function () {
              new Sprite({
                from: new Field(x, y, true).add2(Math.random() * Math.PI * 2, Math.random() * 0.5),
                img: imgs['fire' + (Math.floor(Math.random() * 4) + 1)],
                scaleFunction: function (age) {
                  return (1 / (age + 0.25) + age - 4) * (-2) + this.r1;
                },
                r1: 1 + Math.random() * 2,
                zFunction: function (age) {
                  return -age * 2;
                },
              });
            }, i * 317);

            setTimeout(function () {
              for (var k = 0; k <= 1; k++) {
                new Dust({ from: pos.add3(Math.random() - 0.5, 0), scale: size + Math.random(), ageScale: 2 + Math.random(), height: Math.random() - 0.5 });
              }
            }, i * 333);
          }

          // create side smoke effects (big dust clouds that go sideways)
          for (var i = 0; i < Math.PI * 2; i += Math.random() * 1.5) {
            new Dust({
              from: pos,
              scale: Math.random() * 7 + 1.5,
              ageScale: 2,
              vz: 0.01,
              xFunction: function (age) {
                return ((-1) / (age + 0.3) + 3) * this.x_;
              },
              yFunction: function (age) {
                return ((-1) / (age + 0.3) + 3) * this.y_;
              },
              x_: Math.cos(i),
              y_: Math.sin(i),
            });
          }

          // create soot
          game.groundTilesCanvas.getContext('2d').drawImage(miscSheet[0], imgs.soot.img.x, imgs.soot.img.y, imgs.soot.img.w, imgs.soot.img.h, x * FIELD_SIZE / SCALE_FACTOR - imgs.soot.img.w / 2, (y + 2) * FIELD_SIZE / SCALE_FACTOR - imgs.soot.img.h / 2, imgs.soot.img.w, imgs.soot.img.h);
        };

        function realTimeCompile(htmlElID) {
          var jqueryEL = $(`#${htmlElID}`).parent().parent();
          var compile = Command.prototype.compileCondition($(`#${htmlElID}`).val());

          jqueryEL.prop('title', compile[0] ? 'condition is ok' : compile[1]);
          jqueryEL.tooltip({ content: jqueryEL.prop('title') });
          jqueryEL.tooltip('open');
        }

        function getRankCode(text) {
          return text.replace(/S/g, '<img src=\'imgs/star-white.png\' style=\'margin-bottom: -2px;\' /> ')
            .replace(/Y/g, '<img src=\'imgs/star-yellow.png\' style=\'margin-bottom: -2px;\' /> ')
            .replace(/G/g, '<img src=\'imgs/star-green.png\' style=\'margin-bottom: -2px;\' /> ')
            .replace(/R/g, '<img src=\'imgs/star-red.png\' style=\'margin-bottom: -2px;\' /> ');
        }


        function displayInfoMsg(msg) {
          if (typeof msg === 'string') {
            msg = escapeHtml(msg);
          }
          fadeIn($('#infoWindow'));
          new HTMLBuilder()
            .add('<div class=\'infoWindowText\'>')
            .add(msg)
            .add('</div>')
            .insertInto('#infoWindowTextArea');
        };

        function displayInfoMsgDarkBG(msg, arch_sound) {
          fadeIn($('#darkScreenDiv'));
          fadeIn($('#infoWindow2'));
          if (msg instanceof HTMLBuilder) {
            msg.insertInto('#infoWindowTextArea2');
          } else {
            $('#infoWindowTextArea2').html(msg);
          }
          soundManager.playSound(arch_sound ? SOUND.ARCHIVEMENT : SOUND.OPEN_WINDOW, 0.7);
        };

        function displayConfirmPrompt(msg, yesCallback, noCallback) {
          // The only way they can exit is by pressing yes or no
          $(uimanager.infoWindow.closeButton).hide();
          const restoreCloseButton = () => setTimeout(() => $(uimanager.infoWindow.closeButton).show(), 201);

          const yesButtonID = uniqueID();
          const noButtonID = uniqueID();
          displayInfoMsg(new HTMLBuilder()
            .add(`${msg}<br /><br />`)
            .add(`<button id='${yesButtonID}'>Yes</button> <button id='${noButtonID}'>No</button>`)
            .addHook(() => $(`#${yesButtonID}`).click(() => {
              // TODO: jQuery animations completely break if the UI thread gets blocked, so using this instead
              // of fadeOut. Figure out how to fix this and add an animation here
              $('#infoWindow').hide();
              restoreCloseButton();
              setTimeout(() => yesCallback(), 0);
            }))
            .addHook(() => $(`#${noButtonID}`).click(() => {
              $('#infoWindow').hide();
              restoreCloseButton();
              setTimeout(() => noCallback(), 0);
            })));
        }

        function sendFriendRequest() {
          network.send('add-friend<<$' + $('#newFriendInput')[0].value);
        };

        function showAllDivisions() {
          const builder = new HTMLBuilder();

          let x = 10;
          let y = 10;

          for (let i = 0; i < leagueNames.length; i++) {
            builder.add(`<div style='position: absolute; left: ${x}px; top: ${y}px;'>`);
            builder.add(getLeagueLink(i, true, 3));
            builder.add('</div>');

            y += 100;
            if (i == 3) {
              y = 10;
              x += 270;
            }
          }

          builder.insertInto('#addScrollableSubDivTextArea');

          uimanager.playerInfoWindow.setTitleText('Divisions');
          uimanager.playerInfoWindow.setRider(new HTMLBuilder());
          uimanager.playerInfoWindow.setHeadRider(new HTMLBuilder());
          fadeIn($('#playerInfoWindow'));
        };

        function clearCache(extended) {
          if (!extended && network_game) {
            network.send('cache-clear');
          } else if (extended && network_game) {
            network.send('cache-clear-extended');
          }
        };


        var visionOffsets = [];
        var countCircles = 6;

        for (var i = 0; i <= countCircles; i++) {
          visionOffsets[i] = [];
        }

        for (var x = -7; x <= countCircles + 1; x++) {
          for (var y = -7; y <= countCircles + 1; y++) {
            var dist = Math.sqrt(x * x + y * y);

            for (var i = 0; i <= countCircles; i++) {
              if (dist <= i && dist >= i - 1) {
                visionOffsets[i].push([x, y]);
              }
            }
          }
        }

        function getPlayerCountFromMap(map) {
          var players = [];
          var units = map.units.concat(map.buildings);
          for (var k = 0; k < units.length; k++) {
            if (units[k].owner != 0 && !players.contains(units[k].owner)) {
              players.push(units[k].owner);
            }
          }

          return players.length;
        };

        function getImageFromMap(map) {
          var imgSize = 265;

          var newCanvas = document.createElement('canvas');
          newCanvas.width = imgSize;
          newCanvas.height = imgSize;
          var ctx = newCanvas.getContext('2d');

          // set scales
          var scale_x = imgSize / map.x;
          var scale_y = imgSize / map.y;

          // fill map with default tiles background
          ctx.fillStyle = map.defaultTiles[0].toUnitType().minimapColor;
          ctx.fillRect(0, 0, imgSize, imgSize);

          // draw tiles
          for (var k = 0; k < map.tiles.length; k++) {
            var type = map.tiles[k].type.toUnitType();
            if (type.blocking) {
              ctx.fillStyle = type.minimapColor;
              ctx.fillRect((map.tiles[k].x - 1) * scale_x, (map.tiles[k].y - 1) * scale_y, type.sizeX * scale_x, type.sizeY * scale_y);
            }
          }

          // draw buildings
          for (var k = 0; k < map.buildings.length; k++) {
            var type = map.buildings[k].type.toUnitType();
            var size = type ? type.size : 3;

            if (map.buildings[k].owner == 0 && map.buildings[k].type.alwaysNeutral) {
              ctx.fillStyle = 'yellow';
            } else if (map.buildings[k].owner == 0) {
              ctx.fillStyle = '#4DA6AE';
            } else {
              var colorArray = playerColors[map.buildings[k].owner - 1][4];
              ctx.fillStyle = 'rgba(' + colorArray[0] + ', ' + colorArray[1] + ', ' + colorArray[2] + ', 1)';
            }

            ctx.fillRect((map.buildings[k].x - 1) * scale_x, (map.buildings[k].y - 1) * scale_y, size * scale_x, size * scale_y);
          }

          return newCanvas.toDataURL('image/png');
        };

        var interpreter = [

          {
            funcName: 'getField',
            func: function (s) {
              var type = s.replace(/ /g, '').split('.');

              if (lists.types[type[0]]) {
                if (lists.types[type[0]][type[1]] && typeof lists.types[type[0]][type[1]] !== 'number') {
                  return lists.types[type[0]][type[1]];
                }

                if (lists.types[type[0]].isUpgrade) {
                  return lists.types[type[0]].getValue(type[1], PLAYING_PLAYER, true) * ((list_upgrade_fields[type[1]] && list_upgrade_fields[type[1]].displayScale) ? list_upgrade_fields[type[1]].displayScale : 1);
                } else if (lists.types[type[0]].isUnit) {
                  return lists.types[type[0]].getValue(type[1], PLAYING_PLAYER) * ((list_unit_fields[type[1]] && list_unit_fields[type[1]].displayScale) ? list_unit_fields[type[1]].displayScale : 1);
                } else if (lists.types[type[0]].isBuilding) {
                  return lists.types[type[0]].getValue(type[1], PLAYING_PLAYER) * ((list_building_fields[type[1]] && list_building_fields[type[1]].displayScale) ? list_building_fields[type[1]].displayScale : 1);
                } else if (lists.types[type[0]].isModifier) {
                  return lists.types[type[0]].getValue(type[1], PLAYING_PLAYER) * ((list_modifiers_fields[type[1]] && list_modifiers_fields[type[1]].displayScale) ? list_modifiers_fields[type[1]].displayScale : 1);
                } else // ability
                {
                  return lists.types[type[0]].getValue([type[1]], game.selectedUnits[0]) * ((list_ability_fields[type[1]] && list_ability_fields[type[1]].displayScale) ? list_ability_fields[type[1]].displayScale : 1);
                }
              }

              return '';
            },
          },

          {
            funcName: 'getUpgradeLevel',
            func: function (s) {
              var type = lists.types[s.replace(/ /g, '')];
              return type ? PLAYING_PLAYER.getUpgradeLevel(type) : 0;
            },
          },

          {
            funcName: 'upgradeCountInResearch',
            func: function (s) {
              var type = lists.types[s.replace(/ /g, '')];
              return type ? PLAYING_PLAYER.upgradeCountInResearch(type) : 0;
            },
          },

          {
            funcName: 'add',
            func: function (s) {
              var numbers = s.replace(/ /g, '').split(',');
              var number = 0;
              for (var i = 0; i < numbers.length; i++) {
                number += parseInt(numbers[i]);
              }
              return number;
            },
          },

          {
            funcName: 'mul',
            func: function (s) {
              var numbers = s.replace(/ /g, '').split(',');
              var number = 1;
              for (var i = 0; i < numbers.length; i++) {
                number *= parseInt(numbers[i]);
              }
              return number;
            },
          },

          {
            funcName: 'sub',
            func: function (s) {
              var numbers = s.replace(/ /g, '').split(',');
              var number = parseInt(numbers[0]);
              for (var i = 1; i < numbers.length; i++) {
                number -= parseInt(numbers[i]);
              }
              return number;
            },
          },

          {
            funcName: 'div',
            func: function (s) {
              var numbers = s.replace(/ /g, '').split(',');
              var number = parseInt(numbers[0]);
              for (var i = 1; i < numbers.length; i++) {
                number /= parseInt(numbers[i]) ? parseInt(numbers[i]) : 1;
              }
              return number;
            },
          },

        ];

        function interpreteString(s, unit) {
          if (typeof s !== 'string') {
            return '';
          }

          for (var i = 0; i < interpreter.length; i++) {
            var data = interpreter[i];

            var s1 = s.indexOf(data.funcName + '(');
            var s2 = s.indexOf(')', s1);

            while (s1 >= 0 && s2 >= 0 && s2 > s1) {
              var s3 = s.split(data.funcName + '(');
              s3[1] = s3.slice(1).join(data.funcName + '(');
              var s4 = s3[1].split(')');
              s4[1] = s4.slice(1).join(')');

              s = s3[0] + data.func(s4[0], unit) + s4[1];

              s1 = s.indexOf(data.funcName + '(');
              s2 = s.indexOf(')', s1);
            }
          }

          return s;
        };

        // draw wrapped text (returns the number of drawed lines if wrapped)
        // if overflow is set to "ellipses" instead of "wrap", it will terminate with
        // ...
        function drawText(ctx, text, color, size, x, y, w, align, alpha, fillStyle, shadowStyle, height, overflow = 'wrap') {
          const ellipses = overflow == 'ellipses' ? '...' : '';

          var text2 = text;
          var w2 = w ? w : 99999;
          alpha = alpha ? alpha : 1;
          var returnValue = 1; // number of lines we used to draw the text

          ctx.font = size;
          ctx.textAlign = align ? align : 'left';

          // check if text fits in line, if not, recursively call for next line
          if (ctx.measureText(text).width > w2) {
            var words = text.split(' ');

            var line = words[0];
            var lastFittingLine;
            var i = 1;

            while (ctx.measureText(line + ellipses).width <= w2 && i < words.length) {
              lastFittingLine = line;
              line = line + ' ' + words[i];
              i++;
            }

            text2 = lastFittingLine ? lastFittingLine : text;
            if (text2 != text) {
              text2 += ellipses;
            }

            words.splice(0, Math.max(i - 1, 1));

            if (words.length > 0 && overflow == 'wrap') {
              returnValue += drawText(ctx, words.join(' '), color, size, x, y + height + 4, w2, align, alpha, fillStyle, shadowStyle, height);
            }
          }

          var textWidth = ctx.measureText(text2).width;

          // round
          var x2 = Math.floor(x);
          var y2 = Math.floor(y);

          // fillrect, if fillstyle parameter passed
          if (fillStyle) {
            ctx.globalAlpha = alpha;
            ctx.fillStyle = fillStyle;
            ctx.fillRect(x2 - (align == 'center' ? (textWidth + 6) / 2 : 0), y2 - height * 0.9, textWidth + 6, height * 1.1);
          }

          // nu shadow
          // ctx.shadowColor = shadowStyle ? shadowStyle : "black";
          // ctx.shadowBlur = 3;

          // draw text
          ctx.fillStyle = color;
          ctx.fillText(text2, x2, y2);
          ctx.globalAlpha = 1;

          // ctx.shadowBlur = 0;

          return returnValue;
        };

        // when window gets resized, this is calld
        function resize() {
          WIDTH = window.innerWidth;
          HEIGHT = window.innerHeight;
          canvas.width = WIDTH;
          canvas.height = HEIGHT;

          // Settings
          c.mozImageSmoothingEnabled = false;
          c.imageSmoothingEnabled = false;
        };

        function getFriendlyDate(unixTime) {
          if (unixTime == 0) {
            return 'before records began';
          }
          var d = new Date(unixTime * 1000);
          var months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
          var year = d.getFullYear();
          var month = months[d.getMonth()];
          var date = d.getDate();
          return month + ' ' + date + ', ' + year;
        }

        async function httpGet(url) {
          return new Promise((resolve, reject) => {
            $.get(url)
              .done(resolve)
              .fail((jqXHR, textStatus, errorThrown) => reject(JSON.stringify(jqXHR)));
          });
        }

        // parent class for map object types (unit types, building typed, tile / doodas types)
        function MapObjectType() {
          this.projectileLen = 0.2;
          this.projectileStartHeight = 0;
          this.projectileSpeed = 8;
          this.imageScale = 1;
          this.canAttackGround = true;
          this.isHeatSeeking = true;
          this.aoeRadius = 0;
          this.isInvisible = false;
          this.noShow = false;
          this.controllable = true;
          this.hasDetection = false;
        };

        MapObjectType.prototype.replaceReferences = function () {
          var t = this;
          if (this.commands) {
            _.each(this.commands, function (c, key) {
              if (typeof c == 'string') {
                t.commands[key] = lists.types[c];
              }
            });
          }

          if (this.img && (typeof this.img == 'string')) {
            this.img = lists.imgs[this.img] ? lists.imgs[this.img] : (this.isBuilding ? lists.imgs.castle : lists.imgs.soldier);
          }

          if (this.modifiers) {
            for (var k = 0; k < this.modifiers.length; k++) {
              if (typeof this.modifiers[k] == 'string') {
                this.modifiers[k] = lists.types[this.modifiers[k]];
              }
            }
          }

          if (this.modifiersSelf) {
            for (var k = 0; k < this.modifiersSelf.length; k++) {
              if (typeof this.modifiersSelf[k] == 'string') {
                this.modifiersSelf[k] = lists.types[this.modifiersSelf[k]];
              }
            }
          }

          if (this.spawnModifiers) {
            for (var k = 0; k < this.spawnModifiers.length; k++) {
              if (typeof this.spawnModifiers[k] == 'string') {
                this.spawnModifiers[k] = lists.types[this.spawnModifiers[k]];
              }
            }
          }

          if (this.onDamageModifiers) {
            for (var k = 0; k < this.onDamageModifiers.length; k++) {
              if (typeof this.onDamageModifiers[k] == 'string') {
                this.onDamageModifiers[k] = lists.types[this.onDamageModifiers[k]];
              }
            }
          }

          if (this.modifiersPerLevel) {
            for (var k = 0; k < this.modifiersPerLevel.length; k++) {
              if (typeof this.modifiersPerLevel[k] == 'string') {
                this.modifiersPerLevel[k] = lists.types[this.modifiersPerLevel[k]];
              }
            }
          }

          if (this.costIncreaseGroup) {
            for (var k = 0; k < this.costIncreaseGroup.length; k++) {
              if (typeof this.costIncreaseGroup[k] == 'string') {
                this.costIncreaseGroup[k] = lists.types[this.costIncreaseGroup[k]];
              }
            }
          }
        };

        MapObjectType.prototype.getValue = function (value, owner) {
          return this[value] + owner.getValueModifier(value, this);
        };

        MapObjectType.prototype.toString = function () {
          return this.name;
        };

        // where would this be placed regarding the current mouse cursor pos
        MapObjectType.prototype.getFieldFromMousePos = function () {
          return game.getFieldFromPos(null, null, !this.isCliff).add3(-this.sizeX / 2 + 0.5, -this.sizeY / 2 + 0.5);
        };

        MapObjectType.prototype.getDataFields = function () {
          return this.isUnit ? list_unit_fields : list_building_fields;
        };

        MapObjectType.prototype.draw = function (x, y) {
          var img = this.img.img;
          var scale = this.getValue('imageScale', PLAYING_PLAYER) * SCALE_FACTOR;

          var x_ = 0;
          var y_ = 0;

          // decorations coords are exact pixels
          if (this.ignoreGrid) {
            x_ = Math.floor((x - (img.w / 2) * SCALE_FACTOR) / SCALE_FACTOR) * SCALE_FACTOR - game.cameraX;
            y_ = Math.floor(((y + 3 * SCALE_FACTOR) - (img.h / 2) * SCALE_FACTOR) / SCALE_FACTOR) * SCALE_FACTOR - game.cameraY;
          } else {
            x_ = (x - 1 + this.sizeX / 2) * FIELD_SIZE - game.cameraX - img.w / 2 * scale;
            y_ = (y - 1 + this.sizeY) * FIELD_SIZE - game.cameraY - img.h * scale;
          }

          var nr = Math.max(PLAYING_PLAYER.number, 1);

          c.drawImage(this.img.file[this.img.file[nr] ? nr : 0], img.x, img.y, img.w, img.h, x_, y_, img.w * scale, img.h * scale);
        };

        MapObjectType.prototype.couldBePlacedAt = function (field, dontIgnoreHiddenBlocks) {
          var checkObj = dontIgnoreHiddenBlocks ? PLAYING_PLAYER.team : game;
          var distanceAllowed = true;

          for (var x = field.x; x < field.x + this.sizeX; x++) {
            for (var y = field.y; y < field.y + this.sizeY; y++) {
              // get the nearest CC, Goldmine and Start Location, because those are not allowed to be placed near eachother
              var f = new Field(x, y);
              var nextGoldmine = game.getNextBuildingOfType(f, null, false, 'startGold');
              var nextCC = game.getNextBuildingOfType(f, null, false, 'takesGold');

              if (this.takesGold && nextGoldmine && nextGoldmine.pos.distanceTo2(f) < game.getMineDistance()) {
                distanceAllowed = false;
              }

              if (this.startGold && nextCC && nextCC.pos.distanceTo2(field) < game.getMineDistance()) {
                distanceAllowed = false;
              }

              if (checkObj.fieldIsBlockedForBuilding(x, y) || !distanceAllowed) {
                return false;
              }
            }
          }

          return true;
        };

        MapObjectType.prototype.getTitleImage = function () {
          var img = (game_state == GAME.EDITOR && this.img.imgEditor) ? this.img.imgEditor : this.img.img;

          return { file: this.img.file[0], x: img.x, y: img.y, w: img.w, h: img.h };
        };

        UnitType.prototype = new MapObjectType();
        function UnitType(data) {
          _.extend(this, data);

          // copy arrays (so they dont get only referenced)
          var thisRef = this;
          _.each(data, function (val, key) {
            thisRef[key] = Object.prototype.toString.call(thisRef[key]) === '[object Array]' ? thisRef[key].slice() : thisRef[key];
          });

          // copy command object
          this.commands = copyObject(this.commands);

          this.minimapColor = '#ffffff';

          this.isUnit = true;

          this.dustCreationChance = this.dustCreationChance ? this.dustCreationChance : 0.05; // if not set, use default which is 0,05

          this.minRange = this.minRange ? this.minRange : -999; // if no min range is set, set it to -999 (otherwise some calculations would fail)

          this.id = game.unitTypeIdCounter++;

          this.animSpeed = this.animSpeed ? this.animSpeed : 1.5;

          this.oscillationAmplitude = this.oscillationAmplitude ? this.oscillationAmplitude : 0;

          this.yesSound = this.yesSound ? this.yesSound : SOUND.YES;
          this.yesSoundVolume = this.yesSoundVolume ? this.yesSoundVolume : 0.6;
          this.readySound = this.readySound ? this.readySound : SOUND.READY;
          this.readySoundVolume = this.readySoundVolume ? this.readySoundVolume : 0.9;

          this.selectionOffsetY = this.selectionOffsetY ? this.selectionOffsetY : 0;
          this.height = this.height ? this.height : 0.3;
          this.deathAnimationSpeed = data.deathAnimationSpeed ? data.deathAnimationSpeed : 0.6;
        };

        UnitType.prototype.addToLists = function () {
          lists.types[this.id_string] = this;
          lists.unitTypes[this.id_string] = this;
        };

        // get the title img of this unit type; if nr is passed, return img of color of player nr, else return of player PLAYING_PLAYER
        UnitType.prototype.getTitleImage = function (player) {
          try {
            player = player ? player : game.players[1];

            var img = (player && player.skins && player.skins[this.id_string]) ? player.skins[this.id_string] : this.img;

            return { file: img.file[player ? player.number : 1], x: img.idle.x, y: img.idle.y, w: img.idle.frameWidth, h: img.idle.h / img._angles };
          } catch (err) {
            console.error(`Failed to find titleImage for ${this.name}. Img "${this.img}".`);
          }
        };

        // checks if the unit could stand at a position (without beeing blocked, only checks for buildings and tiles, not units)
        UnitType.prototype.couldStandAt = function (pos) {
          if (this.flying) {
            for (i = 0; i < this.circleOffsets.length; i++) {
              if (game.fieldIsBlockedFlying(Math.ceil(pos.px + this.circleOffsets[i][0]), Math.ceil(pos.py + this.circleOffsets[i][1]))) {
                return false;
              }
            }
          } else {
            for (i = 0; i < this.circleOffsets.length; i++) {
              if (game.fieldIsBlocked(Math.ceil(pos.px + this.circleOffsets[i][0]), Math.ceil(pos.py + this.circleOffsets[i][1]))) {
                return false;
              }
            }
          }

          return true;
        };

        // find the next free position where a unit of this type could stand (is pos is valid itself, return pos; only check for buildings and tiles, no units)
        UnitType.prototype.getNextFreePositionFrom = function (pos) {
          var testPos = pos;
          var len = 0.02;
          var i = 0;

          while (!this.couldStandAt(testPos)) {
            testPos = pos.add(new Field(angleOffsets[i][0], angleOffsets[i][1], true).normalize(len));
            len += 0.02;
            i = (i + 1) % 12;
          }

          return testPos;
        };

        UnitType.prototype.getBasicType = function () {
          for (var i = 0; i < basicUnitTypes.length; i++) {
            if (basicUnitTypes[i].id_string == this.id_string) {
              return basicUnitTypes[i];
            }
          }

          return false;
        };

        // not sure if this gets ever called (it does when placing in editor)
        UnitType.prototype.draw = function (px, py) {
          var img = this.getTitleImage();
          var scale = this.getValue('imageScale', PLAYING_PLAYER) * SCALE_FACTOR;
          c.drawImage(img.file, img.x, img.y, img.w, img.h, px - img.w / 2 * scale - game.cameraX, py - img.h / 2 * scale - game.cameraY, img.w * scale, img.h * scale);
        };

        BuildingType.prototype = new MapObjectType();
        function BuildingType(data) {
          this.preventsReveal = true;
          this.preventsLoss = true;

          this.deathSound = SOUND.BUILDING_DEATH;

          _.extend(this, data);

          // copy arrays (so they dont get only referenced)
          var thisRef = this;
          _.each(data, function (val, key) {
            thisRef[key] = Object.prototype.toString.call(thisRef[key]) === '[object Array]' ? thisRef[key].slice() : thisRef[key];
          });

          // copy command object
          this.commands = copyObject(this.commands);

          this.minRange = this.minRange ? this.minRange : -999; // if no min range is set, set it to -999 (otherwise some calculations would fail)

          this.isBuilding = true;

          this.minimapColor = 'white';

          this.id = game.buildingTypeIdCounter++;

          this.height = this.height ? this.height : 1;

          this.selectionOffsetY = this.selectionOffsetY ? this.selectionOffsetY : 0;
        };

        BuildingType.prototype.addToLists = function () {
          lists.types[this.id_string] = this;
          // lists.imgs[this.id_string] = this.img;
          lists.unitTypes[this.id_string] = this;
          lists.buildingTypes[this.id_string] = this;
          lists.buildingsUpgrades[this.id_string] = this;
        };

        BuildingType.prototype.getValue = function (value, owner) {
          if (value == 'cost') {
            return owner.getCostOfNextInstanceForBuilding(this);
          }

          return this[value] + owner.getValueModifier(value, this);
        };

        BuildingType.prototype.getBasicType = function () {
          for (var i = 0; i < basicBuildingTypes.length; i++) {
            if (basicBuildingTypes[i].id_string == this.id_string) {
              return basicBuildingTypes[i];
            }
          }

          return false;
        };

        BuildingType.prototype.getTitleImage = function (player) {
          player = player ? player : game.players[1];

          var img = (player && player.skins && player.skins[this.id_string]) ? player.skins[this.id_string] : this.img;

          return { file: img.file[player ? player.number : 1], x: img.img.x, y: img.img.y, w: img.img.frameWidth, h: img.img.h };
        };



        function Command(data) {
          this.manaCost = [0];
          this.goldCost = 0;
          this.range = [0];
          this.minRange = [-999];
          this.aoeRadius = [0];
          this.damage = [0];
          this.projectileSpeed = [8];
          this.hitsFriendly = true;
          this.hitsEnemy = true;
          this.hitsSelf = true;
          this.effectScale = 1;
          this.projectileAoeRadius = [0];
          this.projectileDamage = [0];
          this.modifiers = [];
          this.summonedUnits = [];
          this.autocastConditions = '';
          this.cooldown = 0;
          this.cooldown2 = 0;
          this.attackEffectInit = 'spell';
          this.bounceDistMax = 0;
          this.bounceDistMin = 0;

          _.extend(this, data);

          // copy arrays (so they dont get only referenced)
          var thisRef = this;
          _.each(data, function (val, key) {
            thisRef[key] = Object.prototype.toString.call(thisRef[key]) === '[object Array]' ? thisRef[key].slice() : thisRef[key];
          });

          this.isCommand = true;

          this.id = game.global_command_id++;

          if (!IS_LOGIC && this.image) {
            this.buttons = [new Button(this)];
            interface_.buttons.push(this.buttons[0]);

            if (this.requiredLevels && this.requiredLevels.length > 0) {
              this.buttons.push(new Button(this, true));
              interface_.buttons.push(this.buttons[1]);
            }
          }
        };

        Command.prototype.updateHotkey = function (hotkey) {
          this.hotkey = hotkey;
          this.buttons.forEach((b) => b.refresh());
        };

        Command.prototype.compileCondition0 = function () {
          if (this.autocastConditions && this.autocastConditions.length > 0) {
            var comp = this.compileCondition(this.autocastConditions);

            if (comp && comp[0]) {
              eval('this.autocastCondition = function(u, uthis){return ' + comp[1] + ';};');
            }
          }
        };

        Command.prototype.getTitleImage = function (nr) {
          return this.image.getTitleImage(nr);
        };

        // returns an 2 len array; 1st element: false on error, true on no error; 2nd element: error msg on error, finished language on no error
        Command.prototype.compileCondition = function (str) {
          if (!str || str.length == 0) {
            return [0, 'no content'];
          }

          var lastType = '';
          var word = '';
          var words = [];

          str += ' ';

          for (var i = 0; i < str.length; i++) {
            var char_ = str.substr(i, 1);

            var type_ = '';

            if (char_.match(/[a-zA-Z_]/) == char_) {
              type_ = 'char';
            } else if (char_.match(/[0-9]/) == char_) {
              type_ = 'numerical';
            } else if (char_.match(/[<>!=]/) == char_) {
              type_ = 'compare';
            } else if (char_.match(/[\-+*/]/) == char_) {
              type_ = 'arithmetic';
            } else if (char_.match(/[\.]/) == char_) {
              type_ = lastType == 'char' ? 'char' : 'numerical';
            } else if (char_.match(/[&|]/) == char_) {
              type_ = 'conjunction';
            } else if (char_ == ' ') {
              type_ = 'undefined';
            } else {
              return [false, 'invalid character: ' + char_];
            }

            if (type_ == lastType || lastType == '') {
              word += char_;
            } else {
              if (lastType != 'undefined') {
                if (lastType == 'numerical') {
                  var word2 = parseFloat(word);

                  if (word2.isNaN) {
                    return [false, word2 + ' is not a number'];
                  } else {
                    word = word2;
                  }
                } else if (lastType == 'compare') {
                  if (word != '<' && word != '>' && word != '<=' && word != '>=' && word != '=' && word != '==' && word != '!=') {
                    return [false, word + ' is not a valid comparison expression (allowed are: < > <= >= == !=)'];
                  }

                  if (word == '=') {
                    word = '==';
                  }
                } else if (lastType == 'arithmetic') {
                  if (word.length != 1) {
                    return [false, word + ' is not a valid arithmetic expression (allowed are: + - / *)'];
                  }
                } else if (lastType == 'conjunction') {
                  if (word != '&&' && word != '||') {
                    return [false, word + ' is not a valid conjunction (allowed are: && ||)'];
                  }
                } else if (lastType == 'char') {
                  var countDots = (word.match(/\./g) || []).length > 0;

                  if (countDots == 1) {
                    if (word.substr(0, 5) != 'type.' && word.substr(0, 5) != 'this.' && word.substr(0, 6) != 'owner.') {
                      return [false, word + ' is not a valid field name'];
                    }
                  } else if (countDots > 2) {
                    return [false, word + ' is not a valid field name'];
                  }

                  if (word != 'true' && word != 'false') {
                    word = word.substr(0, 5) != 'this.' ? ('u.' + word) : ('u' + word);
                  }
                }

                words.push({
                  word: word,
                  type: (lastType == 'char' || lastType == 'numerical') ? 'expression' : lastType,
                });
              }

              word = char_;
            }

            lastType = type_;
          }

          var stateMachine = {

            start: {
              expression: 'exp1',
            },

            exp1: {
              arithmetic: 'start',
              compare: 'c',
            },

            c: {
              expression: 'exp2',
            },

            exp2: {
              isFinish: true,
              arithmetic: 'c',
              conjunction: 'start',
            },

          };

          var state = stateMachine.start;
          var language = '';

          for (var i = 0; i < words.length; i++) {
            language += words[i].word + ' ';

            if (state[words[i].type]) {
              state = stateMachine[state[words[i].type]];
            } else {
              return [false, 'syntax error; unexpected word: ' + words[i].word];
            }
          }

          if (!state.isFinish) {
            return [false, 'syntax error; expecting at least one more word'];
          }

          return [true, language];
        };

        Command.prototype.canTargetUnit = function (u) {
          for (var k = 0; k < this.targetRequiremementsArray.length; k++) {
            var met = false;

            for (var i = 0; i < this.targetRequiremementsArray[k].length; i++) {
              if (this.targetRequiremementsArray[k][i].func(u)) {
                met = true;
              }
            }

            if (!met) {
              return false;
            }
          }

          return true;
        };

        Command.prototype.replaceReferences = function () {
          if (typeof this.unitType == 'string') {
            this.unitType = lists.types[this.unitType];
          }

          if (typeof this.improvedBuilding == 'string') {
            this.improvedBuilding = lists.types[this.improvedBuilding];
          }

          if (typeof this.upgrade == 'string') {
            this.upgrade = lists.types[this.upgrade];
          }

          if (typeof this.image == 'string') {
            this.image = lists.imgs[this.image] ? lists.imgs[this.image] : lists.imgs.attentionmarkYellow;
          }

          if (this.modifiers) {
            for (var k = 0; k < this.modifiers.length; k++) {
              if (typeof this.modifiers[k] == 'string') {
                this.modifiers[k] = lists.types[this.modifiers[k]];
              }
            }
          }

          if (this.modifiersSelf) {
            for (var k = 0; k < this.modifiersSelf.length; k++) {
              if (typeof this.modifiersSelf[k] == 'string') {
                this.modifiersSelf[k] = lists.types[this.modifiersSelf[k]];
              }
            }
          }

          if (this.summonedUnits) {
            for (var k = 0; k < this.summonedUnits.length; k++) {
              if (typeof this.summonedUnits[k] == 'string') {
                this.summonedUnits[k] = lists.types[this.summonedUnits[k]];
              }
            }
          }

          if (this.requirementType) {
            for (var k = 0; k < this.requirementType.length; k++) {
              if (typeof this.requirementType[k] == 'string') {
                this.requirementType[k] = lists.types[this.requirementType[k]];
              }
            }
          }

          this.targetRequiremementsArray = [];

          if (this.targetRequirements1 && this.targetRequirements1.length > 0) {
            this.targetRequiremementsArray.push(this.targetRequirements1);
          }

          if (this.targetRequirements2 && this.targetRequirements2.length > 0) {
            this.targetRequiremementsArray.push(this.targetRequirements2);
          }

          if (this.targetRequirements3 && this.targetRequirements3.length > 0) {
            this.targetRequiremementsArray.push(this.targetRequirements3);
          }

          for (var i = 0; i < this.targetRequiremementsArray.length; i++) {
            for (var k = 0; k < this.targetRequiremementsArray[i].length; k++) {
              if (typeof this.targetRequiremementsArray[i][k] == 'string') {
                this.targetRequiremementsArray[i][k] = targetRequirements[this.targetRequiremementsArray[i][k]];
              }
            }
          }
        };

        Command.prototype.getValue = function (field, unit) {
          if (field == 'summonedUnits' || field == 'modifiers' || field == 'modifiersSelf') {
            return this[field][Math.min(this[field].length - 1, unit.abilityLevels[this.id] - 1)];
          }

          return ((unit.abilityLevels && (field == 'manaCost' || field == 'range' || field == 'minRange' || field == 'damage' || field == 'aoeRadius' || field == 'projectileSpeed' || field == 'projectileDamage' || field == 'projectileAoeRadius')) ?
            this[field][Math.min(this[field].length - 1, unit.abilityLevels[this.id] - 1)] : this[field]) + (unit.owner ? unit.owner.getValueModifier(field, this) : unit.getValueModifier(field, this));
        };

        Command.prototype.getDataFields = function () {
          return list_ability_fields;
        };

        Command.prototype.addToLists = function () {
          lists.types[this.id_string] = this;
          lists.commands[this.id_string] = this;
        };

        Command.prototype.getBasicType = function () {
          for (var i = 0; i < basicCommands.length; i++) {
            if (basicCommands[i].id_string == this.id_string) {
              return basicCommands[i];
            }
          }

          return false;
        };

        Command.prototype.aoeHitsUnit = function (caster, target) {
          if (caster == target) {
            return this.hitsSelf;
          }

          var isEnemy = caster.owner.isEnemyOfPlayer(target.owner);

          if ((isEnemy && !this.hitsEnemy) || (!isEnemy && !this.hitsFriendly)) {
            return false;
          }

          if (this.targetFilters) {
            for (var i = 0; i < this.targetFilters.length; i++) {
              if (!target.type[this.targetFilters[i]]) {
                return false;
              }
            }
          }

          if (this.targetFiltersExclude) {
            for (var i = 0; i < this.targetFiltersExclude.length; i++) {
              if (target.type[this.targetFiltersExclude[i]]) {
                return false;
              }
            }
          }

          return true;
        };

        function Upgrade(data) {
          _.extend(this, data);

          // copy arrays (so they dont get only referenced)
          var thisRef = this;
          _.each(data, function (val, key) {
            thisRef[key] = Object.prototype.toString.call(thisRef[key]) === '[object Array]' ? thisRef[key].slice() : thisRef[key];
          });

          this.isUpgrade = true;
        };

        Upgrade.prototype.getValue = function (value, owner, alsoUnderConstruction) {
          return (typeof this[value] === 'number') ? (this[value] + owner.getValueModifier(value, this, alsoUnderConstruction)) : this[value];
        };

        Upgrade.prototype.replaceReferences = function () {
          if (this.effectsTypes) {
            for (var k = 0; k < this.effectsTypes.length; k++) {
              if (typeof this.effectsTypes[k] == 'string') {
                this.effectsTypes[k] = lists.types[this.effectsTypes[k]];
              }
            }
          }

          if (typeof this.image == 'string') {
            this.image = lists.imgs[this.image] ? lists.imgs[this.image] : lists.imgs.attentionmarkYellow;
          }
        };

        Upgrade.prototype.getDataFields = function () {
          return list_upgrade_fields;
        };

        Upgrade.prototype.getTitleImage = function (nr) {
          return this.image.getTitleImage(nr);
        };

        Upgrade.prototype.addToLists = function () {
          lists.types[this.id_string] = this;
          lists.upgrades[this.id_string] = this;
          lists.buildingsUpgrades[this.id_string] = this;
        };

        Upgrade.prototype.getBasicType = function () {
          for (var i = 0; i < basicUpgrades.length; i++) {
            if (basicUpgrades[i].id_string == this.id_string) {
              return basicUpgrades[i];
            }
          }

          return false;
        };


        function Modifier(data) {
          this.isModifier = true;

          this.maxStack = 1;
          this.auraHitsFriendly = true;
          this.auraHitsAllied = true;
          this.auraHitsEnemy = true;
          this.auraHitsSelf = true;

          _.extend(this, data);

          // copy arrays (so they dont get only referenced)
          var thisRef = this;
          _.each(data, function (val, key) {
            thisRef[key] = Object.prototype.toString.call(thisRef[key]) === '[object Array]' ? thisRef[key].slice() : thisRef[key];
          });
        };

        Modifier.prototype.getDataFields = function () {
          return list_modifiers_fields;
        };

        Modifier.prototype.replaceReferences = function () {
          if (typeof this.image == 'string') {
            this.image = lists.imgs[this.image] ? lists.imgs[this.image] : lists.imgs.attentionmarkYellow;
          }

          if (this.unitImg && (typeof this.unitImg == 'string')) {
            this.unitImg = lists.imgs[this.unitImg] ? lists.imgs[this.unitImg] : lists.imgs.attentionmarkYellow;
          }

          if (this.auraModifiers) {
            for (var k = 0; k < this.auraModifiers.length; k++) {
              if (typeof this.auraModifiers[k] == 'string') {
                this.auraModifiers[k] = lists.types[this.auraModifiers[k]];
              }
            }
          }

          if (this.killModifiers) {
            for (var k = 0; k < this.killModifiers.length; k++) {
              if (typeof this.killModifiers[k] == 'string') {
                this.killModifiers[k] = lists.types[this.killModifiers[k]];
              }
            }
          }

          if (this.addCommands) {
            for (var k = 0; k < this.addCommands.length; k++) {
              if (typeof this.addCommands[k] == 'string') {
                this.addCommands[k] = lists.types[this.addCommands[k]];
              }
            }
          }

          if (this.disabledCommands) {
            for (var k = 0; k < this.disabledCommands.length; k++) {
              if (typeof this.disabledCommands[k] == 'string') {
                this.disabledCommands[k] = lists.types[this.disabledCommands[k]];
              }
            }
          }
        };

        Modifier.prototype.addToLists = function () {
          lists.types[this.id_string] = this;
          lists.modifiers[this.id_string] = this;
        };

        Modifier.prototype.getBasicType = function () {
          for (var i = 0; i < basicModifiers.length; i++) {
            if (basicModifiers[i].id_string == this.id_string) {
              return basicModifiers[i];
            }
          }

          return false;
        };

        Modifier.prototype.getValue = function (field, owner) {
          return this[field] + owner.getValueModifier(field, this);
        };

        Modifier.prototype.getTitleImage = function (nr) {
          return this.image.getTitleImage(nr);
        };

        Modifier.prototype.aoeHitsUnit = function (caster, target) {
          if (!this.auraHitsSelf && caster == target) {
            return false;
          }

          var isEnemy = caster.owner.isEnemyOfPlayer(target.owner);
          var sameTeam = caster.owner.team == target.owner.team;

          if ((isEnemy && !this.auraHitsEnemy) || (!isEnemy && sameTeam && !this.auraHitsFriendly) || (!isEnemy && !sameTeam && !this.auraHitsAllied)) {
            return false;
          }

          if (this.auraTargetFilters) {
            for (var i = 0; i < this.auraTargetFilters.length; i++) {
              if (!target.type[this.auraTargetFilters[i]]) {
                return false;
              }
            }
          }

          if (this.auraTargetFiltersExclude) {
            for (var i = 0; i < this.auraTargetFiltersExclude.length; i++) {
              if (target.type[this.auraTargetFiltersExclude[i]]) {
                return false;
              }
            }
          }

          return true;
        };

        function Graphic(data) {
          this.isGraphic = true;
          this.noLogic = true;

          _.extend(this, data);

          this.dataFiles = [];

          if (!this.id_string) {
            this.id_string = this.name;
          }

          if (!this.name) {
            this.name = this.id_string;
          }

          if (!this.img) {
            this.img = { x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: [] };
          }

          if (!this.idle) {
            this.idle = { x: 0, y: 0, w: 0, h: 0, frameWidth: 0, frames: [] };
          }

          if (!this.file) {
            this.file = 'buildingSheet';
          }
        };

        Graphic.prototype.getDataURLFile = function (index) {
          if (this.dataFiles[index]) {
            return this.dataFiles[index];
          }

          if (!this.file[index]) {
            return null;
          }

          var img = this.getTitleImage(index);

          var canv_ = document.createElement('canvas');
          canv_.width = img.w;
          canv_.height = img.h;
          canv_.getContext('2d').drawImage(img.file, img.x, img.y, img.w, img.h, 0, 0, img.w, img.h);

          var w = img.w;
          var h = img.h;

          if (w > h) {
            h = 54 * (h / w);
            w = 54;
          } else {
            w = 54 * (w / h);
            h = 54;
          }

          var el = document.createElement('img');
          el.src = canv_.toDataURL();
          el.width = w;
          el.height = h;

          this.dataFiles[index] = el;

          return this.dataFiles[index];
        };

        Graphic.prototype.getDataFields = function () {
          return list_graphic_fields;
        };

        Graphic.prototype.replaceReferences = function () {
          if (this.file && (typeof this.file == 'string')) {
            this.file = customImgs[this.file] ? customImgs[this.file] : miscSheet;
          }
        };

        Graphic.prototype.addToLists = function () {
          lists.imgs[this.id_string] = this;
        };

        Graphic.prototype.getBasicType = function () {
          if (unit_imgs[this.id_string]) {
            return unit_imgs[this.id_string];
          }

          if (building_imgs[this.id_string]) {
            return building_imgs[this.id_string];
          }

          if (imgs[this.id_string]) {
            return imgs[this.id_string];
          }

          return false;
        };

        Graphic.prototype.getTitleImage = function (nr) {
          if (this._angles) {
            return { file: this.file[this.file[nr] ? nr : 0], x: this.idle.x, y: this.idle.y, w: this.idle.frameWidth, h: this.idle.h / this._angles };
          }

          return { file: this.file[this.file[nr] ? nr : 0], x: this.img.x, y: this.img.y, w: this.img.frameWidth ? this.img.frameWidth : this.img.w, h: this.img.h };
        };

        Tile.prototype = new MapObject();
        function Tile(data) {
          _.extend(this, data);

          // random offset for drawing (only on not ground not decoration tiles, do the tiles do appear not so much "in line")
          this.randomOffsetX = 0;
          this.randomOffsetY = 0;

          if (this.type.ignoreGrid) {
            this.pos = new Field(this.x, this.y, true);
          } else {
            this.pos = new Field(this.x - 1 + this.type.sizeX / 2, this.y - 1 + this.type.sizeY / 2, true);

            // if not ground, add a random offset for drawing, to make it look more naturally
            if (this.type.blocking && !this.type.isCliff && !this.type.noRandomOffset) {
              this.randomOffsetX = Math.random() * 0.2 - 0.1;
              this.randomOffsetY = Math.random() * 0.2 - 0.1;
            }
          }

          this.drawPos = this.type.isGround ? this.pos : this.pos.add3(0, -game.getHMValue2(Math.floor(this.x), Math.floor(this.y)) * CLIFF_HEIGHT);
          this.owner = game.players[0]; // tiles always belong to the neutral player
          this.yDrawingOffset = this.type.blocking ? this.drawPos.py + this.randomOffsetY + this.type.sizeY / 2 : this.drawPos.py;

          if (this.type.blocking) {
            game.blockingTiles.push(this);

            if (game_state == GAME.EDITOR && this.type.isCliff != true && data.noHistory != true) {
              editor.clipboard.history.addObject(this);
            }

            this.switchBlocking(true, data.dontRefreshNBs);

            // switch on for all the teams
            for (var i = 0; i < game.teams.length; i++) {
              this.switchBlockingForTeam(true, game.teams[i]);
            }
          } else if (!this.type.isDefault) {
            // adding the tile to the history
            game.groundTiles2.push(this);
            if (game_state == GAME.EDITOR && (this.type.isCliff != true && data.noHistory != true)) {
              editor.clipboard.history.addObject(this);
            }
          }
          // define random offset, if this is an animated tile (img = array), define a random time offset for animation
          if (Object.prototype.toString.call(this.type.img) === '[object Array]') {
            this.randomOffsetFrame = Math.floor(Math.random() * 1000) % this.type.img.length;
          }

          this.modifierMods = {};
        };

        Tile.prototype.getYDrawingOffset = function () {
          return this.yDrawingOffset;
        };

        // draw; expects screen bounds (ingame coords)
        /*
        Tile.prototype.draw = function(x1, x2, y1, y2)
        {
          // if not in screen, return
          if(!(this.pos.px + 1 >= x1 && this.pos.py + 1 >= y1 && this.pos.px - 1 <= x2 && this.pos.py <= y2))
            return;
        
          // check if this.type.img is an array, if yes, its animated and we have to look for the current frame
          var img = this.type.img;
          if(Object.prototype.toString.call(img) === '[object Array]')
            img = this.type.img[(Math.floor(ticksCounter / 6) + this.randomOffsetFrame) % this.type.img.length];
        
          var x = (this.pos.px + this.randomOffsetX) * FIELD_SIZE - img.width * SCALE_FACTOR / 2 - game.cameraX;
          var y = (this.pos.py + this.randomOffsetY + this.type.sizeY / 2) * FIELD_SIZE - img.height * SCALE_FACTOR - game.cameraY;
        
          c.drawImage(img, x, y, img.width * SCALE_FACTOR, img.height * SCALE_FACTOR);
        };
        */

        // represents a field in the grid or an exact position; p_mode = true => exact position, else Field
        function Field(x, y, p_mode) {
          if (p_mode) {
            this.px = x;
            this.py = y;
            this.x = Math.ceil(x);
            this.y = Math.ceil(y);
          } else {
            this.x = x;
            this.y = y;
            this.px = x - 0.5;
            this.py = y - 0.5;
          }

          this.isField = true;
        };

        // get distance to other field, using field values
        Field.prototype.distanceTo = function (otherField) {
          return otherField ? Math.sqrt(Math.pow(this.x - otherField.x, 2) + Math.pow(this.y - otherField.y, 2)) : 999999;
        };

        // get distance to other field, using exact positions
        Field.prototype.distanceTo2 = function (otherField) {
          return otherField ? Math.sqrt(Math.pow(this.px - otherField.px, 2) + Math.pow(this.py - otherField.py, 2)) : 999999;
        };

        Field.prototype.isSameGrid = function (otherField) {
          return this.x == otherField.x && this.y == otherField.y;
        };

        // get vector from here to other Field
        Field.prototype.vectorTo = function (otherField) {
          return new Field(otherField.px - this.px, otherField.py - this.py, true);
        };

        // normalize the vector to a set length
        Field.prototype.normalize = function (factor) {
          var len = Math.sqrt(this.px * this.px + this.py * this.py);
          if (len == 0) {
            len = 0.001;
          }

          this.px *= factor / len;
          this.py *= factor / len;
          return this;
        };

        Field.prototype.mirror = function (width, height, horizontalInvert, verticalInvert) {
          if (horizontalInvert) {
            this.px = width - this.px;
            this.x = width - this.x;
          }
          if (verticalInvert) {
            this.py = height - this.py;
            this.y = height - this.y;
          }
          return this;
        };

        Field.prototype.getLen = function () {
          return Math.sqrt(this.px * this.px + this.py * this.py);
        };

        // adds a vector to this one from x and y values
        Field.prototype.add = function (otherField) {
          return new Field(this.px + otherField.px, this.py + otherField.py, true);
        };

        Field.prototype.add3 = function (x, y) {
          return new Field(this.px + x, this.py + y, true);
        };

        Field.prototype.mul = function (x, y) {
          return new Field(this.px * x, this.py * y, true);
        };

        // returns a new field, created from adding a vector from this to otherfield with a fixed length
        Field.prototype.addNormalizedVector = function (otherField, len) {
          var x = otherField.px - this.px;
          var y = otherField.py - this.py;

          var len2 = Math.sqrt(x * x + y * y);
          if (len2 == 0) {
            len2 = 0.001;
          }

          x *= len / len2;
          y *= len / len2;

          return new Field(this.px + x, this.py + y, true);
        };

        // adds a vector to this field with a given angle and length and returns the resulting field; a different name might be cool
        Field.prototype.add2 = function (angle, len) {
          return this.add(new Field(Math.cos(angle), Math.sin(angle), true).normalize(len));
        };

        // get angle from this point to another point
        Field.prototype.getAngleTo = function (otherField) {
          var returnValue = Math.atan((otherField.py - this.py) / (otherField.px - this.px));
          returnValue -= otherField.px - this.px < 0 ? Math.PI : 0;
          return returnValue;
        };

        Field.prototype.getCopy = function () {
          return new Field(this.px, this.py, true);
        };

        // getCopy does not return a correct copy if the Field was initialized with p_mode == False
        // TODO: determine if any code actually depends on this inaccuracy. If not, replace getCopy with getExactCopy
        Field.prototype.getExactCopy = function () {
          const f = new Field(0, 0, true);
          f.px = this.px;
          f.py = this.py;
          f.x = this.x;
          f.y = this.y;
          return f;
        };

        Field.prototype.equals = function (otherField) {
          return this.px == otherField.px && this.py == otherField.py;
        };

        Field.prototype.toString = function () {
          return this.px + ':' + this.py;
        };

        // the central class of a game; represents a game and holds arrays of all the objects
        function Game() {
          this.selectedUnits = []; // The players currently selected units
          this.blockArray = []; // false = blocked, true = free
          this.timeOfLastSelection = 0; // to check for double click on selection
          this.projectiles = []; // arrows, ...
          this.fields = []; // one Field() for every grid element is stored here, also containing an array with all its neighbours
          this.fields2x2 = []; // Additional grid, we need that for units that are bigger than 1 field
          this.buckets2x2 = [];

          this.units = []; // all units
          this.units4 = []; // dead heroes; they must be stored in case they get ressurected
          this.buildings = []; // all in game existing buildings
          this.buildings2 = []; // all existing buildings plus some already dead buildings (if seen by some play who doesnt know the building is dead it still has to be drawn for him)
          this.groundTiles2 = []; // ground tiles, that are not default (might be added or removed in editor)
          this.blockingTiles = []; // trees, rocks and so on, that block pathing and are bound to the grid
          this.objectsToDraw = [];
          this.unitList = {};

          // camera position (top left corner of the screen, in pixels)
          this.followVision = false;
          this.cameraX = 0;
          this.cameraY = 0;

          this.global_id = 1;
          this.global_command_id = 0;
          this.buildingTypeIdCounter = 0;
          this.unitTypeIdCounter = 0;

          this.minimap = null;
          this.env = new Enviroment();
          this.rain = new Rain();

          this.lastYesSound = -999; // tick of last time unit said "yes" sound (reaction to order)
          this.lastReadySound = -999; // tick of last time unit said "ready" sound (reaction to order)
          this.lastMuteToggle = -999; // tick of last time unit said "ready" sound (reaction to order)

          // create additional canvas for groundtiles
          this.groundTilesCanvas = document.createElement('canvas');

          // create additional canvas for default tiles
          this.defaultTilesCanvas = document.createElement('canvas');

          // canvasses for tiles, we put some tiles together in canvasses, so in game we have less draw calls
          this.tilesCashes = [];

          this.gameHasEnded = false;
          this.playingPlayerWon = false;

          // set replay mode to false (might have been true if we watched a replay before)
          this.replay_mode = false;
          this.chat_muted = false;

          this.playingFromEditor = false;
          this.chatLog = {};
          this.chat = {};

          this.globalVars = null;

          this.visionSetting = 0;

          this.specFieldNames = [
            '',
            'units',
            'buildings',
            'upgrades',
            'production',
            '',
            '',
            'lostUnitTypes',
          ];
        };

        Game.prototype.end = function () {
          Hotkeys.removeHotkeysChangedListener('GAME_SPEC_INTERFACE');
          keyManager.removeListener('GAME_SPEC_INFO');
          keyManager.removeListener('GAME_VISION');

          // TODO: set the scale factor to a valid value in LCG instead of fixing this here
          if (this.isLCG) {
            setScaleFactor(3);
          }
        };

        // load a map
        /*
         * @param data map file data
         * @param playerSetting array of json datas for each player
         * @param aiRandomizer random number that comes from the server and determines the style / strategy, that ai players play, (has to be the same for all clients)
         * @param ticksCounter in case of replay this is the amount of total ticks, so the game knows when the replay is finished and it has to stop
         */
        Game.prototype.loadMap = function (data, playerSettings, aiRandomizer, replayTicksCounter, isEditor, isLCG, chat, rainTime) {
          if (!playerSettings) {
            playerSettings = [];

            let insertedSelf = false;

            if (isEditor) {
              playerSettings.push({ name: networkPlayerName, controller: CONTROLLER.HUMAN, team: 0, isPlayingPlayer: true });
              insertedSelf = true;
            }

            for (let i = 0; i < MAX_PLAYERS; i++) {
              const team = parseInt(data.players?.[i].team.split(' ')[1]) || i + 1;
              const slot = data.players?.[i].slot ?? 'open';
              const isNormalAI = (data.players?.[i].ai ?? 'normal AI') == 'normal AI';
              const common = { nr: i + 1, team: team };

              if (!insertedSelf && slot == 'open') {
                playerSettings.push({ ...common, name: networkPlayerName, controller: CONTROLLER.HUMAN, isPlayingPlayer: true });
                insertedSelf = true;
              } else if ((slot == 'open' || slot == 'computer') && isNormalAI) {
                playerSettings.push({ ...common, name: 'Computer', controller: CONTROLLER.COMPUTER });
              }
            }

            if (!insertedSelf) {
              playerSettings.push({ nr: 7, team: 0, name: networkPlayerName, controller: CONTROLLER.SPECTATOR, isPlayingPlayer: true });
            }
          }

          this.x = parseInt(data.x);
          this.y = parseInt(data.y);
          this.name = data.name;
          this.description = data.description;
          this.data = data;
          this.aiRandomizer = aiRandomizer ? aiRandomizer : Math.ceil(Math.random() * 100000); // this is used to determine, which AI-type the cpu players pick
          this.replayTicksCounter = replayTicksCounter ? replayTicksCounter : -1;
          this.isEditor = !!isEditor;
          this.isLCG = !!isLCG;

          // create Minimap
          this.minimap = new Minimap(this, 0, -MINIMAP_HEIGHT);

          initCustomImgsObj();

          // custom graphics
          if (data.graphics) {
            for (key2_ in data.graphics) {
              var newImg = new Image();
              customImgs[key2_] = [];
              for (var i = 0; i < MAX_PLAYERS + 2; i++) {
                customImgs[key2_][i] = newImg;
              }

              newImg.onload = function () {
                for (key3_ in customImgs) {
                  if (customImgs[key3_] && customImgs[key3_][0] == customImgs[key3_][1]) {
                    var newImgs = ImageTransformer.replaceColors(customImgs[key3_][0], searchColors, playerColors);
                    for (var i = 0; i < newImgs.length; i++) {
                      customImgs[key3_][i + 1] = newImgs[i];
                    }
                    customImgs[key3_][MAX_PLAYERS + 1] = ImageTransformer.getGreyScaledImage(customImgs[key3_][0]);
                  }
                }
              };

              newImg.src = data.graphics[key2_];
            }
          }

          this.updateGlobalVars(data.globalVars);

          // create teams
          this.teams = [];
          for (var i = 0; i < MAX_PLAYERS + 1; i++) {
            this.teams.push(new Team(i));
          }

          // create players, player 0 is always the neutral player. He owns gold mines for example
          this.players = [new Player('Neutral', CONTROLLER.NONE, 0, 0)];

          // create the active players from playerSettings
          var specNr = MAX_PLAYERS + 1;
          for (var i = 0; i < playerSettings.length; i++) {
            var ps = playerSettings[i];

            var nr = ps.nr ? ps.nr : i + 1;
            if (ps.controller == CONTROLLER.SPECTATOR) {
              nr = specNr;
              specNr++;
            }

            var p = new Player(
              ps.name,
              ps.controller,
              nr,
              ps.controller == CONTROLLER.SPECTATOR ? 0 : ps.team,
              ps.clan,
              ps.ai_name,
              ps.skins,
              ps.dances,
            );

            if (playerSettings[i].isPlayingPlayer) {
              PLAYING_PLAYER = p;
            }

            // set controller == remote, if human but not playing player
            if (p.controller == CONTROLLER.HUMAN && PLAYING_PLAYER != p) {
              p.controller == CONTROLLER.REMOTE;
            }

            this.players[nr] = p;
          }

          // reset ticksCounter (= Game timer)
          ticksCounter = 0;

          // reset TICK_TIME
          TICK_TIME = 50;
          replaySpeedIndex = 1;

          // reset storage for commands that will be sent and recieved
          incomingOrders = {};
          outgoingOrders = [];
          playerLefts = {};
          incomingCameraUpdates = {};
          outgoingCameraUpdate = {};

          // Set default delay
          TICKS_DELAY = network_game ? 6 : 2;

          // Reset the keyManager to clear control groups, camera hotkeys, and spectator hotkeys
          keyManager.reset();

          // fill block and Fields Arrays
          for (var x = 0; x <= this.x + 1; x++) {
            this.fields[x] = [];
            this.fields2x2[x] = [];
            this.blockArray[x] = [];
            for (var y = 0; y <= this.y + 1; y++) {
              this.fields[x][y] = new Field(x, y);
              this.fields2x2[x][y] = new Field(x, y, true);
              this.blockArray[x][y] = true;
              if (x < 1 || x > this.x || y < 1 || y > this.y) // if outside borders
              {
                this.blockArray[x][y] = false;
              }
            }
          }

          // create types
          interface_.buttons = [];

          // Clear lists of any old data
          _.each(lists, function (listElement, listName) {
            _.each(listElement, function (type, key) {
              if (key != 'none') {
                delete listElement[key];
              }
            });
          });

          // Load all the default graphics and add to lists
          this.graphics = [];

          for (key in unit_imgs) {
            unit_imgs[key].id_string = key;
            this.graphics.push(new Graphic(unit_imgs[key]));
          }

          for (key in building_imgs) {
            building_imgs[key].id_string = key;
            building_imgs[key].file = building_imgs[key].file ? building_imgs[key].file : buildingSheet;
            this.graphics.push(new Graphic(building_imgs[key]));
          }

          for (key in imgs) {
            this.graphics.push(new Graphic(imgs[key]));
          }

          this.graphics.forEach((g) => g.addToLists());

          // Reset all other types and then populate them differently depending on whether or not the map is a mod
          this.unitTypes = [];
          this.buildingTypes = [];
          this.upgrades = [];
          this.commands = [];
          this.modifiers = [];

          // Populate with default unit data if the map isn't frozen
          if (!this.globalVars.isFrozen) {
            for (var i = 0; i < basicUnitTypes.length; i++) {
              this.unitTypes.push(new UnitType(basicUnitTypes[i]));
            }

            for (var i = 0; i < basicBuildingTypes.length; i++) {
              this.buildingTypes.push(new BuildingType(basicBuildingTypes[i]));
            }

            for (var i = 0; i < basicUpgrades.length; i++) {
              this.upgrades.push(new Upgrade(basicUpgrades[i]));
            }

            for (var i = 0; i < basicCommands.length; i++) {
              this.commands.push(new Command(basicCommands[i]));
            }

            for (var i = 0; i < basicModifiers.length; i++) {
              this.modifiers.push(new Modifier(basicModifiers[i]));
            }

            this.buildingTypes.concat(this.unitTypes, this.commands, this.upgrades, this.modifiers).forEach((t) => t.addToLists());
          }

          // Load custom unit data and graphics if this is a mod (frozen implies modded, so that case should already be included)
          if (this.globalVars.isModded) {
            var gameRef = this;

            // Load custom unit data
            _.each(data.unitData, function (type, typeName) {
              // AMove is handled as a special case ability
              if (typeName == 'amove') {
                return;
              }

              if (!lists.types[typeName]) {
                let o = null;
                if (type.isUnit) {
                  o = new UnitType(type);
                  gameRef.unitTypes.push(o);
                } else if (type.isBuilding) {
                  o = new BuildingType(type);
                  gameRef.buildingTypes.push(o);
                } else if (type.isCommand) {
                  o = new Command(type);
                  gameRef.commands.push(o);
                } else if (type.isUpgrade) {
                  o = new Upgrade(type);
                  gameRef.upgrades.push(o);
                } else if (type.isModifier) {
                  o = new Modifier(type);
                  gameRef.modifiers.push(o);
                } else {
                  assert(false);
                }

                if (o) {
                  o.id_string = typeName;
                  o.addToLists();
                } else {
                  throw Error(`Failed to obtain object for typeName ${typeName}\n${JSON.stringify(type)}`);
                }
              }

              const dataFields = lists.types[typeName].getDataFields();

              _.each(type, function (val, field) {
                if (dataFields[field]) {
                  if (dataFields[field].isObject || dataFields[field].type == 'complex') {
                    var obj = {};

                    _.each(val, function (el, key) {
                      obj[key] = el;
                    });

                    lists.types[typeName][field] = obj;
                  } else if (dataFields[field].isArray) {
                    var arr = [];

                    if (Object.prototype.toString.call(val) === '[object Array]') {
                      for (var i = 0; i < val.length; i++) {
                        arr.push(checkField(dataFields[field], val[i]));
                      }
                    } else {
                      arr.push(checkField(dataFields[field], val));
                    }

                    lists.types[typeName][field] = arr;
                  } else {
                    lists.types[typeName][field] = checkField(dataFields[field], val);

                    if (dataFields[field].type == 'selection' && dataFields[field].all_values && !_.contains(dataFields[field].all_values, lists.types[typeName][field])) {
                      lists.types[typeName][field] = dataFields[field].default_;
                    }
                  }
                }
              });
            });

            // Load specifically AMove as a special case
            const amove = new Command(basicCommands.find((c) => c.id_string == 'amove'));
            amove.addToLists();
            this.commands.push(amove);

            // Load custom graphics data
            _.each(data.graphicObjects, function (type, typeName) {
              if (!lists.imgs[typeName]) {
                var o = new Graphic(type);
                o.id_string = typeName;
                gameRef.graphics.push(o);
                o.addToLists();
              }

              var dataFields = lists.imgs[typeName].getDataFields();

              _.each(type, function (val, field) {
                if (dataFields[field]) {
                  if (dataFields[field].type == 'complex') {
                    var obj = {};

                    _.each(val, function (el, key) {
                      obj[key] = el;
                    });

                    lists.imgs[typeName][field] = obj;
                  } else {
                    lists.imgs[typeName][field] = checkField(dataFields[field], val);

                    if (dataFields[field].type == 'selection' && dataFields[field].all_values && !_.contains(dataFields[field].all_values, lists.types[typeName][field])) {
                      lists.imgs[typeName][field] = dataFields[field].default_;
                    }
                  }
                }
              });
            });
          }

          // refresh all buttons
          for (var k = 0; k < interface_.buttons.length; k++) {
            interface_.buttons[k].init(interface_.buttons[k].command, interface_.buttons[k].learn);
          }

          calculateTypesTickValues();

          // replacing references
          _.each(this.commands.concat(this.upgrades, this.buildingTypes, this.unitTypes, this.modifiers, this.graphics, tileTypes, cliffs, cliffs_winter, egypt_cliffs, grave_cliffs, ramp_tiles, ramp_tiles_egypt, ramp_tiles_grave), function (t) {
            t.replaceReferences();
          });

          mapEditorData = new MapEditorData();

          if (game_state == GAME.EDITOR && editor) {
            editor.createButtons();
          }


          // change environment particle style depending on theme
          var theme = getThemeByName(data.theme);

          if (!theme && this.data.defaultTiles && this.data.defaultTiles[0]) {
            for (var i = 0; i < mapThemes.length; i++) {
              if (mapThemes[i].defaultTiles.contains(this.data.defaultTiles[0])) {
                theme = mapThemes[i];
              }
            }
          }

          if (!theme) {
            theme = mapThemes[0];
          }

          this.theme = theme;

          // generate default ground tiles (by random)
          if (this.data.defaultTiles) {
            for (var x = 1; x <= this.x + DEAD_MAP_SPACE; x++) {
              for (var y = 1; y <= this.y + DEAD_MAP_SPACE; y++) {
                new Tile({
                  x: x,
                  y: y,
                  type: this.data.defaultTiles[Math.floor(Math.random() * this.data.defaultTiles.length)].toUnitType(),
                });
              }
            }
          }

          // make cliffs
          this.makeCliffsArray();
          this.makeCliffs();

          for (var i = 0; i < data.tiles.length; i++) {
            new Tile({
              x: data.tiles[i].x,
              y: data.tiles[i].y,
              type: data.tiles[i].type.toUnitType(),
              dontRefreshNBs: true,
            });
          }

          // set size depending on map size
          this.defaultTilesCanvas.width = (this.x + DEAD_MAP_SPACE) * FIELD_SIZE / SCALE_FACTOR;
          this.defaultTilesCanvas.height = (this.y + 2 + DEAD_MAP_SPACE) * FIELD_SIZE / SCALE_FACTOR;

          var ctx = this.defaultTilesCanvas.getContext('2d');
          var ctxM = this.minimap.groundTiles.getContext('2d');

          // generate default ground tiles (by random)
          if (this.data.defaultTiles) {
            for (var x = 1; x <= this.x + DEAD_MAP_SPACE; x++) {
              for (var y = -1; y <= this.y + DEAD_MAP_SPACE; y++) {
                var type = this.data.defaultTiles[Math.floor(Math.random() * this.data.defaultTiles.length)].toUnitType();

                ctx.drawImage(type.img.file[0], type.img.img.x, type.img.img.y, 16, 16, (x - 1) * 16, (y - 1 + 2) * 16, 16, 16);

                ctxM.fillStyle = type.minimapColor;
                ctxM.fillRect(Math.floor((x - 1) * this.minimap.x_scale), Math.floor((y - 1) * this.minimap.y_scale), Math.ceil(this.minimap.x_scale * type.sizeX), Math.ceil(this.minimap.y_scale * type.sizeY));

                // new Tile({x: x, y: y, type: this.data.defaultTiles[Math.floor(Math.random() * this.data.defaultTiles.length)].toUnitType()});
              }
            }
          }

          this.generateGroundTextureCanvas();

          this.generateTilesCanvasses();

          this.sortTiles();

          this.reduceDelayOnNextTick = false;
          this.increaseDelayOnNextTick = false;

          this.chat = chat ? chat : {};

          FIELD_SIZE = 16 * SCALE_FACTOR;

          this.minimap.refreshTilesCanvas();

          // find cc or start location
          var cc = null;
          for (var k = 0; k < this.buildings.length; k++) {
            if (this.buildings[k].type.takesGold && this.buildings[k].owner == PLAYING_PLAYER) {
              cc = this.buildings[k];
            }
          }

          // clear the stats window of any previous information
          StatsWindow.clear();

          // empty chat history
          $('#chatHistorytextContainer').html('');

          // Initialize the dropdowns for spectators
          // Disable them in the editor, in editor testing, LCG, and obviously if the player is not a spectator
          if (!this.isEditor && !mapData && !this.isLCG && PLAYING_PLAYER.number > MAX_PLAYERS) {
            this.initSpectatorInterface();
          }

          // Load settings if we are in the editor
          MapEditorSettings.loadFromMap(data);

          env.setFromTheme(theme);

          this.replay_mode = typeof replayTicksCounter != 'undefined' && replayTicksCounter !== null;
          game_paused = false;
          show_fps = false;
          this.chat_muted = false;

          if (network_game) {
            interface_.chatMsg('press [ENTER] to chat', true);
          }

          this.rainTime = rainTime ? rainTime : getRainTimeFromSeed(aiRandomizer);
        };

        Game.prototype.initSpectatorInterface = function () {
          const refreshInterface = () => {
            // Clear any existing key listeners
            keyManager.removeListener('GAME_SPEC_INFO');
            keyManager.removeListener('GAME_VISION');

            $('#spectatorDropdowns').empty();

            // Dropdown containing information about the game
            const infoBuilder = new HTMLBuilder();
            infoBuilder.add('<p id=\'spectatorLabel\'>Info</p>');
            infoBuilder.add('<select id=\'spectatorDropdown\'>');
            infoBuilder.add('<option value=\'0\'>Nothing</option>');
            interface_.specGeneralHotkeys.forEach((hotkey, i) => {
              const ID = uniqueID();
              infoBuilder.add(`<option id='${ID}' value='${i + 1}'>${hotkey.name} [${getKeyName(hotkey.value)}]</option>`);

              keyManager.registerListener(hotkey.value, 'GAME_SPEC_INFO', () => {
                this.refreshSpectatorTab(i + 1);
                $(`#${ID}`).prop('selected', 'selected');
              });
            });
            infoBuilder
              .add('</select>')
              .addHook(() => $('#spectatorDropdown').change(() => this.refreshSpectatorTab($('#spectatorDropdown').val())))
              .appendInto('#spectatorDropdowns');

            // Dropdown which allows the spectator to see a specific player's vision
            const visionBuilder = new HTMLBuilder();
            visionBuilder.add('<p id=\'visionLabel\'>Vision</p>');
            visionBuilder.add('<select id=\'visionDropdown\'>');
            for (let i = 0; i < this.players.length; i++) {
              if (!this.players[i] || this.players[i].controller == CONTROLLER.SPECTATOR) {
                continue;
              }

              if (i > MAX_PLAYERS) {
                continue;
              }

              const ID = uniqueID();
              const hotkey = interface_.specVisionHotkeys.getHotkeyValue(i);
              const color = (i > 0) ? playerColors[i - 1][4] : [0, 0, 0];
              visionBuilder
                .add(`<option id='${ID}' value='${i}'>${this.players[i].name} [${getKeyName(hotkey)}]</option>`)
                .addHook(() => $(`#${ID}`).css('color', `rgb(${color[0]}, ${color[1]}, ${color[2]})`));

              keyManager.registerListener(hotkey, 'GAME_VISION', () => {
                this.refreshVision(i);
                this.followVision = false;
                $(`#${ID}`).prop('selected', 'selected');
              });
            }
            visionBuilder
              .add('</select>')
              .addHook(() => $('#visionDropdown').change(() => this.refreshVision($('#visionDropdown').val())))
              .appendInto('#spectatorDropdowns');

            const follow_hotkey = interface_.specVisionHotkeys.getHotkeyValue('toggle_follow_camera');
            keyManager.registerListener(follow_hotkey, 'GAME_VISION', () => {
              const isSpectator = PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR;
              if (this.visionSetting > 0) {
                const player = this.players[this.visionSetting];
                if (player.cameraWidth == 0 || player.cameraHeight == 0) {
                  return;
                }
                this.followVision = isSpectator && !this.followVision;
              }
            });
          };
          Hotkeys.onHotkeysChanged('GAME_SPEC_INTERFACE', refreshInterface);
          refreshInterface();
        };

        Game.prototype.updateGlobalVars = function (o) {
          this.globalVars = o ? o : {};
          this.setModded(this.globalVars.isModded ?? false);
        };

        Game.prototype.automine = function () {
          if (!this.globalVars.automine) {
            return;
          }

          const workers = this.units.filter((u) => u.type == lists.types.worker && u.owner == PLAYING_PLAYER);
          this.issueOrderToUnits(workers, lists.types.mine);
        };

        Game.prototype.setModded = function (value) {
          this.globalVars.isModded = value;
          if (!value) {
            delete this.globalVars.maxSupply;
            delete this.globalVars.startGold;
            delete this.globalVars.mineDist;
          }
        };

        Game.prototype.__getGlobalVar = function (key, min, max, defaultVal) {
          const val = parseInt(this.globalVars?.[key]);
          if (isNaN(val)) {
            return defaultVal;
          }
          return Math.min(max, Math.max(min, val));
        };

        Game.prototype.getMineDistance = function () {
          return this.__getGlobalVar('mineDist', 0, 100, MINE_DIST);
        };

        Game.prototype.getMaxSupply = function () {
          return this.__getGlobalVar('maxSupply', 0, 200, MAX_SUPPLY);
        };

        Game.prototype.getStartGold = function () {
          return this.__getGlobalVar('startGold', 0, 999999, START_GOLD);
        };

        Game.prototype.getFieldFromPos = function (x, y, lowerMod) {
          // if no coords passed, use current mouse pos as default
          if (!x && !y) {
            x = (keyManager.x + game.cameraX) / FIELD_SIZE;
            y = (keyManager.y + game.cameraY) / FIELD_SIZE;
          }

          var bestDist = 99999;
          var bestField = null;
          for (var i = MAX_CLIFF_LEVEL * CLIFF_HEIGHT; i > 0; i -= 0.1) {
            var f = new Field(x, y + i, true);
            var dist = Math.abs(i - (lowerMod ? this.getHMValue3X(f) : this.getHMValue3(f)) * CLIFF_HEIGHT);
            if (dist < 0.2) {
              return f;
            }

            if (dist < bestDist) {
              bestDist = dist;
              bestField = f;
            }
          }

          if (bestField) {
            return bestField;
          }

          return new Field(x, y, true);
        };

        // höhe, auf der Einheiten gezeichnet werden
        Game.prototype.getHMValue3X = function (pos) {
          if (this.fields[pos.x] && this.fields[pos.x][pos.y]) {
            var f = this.fields[pos.x][pos.y];

            if (!f.rampEnds) {
              return f.hm2 ? f.hm2 : 0;
            }

            var dist = f.rampEnds.low.distanceTo2(f.rampEnds.high);
            return f.hm2 + Math.min(Math.max((pos.distanceTo2(f.rampEnds.low) - 0.1) * 1.1, 0) / dist, 1);
          }

          return 0;
        };

        // höhe, auf der Einheiten gezeichnet werden
        Game.prototype.getHMValue3 = function (pos) {
          if (this.fields[pos.x] && this.fields[pos.x][pos.y]) {
            var f = this.fields[pos.x][pos.y];

            if (!f.rampEnds) {
              return f.hm4 ? f.hm4 : 0;
            }

            var dist = f.rampEnds.low.distanceTo2(f.rampEnds.high);
            return f.hm2 + Math.min(Math.max((pos.distanceTo2(f.rampEnds.low) - 0.1) * 1.1, 0) / dist, 1);
          }

          return 0;
        };

        Game.prototype.getHMValue4 = function (x, y) {
          return (this.fields[x] && this.fields[x][y]) ? this.fields[x][y].hm4 : 0;
        };

        Game.prototype.getHMValue2 = function (x, y) {
          return (this.fields[x] && this.fields[x][y]) ? this.fields[x][y].hm2 : 0;
        };

        Game.prototype.getHMValue = function (x, y) {
          return (this.fields[x] && this.fields[x][y]) ? this.fields[x][y].hm : 0;
        };

        Game.prototype.setHMValue = function (x, y, val, noHistory) {
          if (this.fields[x] && this.fields[x][y]) {
            if (game_state == GAME.EDITOR && noHistory != true) {
              var heightMapChange = {
                x: x,
                y: y,
                newHeight: val,
                oldHeight: this.fields[x][y].hm,
              };
              editor.clipboard.history.addObject(heightMapChange, 'ChangeHeight');
            }
            this.fields[x][y].hm = val;
          }
        };

        Game.prototype.makeCliffsArray = function () {
          var hm = this.data.heightmap ? this.data.heightmap : '';
          var i = 0;

          for (var x = 1; x <= this.x; x++) {
            for (var y = 1; y <= this.y; y++) {
              if (hm.length > i) {
                var val = hm.slice(i, i + 1);

                if (parseInt(val) == val) {
                  if (val > MAX_CLIFF_LEVEL) {
                    val = MAX_CLIFF_LEVEL;
                  }

                  if (val < 0) {
                    val = 0;
                  }

                  val = parseInt(val);
                }

                this.fields[x][y].hm = val;
              } else {
                this.fields[x][y].hm = 0;
              }

              i++;
            }
          }
        };

        // make cliffs (in an area from x1:y1 to x2:y2; default: whole map)
        Game.prototype.makeCliffs = function (x1_, y1_, x2_, y2_) {
          x1_ = Math.min(Math.max(x1_ ? x1_ : 1, 1), this.x);
          y1_ = Math.min(Math.max(y1_ ? y1_ : 1, 1), this.y);
          x2_ = Math.min(Math.max(x2_ ? x2_ : this.x, 1), this.x);
          y2_ = Math.min(Math.max(y2_ ? y2_ : this.y, 1), this.y);

          // kill all existing cliff Tiles
          for (var i = 0; i < this.blockingTiles.length; i++) {
            var tile = this.blockingTiles[i];
            if (tile.type.isCliff && tile.x >= x1_ && tile.x <= x2_ && tile.y >= y1_ && tile.y <= y2_) {
              this.blockingTiles[i].switchBlockingTotal(false);
              this.blockingTiles.splice(i, 1);
              i--;
            }
          }

          // higher level, if single low grounded cliff fields, cuz those look stupido
          for (var x = x1_; x <= x2_; x++) {
            for (var y = y1_; y <= y2_; y++) {
              var h = this.fields[x][y].hm;

              if (parseInt(h) == h) {
                var countHigherNBs = 0;

                for (var i = 0; i < 8; i++) {
                  var h2 = this.getHMValue(x + nbCoords[i].x, y + nbCoords[i].y);

                  if (parseInt(h2) == h2 && h2 > h) {
                    countHigherNBs++;
                  }
                }

                // if all but one (or all) nbs are higher, make this field, higher, too
                if (countHigherNBs >= 6) {
                  this.fields[x][y].hm++;
                } else {
                  for (var i = 0; i < reversePairs.length; i++) {
                    var h1_ = this.getHMValue(x + reversePairs[i][0].x, y + reversePairs[i][0].y);
                    var h2_ = this.getHMValue(x + reversePairs[i][1].x, y + reversePairs[i][1].y);

                    if (parseInt(h1_) == h1_ && h1_ > h && parseInt(h2_) == h2_ && h2_ > h) {
                      this.fields[x][y].hm++;
                      i = reversePairs.length;
                    }
                  }
                }
              }
            }
          }

          for (var x = x1_; x <= x2_; x++) {
            for (var y = y1_; y <= y2_; y++) {
              var h = this.fields[x][y].hm;

              this.fields[x][y].hm2 = h;
              this.fields[x][y].hm4 = h;
              this.fields[x][y].rampEnds = null;

              // get height levels of all nbs
              var nbs = [];
              for (var i = 0; i < 8; i++) {
                var h2 = this.getHMValue(x + nbCoords[i].x, y + nbCoords[i].y);

                if (parseInt(h2) != h2) {
                  h2 = h;
                }

                nbs.push(h2 - h);
              }

              // find according cliff
              var cliffTilePlaced = false;
              for (var i = 0; i < cliffTable.length; i++) {
                var match = true;
                var arr = cliffTable[i].arr;
                for (var k = 0; k < 8; k++) {
                  if (!(arr[k] == '*' || (arr[k] == 0 && nbs[k] <= 0) || (arr[k] == 1 && nbs[k] == 1))) {
                    match = false;
                  }
                }

                if (match) {
                  new Tile({
                    x: x,
                    y: y,
                    type: this.theme.cliffs[cliffTable[i].cliffIndex],
                  });
                  cliffTilePlaced = true;
                  this.fields[x][y].hm4++;
                }
              }

              if (!cliffTilePlaced) {
                var atLeastOneHigherGroundExists = false;
                for (var k = 0; k < 8; k++) {
                  if (nbs[k] > 0) {
                    atLeastOneHigherGroundExists = true;
                  }
                }

                if (atLeastOneHigherGroundExists && h == parseInt(h)) {
                  if (this.getHMValue(x, y + 1) <= h) {
                    new Tile({
                      x: x,
                      y: y,
                      type: this.theme.cliffs[0],
                    });
                  } else {
                    new Tile({
                      x: x,
                      y: y,
                      type: this.theme.cliffs[12],
                    });
                  }

                  this.fields[x][y].hm4++;
                }
              }
            }
          }


          // Ramps
          var usedPoints = [];

          for (var x = x1_; x <= x2_; x++) {
            for (var y = y1_; y <= y2_; y++) {
              var h = this.fields[x][y].hm;

              if (h == 'N' || h == 'S' || h == 'E' || h == 'W') {
                var ramp = getRampTypeFromCode(h);

                // determine height level of this ramp
                var x2 = x;
                var y2 = y;

                while (this.getHMValue(x2, y2) == h) {
                  x2 += ramp.vec.x;
                  y2 += ramp.vec.y;
                }

                this.fields[x][y].hm2 = this.getHMValue(x2, y2);

                // search and set lowest and highest point
                x2 = x;
                y2 = y;

                while (this.getHMValue(x2, y2) == h) {
                  x2 += ramp.vec.x;
                  y2 += ramp.vec.y;
                }

                var x3 = x;
                var y3 = y;

                while (this.getHMValue(x3, y3) == h) {
                  x3 -= ramp.vec.x;
                  y3 -= ramp.vec.y;
                }

                this.fields[x][y].rampEnds = {
                  low: new Field(x2, y2).add3(-ramp.vec.x / 2, -ramp.vec.y / 2),
                  high: new Field(x3, y3).add3(ramp.vec.x / 2, ramp.vec.y / 2),
                };

                // sides
                for (var i = 0; i < ramp.cliffs.length; i++) {
                  var cliff = ramp.cliffs[i];

                  // search point1
                  x2 = x;
                  y2 = y;

                  while (this.getHMValue(x2 + cliff.x, y2) == h) {
                    x2 += cliff.x;
                  }

                  while (this.getHMValue(x2, y2 + cliff.y) == h) {
                    y2 += cliff.y;
                  }

                  if (cliff.addX) {
                    x2 += cliff.addX;
                  }

                  if (cliff.addY) {
                    y2 += cliff.addY;
                  }

                  var hash = x2 + y2 * 10000;
                  if (usedPoints.contains(hash)) {
                    i = ramp.cliffs.length;
                    continue;
                  } else {
                    usedPoints.push(hash);
                    if (!this.fieldIsBlocked(x2, y2)) {
                      new Tile({
                        x: x2,
                        y: y2,
                        type: cliff.cliff,
                      });
                    }
                  }
                }

                // ground texture

                // move draw pointer to initial position
                x2 = x;
                y2 = y;

                while (this.getHMValue(x2 + ramp.texture.initX, y2) == h) {
                  x2 += ramp.texture.initX;
                }

                while (this.getHMValue(x2, y2 + ramp.texture.initY) == h) {
                  y2 += ramp.texture.initY;
                }

                // draw
                while (this.getHMValue(x2 + ramp.texture.loopX * 2, y2 + ramp.texture.loopY * 2) == h) {
                  new Tile({
                    x: x2 + ramp.texture.drawX,
                    y: y2 + ramp.texture.drawY - this.getHMValue2(x2, y2) * CLIFF_HEIGHT,
                    type: ramp.texture.tiles[Math.floor(Math.random() * ramp.texture.tiles.length)],
                  });

                  x2 += ramp.texture.loopX;
                  y2 += ramp.texture.loopY;
                }
              }
            }
          }
        };
        Game.prototype.enableChat = function (val) {
          this.chat_muted = val; // !this.chat_muted;
          // Pop up
          interface_.addMessage('Chat ' + (this.chat_muted ? 'muted.' : 'unmuted.'), 'yellow', imgs.attentionmarkYellow);
        };

        // kill ramp at position x, y
        Game.prototype.killRamp = function (x, y) {
          var h = this.getHMValue(x, y);

          if (h == parseInt(h)) {
            return;
          }

          var fields = [this.fields[x][y]];
          var fields2 = [];

          while (fields.length > 0) {
            var f = fields.pop();
            fields2.push(f);

            for (var i = 0; i < nbCoords.length; i++) {
              var nb = this.fields[f.x + nbCoords[i].x] ? this.fields[f.x + nbCoords[i].x][f.y + nbCoords[i].y] : null;
              if (nb && !fields.contains(nb) && !fields2.contains(nb) && this.getHMValue(nb.x, nb.y) == h) {
                fields.push(nb);
              }
            }
          }

          for (var i = 0; i < fields2.length; i++) {
            // kill side cliffs
            if (!this.blockArray[fields2[i].x][fields2[i].y]) {
              for (var k = 0; k < this.blockingTiles.length; k++) {
                if (this.blockingTiles[k].includesField(fields2[i].x, fields2[i].y)) {
                  this.blockingTiles[k].switchBlockingTotal(false);
                  this.blockingTiles.splice(k, 1); // kill the object
                }
              }
            }

            // kill ground tiles
            for (var k = 0; k < this.groundTiles2.length; k++) {
              if (this.groundTiles2[k].type.isCliff) {
                this.groundTiles2.splice(k, 1);
              }
            }

            fields2[i].hm = fields2[i].hm2;
          }

          // refresh the pre drawn blocking tiles canvasses
          this.generateTilesCanvasses();

          // re sort tiles
          this.sortTiles();

          // refresh minimap canvas, we might have killed a tile
          this.minimap.refreshTilesCanvas();

          // redraw ground tiles canvas
          this.generateGroundTextureCanvas();
        };

        // sort tiles by y coord to bring them in the right order when drawing
        Game.prototype.sortTiles = function () {
          this.objectsToDraw = _.sortBy(this.tilesCashes.concat(this.units, this.buildings), function (obj) {
            return obj.getYDrawingOffset();
          });
        };

        Game.prototype.generateTilesCanvasses = function () {
          for (var y = 0; y <= this.y; y++) {
            this.refreshBlockingTilesCanvas(y);
          }
        };

        Game.prototype.refreshBlockingTilesCanvas = function (y) {
          var tiles = [];
          var maxHeight = 1;

          // add all tiles that have this y coordinate
          for (var i = 0; i < this.blockingTiles.length; i++) {
            var tile = this.blockingTiles[i];

            if (tile.y + tile.type.sizeY - 1 == y) {
              tiles.push(tile);
              var hm = this.getHMValue2(tile.x, tile.y);
              maxHeight = Math.max(maxHeight, tile.type.img.img.h + (hm ? hm : 0) * CLIFF_HEIGHT * 16);
            }
          }

          // sort the tiles by their exact y offset
          tiles = _.sortBy(tiles, function (tile) {
            return tile.randomOffsetY;
          });

          // create canvas and set parameters
          var canvas = document.createElement('canvas');
          canvas.width = (this.x + 1) * FIELD_SIZE / SCALE_FACTOR;
          canvas.height = maxHeight;
          canvas.y_ = y;

          canvas.getYDrawingOffset = function () {
            return this.y_;
          };

          // define draw function
          canvas.draw = function (x1, x2, y1, y2) {
            c.drawImage(this, -x1 * FIELD_SIZE, (this.y_ - y1) * FIELD_SIZE - this.height * SCALE_FACTOR, this.width * SCALE_FACTOR, this.height * SCALE_FACTOR);
          };

          canvas.isInBox = function (x1, y1, x2, y2) {
            return y1 < this.y_ && y2 > this.y_ - 1 && this.height > 1;
          };

          canvas.isInBoxVisible = canvas.isInBox;

          var ctx = canvas.getContext('2d');

          // draw the tiles on the canvas
          for (var i = 0; i < tiles.length; i++) {
            var tile = tiles[i];

            var img = (game_state == GAME.EDITOR && tile.type.img.imgEditor) ? tile.type.img.imgEditor : tile.type.img.img;
            var x_ = (tile.pos.px + tile.randomOffsetX) * 16 - img.w / 2;
            var y_ = maxHeight - img.h + (tile.randomOffsetY - this.getHMValue2(tile.x, tile.y) * CLIFF_HEIGHT) * 16;
            ctx.drawImage(tile.type.img.file[0], img.x, img.y, img.w, img.h, Math.floor(x_), Math.floor(y_), img.w, img.h);
          }

          this.tilesCashes[y] = canvas;
        };

        Game.prototype.refreshSpectatorTab = function (index) {
          if (isNaN(index)) {
            index = $('#spectatorDropdown')[0].selectedIndex;
          }

          interface_.showInfoDiv = index > 0;
          if (index == 0) {
            return;
          }

          var fieldName = this.specFieldNames[index];

          // draw
          $('#spectatorDiv').html('');

          var x = 0;
          var y = 0;

          for (var i = 1; i < this.players.length; i++) {
            if (this.players[i] && this.players[i].controller != CONTROLLER.SPECTATOR && playerColors[i - 1]) {
              var p = this.players[i];

              x = 20;

              var arr = playerColors[i - 1][4];
              $('#spectatorDiv')[0].innerHTML += '<div class=\'playerIndicator\' style=\'top: ' + y + 'px; background-color: rgb(' + arr[0] + ', ' + arr[1] + ', ' + arr[2] + ');\'></div>';

              if (fieldName) {
                _.each(p[fieldName], function (count, type_id_string) {
                  var type = lists.types[type_id_string];

                  var count_ = 0;
                  var bar = '';

                  if (isNaN(count)) {
                    var perc = 0;

                    if (!count.from) {
                      var buildTicksLeft = _.sortBy(count.to, function (el) {
                        return el.buildTicksLeft;
                      })[0].buildTicksLeft;
                      perc = (type.getValue('buildTime', p) - buildTicksLeft) / type.getValue('buildTime', p);
                    } else {
                      var soonestFinish = _.sortBy(count.to, function (el) {
                        return el;
                      })[0];
                      var soonestStart = _.sortBy(count.from, function (el) {
                        return el;
                      })[0];
                      perc = (ticksCounter - soonestStart) / (soonestFinish - soonestStart);
                    }

                    bar = '<div class=\'whitebar\' style=\'width: 52px; z-index: 1;\'></div><div style=\'width: ' + Math.floor(Math.min(perc, 1) * 50) + 'px; z-index: 1;\'></div>';
                    count_ = count.to.length;
                  } else {
                    count_ = count;
                  }

                  var img = ((type.img && type.img.getDataURLFile) ? type.img : type.image).getDataURLFile(game.players[i].number);

                  var rnd = 'div_' + parseInt(Math.random() * 999999999);

                  var str = '<div id=\'' + rnd + '\' style=\'left: ' + x + 'px; top: ' + y + 'px; overflow: hidden;\'><p style=\'z-index: 1;\'>' + count_ + '</p>' + bar + '</div>';

                  $('#spectatorDiv')[0].innerHTML += str;
                  $('#' + rnd)[0].appendChild(img);

                  x += 60;
                });
              } else if (index == 5) // mined gold
              {
                $('#spectatorDiv')[0].innerHTML += '<div style=\'left: 20px; top: ' + (y - 8) + 'px;\'><p style=\'font-size: 24px; right: initial; width: 450px;\'>Current: <font color=\'#87FF73\'>' + (p.currentMinedGold * 6) + '</font> &nbsp; &nbsp; Total: ' + p.minedGold + ' &nbsp; &nbsp; Lost: <font color=\'#FF7373\'>' + p.goldLost + '</font></p></div>';
              } else if (index == 6) // apm
              {
                $('#spectatorDiv')[0].innerHTML += '<div style=\'left: 20px; top: ' + (y - 8) + 'px;\'><p style=\'font-size: 24px;\'>' + Math.floor(p.apm / (ticksCounter / 1200)) + '</p></div>';
              }

              y += 60;
            }
          }
        };

        Game.prototype.refreshVision = function (playerNr) {
          if (playerNr != this.visionSetting) {
            this.visionSetting = playerNr;
            PLAYING_PLAYER.team = playerNr > 0 ? this.players[playerNr].team : PLAYING_PLAYER.team = this.teams[0];
            worker.postMessage({
              what: 'requestFogMask',
              teamIndex: this.players[playerNr].team.number,
            });
          }
        };

        Game.prototype.getReplayFile = function () {
          // build players info object
          var p = [];
          for (var i = 1; i < this.players.length; i++) {
            if (this.players[i]) {
              const player = this.players[i];
              p.push(player.getReplayObject());
            }
          }

          // strip ticks without orders
          var orders = {};
          for (var i = 0; i <= ticksCounter; i++) {
            if (incomingOrders[i] && incomingOrders[i].length > 0) {
              orders[i] = incomingOrders[i];
            }
          }

          // build and return stringified replay object
          return JSON.stringify({
            map: this.name,
            mapVersion: this.data.timestamp,
            gameVersion: GAME_VERSION,
            players: p,
            aiRandomizer: this.aiRandomizer,
            aiCommit: AIManager.getAICommit(),
            ticksCounter: ticksCounter,
            orders: orders,
            messages: this.chatLog,
            playerLefts: playerLefts,
            cameraUpdates: incomingCameraUpdates,
          });
        };

        Game.prototype.addChatMsgToLog = function (msg) {
          var escapedMsg = escapeHtml(msg);
          // if this index already exists, push the msg
          if (this.chatLog[ticksCounter]) {
            this.chatLog[ticksCounter].push(msg);
          }

          // if the index doesnt exist, create it and add the msg
          else {
            this.chatLog[ticksCounter] = [msg];
          }
          console.log(`Chat msg ${msg}`);
          // add to chat history window
          $('#chatHistorytextContainer')[0].innerHTML += '<p>' + escapedMsg + '</p>';
        };

        // refresh the neighbours of a field, gets called everytime a building gets destroyed or created
        Game.prototype.refreshNBSOfField = function (field) {
          var nbs = [];

          for (var x = field.x - 1; x <= field.x + 1; x++) {
            for (var y = field.y - 1; y <= field.y + 1; y++) {
              if ((x != field.x || y != field.y) && x >= 0 && y >= 0 && x <= this.x && y <= this.y && this.blockArray[x][y] && (x == field.x || y == field.y || (this.blockArray[field.x][y] && this.blockArray[x][field.y]))) {
                nbs.push(this.fields[x][y]);
              }
            }
          }

          field.nbs = nbs;
        };

        // refresh the neighbours of a field, gets called everytime a building gets destroyed or created (2x2)
        Game.prototype.refreshNBSOfField2x2 = function (field) {
          var nbs = [];

          for (var x = field.x - 1; x <= field.x + 1; x++) {
            for (var y = field.y - 1; y <= field.y + 1; y++) {
              if ((x != field.x || y != field.y) && x >= 0 && y >= 0 && x <= this.x - 1 && y <= this.y - 1 && this.fieldIsFree2x2(x, y) && (x == field.x || y == field.y || (this.fieldIsFree2x2(field.x, y) && this.fieldIsFree2x2(x, field.y)))) {
                nbs.push(this.fields2x2[x][y]);
              }
            }
          }

          field.nbs = nbs;
        };

        Game.prototype.fieldIsFree2x2 = function (x, y) {
          return this.blockArray[x][y] && this.blockArray[x + 1][y] && this.blockArray[x][y + 1] && this.blockArray[x + 1][y + 1];
        };

        Game.prototype.generateGroundTextureCanvas = function () {
          // set size depending on map size
          this.groundTilesCanvas.width = this.defaultTilesCanvas.width;
          this.groundTilesCanvas.height = this.defaultTilesCanvas.height;

          var textures = [];
          var nonTextures = [];

          for (var i = 0; i < this.groundTiles2.length; i++) {
            if (this.groundTiles2[i].type.isTexture) {
              textures.push(this.groundTiles2[i]);
            } else {
              nonTextures.push(this.groundTiles2[i]);
            }
          }

          var tiles = textures.concat(nonTextures);

          var ctx = this.groundTilesCanvas.getContext('2d');

          ctx.drawImage(this.defaultTilesCanvas, 0, 0);

          for (var i = 0; i < tiles.length; i++) {
            var img = tiles[i].type.img.img;
            ctx.drawImage(tiles[i].type.img.file[0], img.x, img.y, img.w, img.h, Math.floor(tiles[i].drawPos.px * 16 - img.w / 2), Math.floor((tiles[i].drawPos.py + 2) * 16 - img.h / 2), img.w, img.h);
          }

          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.fillRect(0, 0, this.groundTilesCanvas.width, 32);
        };

        Game.prototype.getHeightmapString = function () {
          var str = '';
          for (var x = 1; x <= this.x; x++) {
            for (var y = 1; y <= this.y; y++) {
              str += this.fields[x][y].hm.toString();
            }
          }
          return str;
        };

        // returns a json file which includes the whole map data including all tiles and units
        Game.prototype.export_ = function (withCliffs) {
          var unitData = {};

          // Checks if the provided field in type t is the same as the field in the provided basic type, so that non-frozen maps
          // can skip saving that field's value
          // TODO: rewrite this to be less incomprehensible (originally was a massive set of nested ternary statements)
          const isFieldSameAsBasicType = (t, field, basicType) => {
            // Figure out the default value that the basic object will have
            // TODO: this logic is likely duplicated somewhere when the basic type is actually loaded into the game
            // Find out where it's duplicated and use that instead
            let basicValue;
            if (field.name in basicType) {
              if (field.values && typeof basicType[field.name] == 'string' && basicType[field.name] in field.values) {
                basicValue = field.values[basicType[field.name]];
              } else {
                basicValue = basicType[field.name];
              }
            } else {
              basicValue = field.default_;
            }

            // The field not being defined means it will take the default value
            return (!(field.name in t)) || t[field.name] == basicValue;
          };

          _.each(lists.types, (t1) => {
            // If this is a frozen map, there is no basic type that we should diff off of
            const basicType = this.globalVars.isFrozen ? null : t1.getBasicType();
            const fields = t1.getDataFields();

            if (!basicType) {
              unitData[t1.id_string] = {
                isUnit: t1.isUnit,
                isBuilding: t1.isBuilding,
                isUpgrade: t1.isUpgrade,
                isCommand: t1.isCommand,
                isModifier: t1.isModifier,
              };
            }

            _.each(fields, (field) => {
              if (field.type == 'complex') {
                // TODO: this is copied from the loop below. Merge the code for these two
                if (!t1[field.name]) {
                  return;
                }

                if (!this.globalVars.isFrozen && mapEditorData.fieldIsDefault(field, t1)) {
                  return;
                }

                if (!unitData[t1.id_string]) {
                  unitData[t1.id_string] = {};
                }
                if (!unitData[t1.id_string][field.name]) {
                  unitData[t1.id_string][field.name] = {};
                }

                field.values.forEach((value) => {
                  unitData[t1.id_string][field.name][value.name] = t1[field.name][value.name];
                });
              } else if (field.isArray) {
                if (basicType && arraysAreSame(t1[field.name], basicType[field.name] ?? field.default2_, field.values)) {
                  return;
                }

                if (!unitData[t1.id_string]) {
                  unitData[t1.id_string] = {};
                }

                var arr = [];

                if (t1[field.name]) {
                  for (var j = 0; j < t1[field.name].length; j++) {
                    if (isObject(t1[field.name][j]) && t1[field.name][j].id_string) {
                      arr[j] = t1[field.name][j].id_string;
                    } else if (isObject(t1[field.name][j]) && t1[field.name][j].isTargetRequirement) {
                      arr[j] = t1[field.name][j].funcName;
                    } else {
                      arr[j] = t1[field.name][j];
                    }
                  }
                }

                unitData[t1.id_string][field.name] = arr;
              } else if (field.type == 'commands') {
                if (basicType && objectsAreSame(t1[field.name], basicType[field.name], lists.types)) {
                  return;
                }

                if (!unitData[t1.id_string]) {
                  unitData[t1.id_string] = {};
                }

                var obj = {};

                _.each(t1[field.name], function (val, key) {
                  if (!val) {
                    throw Error(`Issue with command (${val}, ${key})`);
                  }
                  obj[key] = val.id_string;
                });

                unitData[t1.id_string][field.name] = obj;
              } else {
                if (basicType && isFieldSameAsBasicType(t1, field, basicType)) {
                  return;
                }

                if (!unitData[t1.id_string]) {
                  unitData[t1.id_string] = {};
                }

                var dataToWrite = t1[field.name] ?? field.default_;

                if (isObject(dataToWrite)) {
                  if (getBuildingImgNameFromImgObject(dataToWrite)) // building img
                  {
                    dataToWrite = getBuildingImgNameFromImgObject(dataToWrite);
                  } else if (dataToWrite.name && dataToWrite.file) // unit img
                  {
                    dataToWrite = dataToWrite.id_string;
                  } else if (dataToWrite.id_string) // other type
                  {
                    dataToWrite = dataToWrite.id_string;
                  }
                } else if (_.isFunction(dataToWrite)) {
                  dataToWrite = getImageFunctionName(dataToWrite);
                }

                unitData[t1.id_string][field.name] = dataToWrite;
              }
            });
          });

          var graphics = {};
          for (key in customImgs) {
            if (!unit_imgs[key] && !building_imgs[key] && key != 'buildingSheet' && key != 'tileSheet' && key != 'miscSheet') {
              graphics[key] = customImgs[key][0].src;
            }
          }

          var graphicObjects = {};
          _.each(lists.imgs, (t1) => {
            if (!t1) {
              return;
            }

            const basicType = this.globalVars.isFrozen ? null : t1.getBasicType();
            const fields = t1.getDataFields();

            _.each(fields, (field) => {
              if (field.type == 'complex') {
                if (!t1[field.name]) {
                  return;
                }

                if (!this.globalVars.isFrozen && mapEditorData.fieldIsDefault(field, t1)) {
                  return;
                }

                if (!graphicObjects[t1.id_string]) {
                  graphicObjects[t1.id_string] = {};
                }
                if (!graphicObjects[t1.id_string][field.name]) {
                  graphicObjects[t1.id_string][field.name] = {};
                }

                field.values.forEach((value) => {
                  graphicObjects[t1.id_string][field.name][value.name] = t1[field.name][value.name];
                });
              } else if (field.name == 'file') {
                if (basicType && t1[field.name] == basicType[field.name]) {
                  return;
                }

                if (!graphicObjects[t1.id_string]) {
                  graphicObjects[t1.id_string] = {};
                }

                for (key_ in customImgs) {
                  if (customImgs[key_] == t1[field.name]) {
                    graphicObjects[t1.id_string][field.name] = key_;
                  }
                }
              } else {
                if (basicType && isFieldSameAsBasicType(t1, field, basicType)) {
                  return;
                }

                if (!graphicObjects[t1.id_string]) {
                  graphicObjects[t1.id_string] = {};
                }

                // TODO: this is copy-pasted from above. Honestly, both of these loops should use the same code
                var dataToWrite = t1[field.name] ?? field.default_;

                if (isObject(dataToWrite)) {
                  if (getBuildingImgNameFromImgObject(dataToWrite)) // building img
                  {
                    dataToWrite = getBuildingImgNameFromImgObject(dataToWrite);
                  } else if (dataToWrite.name && dataToWrite.file) // unit img
                  {
                    dataToWrite = dataToWrite.name;
                  } else if (dataToWrite.id_string) // other type
                  {
                    dataToWrite = dataToWrite.id_string;
                  }
                } else if (_.isFunction(dataToWrite)) {
                  dataToWrite = getImageFunctionName(dataToWrite);
                }

                graphicObjects[t1.id_string][field.name] = dataToWrite;
              }
            });
          });

          var data = {
            name: this.name,
            x: this.x,
            y: this.y,
            tiles: [],
            groundTiles: [],
            units: [],
            buildings: [],
            defaultTiles: this.data.defaultTiles,
            heightmap: this.getHeightmapString(),
            unitData: {},
            description: this.description,
            globalVars: this.globalVars,
            players: MapEditorSettings.getPlayerSettings(),
            graphics: {},
            graphicObjects: {},
          };

          if (this.globalVars.isModded || this.globalVars.isFrozen) {
            data.unitData = unitData;
            data.graphics = graphics;
            data.graphicObjects = graphicObjects;
          }

          var tiles = this.groundTiles2.concat(this.blockingTiles);
          for (var i = 0; i < tiles.length; i++) {
            if (!tiles[i].type.isCliff || withCliffs) // dont save default tiles (= ground textures), they are generated randomly at each mapload and dont save cliff tiles, they are created from heightmap
            {
              if (tiles[i].type.ignoreGrid) {
                data.tiles.push({
                  x: tiles[i].pos.px,
                  y: tiles[i].pos.py,
                  type: tiles[i].type.name,
                });
              } else {
                data.tiles.push({
                  x: tiles[i].x,
                  y: tiles[i].y,
                  type: tiles[i].type.name,
                });
              }
            }
          }

          for (var i = 0; i < this.units.length; i++) {
            var u = this.units[i];
            var o = {
              x: u.pos.px,
              y: u.pos.py,
              type: u.type.name,
              owner: u.owner.number,
              waypoint: this.getWaypointExportObject(u.waypoint),
            };
            data.units.push(o);
          }

          for (var i = 0; i < this.buildings.length; i++) {
            var u = this.buildings[i];
            var o = {
              x: u.x,
              y: u.y,
              type: u.type.name,
              owner: u.owner.number,
              waypoint: this.getWaypointExportObject(u.waypoint),
            };
            data.buildings.push(o);
          }

          return data;
        };

        Game.prototype.getWaypointExportObject = function (wp) {
          if (wp) {
            var arr = [];
            for (var i = 0; i < wp.length; i++) {
              if (wp[i].px) {
                arr.push(wp[i].px, wp[i].py);
              }
            }

            return arr;
          }
        };

        Game.prototype.getUnitById = function (id) {
          return this.unitList[id];
        };

        Game.prototype.getNextBuildingOfType = function (pos, owner, onlyFinished, filter) {
          var shortestDistance = 999999;
          var building = null;

          for (var i = 0; i < this.buildings.length; i++) {
            var b = this.buildings[i];
            if ((!filter || b.type[filter]) && pos.distanceTo2(b.pos) < shortestDistance && (!owner || owner == b.owner) && (!onlyFinished || !b.isUnderConstruction)) {
              building = b;
              shortestDistance = pos.distanceTo2(b.pos);
            }
          }

          return building;
        };

        Game.prototype.unitMatchesFilters = function (unit, command) {
          if (unit && unit.type) {
            for (var k = 0; k < command.targetRequiremementsArray.length; k++) {
              var met = false;

              for (var i = 0; i < command.targetRequiremementsArray[k].length; i++) {
                if (command.targetRequiremementsArray[k][i].func(unit)) {
                  met = true;
                }
              }

              if (!met) {
                return false;
              }
            }
          }

          return true;
        };

        // get unit at specific position (usually to check if where we clicked is a unit and which one) or for hover effect
        Game.prototype.getUnitAtPosition = function (x, y, filters) {
          var bestUnit = null;
          var lowestDistance = 99999;
          var clickedField = new Field(x, y, true);

          for (var i = 0; i < this.units.length; i++) {
            var unit = this.units[i];
            var dist = unit.pos.distanceTo2(clickedField);

            if ((game_state == GAME.EDITOR || PLAYING_PLAYER.team.canSeeUnitInvisible(unit) || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) && unit.isInBox(x - CLICK_TOLERANCE, y - CLICK_TOLERANCE + unit.type.selectionOffsetY, x + CLICK_TOLERANCE, y + CLICK_TOLERANCE + 0.4 + unit.type.selectionOffsetY) && lowestDistance > dist && PLAYING_PLAYER.team.canSeeUnit(unit)) {
              if (!filters || this.unitMatchesFilters(unit, filters)) {
                lowestDistance = dist;
                bestUnit = unit;
              }
            }
          }

          if (bestUnit) {
            return bestUnit;
          }

          lowestDistance = 99999;
          for (var i = 0; i < this.buildings2.length; i++) {
            var building = this.buildings2[i];
            var dist = building.pos.distanceTo2(clickedField);

            var selectionOffsetY = building.type.selectionOffsetY || 0;
            if (building.seenBy[PLAYING_PLAYER.team.number] && building.isInBox(x - CLICK_TOLERANCE, y - CLICK_TOLERANCE + selectionOffsetY, x + CLICK_TOLERANCE, y + CLICK_TOLERANCE + selectionOffsetY + 0.4) && lowestDistance > dist) {
              lowestDistance = dist;
              bestUnit = building;
            }
          }
          return bestUnit;
        };

        // return unit-array based on the coordinates of a box drawn (select all units of this type in the screen region if selectAll)
        Game.prototype.getSelection = function (x1, y1, x2, y2, selectAll) {
          var units = [];

          // if click (no box), then look for nearest valiable unit and select this one
          if (x2 - x1 <= 0.05 && y2 - y1 <= 0.05) {
            var newUnit = this.getUnitAtPosition(x1, y1);

            if (newUnit && newUnit.owner == PLAYING_PLAYER && (selectAll || (this.timeOfLastSelection + 500 >= timestamp && /* game.selectedUnits.length == 1 &&*/ newUnit == game.selectedUnits[0]))) {
              var unitsAndBuildings = this.units.concat(this.buildings);
              for (var i = 0; i < unitsAndBuildings.length; i++) {
                var u = unitsAndBuildings[i];
                if ((game_state == GAME.EDITOR || PLAYING_PLAYER.team.canSeeUnitInvisible(u) || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) && u.isInBox(game.cameraX / FIELD_SIZE, game.cameraY / FIELD_SIZE, (WIDTH + game.cameraX) / FIELD_SIZE, (HEIGHT - INTERFACE_HEIGHT + game.cameraY) / FIELD_SIZE) && u.type == newUnit.type && u.owner == PLAYING_PLAYER) {
                  units.push(u);
                }
              }

              return units;
            }

            return newUnit ? [newUnit] : [];
          }

          var countEnemyUnitsSelected = 0; // also buildings
          var countOwnUnitsSelected = 0; // also buildings
          var countOwnBildingsSelected = 0;
          var unitsAndBuildings = this.units.concat(this.buildings);
          var selected_type_id_strings = {};

          for (var i = 0; i < unitsAndBuildings.length; i++) {
            var u = unitsAndBuildings[i];
            if ((game_state == GAME.EDITOR || PLAYING_PLAYER.team.canSeeUnitInvisible(u) || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) && u.isInBox(x1, y1 + u.type.selectionOffsetY, x2, y2 + u.type.selectionOffsetY)) {
              if (selectAll) {
                selected_type_id_strings[u.type.id_string] = true;
              } else {
                units.push(u);
                countEnemyUnitsSelected += u.owner != PLAYING_PLAYER ? 1 : 0;
                countOwnUnitsSelected += u.owner == PLAYING_PLAYER ? 1 : 0;
                countOwnBildingsSelected += (u.owner == PLAYING_PLAYER && u.type.isBuilding) ? 1 : 0;
              }
            }
          }

          if (selectAll) {
            for (var i = 0; i < unitsAndBuildings.length; i++) {
              var u = unitsAndBuildings[i];
              if (selected_type_id_strings[u.type.id_string] && ((game_state == GAME.EDITOR || PLAYING_PLAYER.team.canSeeUnitInvisible(u) || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) && u.isInBox(game.cameraX / FIELD_SIZE, game.cameraY / FIELD_SIZE, (WIDTH + game.cameraX) / FIELD_SIZE, (HEIGHT - INTERFACE_HEIGHT + game.cameraY) / FIELD_SIZE) && u.owner == PLAYING_PLAYER)) {
                units.push(u);
                countEnemyUnitsSelected += u.owner != PLAYING_PLAYER ? 1 : 0;
                countOwnUnitsSelected += u.owner == PLAYING_PLAYER ? 1 : 0;
                countOwnBildingsSelected += (u.owner == PLAYING_PLAYER && u.type.isBuilding) ? 1 : 0;
              }
            }
          }

          // if were in the editor, were allowed to select multiple enemy units and multiple whatever, so return here and dont perform the deselect stuff
          if (game_state == GAME.EDITOR || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) {
            return units;
          }

          // if own and enemy units selected, unselect all enemy units
          if (countOwnUnitsSelected > 0 && countEnemyUnitsSelected > 0) {
            for (var i = 0; i < units.length; i++) {
              if (units[i].owner != PLAYING_PLAYER) {
                units.splice(i, 1);
                i--;
              }
            }
          }

          // if no own but more than 1 enemy units selected, unselect all but 1 enemy units
          if (countOwnUnitsSelected == 0 && countEnemyUnitsSelected > 0) {
            units = [units[0]];
          }

          // if only buildings selected, unselect all but 1
          if (units.length > 1 && countOwnBildingsSelected == units.length) {
            units.length = 1;
          }

          // if buildings but also units selected, unselect all buildings
          if (countOwnBildingsSelected > 0 && countOwnUnitsSelected - countOwnBildingsSelected > 0) {
            for (var i = 0; i < units.length; i++) {
              if (units[i].type.isBuilding) {
                units.splice(i, 1);
                i--;
              }
            }
          }

          return units;
        };

        // adding new units to an existing selection, removing duplicates and not allowing buildings & units or units from several players
        Game.prototype.addUnitsToSelection = function (selection, newUnits) {
          // if no new units, nothing to do
          if (newUnits.length == 0) {
            return;
          }

          // if no existing units, just replace selected units with the new units
          if (selection.length == 0) {
            selection = newUnits;
            return;
          }

          if (newUnits[0].owner == PLAYING_PLAYER && selection[0].owner == PLAYING_PLAYER && (selection[0].type.isBuilding && newUnits[0].type.isBuilding) || (!selection[0].type.isBuilding && !newUnits[0].type.isBuilding)) {
            var newUnitsContainUnselectedUnits = false;

            for (var i = 0; i < newUnits.length; i++) {
              if (!selection.contains(newUnits[i])) {
                newUnitsContainUnselectedUnits = true;
              }
            }

            for (var i = 0; i < newUnits.length; i++) {
              if (selection.contains(newUnits[i])) {
                if (!newUnitsContainUnselectedUnits) {
                  selection.erease(newUnits[i]);
                }
              } else {
                selection.push(newUnits[i]);
              }
            }
          }
        };

        // check if the current selected units belong to the playing player
        Game.prototype.humanUnitsSelected = function () {
          return this.selectedUnits.length > 0 && this.selectedUnits[0].owner == PLAYING_PLAYER;
        };

        Game.prototype.getGameStateCheckSum = function () {
          var checksum = 0;

          for (var i = 0; i < this.units.length; i++) {
            checksum += this.units[i].pos.px + this.units[i].pos.py;
          }

          return checksum;
        };

        Game.prototype.fieldIsBlocked = function (x, y) {
          return !(x > 0 && x <= this.x && y > 0 && y <= this.y && this.blockArray[x][y]);
        };

        Game.prototype.fieldIsBlockedForBuilding = function (x, y) {
          return !(x > 0 && x <= this.x && y > 0 && y <= this.y && this.blockArray[x][y] && this.fields[x][y].hm == parseInt(this.fields[x][y].hm));
        };

        Game.prototype.fieldIsBlockedFlying = function (x, y) {
          return !(x > 0 && x <= this.x && y > 2 && y <= this.y);
        };

        // get the center of a group of units
        Game.prototype.getCenterOfUnits = function (units) {
          var x = 0;
          var y = 0;

          for (var i = 0; i < units.length; i++) {
            x += units[i].pos.px;
            y += units[i].pos.py;
          }

          return new Field(x / units.length, y / units.length, true);
        };

        // return true, if at least one of the selected units can perform a specific order; only the units matching 'type' are checked
        Game.prototype.selectedUnitsCanPerformOrder = function (order, type) {
          // loop through all units, and check if one of the highest prio units can perform the order
          var units = this.selectedUnits;
          for (var i = 0; i < units.length; i++) {
            if (units[i].type == type) {
              if (units[i].type.commands[order.id_string] && (!units[i].type.isBuilding || !units[i].isUnderConstruction)) {
                return true;
              }

              if (order.type == COMMAND.CANCEL && units[i].type.isBuilding && (units[i].isUnderConstruction || units[i].queue[0])) {
                return true;
              }
            }
          }

          return false;
        };

        Game.prototype.playerHasIdleWorkers = function (player) {
          for (var i = 0; i < this.units.length; i++) {
            if (this.units[i].owner == player && this.units[i].type == lists.types.worker && (!this.units[i].order || this.units[i].order.type == COMMAND.IDLE)) {
              return true;
            }
          }
          return false;
        };

        Game.prototype.getOrderArray = function (units, order, target, shift, autoCast, on, learn) {
          // make array with target and order
          var o;

          if (learn) {
            o = ['learn', order.id];
          } else if (autoCast) {
            o = ['ac', order.id, on];
          } else if (!target) {
            o = ['instant', order.id, shift];
          } else if (target.isField) {
            o = ['field', order.id, shift, target.px, target.py];
          } else if (order.targetIsInt) {
            o = ['int', order.id, shift, parseInt(target)];
          } else {
            o = ['unit', order.id, shift, target.id];
          }

          // add all the selected units
          for (var i = 0; i < units.length; i++) {
            o.push(units[i].id);
          }

          return o;
        };

        Game.prototype.getUnitsWithRdyCooldown = function (units, cmd) {
          // Negation specifically used instead of <= to account for case where addends are NaN
          return units.filter((u) =>
            !(u.lastTickAbilityUsed[cmd.id] + cmd.getValue('cooldown2', u) > ticksCounter));
        };

        // store an order
        Game.prototype.issueOrderToUnits = function (units, order, target, shift, autoCast, on, learn) {
          if (!units || units.length == 0) {
            return;
          }

          if (learn) {
            if (network_game) {
              outgoingOrders.push(this.getOrderArray(units, order, target, shift, autoCast, on, true));
            } else {
              worker.postMessage({
                what: 'order',
                msg: [units[0].owner.number].concat(this.getOrderArray(units, order, target, shift, autoCast, on, true)),
              });
            }

            return;
          }

          // check for cooldown
          if (order.cooldown2) {
            units = this.getUnitsWithRdyCooldown(units, order);
          }

          if (units.length == 0) {
            interface_.addMessage('Cooldown not ready', 'red', imgs.attentionmark);
            soundManager.playSound(SOUND.NEGATIVE);
            return;
          }

          // if attacking invincible unit (Goldmine) and drawing and playingplayer, create msg and sound
          if (order.type == COMMAND.ATTACK && target.getValue('isInvincible')) {
            // if drawing, show alert
            if (units[0].owner == PLAYING_PLAYER) {
              interface_.addMessage('This ' + (target.type.isBuilding ? 'building' : 'unit') + ' is invincible.', 'red', imgs.attentionmark);
              soundManager.playSound(SOUND.NEGATIVE);
            }

            return;
          }

          // check for target requirements
          var requirement_text = !autoCast ? units[0].owner.getCommandRequirementText(order, units, target) : null;

          if (requirement_text) {
            // if drawing, show alert
            if (units[0].owner == PLAYING_PLAYER) {
              interface_.addMessage(requirement_text, 'red', imgs.attentionmark);
              soundManager.playSound(SOUND.NEGATIVE);
            }

            return;
          }

          if (network_game) {
            outgoingOrders.push(this.getOrderArray(units, order, target, shift, autoCast, on));
          } else {
            worker.postMessage({
              what: 'order',
              msg: [units[0].owner.number].concat(this.getOrderArray(units, order, target, shift, autoCast, on)),
            });
          }
        };

        Game.prototype.getReplayName = function () {
          var str = '';

          for (var i = 0; i < this.players.length; i++) {
            if (this.players[i] && this.players[i].originalTeam.number > 0) {
              str += this.players[i].name + '_v_';
            }
          }

          if (str.length > 2) {
            str = str.substring(0, str.length - 2);
          }

          str += 'on_' + this.data.name;

          return str;
        };

        Game.prototype.selectionContainsCargoUnits = function () {
          for (var i = 0; i < this.selectedUnits.length; i++) {
            if (this.selectedUnits[i].type.cargoSpace) {
              return true;
            }
          }
          return false;
        };

        Game.prototype.selectionContainsWorkers = function () {
          for (var i = 0; i < this.selectedUnits.length; i++) {
            if (this.selectedUnits[i].type == lists.types.worker) {
              return true;
            }
          }
          return false;
        };

        Game.prototype.addObject = function (o) {
          if (o.type && o.type.isUnit) {
            this.units.push(o);
          } else if (o.type && o.type.isBuilding && !o.isDummy) {
            this.buildings.push(o);
            this.buildings2.push(o);
          }

          if (!o.isDummy) {
            this.unitList[o.id] = o;
          }

          this.addToObjectsToDraw(o);
        };

        Game.prototype.addToObjectsToDraw = function (o) {
          for (var i = 0; i < this.objectsToDraw.length; i++) {
            if (this.objectsToDraw[i].getYDrawingOffset() > o.getYDrawingOffset()) {
              this.objectsToDraw.splice(i, 0, o);
              return;
            }
          }
          this.objectsToDraw.push(o);
        };

        Game.prototype.cacheCameraUpdate = function () {
          if (PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) {
            return;
          }

          outgoingCameraUpdate = {
            x: this.cameraX,
            y: this.cameraY,
            width: WIDTH,
            height: HEIGHT,
            fieldSize: FIELD_SIZE,
          };
        };

        Game.prototype.setCameraX = function (x) {
          this.cameraX = x;

          // if camera is out of bounds, bring it back
          this.cameraX = Math.floor(Math.min(this.cameraX, this.x * FIELD_SIZE - WIDTH));
          this.cameraX = Math.floor(Math.max(this.cameraX, 0));

          this.cacheCameraUpdate();
        };

        Game.prototype.setCameraY = function (y) {
          this.cameraY = y;

          // if camera is out of bounds, bring it back
          this.cameraY = Math.floor(Math.min(this.cameraY, (this.y - this.getHMValue(1, this.y) * CLIFF_HEIGHT) * FIELD_SIZE - HEIGHT + (game_state == GAME.EDITOR ? MINIMAP_HEIGHT : INTERFACE_HEIGHT)));
          this.cameraY = Math.floor(Math.max(this.cameraY, /* -FIELD_SIZE * 2*/ 0));

          this.cacheCameraUpdate();
        };

        Game.prototype.draw = function () {
          // limit the max zoom, users can archive with their browser zoom
          var maxViewSize = 1200 / 2;

          if (HEIGHT / SCALE_FACTOR > maxViewSize) {
            var middle_x = (game.cameraX + WIDTH / 2) / FIELD_SIZE;
            var middle_y = (game.cameraY + HEIGHT / 2) / FIELD_SIZE;

            setScaleFactor(HEIGHT / maxViewSize);
            FIELD_SIZE = 16 * SCALE_FACTOR;

            this.setCameraX(middle_x * FIELD_SIZE - WIDTH / 2);
            this.setCameraY(middle_y * FIELD_SIZE - HEIGHT / 2);
          }

          // limit the max zoom, users can archive with their browser zoom
          if (HEIGHT > 1200) {
            var max_scale = HEIGHT / maxViewSize;

            if (SCALE_FACTOR < max_scale) {
              setScaleFactor(max_scale);
              FIELD_SIZE = 16 * SCALE_FACTOR;
            }
          }

          // mute chat
          if (keyManager.keys[KEY.M] && this.lastMuteToggle + 10 <= ticksCounter) {
            this.enableChat(!this.chat_muted);
            this.lastMuteToggle = ticksCounter;
          }

          // Cameras for all players
          if (PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) {
            if (incomingCameraUpdates[ticksCounter]) {
              // Camera updates has format {player_nr: {x, y, width, height}, ...}
              for (const player_nr in incomingCameraUpdates[ticksCounter]) {
                const update = incomingCameraUpdates[ticksCounter][player_nr];
                this.players[player_nr].cameraX = update.x;
                this.players[player_nr].cameraY = update.y;
                this.players[player_nr].cameraWidth = update.width;
                this.players[player_nr].cameraHeight = update.height;
                this.players[player_nr].fieldSize = update.fieldSize;
              }
            }
          }

          var oldCameraX = this.cameraX;
          var oldCameraY = this.cameraY;

          // Scrolling
          if (this.followVision && this.visionSetting > 0) {
            const player = this.players[this.visionSetting];
            const targetX = player.cameraX + player.cameraWidth / 2 - WIDTH / 2;
            const targetY = player.cameraY + player.cameraHeight / 2 - HEIGHT / 2;
            FIELD_SIZE = player.fieldSize;
            this.setCameraX(targetX);
            this.setCameraY(targetY);
          } else if (!game_paused || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) {
            const mouseScrollEnabled = timeDiff < 1000 && (
              document.fullScreen ||
              document.mozFullScreen ||
              document.webkitIsFullScreen ||
              interface_.mouseScrollWhenWindowed.get()
            );

            const scrollSpeed = interface_.scrollSpeed.get();
            if (keyManager.keys[KEY.DOWN] || keyManager.y >= HEIGHT - SCROLL_RANGE && mouseScrollEnabled) {
              this.setCameraY(this.cameraY + timeDiff * scrollSpeed / 1000);
            } else if (keyManager.keys[KEY.UP] || keyManager.y <= 25 && mouseScrollEnabled) {
              this.setCameraY(this.cameraY - timeDiff * scrollSpeed / 1000);
            }

            if (keyManager.keys[KEY.LEFT] || keyManager.x <= SCROLL_RANGE && mouseScrollEnabled) {
              this.setCameraX(this.cameraX - timeDiff * scrollSpeed / 1000);
            } else if (keyManager.keys[KEY.RIGHT] || keyManager.x >= WIDTH - SCROLL_RANGE && mouseScrollEnabled) {
              this.setCameraX(this.cameraX + timeDiff * scrollSpeed / 1000);
            }

            // Minimap click change screen
            if (keyManager.minimapScroll && keyManager.x < MINIMAP_WIDTH && keyManager.y > HEIGHT - MINIMAP_HEIGHT) {
              var field = this.minimap.getFieldFromClick(keyManager.x, keyManager.y);

              this.setCameraX(Math.floor(field.px * FIELD_SIZE - WIDTH / 2));
              this.setCameraY(Math.floor(field.py * FIELD_SIZE - HEIGHT / 2));
            }

            // clicking portrait scrolling (following unit)
            var unitNfoX = (WIDTH - 780) / 2;
            if (this.selectedUnits.length == 1 && (keyManager.leftMouse && keyManager.x > unitNfoX && keyManager.y > HEIGHT - INTERFACE_HEIGHT + 20 && keyManager.x < unitNfoX + 140)) {
              this.setCameraX(this.selectedUnits[0].drawPos.px * FIELD_SIZE - WIDTH / 2);
              this.setCameraY(this.selectedUnits[0].drawPos.py * FIELD_SIZE - HEIGHT / 2);
            }

            if (keyManager.keys[KEY.SPACE] && this.selectedUnits.length > 0) {
              var location = this.getCenterOfUnits(this.selectedUnits);
              this.setCameraX(location.px * FIELD_SIZE - WIDTH / 2);
              this.setCameraY(location.py * FIELD_SIZE - HEIGHT / 2);
            }
          }

          if (keyManager.drawBox && (oldCameraX != this.cameraX || oldCameraY != this.cameraY)) {
            keyManager.startX -= this.cameraX - oldCameraX;
            keyManager.startY -= this.cameraY - oldCameraY;
          }

          // unselected units
          if (game_state == GAME.PLAYING) {
            for (var i = 0; i < this.selectedUnits.length; i++) {
              if (!PLAYING_PLAYER.team.canSeeUnit(this.selectedUnits[i], true) || (!(PLAYING_PLAYER.team.canSeeUnitInvisible(this.selectedUnits[i]) || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR))) {
                this.selectedUnits.splice(i, 1);
                i--;
              }
            }
          }

          var unitsBuildings = this.buildings2.concat(this.units);

          var hoverUnit = null;

          // clear screen
          c.fillStyle = 'black';
          c.fillRect(0, 0, WIDTH, HEIGHT);

          // draw GroundTiles canvas
          var drawW = Math.min(WIDTH, this.groundTilesCanvas.width * SCALE_FACTOR);
          var drawH = Math.min(HEIGHT - (game_state == GAME.EDITOR ? MINIMAP_HEIGHT : INTERFACE_HEIGHT), this.groundTilesCanvas.height * SCALE_FACTOR);
          c.drawImage(this.groundTilesCanvas, this.cameraX / SCALE_FACTOR, (this.cameraY + 2 * FIELD_SIZE) / SCALE_FACTOR, drawW / SCALE_FACTOR, drawH / SCALE_FACTOR, 0, 0, drawW, drawH);

          // calculate gameplay screen coords
          var x1 = this.cameraX / FIELD_SIZE;
          var y1 = this.cameraY / FIELD_SIZE;
          var x2 = (this.cameraX + WIDTH) / FIELD_SIZE;
          var y2 = (this.cameraY + HEIGHT) / FIELD_SIZE;

          // editor grid
          if (game_state == GAME.EDITOR && $('#showGridCheckbox')[0].checked) {
            c.lineWidth = 1;
            c.strokeStyle = 'rgba(' + this.theme.line_red + ', ' + this.theme.line_green + ', ' + this.theme.line_blue + ', 0.7)';
            c.beginPath();

            var y_ = Math.ceil(y1) * FIELD_SIZE - this.cameraY + 0.5;

            while (y_ < HEIGHT - INTERFACE_HEIGHT) {
              c.moveTo(0, y_);
              c.lineTo(WIDTH, y_);

              y_ += FIELD_SIZE;
            }

            var x_ = Math.ceil(x1) * FIELD_SIZE - this.cameraX + 0.5;

            while (x_ < WIDTH) {
              c.moveTo(x_, 0);
              c.lineTo(x_, HEIGHT - INTERFACE_HEIGHT);

              x_ += FIELD_SIZE;
            }

            c.stroke();
            c.closePath();

            // make middle lines red
            if (this.x / 2 > x1 && this.x / 2 < x2 && this.x % 2 == 0) {
              var x2_ = (this.x / 2) * FIELD_SIZE - this.cameraX + 0.5;

              c.strokeStyle = 'rgba(255, 0, 0, 0.9)';
              c.beginPath();
              c.moveTo(x2_, 0);
              c.lineTo(x2_, HEIGHT - INTERFACE_HEIGHT);
              c.stroke();
              c.closePath();
            }

            // make middle lines red
            if (this.y / 2 > y1 && this.y / 2 < y2 && this.y % 2 == 0) {
              var y2_ = (this.y / 2) * FIELD_SIZE - this.cameraY + 0.5;

              c.strokeStyle = 'rgba(255, 0, 0, 0.9)';
              c.beginPath();
              c.moveTo(0, y2_);
              c.lineTo(WIDTH, y2_);
              c.stroke();
              c.closePath();
            }
          }

          // calculate exact drawing positions (interpolate between real positions)
          for (var i = 0; i < this.units.length; i++) {
            this.units[i].updateDrawPosition();
          }

          // mark selected units
          for (var i = 0; i < this.selectedUnits.length; i++) {
            this.selectedUnits[i].lastSelectionTime = timestamp;
          }

          // mark hover units
          if (keyManager.drawBox) {
            var x1n = (Math.min(keyManager.x, keyManager.startX) + this.cameraX) / FIELD_SIZE;
            var x2n = (Math.max(keyManager.x, keyManager.startX) + this.cameraX) / FIELD_SIZE;
            var y1n = (Math.min(keyManager.y, keyManager.startY) + this.cameraY) / FIELD_SIZE;
            var y2n = (Math.max(keyManager.y, keyManager.startY) + this.cameraY) / FIELD_SIZE;

            for (var i = 0; i < unitsBuildings.length; i++) {
              var u = unitsBuildings[i];

              if (u.isAlive && u.isInBox(x1n, y1n + u.type.selectionOffsetY, x2n, y2n + u.type.selectionOffsetY) && PLAYING_PLAYER.team.canSeeUnit(u, true) && (PLAYING_PLAYER.team.canSeeUnitInvisible(u) || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR)) {
                u.lastHoverTime = timestamp;
              }
            }
          }

          // mark curser hovering unit
          else if (!keyManager.command || keyManager.command.targetIsUnit) {
            hoverUnit = this.getUnitAtPosition((keyManager.x + this.cameraX) / FIELD_SIZE, (keyManager.y + this.cameraY) / FIELD_SIZE);
            hoverUnit = (hoverUnit && PLAYING_PLAYER.team.canSeeUnit(hoverUnit, true)) ? hoverUnit : null;

            if (hoverUnit && (PLAYING_PLAYER.team.canSeeUnitInvisible(hoverUnit) || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR)) {
              hoverUnit.lastHoverTime = timestamp;
            }
          }


          // selection circcles of tiles (if editor)
          if (game_state == GAME.EDITOR) {
            for (var i = 0; i < this.selectedUnits.length; i++) {
              if (this.selectedUnits[i].type.isTile) {
                drawCircle(this.selectedUnits[i].drawPos.px * FIELD_SIZE - this.cameraX, (this.selectedUnits[i].drawPos.py + this.selectedUnits[i].getValue('circleOffset')) * FIELD_SIZE - this.cameraY, this.selectedUnits[i].getValue('circleSize') * FIELD_SIZE, this.selectedUnits[i].owner.getAllyColor());
              }
            }
          }

          // draw all objects
          var objectsToDraw = this.objectsToDraw.slice();
          for (var i = 0; i < objectsToDraw.length; i++) {
            var u = objectsToDraw[i];

            if (u.isInBoxVisible(x1, y1, x2, y2)) {
              // selection circles or blinking circles
              if (u.lastSelectionTime == timestamp && u.isThrowedUntil < ticksCounter) {
                drawCircle(u.drawPos.px * FIELD_SIZE - this.cameraX, (u.drawPos.py + u.getValue('circleOffset')) * FIELD_SIZE - this.cameraY, u.getValue('circleSize') * FIELD_SIZE, u.owner.getAllyColor());
              }

              // hover circles
              if (u.isThrowedUntil < ticksCounter && ((u.lastBlinkStart && u.lastBlinkStart + 1000 > timestamp && (timestamp - u.lastBlinkStart) % 200 < 100) || (u.lastHoverTime == timestamp && (!u.lastBlinkStart || u.lastBlinkStart + 1000 <= timestamp)))) {
                drawCircle(u.drawPos.px * FIELD_SIZE - this.cameraX, (u.drawPos.py + u.getValue('circleOffset')) * FIELD_SIZE - this.cameraY, u.getValue('circleSize') * FIELD_SIZE, u.owner.getAllyColor(), u.owner.getAllyColor(0.4));
              }

              u.draw(x1, x2, y1, y2);
            }

            if (u.isEffect && u.isExpired()) {
              this.objectsToDraw.erease(u);
            }
          }

          // draw health bars
          for (var i = 0; i < unitsBuildings.length; i++) {
            var unit = unitsBuildings[i];

            if (PLAYING_PLAYER.team.canSeeUnit(unit, true) && (PLAYING_PLAYER.team.canSeeUnitInvisible(unit) || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) && unit.isAlive && unit.isInBoxVisible(x1, y1, x2, y2)) {
              var x = (unit.drawPos.px - unit.type.healthbarWidth / 2) * FIELD_SIZE - game.cameraX;
              var y = (unit.drawPos.py - unit.type.healthbarOffset) * FIELD_SIZE - game.cameraY;

              if (!unit.type.isInvincible && (interface_.showFullHPBars.get() || unit.hp < unit.getValue('hp'))) {
                unit.drawHealthbar(x, y, unit.type.healthbarWidth * FIELD_SIZE, 0.125 * FIELD_SIZE, SCALE_FACTOR / 2);
                y -= FIELD_SIZE * 0.16;
              }

              if (unit.type.mana) {
                unit.drawManabar(x, y, unit.type.healthbarWidth * FIELD_SIZE, 0.125 * FIELD_SIZE, SCALE_FACTOR / 2);
                y -= FIELD_SIZE * 0.16;
              }

              if (unit.type.lifetime) {
                unit.drawLifetimebar(x, y, unit.type.healthbarWidth * FIELD_SIZE, 0.125 * FIELD_SIZE, SCALE_FACTOR / 2);
                y -= FIELD_SIZE * 0.16;
              }

              if (unit.owner == PLAYING_PLAYER && unit.cargo && unit.cargo.length > 0) {
                unit.drawLoadbar(x, y, unit.type.healthbarWidth * FIELD_SIZE, 0.125 * FIELD_SIZE, SCALE_FACTOR / 2);
                y -= FIELD_SIZE * 0.16;
              }

              if ((unit.owner == PLAYING_PLAYER || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) && unit.queue[0]) {
                unit.drawProgressBar(x, y, unit.type.healthbarWidth * FIELD_SIZE, 0.125 * FIELD_SIZE, SCALE_FACTOR / 2);
              }
            }

            // draw workload
            if (unit.gold && unit.type.startGold && unit.countWorkingWorkers > 0) {
              var workload = unit.getWorkload();

              drawText(c, 'Workload', 'white', 'bold ' + (SCALE_FACTOR * 6) + 'px LCDSolid', unit.drawPos.px * FIELD_SIZE - this.cameraX, (unit.drawPos.py - unit.type.healthbarOffset * 0.3) * FIELD_SIZE - this.cameraY, 999, 'center', null, 'rgba(0, 0, 0, 0.5)', null, (SCALE_FACTOR * 6));
              drawText(c, workload + ' %', 'white', 'bold ' + (SCALE_FACTOR * 6) + 'px LCDSolid', unit.drawPos.px * FIELD_SIZE - this.cameraX, (unit.drawPos.py - unit.type.healthbarOffset * 0.1) * FIELD_SIZE - this.cameraY, 999, 'center', null, 'rgba(0, 0, 0, 0.5)', null, (SCALE_FACTOR * 6));

              c.strokeStyle = 'white';
              c.fillStyle = 'white';
              c.strokeRect(unit.drawPos.px * FIELD_SIZE - this.cameraX - FIELD_SIZE * 1.1, (unit.drawPos.py + unit.type.healthbarOffset * 0.0) * FIELD_SIZE - this.cameraY, FIELD_SIZE * 2.2, FIELD_SIZE * 0.3);
              c.fillRect(unit.drawPos.px * FIELD_SIZE - this.cameraX - FIELD_SIZE * 1.05, (unit.drawPos.py + unit.type.healthbarOffset * 0.0 + 0.05) * FIELD_SIZE - this.cameraY, FIELD_SIZE * 2.1 * (workload / 100), FIELD_SIZE * 0.2);
            }
          }

          // draw waypoints
          if (this.humanUnitsSelected() || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR || game_state == GAME.EDITOR) {
            c.lineWidth = 2;

            for (var i = 0; i < this.selectedUnits.length; i++) {
              var unit = this.selectedUnits[i];

              if (unit.waypoint && (unit.type.isBuilding || unit.queue[0])) {
                for (var k = 0; k < unit.waypoint.length; k++) {
                  c.strokeStyle = 'rgba(' + this.theme.line_red + ', ' + this.theme.line_green + ', ' + this.theme.line_blue + ', ' + (1 - ((timestamp / 1000) % 0.8) * 0.8) + ')';

                  var point0 = (k > 0 ? (unit.waypoint[k - 1].pos ? unit.waypoint[k - 1].pos : unit.waypoint[k - 1]) : unit.pos);
                  point0 = point0.add3(0, -this.getHMValue3(point0) * CLIFF_HEIGHT);

                  var point = unit.waypoint[k].pos ? unit.waypoint[k].pos : unit.waypoint[k];
                  point = point.add3(0, -this.getHMValue3(point) * CLIFF_HEIGHT);

                  c.beginPath();
                  c.moveTo(point0.px * FIELD_SIZE - game.cameraX, (point0.py + (k == 0 ? (unit.getValue('circleOffset') / 2) : -Y_OFFSET)) * FIELD_SIZE - game.cameraY);
                  c.lineTo(point.px * FIELD_SIZE - game.cameraX, (point.py - Y_OFFSET) * FIELD_SIZE - game.cameraY);
                  c.stroke();

                  // circle effect
                  if (k == (unit.waypoint.length - 1) && ticksCounter % 8 == 0 && unit.lastTickCircleEffect != ticksCounter) {
                    new GroundOrder({
                      from: point.add3(0, -Y_OFFSET),
                    });
                    unit.lastTickCircleEffect = ticksCounter;
                  }
                }
              }

              if (unit.targetsQueue && unit.targetsQueue.length > 0 && unit.targetUnit) {
                c.strokeStyle = 'rgba(164, 0, 0, ' + (1 - ((timestamp / 1000) % 0.8) * 0.8) + ')';

                var targetsArray = [unit.targetUnit.drawPos];
                for (var k = 0; k < unit.targetsQueue.length; k++) {
                  targetsArray.push(unit.targetsQueue[k].drawPos);
                }

                c.beginPath();
                c.moveTo(unit.drawPos.px * FIELD_SIZE - game.cameraX, (unit.drawPos.py + unit.getValue('circleOffset') / 2) * FIELD_SIZE - game.cameraY);
                for (var k = 0; k < targetsArray.length; k++) {
                  c.lineTo(targetsArray[k].px * FIELD_SIZE - game.cameraX, (targetsArray[k].py + Y_OFFSET) * FIELD_SIZE - game.cameraY);
                }
                c.stroke();
              }
            }
          }

          // queued paths
          if (this.humanUnitsSelected() && this.selectedUnits[0].type.isUnit) {
            c.strokeStyle = 'rgba(' + this.theme.line_red + ', ' + this.theme.line_green + ', ' + this.theme.line_blue + ', 0.5)';

            for (var i = 0; i < this.selectedUnits.length; i++) {
              if (this.selectedUnits[i].queueOrder && this.selectedUnits[i].queueOrder.length > 0) {
                var unit = this.selectedUnits[i];

                var targetsArray = [unit.drawPos];
                if (unit.hasPath()) {
                  targetsArray.push(unit.path.add3(0, -this.getHMValue3(unit.path) * CLIFF_HEIGHT));
                }

                for (var k = 0; k < unit.queueOrder.length; k++) {
                  var target = unit.queueTarget[k];

                  if (target && target.isField) {
                    targetsArray.push(target.add3(0, -this.getHMValue3(target) * CLIFF_HEIGHT));
                  }

                  if (target && target.pos) {
                    targetsArray.push(target.drawPos);
                  }
                }

                for (var k = 1; k < targetsArray.length; k++) {
                  c.beginPath();
                  c.moveTo(targetsArray[k - 1].px * FIELD_SIZE - game.cameraX, (targetsArray[k - 1].py) * FIELD_SIZE - game.cameraY);
                  c.lineTo(targetsArray[k].px * FIELD_SIZE - game.cameraX, (targetsArray[k].py) * FIELD_SIZE - game.cameraY);
                  c.stroke();
                }

                // circle effect
                if (ticksCounter % 8 == 0 && unit.lastTickCircleEffect != ticksCounter) {
                  new GroundOrder({
                    from: targetsArray[targetsArray.length - 1].add3(0, 0),
                  });
                  unit.lastTickCircleEffect = ticksCounter;
                }
              }
            }
          }

          // map pings
          for (var i = 0; i < this.minimap.mapPings.length; i++) {
            var ping = this.minimap.mapPings[i];

            var age = Date.now() - ping.time;

            if (age > 7000) // ping is too old, kill it
            {
              this.minimap.mapPings.splice(i, 1);
              i--;
            } else {
              var drawX = (ping.field.x - 0.5) * FIELD_SIZE - this.cameraX;
              var drawY = (ping.field.y - 0.5) * FIELD_SIZE - this.cameraY;

              c.strokeStyle = 'rgba(255, 255, 0, ' + (age < 6000 ? 0.9 : Math.max((7000 - age) / 1000, 0)) + ')';
              c.lineWidth = 1.5 * SCALE_FACTOR;


              var radius = FIELD_SIZE * 0.3 * Math.max(Math.sin(Math.PI * age / 250) + 1.5) / 2.5;
              var radius2 = FIELD_SIZE * 0.3 * Math.max(Math.sin(Math.PI * age / 250 + 3.14 / 2) + 1.5) / 2.5;

              c.beginPath();
              c.strokeRect(drawX - radius, drawY - radius, 2 * radius, 2 * radius);
              c.strokeRect(drawX - radius2, drawY - radius2, 2 * radius2, 2 * radius2);
              c.stroke();


              var angles = [0, 90, 180, 270];

              var sin = angles.map(function (s) {
                return Math.sin(s / 180 * Math.PI + age / 5000 * Math.PI * 3);
              });
              var cos = angles.map(function (s) {
                return Math.cos(s / 180 * Math.PI + age / 5000 * Math.PI * 3);
              });

              var xs = [FIELD_SIZE, FIELD_SIZE, FIELD_SIZE / 2];
              var ys = [-FIELD_SIZE / 3, FIELD_SIZE / 3, 0];

              for (var j = 0; j < 4; j++) {
                c.beginPath();

                c.moveTo(drawX + xs[0] * cos[j] - ys[0] * sin[j], drawY + ys[0] * cos[j] + xs[0] * sin[j]);
                c.lineTo(drawX + xs[1] * cos[j] - ys[1] * sin[j], drawY + ys[1] * cos[j] + xs[1] * sin[j]);
                c.lineTo(drawX + xs[2] * cos[j] - ys[2] * sin[j], drawY + ys[2] * cos[j] + xs[2] * sin[j]);

                c.closePath();
                c.stroke();
              }
            }
          }

          if (game_state == GAME.PLAYING) {
            this.env.draw();
            this.rain.draw();
          }

          // draw fog
          c.drawImage(game_state == GAME.PLAYING ? this.minimap.screenCanvas : this.minimap.editorCanvas, this.cameraX / SCALE_FACTOR, this.cameraY / SCALE_FACTOR, drawW / SCALE_FACTOR, drawH / SCALE_FACTOR, 0, 0, drawW, drawH);

          // if cursor is hovering a unit, draw the units owners name (if not playing player)
          if (hoverUnit && ((hoverUnit.owner != PLAYING_PLAYER && hoverUnit.owner.number > 0) || (hoverUnit.type.hoverText && hoverUnit.type.hoverText.length > 0))) {
            var y = hoverUnit.drawPos.py * FIELD_SIZE - this.cameraY;
            y += hoverUnit.type.isUnit ? FIELD_SIZE : ((hoverUnit.type.sizeY / 2 + 0.7) * FIELD_SIZE);

            var text = (hoverUnit.type.hoverText && hoverUnit.type.hoverText.length > 0) ? hoverUnit.type.hoverText : hoverUnit.owner.name;

            if (game_state == GAME.EDITOR) {
              text = hoverUnit.type.name + ' (x: ' + (parseInt(hoverUnit.pos.px * 100) / 100) + ', y: ' + (parseInt(hoverUnit.pos.py * 100) / 100) + ')';
            }

            drawText(c, text, 'white', 'bold ' + (4 * 6) + 'px LCDSolid', hoverUnit.drawPos.px * FIELD_SIZE - this.cameraX, y, 300, 'center', 1, 'rgba(0, 0, 0, 0.5)', null, (4 * 6));
          }

          // if game paused, draw black screen with opac
          if (game_paused) {
            c.fillStyle = 'rgba(0, 0, 0, 0.5)';
            c.fillRect(0, 0, WIDTH, HEIGHT);
          }

          // print path
          if (path2Print) {
            for (var i = 1; i < path2Print.length; i++) {
              c.beginPath();
              c.moveTo(path2Print[i - 1].px * FIELD_SIZE - game.cameraX, (path2Print[i - 1].py) * FIELD_SIZE - game.cameraY);
              c.lineTo(path2Print[i].px * FIELD_SIZE - game.cameraX, (path2Print[i].py) * FIELD_SIZE - game.cameraY);
              c.stroke();
            }
          }

          /*
          for(var x = parseInt(x1); x < x2; x++)
            for(var y = parseInt(y1); y < y2; y++)
            {
              drawText(c, x + ":" + y, "white", 12, (x - x1) * FIELD_SIZE, (y - y1) * FIELD_SIZE);
              drawText(c, "hm: " + this.fields[x][y].hm, "white", 12, (x - x1) * FIELD_SIZE, (y - y1) * FIELD_SIZE + 16);
              drawText(c, "hm2: " + this.fields[x][y].hm2, "white", 12, (x - x1) * FIELD_SIZE, (y - y1) * FIELD_SIZE + 32);
              drawText(c, "hm4: " + this.fields[x][y].hm4, "white", 12, (x - x1) * FIELD_SIZE, (y - y1) * FIELD_SIZE + 48);
            }
          */

          // draw minimap
          this.minimap.draw();
        };


        // pos has influence on the volume; if a pos is given, the distance from the screen to pos is checked, and the volume is lower, the higher the distance is
        Game.prototype.getVolumeModifier = function (pos) {
          var volume = 1;

          var left = game.cameraX / FIELD_SIZE;
          var top = game.cameraY / FIELD_SIZE;
          var right = (game.cameraX + WIDTH) / FIELD_SIZE;
          var bottom = (game.cameraY + HEIGHT - INTERFACE_HEIGHT) / FIELD_SIZE;

          var distX = 0;
          if (pos.px < left || pos.px > right) {
            distX = Math.min(Math.abs(pos.px - left), Math.abs(pos.px - right));
          }

          var distY = 0;
          if (pos.py < top || pos.py > bottom) {
            distY = Math.min(Math.abs(pos.py - top), Math.abs(pos.py - bottom));
          }

          var dist = Math.sqrt(distX * distX + distY * distY);

          if (dist > 0) {
            volume = 1 - dist / 5;
          }

          // make sounds a little bit lower, when zoomed out
          volume *= Math.min(SCALE_FACTOR / 15 + 0.6, 1);

          return volume;
        };

        //IDLEWORKERINDEX is shared between interface and keymanager
        IDLEWORKERINDEX = 0;
        // input manager, manages all the inputs
        // TODO: rename this to InputManager to better reflect what it does
        function KeyManager() {
          this.reset();

          // Register hotkeys that the KeyManager is responsible for
          this.interfaceHotkeys = new HotkeyGroup('Interface Hotkeys')
            .addChild(new HotkeySetting('Queue actions', KEY.SHIFT, 'queue'))
            .addChild(new HotkeySetting('Select all idle workers', KEY.PERIOD, 'selectallidle'))
            .addChild(new HotkeySetting('Select and go to next idle worker', KEY.COMMA, 'selectnextidle'))
            .addChild(new HotkeySetting('Select all idle army units', KEY.SEMICOLON, 'selectallidlearmy'))
            .addChild(new HotkeySetting('Select all army units', KEY.QUOTE, 'selectallarmy'))
            .addChild(new HotkeySetting('Select all units of matching type', KEY.CTRL, 'selectall'))
            .addChild(new HotkeySetting('Add / remove units from selection', KEY.SHIFT, 'toggleselection'))
            .addChild(new HotkeySetting('Toggle chat between all and allies', KEY.SHIFT, 'togglechat'))
            .addChild(new HotkeySetting('Zoom in', KEY.O, 'zoomin'))
            .addChild(new HotkeySetting('Zoom out', KEY.L, 'zoomout'))
            .addChild(new HotkeySetting('Map ping', KEY.K, 'ping'));
          Hotkeys.registerHotkeyGroup(this.interfaceHotkeys, true);

          this.controlGroupHotkeys = new HotkeyGroup('Control Groups', false, 'Set with [set] + [key], add units with [add] + [key], and select with [key]');
          this.controlGroupHotkeys.addChild(new HotkeySetting('Set control group modifier [set]', KEY.CTRL, 'set'));
          this.controlGroupHotkeys.addChild(new HotkeySetting('Add to control group modifier [add]', KEY.SHIFT, 'add'));
          this.controlGroupHotkeys.addChild(new HotkeySetting('Create control group and take away units modifier [set]', KEY.ALT, 'removeandcreate'));
          this.controlGroupHotkeys.addChild(new HotkeySetting('Add to control group and take away units modifier [add]', KEY.CAPSLOCK, 'removeandadd'));
          for (let i = 1; i <= 10; i++) {
            const key = i == 10 ? 0 : i;
            this.controlGroupHotkeys.addChild(new HotkeySetting(`CTRL Group ${i}`, KEY[`NUM${key}`]).setData('num', i));
          }
          for (let i = 11; i <= 20; i++) {
            const key = i - 11;
            this.controlGroupHotkeys.addChild(new HotkeySetting(`CTRL Group ${i}`, KEY[`NUMPAD${key}`]).setData('num', i));
          }
          Hotkeys.registerHotkeyGroup(this.controlGroupHotkeys);

          this.cameraHotkeys = new HotkeyGroup('Camera Locations', false, 'Set with [set] + [key], and move to location with [key]');
          this.cameraHotkeys.addChild(new HotkeySetting('Set camera location modifier [set]', KEY.CTRL, 'set'));
          for (let i = 1; i <= 6; i++) {
            this.cameraHotkeys.addChild(new HotkeySetting(`Camera Location ${i}`, KEY[`F${i}`]).setData('num', i));
          }
          Hotkeys.registerHotkeyGroup(this.cameraHotkeys);

          // Register relevant configuration values
          this.mmScrollInvert = LocalConfig.registerValue('mm_scroll_invert', false);
        };

        KeyManager.prototype.reset = function () {
          this.keys = new Array(300); // stores which keys are pressed atm (for active button effect) (index = asci code, true for button is pressed)
          this.drawBox = false; // use to check if selection box has to be drawn
          this.leftMouse = false; // is leftmouse is pressed down atm, for button pressed graphic effect
          this.middleMouse = false; // if true, activate map scrolling
          this.minimapScroll = false; // if clicking in the minimap, set this true as long as leftmouse is true
          this.timeOfLastKeyPressed = 0; // to check for double press
          this.lastKeyPressed = 0;
          this.commandCardWhenPressStart = 0;

          this.cursor = Cursors.DEFAULT;
          this.setCursor(this.cursor);
          this.x = 0; // x mouse pos
          this.y = 0; // y mouse pos
          this.startX = 0; // when box is drawn, store start X
          this.startY = 0; // when box is drawn, store start Y
          this.command = null; // active command

          this.controlGroups = new Array(11);
          this.cameraLocations = new Array(11);
          for (let i = 0; i < this.controlGroups.length; i++) {
            this.controlGroups[i] = [];
          }

          this.listeners = {};
        };

        KeyManager.prototype.draw = function () {
          if (this.drawBox && (game_state != GAME.EDITOR || !editor.dragging)) // Leftmouse is pressed, so we draw a box
          {
            c.fillStyle = 'rgba(150, 190, 255, 0.4)';
            c.fillRect(this.x, this.y, this.startX - this.x, this.startY - this.y);
            c.strokeStyle = 'rgba(0, 50, 133, 0.8)';
            c.strokeRect(this.x, this.y, this.startX - this.x, this.startY - this.y);
          }

          // Aoe cursor
          if (this.command && this.command.useAoeCursor && game.selectedUnits[0]) {
            var radius = this.command.getValue('aoeRadius', game.selectedUnits[0]) * FIELD_SIZE;
            drawCircle(this.x, this.y, radius, null, 'rgba(' + game.theme.line_red + ', ' + game.theme.line_green + ', ' + game.theme.line_blue + ', 0.4)', 0.8);
          }

          // call editor click function every frame (as if we would click all the time, because editor can draw multiple stuff, when mouse is clicked)
          if (game_state == GAME.EDITOR && this.leftMouse) {
            editor.click(this.x, this.y, false, 1);
          }
        };

        // Registers a key listener under a non-unique ID
        KeyManager.prototype.registerListener = function (key, id, listener) {
          if (!this.listeners[key]) {
            this.listeners[key] = {};
          }
          this.listeners[key][id] = listener;
        };

        // Removes all listeners with the provided ID
        KeyManager.prototype.removeListener = function (id) {
          for (const key in this.listeners) {
            delete this.listeners[key]?.[id];
          }
        };

        KeyManager.prototype.callListeners = function (key) {
          if (this.listeners[key]) {
            for (let id in this.listeners[key]) {
              this.listeners[key][id]();
            }
          }
        };

        KeyManager.prototype.interfaceHotkeyPressed = function (name) {
          return this.keys[this.interfaceHotkeys.getHotkeyValue(name)];
        };

        KeyManager.prototype.changeUnitSelection = function (oldType) {
          if ((game.selectedUnits[0] && game.selectedUnits[0].type == oldType) || game_state != GAME.PLAYING) {
            return;
          }

          if (oldType && oldType.clickSound) {
            while (soundManager.buildingClickSound.length > 1) {
              soundManager.buildingClickSound[0].sound.pause();
              soundManager.buildingClickSound[0].sound.volume = 0;
              soundManager.buildingClickSound[0].sound.currentTime = 0;
              soundManager.buildingClickSound.splice(0, 1);
            }

            if (soundManager.buildingClickSound[0]) {
              soundManager.buildingClickSound[0].fadeOut = true;
              setTimeout(soundFaceOut, 1);
            }
          }

          if (game.selectedUnits[0] && game.selectedUnits[0].owner == PLAYING_PLAYER && game.selectedUnits[0].type.clickSound) {
            soundManager.playSound(
              game.selectedUnits[0].isUnderConstruction ? SOUND.BUILD : game.selectedUnits[0].type.clickSound,
              0.5,
              game.selectedUnits[0].isUnderConstruction ? 0.5 : game.selectedUnits[0].type.clickSoundVolume,
              true,
            );
          }
        };

        // replace the cursor with tho normal one
        KeyManager.prototype.resetCommand = function () {
          this.command = null;
          this.setCursor(Cursors.DEFAULT);
        };

        KeyManager.prototype.setCursor = function (cursor) {
          // TODO: might want to store this in interface
          this.cursor = cursor;
          document.body.style.cursor = `url(${CursorFiles[this.cursor]}), auto`;
        };

        KeyManager.prototype.getCursor = function () {
          return this.cursor;
        };

        // a command is started
        KeyManager.prototype.order = function (cmd, learn) {
          if (learn) {
            game.issueOrderToUnits(game.selectedUnits, cmd, null, this.interfaceHotkeyPressed('queue'), false, null, true);
            return;
          }

          if (!this.interfaceHotkeyPressed('queue')) {
            this.resetCommand();
          }

          if (cmd.type == COMMAND.SWITCH_CC) {
            interface_.commandCard = cmd.targetCC;
          }

          // instant order: execute them
          else if (cmd.isInstant) {
            game.issueOrderToUnits(game.selectedUnits, cmd, null, this.interfaceHotkeyPressed('queue'));
          } else if (game.selectedUnitsCanPerformOrder(cmd, interface_.unitTypeWithCurrentTabPrio)) {
            if (cmd.cursor && cmd.cursor in CursorFiles) {
              this.setCursor(cmd.cursor);
            }

            if (cmd.type == COMMAND.MAKEBUILDING && PLAYING_PLAYER.gold < cmd.unitType.getValue('cost', PLAYING_PLAYER)) {
              interface_.addMessage('not enough gold (' + Math.ceil(cmd.unitType.getValue('cost', PLAYING_PLAYER) - PLAYING_PLAYER.gold) + ' missing)', 'red', imgs.attentionmark);
              soundManager.playSound(SOUND.NEGATIVE);
            } else if (cmd.type == COMMAND.MAKEBUILDING && cmd.unitType.supply && cmd.unitType.supply > PLAYING_PLAYER.maxSupply - PLAYING_PLAYER.supply) {
              interface_.addMessage('not enough supply', 'red', imgs.attentionmark);
              soundManager.playSound(SOUND.NEGATIVE);
            } else {
              this.command = cmd;
            }
          }
        };

        KeyManager.prototype.getKeyCode = function (e) {
          return e.which || e.keyCode;
        };

        // create object
        var keyManager = new KeyManager();

        document.onkeyup = function (e) {
          keyManager.keys[keyManager.getKeyCode(e)] = false;
          return false;
        };

        document.onkeydown = function (e) {
          if (!e.repeat) {
            keyManager.commandCardWhenPressStart = interface_.commandCard;
          }

          var key = keyManager.getKeyCode(e);

          if (key == KEY.F8) {
            toggleFullscreen(document.documentElement);
          }

          // if theres ui windows open, return because no delegation to the game
          if (document.activeElement && ((document.activeElement.nodeName == 'INPUT' && document.activeElement.type == 'text') || document.activeElement.nodeName == 'TEXTAREA') && document.activeElement.style.visibility != 'hidden' && document.activeElement.offsetParent !== null) {
            return true;
          }

          keyManager.callListeners(key);
          uimanager.onKey(key);

          // if were not ingame, return, because no delegation to the game
          if (game_state != GAME.PLAYING && game_state != GAME.EDITOR) {
            return true;
          }

          keyManager.keys[key] = true;

          // zoom via keys
          if ((game_state == GAME.PLAYING || game_state == GAME.EDITOR) && key == keyManager.interfaceHotkeys.getHotkeyValue('zoomin')) {
            zoom(120);
          }

          if ((game_state == GAME.PLAYING || game_state == GAME.EDITOR) && key == keyManager.interfaceHotkeys.getHotkeyValue('zoomout')) {
            zoom(-120);
          }

          if (game_state == GAME.EDITOR) {
            editor.keyPressed(key);
            return false;
          }

          // map ping
          if (game_state == GAME.PLAYING && key == keyManager.interfaceHotkeys.getHotkeyValue('ping')) {
            var f = null;

            if (keyManager.x < MINIMAP_WIDTH && keyManager.y > HEIGHT - MINIMAP_HEIGHT) // if click in minimap
            {
              f = game.minimap.getFieldFromClick(keyManager.x, keyManager.y);
            } else if (keyManager.y < HEIGHT - INTERFACE_HEIGHT) // if click in main screen map
            {
              f = game.getFieldFromPos();
            }

            if (f) {
              if (network_game) {
                network.send('map-ping<<$' + f.x + '<<$' + f.y);
              } else if (game.minimap.mapPings.length < 3) {
                game.minimap.mapPings.push({ field: f, time: Date.now() });
                soundManager.playSound(SOUND.BING2);
              }
            }
          }

          // open ingame chat input and set all/allies dropdown
          if (game_state == GAME.PLAYING && key == KEY.ENTER && !uimanager.ingameInput.active) {
            uimanager.ingameInput.active = true;

            // check, if playing player has allies
            var playingPlayerHasAllies = false;
            for (var i = 1; i < game.players.length; i++) {
              if (game.players[i] && game.players[i] != PLAYING_PLAYER && !game.players[i].isEnemyOfPlayer(PLAYING_PLAYER) && game.players[i].controller != CONTROLLER.SPECTATOR && game.players[i].isAlive) {
                playingPlayerHasAllies = true;
              }
            }

            // if is spectator, then always send to all
            if (PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) {
              playingPlayerHasAllies = false;
            }

            // if shift pressed, set the opposite
            var setDropdown = keyManager.interfaceHotkeyPressed('togglechat') ? !playingPlayerHasAllies : playingPlayerHasAllies;

            $('#ingameChatDropdown')[0].selectedIndex = setDropdown ? 1 : 0;
          }

          // tell interface, a key has been pressed
          if (interface_ && keyManager.commandCardWhenPressStart == interface_.commandCard) {
            interface_.keyPressed(key);
          }

          // pause
          if (key == KEY.PAUSE && game_state == GAME.PLAYING) {
            pauseGame();
            if (game_paused) {
              $('#replayPlayButton').text('||').css({ 'font-size': '10px' });
            } else {
              $('#replayPlayButton').text('>').css({ 'font-size': '' });
            }
          }

          // if idle worker hotkey stuff
          if (game_state == GAME.PLAYING && game.playerHasIdleWorkers(PLAYING_PLAYER)) {
            if (key == keyManager.interfaceHotkeys.getHotkeyValue('selectallidle')) {
              var workers = [];
              for (var i = 0; i < game.units.length; i++) {
                if (game.units[i].owner == PLAYING_PLAYER && game.units[i].type == lists.types.worker && game.units[i].order && game.units[i].order.type == COMMAND.IDLE) {
                  workers.push(game.units[i]);
                }
              }
              if (workers.length > 0) {
                game.selectedUnits = workers;
              }
            }
            else if (key == keyManager.interfaceHotkeys.getHotkeyValue('selectnextidle')) {
              var workers = [];
              for (var i = 0; i < game.units.length; i++) {
                if (game.units[i].owner == PLAYING_PLAYER && game.units[i].type == lists.types.worker && game.units[i].order && game.units[i].order.type == COMMAND.IDLE) {
                  workers.push(game.units[i]);
                }
              }
              if (workers.length > 0) {
                IDLEWORKERINDEX = (IDLEWORKERINDEX + 1) % workers.length;
                var worker = workers[IDLEWORKERINDEX];
                game.selectedUnits = [worker];
                game.setCameraX(worker.pos.px * FIELD_SIZE - WIDTH / 2);
                game.setCameraY(worker.pos.py * FIELD_SIZE - HEIGHT / 2);
              }
            }
          }

          // if select all army hotkey stuff
          if (game_state == GAME.PLAYING && key == keyManager.interfaceHotkeys.getHotkeyValue('selectallarmy')) {
            var armyunits = [];
            for (var i = 0; i < game.units.length; i++) {
              if (game.units[i].owner == PLAYING_PLAYER && game.units[i].type != lists.types.worker && !game.units[i].type.isBuilding) {
                armyunits.push(game.units[i]);
              }
            }
            if (armyunits.length > 0) {
              game.selectedUnits = armyunits;
            }
          }

          if (game_state == GAME.PLAYING && key == keyManager.interfaceHotkeys.getHotkeyValue('selectallidlearmy')) {
            var idlearmyunits = [];
            for (var i = 0; i < game.units.length; i++) {
              if (game.units[i].owner == PLAYING_PLAYER && game.units[i].type != lists.types.worker && !game.units[i].type.isBuilding && game.units[i].order && game.units[i].order.type == COMMAND.IDLE) {
                idlearmyunits.push(game.units[i]);
              }
            }
            if (idlearmyunits.length > 0) {
              game.selectedUnits = idlearmyunits;
            }
          }

          // if camera location hotkey stuff
          let cameraHotkey = 0;
          keyManager.cameraHotkeys.forEach((hotkey, i) => {
            if (key == hotkey.value) {
              cameraHotkey = hotkey.getData('num');
            }
          });

          if (game_state == GAME.PLAYING && cameraHotkey > 0) {
            const nr = cameraHotkey;

            if (nr < keyManager.cameraLocations.length) {
              // if modifier key pressed, set camera location
              if (keyManager.keys[keyManager.cameraHotkeys.getHotkeyValue('set')]) {
                keyManager.cameraLocations[nr] = new Field((game.cameraX + WIDTH / 2) / FIELD_SIZE, (game.cameraY + HEIGHT / 2) / FIELD_SIZE, true);
              }

              // else, go to camera location
              else if (keyManager.cameraLocations[nr]) {
                game.setCameraX(keyManager.cameraLocations[nr].px * FIELD_SIZE - WIDTH / 2);
                game.setCameraY(keyManager.cameraLocations[nr].py * FIELD_SIZE - HEIGHT / 2);
              }
            }
          }

          // if ctrl group stuff
          let ctrlGroupKey = 0;
          keyManager.controlGroupHotkeys.forEach((hotkey, i) => {
            if (key == hotkey.value) {
              ctrlGroupKey = hotkey.getData('num');
            }
          });

          if (game_state == GAME.PLAYING && ctrlGroupKey > 0) {
            const nr = ctrlGroupKey;

            // create new ctrl grp
            if (keyManager.keys[keyManager.controlGroupHotkeys.getHotkeyValue('set')] && game.humanUnitsSelected()) {
              keyManager.controlGroups[nr] = game.selectedUnits;
            }

            // add units to ctrl grp
            else if (keyManager.keys[keyManager.controlGroupHotkeys.getHotkeyValue('add')] && game.humanUnitsSelected()) {
              for (var i = 0; i < game.selectedUnits.length; i++) {
                var contains = false;
                for (var k = 0; k < keyManager.controlGroups[nr].length; k++) {
                  if (game.selectedUnits[i] == keyManager.controlGroups[nr][k]) {
                    contains = true;
                  }
                }

                if (!contains && game.selectedUnits[i].owner == PLAYING_PLAYER && (keyManager.controlGroups[nr].length == 0 || keyManager.controlGroups[nr][0].type.isBuilding == game.selectedUnits[i].type.isBuilding)) {
                  keyManager.controlGroups[nr].push(game.selectedUnits[i]);
                }
              }
            }

            // remove units from ctrl grps and create to ctrl grp
            else if (keyManager.keys[keyManager.controlGroupHotkeys.getHotkeyValue('removeandcreate')] && game.humanUnitsSelected()) {
              for (let i = 0; i < game.selectedUnits.length; i++) {
                if (game.selectedUnits[i].owner == PLAYING_PLAYER) {
                  for (let j = 1; j <= 10; j++) {
                    var unitsToRemove = [];
                    for (let k = 0; k < keyManager.controlGroups[j].length; k++) {
                      if (game.selectedUnits[i] == keyManager.controlGroups[j][k]) {
                        unitsToRemove.push(k)
                      }
                    }
                    for (const k of unitsToRemove) {
                      keyManager.controlGroups[j].splice(k, 1);
                    }
                  }
                }
              }
              keyManager.controlGroups[nr] = game.selectedUnits;
            }

            // remove units from ctrl grps and add to ctrl grp
            else if (keyManager.keys[keyManager.controlGroupHotkeys.getHotkeyValue('removeandadd')] && game.humanUnitsSelected()) {
              for (let i = 0; i < game.selectedUnits.length; i++) {
                if (game.selectedUnits[i].owner == PLAYING_PLAYER && (keyManager.controlGroups[nr].length == 0 || keyManager.controlGroups[nr][0].type.isBuilding == game.selectedUnits[i].type.isBuilding)) {
                  var contains = false;
                  for (let j = 1; j <= 10; j++) {
                    var unitsToRemove = [];
                    for (let k = 0; k < keyManager.controlGroups[j].length; k++) {
                      if (game.selectedUnits[i] == keyManager.controlGroups[j][k]) {
                        if (j != nr) {
                          unitsToRemove.push(k)
                        }
                        else {
                          contains = true;
                        }
                      }
                    }
                    for (const k of unitsToRemove) {
                      keyManager.controlGroups[j].splice(k, 1);
                    }
                  }
                  if (!contains) {
                    keyManager.controlGroups[nr].push(game.selectedUnits[i]);
                  }
                }
              }
            }

            // select ctrl grp
            else if (keyManager.controlGroups[nr].length > 0) {
              var oldType = game.selectedUnits[0] ? game.selectedUnits[0].type : null;
              game.selectedUnits = keyManager.controlGroups[nr].slice();

              interface_.unitsTab = 0;

              keyManager.resetCommand();

              // deselct units, that are currently "not active" (= means, they are in buildings for example)
              for (var i = 0; i < game.selectedUnits.length; i++) {
                if (!game.selectedUnits[i].isActive) {
                  game.selectedUnits.splice(i, 1);
                  i--;
                }
              }

              interface_.commandCard = 0; // reset command card (in case we were in the building submenu)
              interface_.unitTypeWithCurrentTabPrio = null; // reset command card prio

              // if double pressed this ctrl grp, jump camera there
              if (keyManager.lastKeyPressed == key && keyManager.timeOfLastKeyPressed + 350 > timestamp && game.selectedUnits.length > 0) {
                var point = game.getCenterOfUnits(game.selectedUnits);

                var nextUnit = null;
                var closestDistance = 9999;
                for (var i = 0; i < game.selectedUnits.length; i++) {
                  var distance = point.distanceTo2(game.selectedUnits[i].pos);
                  if (distance < closestDistance) {
                    closestDistance = distance;
                    nextUnit = game.selectedUnits[i];
                  }
                }

                game.setCameraX(nextUnit.pos.px * FIELD_SIZE - WIDTH / 2);
                game.setCameraY(nextUnit.pos.py * FIELD_SIZE - HEIGHT / 2);
              }

              keyManager.changeUnitSelection(oldType);
            }
          }

          keyManager.timeOfLastKeyPressed = timestamp;
          keyManager.lastKeyPressed = key;

          return false;
        };

        // IE9, Chrome, Safari, Opera
        canvas.addEventListener('mousewheel', MouseWheelHandler, false);

        // Firefox
        canvas.addEventListener('DOMMouseScroll', MouseWheelHandler, false);

        function MouseWheelHandler(e) {
          // set zoom level
          if (game_state == GAME.PLAYING || game_state == GAME.EDITOR) {
            var e = window.event || e;
            zoom(e.wheelDelta || -e.detail);
          }
        };

        function zoom(direction) {
          // middle of camera
          var middle_x = (game.cameraX + WIDTH / 2) / FIELD_SIZE;
          var middle_y = (game.cameraY + HEIGHT / 2) / FIELD_SIZE;

          if (direction > 0) {
            setScaleFactor(SCALE_FACTOR + 1);
          } else {
            setScaleFactor(SCALE_FACTOR - 1);
          }

          FIELD_SIZE = 16 * SCALE_FACTOR;

          // adjust camera
          game.setCameraX(middle_x * FIELD_SIZE - WIDTH / 2);
          game.setCameraY(middle_y * FIELD_SIZE - HEIGHT / 2);
        }

        canvas.onmousedown = function (e) {
          if (game_paused && PLAYING_PLAYER.controller != CONTROLLER.SPECTATOR) {
            return;
          }

          // leftmouse
          if (keyManager.getKeyCode(e) == 1) {
            keyManager.leftMouse = true;
          }

          // if click in minimap
          if (keyManager.x < MINIMAP_WIDTH && keyManager.y > HEIGHT - MINIMAP_HEIGHT && (game_state == GAME.PLAYING || game_state == GAME.EDITOR)) {
            var clickedPos = game.minimap.getFieldFromClick(keyManager.x, keyManager.y);

            // leftmouse
            if (keyManager.getKeyCode(e) == 1) {
              // if no command is active, set minimap scroll enabled
              if (!keyManager.command) {
                keyManager.minimapScroll = true;
              }

              // if attack order has been issued
              else if (keyManager.command.type == COMMAND.ATTACK && game.humanUnitsSelected()) {
                game.issueOrderToUnits(game.selectedUnits, lists.types.amove, clickedPos, keyManager.interfaceHotkeyPressed('queue'));
                new GroundOrder({ from: clickedPos.add3(0, Y_OFFSET) });
                keyManager.resetCommand();
              }
            }

            // rightmouse & no command active, order move command
            else if (keyManager.getKeyCode(e) == 3 && !keyManager.command && game.humanUnitsSelected()) {
              game.issueOrderToUnits(game.selectedUnits, lists.types.move, clickedPos, keyManager.interfaceHotkeyPressed('queue'));
              new GroundOrder({ from: clickedPos.add3(0, Y_OFFSET) });
            }

            // return false;
            return;
          }

          // if editor, delegate there
          if (game_state == GAME.EDITOR) {
            editor.click(keyManager.x, keyManager.y, true, keyManager.getKeyCode(e));
          }

          // if left click in interface and hit something (returns true), return
          if (!keyManager.command && keyManager.getKeyCode(e) == 1 && game_state == GAME.PLAYING && interface_.leftClick(keyManager.x, keyManager.y)) {
            return;
          }

          // if right click in interface and hit something (returns true), return
          if (!keyManager.command && keyManager.getKeyCode(e) == 3 && game_state == GAME.PLAYING && interface_.rightClick(keyManager.x, keyManager.y)) {
            return;
          }

          // if click in screen map
          if ((keyManager.y < HEIGHT - INTERFACE_HEIGHT || keyManager.command) && (game_state == GAME.PLAYING || game_state == GAME.EDITOR)) {
            var field = game.getFieldFromPos();

            // activate map scrolling
            if (keyManager.getKeyCode(e) == 2) {
              keyManager.middleMouse = true;
            }

            // leftmouse
            else if (keyManager.getKeyCode(e) == 1) {
              // if no active command && if editor, then only when no button selected
              if ((game_state == GAME.PLAYING && !keyManager.command) || (game_state == GAME.EDITOR && !editor.selectedItemType && editor.terrainModifier == 0)) {
                keyManager.drawBox = true;
                keyManager.startX = keyManager.x;
                keyManager.startY = keyManager.y;
              }

              // attack order has been issued
              else if (keyManager.command && keyManager.command.type == COMMAND.ATTACK && game.humanUnitsSelected()) {
                var targetUnit = (interface_ && interface_.currentHoverUnit) ? interface_.currentHoverUnit : game.getUnitAtPosition((keyManager.x + game.cameraX) / FIELD_SIZE, (keyManager.y + game.cameraY) / FIELD_SIZE);

                // AMove
                if (!targetUnit || targetUnit.getValue('noShow')) {
                  game.issueOrderToUnits(game.selectedUnits, lists.types.amove, field.add3(0, -Y_OFFSET), keyManager.interfaceHotkeyPressed('queue'));
                  new GroundOrder({ from: new Field((keyManager.x + game.cameraX) / FIELD_SIZE, (keyManager.y + game.cameraY + 3) / FIELD_SIZE, true) });
                }

                // Attack specific unit order
                else {
                  game.issueOrderToUnits(game.selectedUnits, lists.types.attack, targetUnit, keyManager.interfaceHotkeyPressed('queue'));
                  targetUnit.blink();
                }

                keyManager.resetCommand();
              }

              // make building order has been issued
              else if (keyManager.command && keyManager.command.type == COMMAND.MAKEBUILDING && game.humanUnitsSelected()) {
                // get building type and field
                var building = keyManager.command.unitType;
                var field = building.getFieldFromMousePos();

                // if building has space, issue order
                if (building.couldBePlacedAt(field, true)) {
                  var cost = PLAYING_PLAYER.getCostOfNextInstanceForBuilding(building);

                  // player has enough gold to make building
                  if (PLAYING_PLAYER.gold >= cost) {
                    if (!building.supply || building.supply <= PLAYING_PLAYER.maxSupply - PLAYING_PLAYER.supply) {
                      game.issueOrderToUnits(game.selectedUnits, keyManager.command, field, keyManager.interfaceHotkeyPressed('queue'));

                      if (!keyManager.interfaceHotkeyPressed('queue')) {
                        keyManager.resetCommand();
                      }

                      soundManager.playSound(SOUND.PLACE);
                    } else {
                      interface_.addMessage('not enough supply', 'red', imgs.attentionmark);
                      soundManager.playSound(SOUND.NEGATIVE);
                    }
                  } else {
                    interface_.addMessage('not enough gold (' + Math.ceil(cost - PLAYING_PLAYER.gold) + ' missing)', 'red', imgs.attentionmark);
                    soundManager.playSound(SOUND.NEGATIVE);
                  }
                }

                // if no space for building at this position, display warning msg and play sound
                else {
                  interface_.addMessage('no space', 'red', imgs.attentionmark);
                  soundManager.playSound(SOUND.NEGATIVE);
                }
              }

              // if unload
              else if (keyManager.command && keyManager.command.type == COMMAND.UNLOAD && game.humanUnitsSelected()) {
                var targetUnit = (interface_ && interface_.currentHoverUnit) ? interface_.currentHoverUnit : game.getUnitAtPosition((keyManager.x + game.cameraX) / FIELD_SIZE, (keyManager.y + game.cameraY) / FIELD_SIZE);
                game.issueOrderToUnits(game.selectedUnits, keyManager.command, (targetUnit && game.selectedUnits.contains(targetUnit)) ? targetUnit : field, keyManager.interfaceHotkeyPressed('queue'));
                if (!targetUnit || !game.selectedUnits.contains(targetUnit)) {
                  new GroundOrder({ from: new Field((keyManager.x + game.cameraX) / FIELD_SIZE, (keyManager.y + game.cameraY + 3) / FIELD_SIZE, true) });
                }
                keyManager.resetCommand();
              }

              // if target is point
              else if (keyManager.command && (keyManager.command.targetIsPoint || keyManager.command.type == COMMAND.TELEPORT) && game.humanUnitsSelected()) {
                game.issueOrderToUnits(game.selectedUnits, keyManager.command, field, keyManager.interfaceHotkeyPressed('queue'));
                new GroundOrder({ from: new Field((keyManager.x + game.cameraX) / FIELD_SIZE, (keyManager.y + game.cameraY + 3) / FIELD_SIZE, true) });
                keyManager.resetCommand();
              } else if (keyManager.command && keyManager.command.targetIsUnit && game.humanUnitsSelected()) {
                var targetUnit = (interface_ && interface_.currentHoverUnit) ? interface_.currentHoverUnit : game.getUnitAtPosition((keyManager.x + game.cameraX) / FIELD_SIZE, (keyManager.y + game.cameraY) / FIELD_SIZE, keyManager.command.targetRequiremementsArray.length > 0 ? keyManager.command : null);

                if (targetUnit && targetUnit.getValue('noShow')) {
                  targetUnit = null;
                }

                if (targetUnit && keyManager.command.type == COMMAND.LOAD && targetUnit.owner != game.selectedUnits[0].owner) {
                  interface_.addMessage('can only target own units', 'red', imgs.attentionmark);
                  soundManager.playSound(SOUND.NEGATIVE);
                } else if (targetUnit) {
                  game.issueOrderToUnits(game.selectedUnits, keyManager.command, targetUnit, keyManager.interfaceHotkeyPressed('queue'));
                  targetUnit.blink();
                  keyManager.resetCommand();
                } else {
                  interface_.addMessage('must target unit', 'red', imgs.attentionmark);
                  soundManager.playSound(SOUND.NEGATIVE);
                }
              }
            }

            // rightmouse (and were ingame; rightmouse only works when ingame)
            if (keyManager.getKeyCode(e) == 3 && game_state == GAME.PLAYING) {
              e.preventDefault();
              e.stopPropagation();
              // if no command has been clicked -> move / attack / waypoint
              if (!keyManager.command && game && game.humanUnitsSelected()) {
                var targetUnit = game.getUnitAtPosition((keyManager.x + game.cameraX) / FIELD_SIZE, (keyManager.y + game.cameraY) / FIELD_SIZE);

                if (targetUnit && targetUnit.getValue('noShow')) {
                  targetUnit = null;
                }

                // if the unit is a gold mine
                if (targetUnit && targetUnit.owner.controller == CONTROLLER.NONE && targetUnit.type.isBuilding && targetUnit.type.startGold) {
                  game.issueOrderToUnits(game.selectedUnits, lists.types.moveto, targetUnit, keyManager.interfaceHotkeyPressed('queue'));
                  targetUnit.blink();
                }

                // if theres an enemy unit at this point, attack
                else if (targetUnit && targetUnit.owner.isEnemyOfPlayer(PLAYING_PLAYER)) {
                  game.issueOrderToUnits(game.selectedUnits, lists.types.attack, targetUnit, keyManager.interfaceHotkeyPressed('queue'));
                  targetUnit.blink();
                }

                // if theres a friendly or neutral unit, moveto or mine
                else if (targetUnit && !targetUnit.owner.isEnemyOfPlayer(PLAYING_PLAYER) && ((game.selectedUnits[0].type.isBuilding || targetUnit.type.isBuilding) || (game.selectionContainsCargoUnits() && targetUnit.type.cargoUse) || (targetUnit.type.isMechanical && game.selectionContainsWorkers()) || targetUnit.canLoad())) {
                  game.issueOrderToUnits(game.selectedUnits, lists.types.moveto, targetUnit, keyManager.interfaceHotkeyPressed('queue'));
                  targetUnit.blink();
                }

                // if theres no enemy unit => move / waypoint
                else {
                  game.issueOrderToUnits(game.selectedUnits, lists.types.move, field.add3(0, -Y_OFFSET), keyManager.interfaceHotkeyPressed('queue'));
                  new GroundOrder({ from: new Field((keyManager.x + game.cameraX) / FIELD_SIZE, (keyManager.y + game.cameraY + 3) / FIELD_SIZE, true) });
                }
              }
            }
          }

          // rightmouse
          if (keyManager.getKeyCode(e) == 3) {
            keyManager.resetCommand();
          }

          return false;
        };
        document.addEventListener('mousedown', function (e) {
          if (e.button == 2) {
            e.preventDefault();
          }
        }, false);
        // this prevents the context menu when shift right clicking (at least for some browsers)
        document.onclick = function (e) {
          var b = keyManager.getKeyCode(e);

          if ((b == 2 || b == 3) && (game_state == GAME.PLAYING || game_state == GAME.EDITOR)) {
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        };

        canvas.onmouseup = function (e) {
          if (keyManager.getKeyCode(e) == 1) // leftmouse
          {
            // if we were drawing a box
            if (keyManager.drawBox && ((game_state == GAME.PLAYING && !keyManager.command) || (game_state == GAME.EDITOR && !editor.dragging && !editor.selectedItemType && editor.terrainModifier == 0))) {
              var oldType = game.selectedUnits[0] ? game.selectedUnits[0].type : null;

              var x1 = (keyManager.x + game.cameraX) / FIELD_SIZE;
              var y1 = (keyManager.y + game.cameraY) / FIELD_SIZE;
              var x2 = (keyManager.startX + game.cameraX) / FIELD_SIZE;
              var y2 = (keyManager.startY + game.cameraY) / FIELD_SIZE;

              var x1n = Math.min(x1, x2);
              var x2n = Math.max(x1, x2);
              var y1n = Math.min(y1, y2);
              var y2n = Math.max(y1, y2);

              var units = game.getSelection(x1n, y1n, x2n, y2n, keyManager.interfaceHotkeyPressed('selectall'));

              // deselect units that we cant see
              for (var i = 0; i < units.length; i++) {
                if (!PLAYING_PLAYER.team.canSeeUnit(units[i], true)) {
                  units.splice(i, 1);
                  i--;
                }
              }

              // if were in editor and no units selected, check for selected tiles
              if (units.length == 0 && game_state == GAME.EDITOR) {
                for (var i = 0; i < game.blockingTiles.length; i++) {
                  if (game.blockingTiles[i].isInBox(x1n, y1n, x2n, y2n)) {
                    units.push(game.blockingTiles[i]);
                  }
                }

                // deselect cliffs
                for (var i = 0; i < units.length; i++) {
                  if (units[i].type.isCliff) {
                    units.splice(i, 1);
                    i--;
                  }
                }

                // if we still selected nothing, check if we selected ground tiles
                if (units.length == 0) {
                  for (var i = 0; i < game.groundTiles2.length; i++) {
                    if (!game.groundTiles2[i].type.isCliff && game.groundTiles2[i].isInBox(x1n, y1n, x2n, y2n)) {
                      units.push(game.groundTiles2[i]);
                    }
                  }
                }
              }

              // Add / remove units instead of replacing them
              if (keyManager.interfaceHotkeyPressed('toggleselection')) {
                game.addUnitsToSelection(game.selectedUnits, units);
              }

              // if we selected something, replace the old selection with the new one
              else if (units.length > 0) {
                game.selectedUnits = units;
                game.timeOfLastSelection = timestamp;
                interface_.commandCard = 0; // reset command card (in case we were in the building submenu)
                interface_.unitTypeWithCurrentTabPrio = null; // reset command card prio
                interface_.unitsTab = 0;
              }

              // if editor and something is selected, set player dropdown box to owning player
              if (game.selectedUnits.length > 0 && game_state == GAME.EDITOR) {
                $('#playerDropdown')[0].selectedIndex = game.selectedUnits[0].owner.number;
                editor.player = game.selectedUnits[0].owner.number;
              }

              // sort selected units
              game.selectedUnits = _.sortBy(game.selectedUnits, function (o) {
                return -o.type.tabPriority;
              });

              keyManager.changeUnitSelection(oldType);
            }

            keyManager.leftMouse = false;
            keyManager.drawBox = false;
            keyManager.minimapScroll = false;
          }

          // middleMouse
          else if (keyManager.getKeyCode(e) == 2) {
            keyManager.middleMouse = false;
          }

          return false;
        };

        // when mouse is moved, store position
        document.onmousemove = function (e) {
          // Calculate pageX/Y if missing and clientX/Y available
          if (e.pageX == null && e.clientX != null) {
            var doc = document.documentElement;
            var body = document.body;
            e.pageX = e.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
            e.pageY = e.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
          }

          const clamp = (val, min, max) => {
            return val < min ? min : (val > max ? max : val);
          };
          const isPointerLocked = interface_.isPointerLocked();
          let x = isPointerLocked ? clamp(keyManager.x + e.movementX, 0, WIDTH) : e.pageX;
          let y = isPointerLocked ? clamp(keyManager.y + e.movementY, 0, HEIGHT) : e.pageY;


          // if middlemouse is pressed, scroll
          if (keyManager.middleMouse && game && (!game_paused || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR)) {
            game.setCameraX(game.cameraX + (keyManager.x - x) * 1.5 * (keyManager.mmScrollInvert.get() ? -1 : 1));
            game.setCameraY(game.cameraY + (keyManager.y - y) * 1.5 * (keyManager.mmScrollInvert.get() ? -1 : 1));
          }

          keyManager.x = x;
          keyManager.y = y;

          // fix shift bug that sometimes happens (special thanks to pox)
          if (!e) {
            e = document.event;
          }

          if (!e.shiftKey) {
            keyManager.keys[KEY.SHIFT] = false;
          }
        };

        function Interface() {
          Initialization.onDocumentReady(() => this.init());

          this.messages = []; // active chat messages are stores here

          this.commandCard = 0; // command card 0 => normal commands; command card 1 => buildings, ...

          this.unitTypeWithCurrentTabPrio = null; // prio of the command card that is currently displayed (if more than 1 unit type is selected, only the cc of one unit type can be displayd, can be tabbed with tab key by user)

          // create all the command buttons
          this.buttons = [];

          // Preload all the cursor images for pointer lock
          this.fakeCursors = {};
          for (const key in CursorFiles) {
            const url = CursorFiles[key];
            const img = document.createElement('img');
            document.body.insertBefore(img, canvas);
            $(img).addClass('fakeCursor').hide();
            img.src = CursorFiles[key];
            this.fakeCursors[key] = img;
          }
          this.pointerLockEnabled = LocalConfig.registerValue('pointer_lock_enabled', false);

          // Key events are queued up in here every time draw() is called, and they
          // are checked at the end.
          //
          // Map from ("left", "right" or "hover") -> array of {x, y, w, h, callback}
          // which defines what happens when the region defined by (x, y, w, h) is
          // left clicked, right clicked, and hovered over respectively
          this.keyEvents = { 'left': [], 'right': [], 'hover': [] };

          this.currentHoverUnit = null;

          this.idleWorkersButtonIsActive = false;

          this.timeOflastGoldMsg = -9999;

          this.unitsTab = 0;

          this.showInfoDiv = false;

          // Register interface configuration values
          this.mouseScrollWhenWindowed = LocalConfig.registerValue('mouse_scroll_on', true);
          this.scrollSpeed = LocalConfig.registerValue('scroll_speed', 2000);
          this.showFullHPBars = LocalConfig.registerValue('show_full_hp_bars', true);
          this.noRain = LocalConfig.registerValue('no_rain', true);
          this.noGuestDM = LocalConfig.registerValue('no_guest_dms', false);
          this.lastChosenAI = LocalConfig.registerValue('last_ai_chosen', 'Default');

          // Register interface hotkeys
          // Must remain in sync with Game.specFieldNames
          const spectatorHotkeys = new HotkeyGroup('Spectator Hotkeys', true);

          this.specVisionHotkeys = new HotkeyGroup('Vision');
          this.specVisionHotkeys
            .addChild(new HotkeySetting('Toggle following player camera', KEY.BACKTICK, 'toggle_follow_camera'))
            .addChild(new HotkeySetting('Set vision all', KEY.NUM0, 0));
          for (let i = 0; i < MAX_PLAYERS; i++) {
            this.specVisionHotkeys.addChild(new HotkeySetting(`Set vision to player ${i + 1}`, KEY[`NUM${i + 1}`], i + 1));
          }

          this.specGeneralHotkeys = new HotkeyGroup('General')
            .addChild(new HotkeySetting('Units', KEY.Q))
            .addChild(new HotkeySetting('Buildings', KEY.W))
            .addChild(new HotkeySetting('Upgrades', KEY.E))
            .addChild(new HotkeySetting('Production', KEY.R))
            .addChild(new HotkeySetting('Income', KEY.T))
            .addChild(new HotkeySetting('APM', KEY.Z))
            .addChild(new HotkeySetting('Units lost', KEY.U));

          spectatorHotkeys.addChild(this.specGeneralHotkeys).addChild(this.specVisionHotkeys);
          Hotkeys.registerHotkeyGroup(spectatorHotkeys);
        };

        Interface.prototype.init = function () {
          const showSpectatorInterface = () =>
            game_state == GAME.PLAYING && PLAYING_PLAYER && PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR;

          const infoDiv = new UIElement('div', 'spectatorDiv', () => showSpectatorInterface() && this.showInfoDiv);
          const spectatorDropdowns = new UIElement('div', 'spectatorDropdowns', showSpectatorInterface);
          UIManagerSingleton.registerUIElement(infoDiv);
          UIManagerSingleton.registerUIElement(spectatorDropdowns);

          canvas.addEventListener('click', async () => {
            if (this.pointerLockEnabled.get()) {
              try {
                await canvas.requestPointerLock({ unadjustedMovement: true });
              } catch (e) {
                await canvas.requestPointerLock();
              }
            }
          });
        };

        Interface.prototype.isPointerLocked = function () {
          return document.pointerLockElement === canvas;
        };

        Interface.prototype.setPointerLockEnabled = function (enabled) {
          if (!enabled && this.isPointerLocked()) {
            document.exitPointerLock();
          }
          this.pointerLockEnabled.set(enabled);
        };

        // add a message
        Interface.prototype.addMessage = function (msg, font, img, whiteShadow) {
          if (msg.slice(0, 15) == 'not enough gold' || msg.slice(0, 15) == 'This spell need') {
            if (this.timeOflastGoldMsg + 3000 < timestamp) {
              this.timeOflastGoldMsg = timestamp;
            } else {
              return;
            }
          }

          this.messages.splice(0, 0, {
            msg: msg,
            font: font,
            img: img ? img.img : null,
            creationTime: timestamp,
            shadow: whiteShadow ? 'white' : 'black',
          });
        };

        // add a chat message
        Interface.prototype.chatMsg = function (msg, noSound) {
          var str = msg.split(': ');

          var color = 'white';
          var playerName = str[0].indexOf(' [') >= 0 ? (str[0].split(' ['))[0] : str[0];
          var str1 = /^\[.*\]/.test(str[1]) ? str[1].substr(str[1].indexOf('[') + 1) : str[1];
          for (var i = 0; i < game.players.length; i++) {
            if (game.players[i] && game.players[i].name == playerName && game.players[i].controller != CONTROLLER.SPECTATOR && playerColors[game.players[i].number - 1]) {
              color = game.players[i].number == 5 ? 'gray' : game.players[i].getColor();
            }
          }

          if (str1 === 'showfps' || str1 === '/showfps') {
            show_fps = !show_fps;
          } else if (str[1] == 'showunitdetails' && !network_game) {
            show_unit_details = !show_unit_details;
          }

          this.addMessage(msg, color, null, color == 'black');

          if (!noSound) {
            soundManager.playSound(SOUND.POSITIVE);
          }
        };

        Interface.prototype.checkKeyEvents = function (type) {
          let retval = false;
          for (e of this.keyEvents[type]) {
            if (keyManager.x >= e.x && keyManager.y >= e.y &&
              keyManager.x < e.x + e.w && keyManager.y < e.y + e.h) {
              e.callback();
              retval = true;
              break;
            }
          }
          // Clear the events to be replenished on the next iteration
          this.keyEvents[type] = [];
          return retval;
        };

        Interface.prototype.draw = function () {
          // chat msg width
          var width = Math.max(WIDTH - 500, 200);

          var offset = -1;

          // set font so we can measure the text correctly
          c.font = 'bold 24px LCDSolid';

          // messages
          for (var i = 0; i < this.messages.length; i++) {
            var msg = this.messages[i];

            var age = timestamp - msg.creationTime;

            // if more than 10 msges or time expired, kill msg
            if (i > 10 || age > 10000) {
              this.messages.splice(i, 1);
              i--;
            }

            // draw msg
            else {
              // measure text
              var textWidth = c.measureText(msg.msg).width;
              var predictedAmountOfLines = Math.ceil(textWidth / width);
              offset += predictedAmountOfLines * 28;

              // calculate alpha (if older than a )
              var alpha = age < 8000 ? 1 : Math.max(10000 - age, 0.001) / 2000;

              // if msg contains an icon, draw it
              if (msg.img) {
                c.globalAlpha = alpha;
                c.drawImage(miscSheet[0], msg.img.x, msg.img.y, msg.img.w, msg.img.h, 334 - msg.img.w * 2, HEIGHT - INTERFACE_HEIGHT - 70 - offset, msg.img.w * 2, msg.img.h * 2);
                c.globalAlpha = 1;
              }

              // draw text
              drawText(c, ' ' + msg.msg, msg.font, 'bold 24px LCDSolid', 300 + (msg.img ? msg.img.w * 2 + 6 : 0), HEIGHT - INTERFACE_HEIGHT - 40 - offset, width, 'left', alpha, 'rgba(0, 0, 0, 0.5)', msg.shadow, 24);
            }
          }

          if (game_state == GAME.PLAYING) {
            // draw background
            c.fillStyle = '#4E4A4E';
            c.fillRect(MINIMAP_WIDTH, HEIGHT - INTERFACE_HEIGHT, WIDTH - MINIMAP_WIDTH, INTERFACE_HEIGHT);
            c.lineWidth = 4;
            c.strokeStyle = '#757161';
            c.strokeRect(MINIMAP_WIDTH + 2, HEIGHT - INTERFACE_HEIGHT + 2, WIDTH - MINIMAP_WIDTH, INTERFACE_HEIGHT);

            // small black line below the top boarder
            c.lineWidth = 1;
            c.strokeStyle = 'rgba(0, 0, 0, 0.8)';
            c.beginPath();
            c.moveTo(MINIMAP_WIDTH + 4, HEIGHT - INTERFACE_HEIGHT + 4.5);
            c.lineTo(WIDTH, HEIGHT - INTERFACE_HEIGHT + 4.5);
            c.stroke();
          }

          var unitNfoX = (WIDTH - 780) / 2;

          this.currentHoverUnit = null;

          var unit0 = game.selectedUnits[0] ? game.selectedUnits[0] : null;

          // imgs
          if (game_state == GAME.PLAYING) {
            c.drawImage(miscSheet[0], imgs.interfaceRight.img.x, imgs.interfaceRight.img.y, imgs.interfaceRight.img.w, imgs.interfaceRight.img.h, WIDTH - 510, 0, imgs.interfaceRight.img.w * 2, imgs.interfaceRight.img.h * 2);
          }

          c.drawImage(miscSheet[0], imgs.interfaceLeft.img.x, imgs.interfaceLeft.img.y, imgs.interfaceLeft.img.w, imgs.interfaceLeft.img.h, -346, 0, imgs.interfaceRight.img.w * 2, imgs.interfaceRight.img.h * 2);

          if (game_state == GAME.PLAYING) {
            c.drawImage(miscSheet[0], imgs.interfaceButtonDiv.img.x, imgs.interfaceButtonDiv.img.y, imgs.interfaceButtonDiv.img.w, imgs.interfaceButtonDiv.img.h, WIDTH - 390, HEIGHT - 170, imgs.interfaceButtonDiv.img.w * 2, imgs.interfaceButtonDiv.img.h * 2);
          }

          c.drawImage(miscSheet[0], imgs.interfaceMapBorder.img.x, imgs.interfaceMapBorder.img.y, imgs.interfaceMapBorder.img.w, imgs.interfaceMapBorder.img.h, -16, HEIGHT - 200, imgs.interfaceMapBorder.img.w * 2, imgs.interfaceMapBorder.img.h * 2);

          if (game_state == GAME.PLAYING) {
            c.drawImage(miscSheet[0], imgs.interfaceUnitInfo.img.x, imgs.interfaceUnitInfo.img.y, imgs.interfaceUnitInfo.img.w, imgs.interfaceUnitInfo.img.h, unitNfoX, HEIGHT - 152, imgs.interfaceUnitInfo.img.w * 2, imgs.interfaceUnitInfo.img.h * 2);
          }


          var units = game.selectedUnits;

          // unit data / stats, if only 1 unit is selected
          if (units.length == 1) {
            var u = units[0];
            var isInvincible = u.getValue('isInvincible');

            this.drawUnitInfo(u);

            var countBars = (!isInvincible ? 1 : 0) + (u.type.mana ? 1 : 0) + (u.type.experienceLevels && u.type.experienceLevels.length > 0 ? 1 : 0);
            var x = countBars == 3 ? HEIGHT - 136 : HEIGHT - 130;
            var step = countBars == 3 ? 26 : 30;

            // hp bar (if not invincible)
            if (!isInvincible) {
              u.drawHealthbar(unitNfoX + 350 - 70, x, 180, 20);
              drawText(c, Math.floor(u.hp) + ' / ' + u.getValue('hp'), 'black', 'bold 16px LCDSolid', unitNfoX + 370, x + 16, 200, 'center', 1, null, 'white');
            }

            // mana bar (if has mana)
            if (u.type.mana) {
              x += step;
              u.drawManabar(unitNfoX + 350 - 70, x, 180, 20);
              drawText(c, Math.floor(u.mana) + ' / ' + u.getValue('mana'), 'black', 'bold 16px LCDSolid', unitNfoX + 370, x + 16, 200, 'center', 1, null, 'white');
            }

            // exp bar
            if (u.type.experienceLevels && u.type.experienceLevels.length > 0) {
              x += step;
              u.drawExpbar(unitNfoX + 350 - 70, x, 180, 20);
              drawText(c, 'Level ' + u.level + ' (' + Math.floor(Math.min(u.exp, u.type.experienceLevels[u.type.experienceLevels.length - 1])) + ' / ' + u.getXP4NextLevel() + ' exp)', 'black', 'bold 16px LCDSolid', unitNfoX + 370, x + 16, 200, 'center', 1, null, 'white');
            }

            const boxesStartPosX = unitNfoX + 188;
            const boxesPosY = HEIGHT - 94;
            const boxesWidth = 64;
            const boxesHeight = 64;
            const numberOfBoxes = 5;

            // buildings queue
            if ((game.humanUnitsSelected() || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) && u.queue[0]) {
              c.lineWidth = 2;
              c.strokeStyle = 'white';

              for (let i = 0; i < numberOfBoxes; i++) {
                const boxX = boxesStartPosX + i * 70;
                c.strokeRect(boxesStartPosX + i * 70, boxesPosY, boxesWidth, boxesHeight);

                if (u.queue[i]) {
                  var img = u.queue[i].getTitleImage(u.owner);
                  var scale = 64 / Math.max(img.w, img.h);
                  const x = boxesStartPosX + i * 70 + 32 - img.w * scale / 2;
                  const y = boxesPosY + 32 - img.h * scale / 2;
                  const w = img.w * scale;
                  const h = img.h * scale;
                  c.drawImage(img.file, img.x, img.y, img.w, img.h, x, y, w, h);

                  if (PLAYING_PLAYER &&
                    PLAYING_PLAYER.controller != CONTROLLER.SPECTATOR &&
                    u.owner == PLAYING_PLAYER) {
                    this.keyEvents['hover'].push({
                      x: boxX, y: boxesPosY, w: boxesWidth, h: boxesHeight,
                      callback: () => {
                        c.fillStyle = 'rgba(255, 255, 255, 0.5)';
                        c.fillRect(boxX, boxesPosY, boxesWidth, boxesHeight);
                      },
                    });
                    this.keyEvents['left'].push({
                      x: boxX, y: boxesPosY, w: boxesWidth, h: boxesHeight,
                      callback: () => {
                        game.issueOrderToUnits([u], lists.types.cancel, /* target=*/i + 1); // adding 1 because if sending 0, it gets converted to null somewhere, and therefore can't differenciate between cancelling first in queue by clicking or cancelling last in queue by default
                      },
                    });
                  }
                } else {
                  drawText(c, (i + 1).toString(), 'white', 'bold 38px LCDSolid', unitNfoX + 212 + i * 70, boxesPosY + 48);
                }
              }

              // building unit bar
              var progress = u.queueStarted ? u.currentBuildTime - (u.queueFinish - ticksCounter) : 0;
              var total = u.currentBuildTime;
              this.drawConstructionProgress(boxesStartPosX, boxesPosY + 72, 344, 14, progress / 20, total / 20);
            }

            // under construction
            else if (u.isUnderConstruction && (game.humanUnitsSelected() || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR)) {
              var dots = '';
              for (var i = 200; i < timestamp % 1000; i += 200) {
                dots += '.';
              }
              drawText(c, 'Constructing' + dots, 'white', 'bold 38px LCDSolid', unitNfoX + 190, HEIGHT - 56);

              var progress = u.type.getValue('buildTime', unit0.owner) - u.buildTicksLeft;
              var total = u.type.getValue('buildTime', unit0.owner);
              this.drawConstructionProgress(boxesStartPosX, boxesPosY + 54, 344, 14, progress / 20, total / 20);
            }

            // else if unit has cargo
            else if (u.cargo && u.cargo.length > 0 && (u.owner == PLAYING_PLAYER || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR)) {
              c.fillStyle = 'rgba(255, 255, 255, 0.2)';

              var spc = Math.min(u.type.cargoSpace, 10);
              c.fillRect(unitNfoX + 249, HEIGHT - 98, Math.ceil(spc / 2) * 47, spc == 1 ? 48 : 98);

              var sortedCargo = _.sortBy(u.cargo, function (e) {
                return -e.type.cargoUse;
              });

              c.strokeStyle = 'white';
              c.lineWidth = 2;
              c.fillStyle = 'rgba(255, 255, 255, 0.5)';

              var cargo = 0;

              for (var i = 0; i < sortedCargo.length && i < 10; i++) {
                var type = sortedCargo[i].type;

                if (cargo + type.cargoUse <= 10) {
                  var x = unitNfoX + 254 + Math.floor(cargo / 2) * 46;
                  var y = HEIGHT - 94 + (cargo % 2) * 46;
                  var w = Math.ceil((type.cargoUse - 0.5) / 2) * 40;
                  var h = type.cargoUse <= 1 ? 40 : 80;

                  c.strokeRect(x, y, w, h);
                  var img = type.getTitleImage(u.owner);
                  var scale = Math.max(w / img.w, h / img.h);
                  c.drawImage(img.file, img.x, img.y, img.w, img.h, x + w / 2 - img.w * scale / 2, y + h / 2 - img.h * scale / 2, img.w * scale, img.h * scale);

                  // hover
                  if (keyManager.x > x && keyManager.y > y && keyManager.x < x + w && keyManager.y < y + h) {
                    c.fillRect(x, y, w, h);
                  }

                  cargo += type.cargoUse;
                } else {
                  i = sortedCargo.length;
                }
              }
            }

            // display attributes
            else {
              // if damage not 0, display damage value and range
              if (u.type.dmg > 0 && !u.isUnderConstruction) {
                c.font = 'bold 20px LCDSolid';

                // dmg
                var bonusDamage = u.owner.getValueModifier('dmg', u.type) + (u.modifierMods['dmg'] ? u.modifierMods['dmg'] : 0);
                var basicText = 'Damage: ' + u.type.dmg;
                drawText(c, basicText, 'white', '16px LCDSolid', unitNfoX + 170, HEIGHT - 60);
                var pointer = unitNfoX + 170 + c.measureText(basicText).width + 6;

                if (bonusDamage) {
                  var text = ' (' + (bonusDamage > 0 ? '+' : '') + bonusDamage + ')';
                  drawText(c, text, bonusDamage > 0 ? '#34DA34' : '#FF0000', '16px LCDSolid', pointer, HEIGHT - 60);
                  pointer += c.measureText(text).width + 6;
                }

                var basicDmg = u.getValue('dmg');
                var modifiersObj = {};
                if (u.type.dmgModifierAttributes) {
                  for (var i = 0; i < u.type.dmgModifierAttributes.length; i++) {
                    var att = u.type.dmgModifierAttributes[i];

                    if (u.type.dmgModifierMultiplier && u.type.dmgModifierMultiplier[i]) {
                      modifiersObj[att] = modifiersObj[att] ? ((modifiersObj[att] + basicDmg) * (u.type.dmgModifierMultiplier[i] - 1)) : ((u.type.dmgModifierMultiplier[i] - 1) * basicDmg);
                    }

                    if (u.type.dmgModifierAddition && u.type.dmgModifierAddition[i]) {
                      modifiersObj[att] = modifiersObj[att] ? (modifiersObj[att] + u.type.dmgModifierAddition[i]) : u.type.dmgModifierAddition[i];
                    }
                  }
                }

                var modifierStr = '';
                _.each(modifiersObj, function (val, att) {
                  if (val) {
                    var text = ' (' + (val > 0 ? '+' : '') + val + ' vs ' + (att.startsWith('is') ? att.slice(2) : att) + ')';
                    drawText(c, text, val > 0 ? '#34DA34' : '#FF0000', '16px LCDSolid', pointer, HEIGHT - 60);
                    pointer += c.measureText(text).width + 8;
                  }
                });


                // attack speed
                var atkSpeed = (Math.round(u.getValue('weaponCooldown') / 20 * 100) / 100);
                drawText(c, 'Attack speed: ' + atkSpeed, 'white', '16px LCDSolid', unitNfoX + 170, HEIGHT - 42);

                // armor penetration
                if (u.type.armorPenetration > 0) {
                  var armorPenetrationText = 'Armor Penetration: ' + u.type.armorPenetration;
                  drawText(c, armorPenetrationText, 'white', '16px LCDSolid', unitNfoX + 170, HEIGHT - 24);
                }

                // range
                var bonusRange = u.owner.getValueModifier('range', u.type) + (u.modifierMods['range'] ? u.modifierMods['range'] : 0);
                basicText = 'Range: ' + (u.type.range > 1 ? u.type.range : 'Melee') + (u.type.minRange > 0 ? ' (min: ' + u.type.minRange + ')' : '');
                drawText(c, basicText, 'white', '16px LCDSolid', unitNfoX + 170, HEIGHT - 78);
                if (bonusRange) {
                  drawText(c, ' (' + (bonusRange > 0 ? '+' : '') + bonusRange + ')', bonusRange > 0 ? '#34DA34' : '#FF0000', '16px LCDSolid', unitNfoX + 170 + c.measureText(basicText).width + 6, HEIGHT - 78);
                }

                // kills
                drawText(c, 'Kills: ' + u.kills, 'white', '16px LCDSolid', unitNfoX + 170, HEIGHT - 6);

                // dmg hover
                if (keyManager.x > unitNfoX + 170 && keyManager.y > HEIGHT - 76 && keyManager.x < unitNfoX + 280 && keyManager.y < HEIGHT - 60) {
                  this.drawHoverBox();
                  drawText(c, 'This is the damage this unit deals everytime it hits another unit.', 'white', '18px LCDSolid', WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310, null, null, null, null, 18);
                }

                // range hover
                if (keyManager.x > unitNfoX + 170 && keyManager.y > HEIGHT - 94 && keyManager.x < unitNfoX + 280 && keyManager.y < HEIGHT - 78) {
                  this.drawHoverBox();
                  drawText(c, 'This is the range this unit can shoot.', 'white', '18px LCDSolid', WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310, null, null, null, null, 18);
                }

                // attack speed hover
                if (keyManager.x > unitNfoX + 170 && keyManager.y > HEIGHT - 58 && keyManager.x < unitNfoX + 280 && keyManager.y < HEIGHT - 42) {
                  this.drawHoverBox();
                  drawText(c, 'This unit attacks once every ' + atkSpeed + ' seconds.', 'white', '18px LCDSolid', WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310, null, null, null, null, 18);
                }

                // armor penetration hover
                if (keyManager.x > unitNfoX + 170 && keyManager.y > HEIGHT - 40 && keyManager.x < unitNfoX + 280 && keyManager.y < HEIGHT - 24) {
                  if (u.type.armorPenetration > 0) {
                    this.drawHoverBox();
                    drawText(c, 'This unit ignores up to ' + u.type.armorPenetration + ' armor when attacking.', 'white', '18px LCDSolid', WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310, null, null, null, null, 18);
                  }
                }
              }

              // stati
              var stati = '';

              if (u.type.flying) {
                stati += 'flying, ';
              }

              if (u.type.isBiological) {
                stati += 'biological, ';
              }

              if (u.type.isMechanical) {
                stati += 'mechanical, ';
              }

              if (u.getValue('hasDetection')) {
                stati += 'detection, ';
              }

              if (u.type.isUndead) {
                stati += 'undead, ';
              }

              drawText(c, stati.slice(0, stati.length - 2), 'white', '16px LCDSolid', unitNfoX + 340, HEIGHT - 24);

              // modifiers
              if (u.modifiers.length > 0) {
                var k = 0;
                for (var i = 0; i < u.modifiers.length && k < 5; i++) {
                  if (u.modifiers[i].modifier.image) {
                    var img = u.modifiers[i].modifier.getTitleImage();
                    c.drawImage(img.file, img.x, img.y, img.w, img.h, unitNfoX + 554, HEIGHT - INTERFACE_HEIGHT + 37 + k * 22, 20, 20);

                    // hover
                    if (keyManager.x > unitNfoX + 554 && keyManager.y > HEIGHT - INTERFACE_HEIGHT + 37 + k * 22 && keyManager.x < unitNfoX + 554 + 20 && keyManager.y < HEIGHT - INTERFACE_HEIGHT + 37 + k * 22 + 20) {
                      this.drawHoverBox();

                      var duration = (u.modifiers[i].removeAt && u.modifiers[i].removeAt > ticksCounter) ? (Math.ceil((u.modifiers[i].removeAt - ticksCounter) / 20) + ' sec left') : null;

                      drawText(c, u.modifiers[i].modifier.name, 'yellow', '22px LCDSolid', WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310);

                      if (duration) {
                        drawText(c, duration, 'grey', '16px LCDSolid', WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 248, 310);
                      }

                      var str = interpreteString(u.modifiers[i].modifier.description, u).split('#BR');
                      for (var j = 0; j < str.length; j++) {
                        drawText(c, str[j], 'white', '18px LCDSolid', WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 246 + (duration ? 28 : 0) + j * 22, 310, null, null, null, null, 18);
                      }
                    }

                    k++;
                  }
                }
              }

              // if has gold (= is Mine), display remaining gold amount
              if (u.type.startGold) {
                drawText(c, 'Gold remaining: ' + u.gold, u.gold ? 'white' : 'red', '20px LCDSolid', unitNfoX + 170, HEIGHT - 60);
              }

              // armor
              if (!isInvincible) {
                var bonusArmor = u.owner.getValueModifier('armor', u.type) + (u.modifierMods['armor'] ? u.modifierMods['armor'] : 0);
                c.font = 'bold 20px LCDSolid';
                var basicText = 'Armor: ' + u.type.armor;
                drawText(c, basicText, 'white', '16px LCDSolid', unitNfoX + 170, HEIGHT - 96);
                if (bonusArmor) {
                  drawText(c, ' (' + (bonusArmor > 0 ? '+' : '') + bonusArmor + ')', bonusArmor > 0 ? '#34DA34' : '#FF0000', '16px LCDSolid', unitNfoX + 160 + c.measureText(basicText).width + 16, HEIGHT - 96);
                }

                // armor hover
                if (keyManager.x > unitNfoX + 160 && keyManager.y > HEIGHT - 112 && keyManager.x < unitNfoX + 280 && keyManager.y < HEIGHT - 96) {
                  this.drawHoverBox();
                  drawText(c, 'This is the units\' armor. 1 armor reduces the incoming damage by 1.', 'white', '18px LCDSolid', WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310, null, null, null, null, 18);
                }
              }

              // speed
              if (u.getValue('movementSpeed')) {
                var bonusSpeed = Math.round((u.owner.getValueModifier('movementSpeed', u.type) + (u.modifierMods['movementSpeed'] ? u.modifierMods['movementSpeed'] : 0)) * 20 * 100) / 100;
                c.font = 'bold 20px LCDSolid';
                var basicText = 'Speed: ' + (Math.round(u.type.movementSpeed * 20 * 100) / 100);
                drawText(c, basicText, 'white', '16px LCDSolid', unitNfoX + 170, HEIGHT - 114);
                if (bonusSpeed) {
                  drawText(c, ' (' + (bonusSpeed > 0 ? '+' : '') + bonusSpeed + ')', bonusSpeed > 0 ? '#34DA34' : '#FF0000', '16px LCDSolid', unitNfoX + 160 + c.measureText(basicText).width + 16, HEIGHT - 114);
                }

                // speed hover
                if (keyManager.x > unitNfoX + 160 && keyManager.y > HEIGHT - 130 && keyManager.x < unitNfoX + 280 && keyManager.y < HEIGHT - 114) {
                  this.drawHoverBox();
                  drawText(c, 'This is the units\' movement speed.', 'white', '18px LCDSolid', WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310, null, null, null, null, 18);
                }
              }
            }

            // description hover
            if (keyManager.x > unitNfoX && keyManager.y > HEIGHT - 140 && keyManager.x < unitNfoX + 150) {
              this.drawHoverBox();
              drawText(c, u.type.description, 'white', '18px LCDSolid', WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310, null, null, null, null, 18);
            }
          }

          // if more than 1 units selected
          else if (units.length > 1) {
            var x_ = unitNfoX + 160;
            var y_ = HEIGHT - 142;

            for (var i = this.unitsTab * 27; i < units.length; i++) {
              var u = units[i];

              // active
              if (u.type == this.unitTypeWithCurrentTabPrio) {
                c.fillStyle = 'rgba(255, 255, 255, 0.2)';
                c.fillRect(x_ + 1.5, y_ + 1.5, 37, 40);
              }

              // unit img
              var img = u.type.getTitleImage(u.owner);
              var scale = Math.min(40 / img.w, 40 / img.h);
              var x = (40 - img.w * scale) / 2;
              var y = (40 - img.h * scale) / 2;

              c.drawImage(img.file, img.x, img.y, img.w, img.h, x_ + x, y_ + y, img.w * scale, img.h * scale);

              // hp bar (if not invincible)
              if (!isInvincible) {
                u.drawHealthbar(x_ + 2, y_ + 39, 36, 4);
              }

              // mana bar (if has mana)
              if (u.type.mana) {
                u.drawManabar(x_ + 2, y_ + 32, 36, 4);
              }

              // small building queue
              if ((u.owner == PLAYING_PLAYER || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) && u.queue && u.queue[0]) {
                c.strokeStyle = 'white';
                c.lineWidth = 1;

                for (var k = 0; k < BUILDING_QUEUE_LEN; k++) {
                  c.strokeRect(x_ + 2.5 + k * 7, y_ + 28.5, 7, 7);
                  c.fillStyle = u.queue[k] ? 'rgba(0, 160, 230, 1)' : 'rgba(255, 255, 255, 0.5)';
                  c.fillRect(x_ + k * 7 + 3.5, y_ + 29.5, 5, 5);
                }
              }

              // hover
              if (keyManager.x > x_ && keyManager.y > y_ && keyManager.x < x_ + 40 && keyManager.y < y_ + 40) {
                this.drawHoverBox();
                drawText(c, u.type.description, 'white', '18px LCDSolid', WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310, null, null, null, null, 18);

                this.drawUnitInfo(u);

                // box
                c.strokeStyle = 'white';
                c.lineWidth = 1;
                c.strokeRect(x_ - 0.5, y_ - 0.5, 41, 44);

                this.currentHoverUnit = u;
              }

              x_ += 44;
              if (x_ > unitNfoX + 540) {
                x_ = unitNfoX + 160;
                y_ += 44;

                if (y_ > HEIGHT - 20) {
                  break;
                }
              }
            }

            if (units.length > 27) {
              for (var i = 0; i * 27 < units.length && i <= 4; i++) {
                var _x = unitNfoX + 594;
                var _y = HEIGHT - 139 + i * 24;

                // box
                c.strokeStyle = 'white';
                c.fillStyle = (keyManager.x > _x && keyManager.y > _y && keyManager.x < _x + 20 && keyManager.y < _y + 20) ? 'rgba(255, 255, 255, 0.8)' : 'rgba(255, 255, 255, 0.5)';
                c.lineWidth = 2;
                c.strokeRect(_x, _y, 20, 20);
                c.fillRect(_x, _y, 20, 20);

                drawText(c, i + 1, 'white', 'bold 18px LCDSolid', unitNfoX + 606, HEIGHT - 122 + i * 24, 20, 'center');
              }
            }
          }


          // draw building @cursorpos, if ordering building placement right now
          var placedBuilding = keyManager.command && keyManager.command.type == COMMAND.MAKEBUILDING && keyManager.command.unitType;
          if (placedBuilding && placedBuilding.isBuilding) {
            var field = placedBuilding.getFieldFromMousePos();
            var hm = game.getHMValue4(field.x, field.y);

            c.globalAlpha = 0.6;
            placedBuilding.draw(field.x, field.y - hm * CLIFF_HEIGHT);
            c.globalAlpha = 1;
            var gap = FIELD_SIZE / 24;

            // draw red box with alpha over the image when blocked, otherwise white alpha, for every grid field the building covers
            for (x = field.x - 2; x < field.x + placedBuilding.size + 2; x++) {
              for (y = field.y - 2; y < field.y + placedBuilding.size + 2; y++) {
                var f = new Field(x, y);
                var distanceAllowed = true;
                var nextGoldmine = game.getNextBuildingOfType(f, null, false, 'startGold');
                var nextCC = game.getNextBuildingOfType(f, null, false, 'takesGold');

                if (placedBuilding.takesGold && nextGoldmine && nextGoldmine.pos.distanceTo2(f) < game.getMineDistance()) {
                  distanceAllowed = false;
                }

                if (placedBuilding.startGold && nextCC && nextCC.pos.distanceTo2(field) < game.getMineDistance()) {
                  distanceAllowed = false;
                }

                if (PLAYING_PLAYER.team.fieldIsBlocked(f.x, f.y) || !distanceAllowed) {
                  c.fillStyle = 'rgba(200, 0, 0, 0.25)';
                } else if (x >= field.x && x < field.x + placedBuilding.size && y >= field.y && y < field.y + placedBuilding.size) {
                  c.fillStyle = 'rgba(255, 255, 255, 0.45)';
                } else {
                  c.fillStyle = 'rgba(122, 255, 122, 0.2)';
                }

                c.fillRect((f.x - 1) * FIELD_SIZE - game.cameraX + gap / 2, (f.y - 1 - hm * CLIFF_HEIGHT) * FIELD_SIZE - game.cameraY + gap / 2, FIELD_SIZE - gap, FIELD_SIZE - gap);
              }
            }
          }

          var goldDisplay = '';
          var supplyDisplay = '';
          var maxSupplyDisplay = '';

          if (PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) {
            if (unit0 && unit0.owner.number > 0) {
              goldDisplay = Math.floor(unit0.owner.gold);
              supplyDisplay = Math.floor(unit0.owner.supply);
              maxSupplyDisplay = Math.floor(unit0.owner.maxSupply);
            } else {
              goldDisplay = '';
              supplyDisplay = '';
              maxSupplyDisplay = '';
            }
          } else {
            goldDisplay = Math.floor(PLAYING_PLAYER.gold);
            supplyDisplay = Math.floor(PLAYING_PLAYER.supply);
            maxSupplyDisplay = Math.floor(PLAYING_PLAYER.maxSupply);
          }

          if (game_state == GAME.PLAYING) {
            drawText(c, goldDisplay, 'white', 'bold 24px LCDSolid', WIDTH - 264, 35);

            var supplyFontColor;
            if (PLAYING_PLAYER.supply < PLAYING_PLAYER.maxSupply - 2 || PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) {
              supplyFontColor = 'white';
            } else if (PLAYING_PLAYER.supply < PLAYING_PLAYER.maxSupply) {
              supplyFontColor = 'orange';
            } else {
              supplyFontColor = 'red';
            }

            // supply
            drawText(c, supplyDisplay + ' / ' + maxSupplyDisplay, supplyFontColor, 'bold 24px LCDSolid', WIDTH - 120, 35);

            // supply hover info
            if (keyManager.x > WIDTH - 168 && keyManager.y < 47) {
              this.drawHoverBox();
              drawText(c, 'This is your supply count. The left number is your current supply ( = how many units you have). The right number is your maximum supply. If you reach it, you can\'t spawn any more units. You can build Houses or Castles to increase your max supply count up to ' + game.getMaxSupply() + '.', 'white', '18px LCDSolid', WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310, null, null, null, null, 18);
            }

            // timer
            var sec_total = Math.floor(ticksCounter * 50 / 1000);
            var min = Math.floor(sec_total / 60);
            var sec = sec_total % 60;
            sec = sec < 10 ? '0' + sec : sec;
            drawText(c, min + ':' + sec, 'white', 'bold 24px LCDSolid', WIDTH - 442, 35);

            // idle workers button
            if (game.playerHasIdleWorkers(PLAYING_PLAYER)) {
              this.idleWorkersButtonIsActive = true;

              c.fillStyle = 'rgba(155, 155, 155, 0.6)';
              c.fillRect(20, HEIGHT - MINIMAP_HEIGHT - 93, 70, 70);

              var img = lists.types.worker.getTitleImage(PLAYING_PLAYER);
              c.drawImage(img.file, img.x, img.y, img.w, img.h, 10, HEIGHT - MINIMAP_HEIGHT - 103, 90, 90);

              // hover
              if (keyManager.x > 20 && keyManager.x < 90 && keyManager.y > HEIGHT - MINIMAP_HEIGHT - 93 && keyManager.y < HEIGHT - MINIMAP_HEIGHT - 23) {
                c.fillRect(20, HEIGHT - MINIMAP_HEIGHT - 93, 70, 70);
                this.drawHoverBox();
                drawText(c, 'You have idle workers. Click this button to select one of them.', 'white', '18px LCDSolid', WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270, 310, null, null, null, null, 18);
              }
            } else {
              this.idleWorkersButtonIsActive = false;
            }
          }

          // draw buttons
          if (game.humanUnitsSelected()) {
            // check if tab prio is ok
            var currentTabPrioIsFine = false;
            for (var i = 0; i < units.length; i++) {
              if (units[i].type == this.unitTypeWithCurrentTabPrio) {
                currentTabPrioIsFine = true;
              }
            }

            // if prio has to be re-set
            if (!currentTabPrioIsFine) {
              this.unitTypeWithCurrentTabPrio = units[0].type;
              for (var i = 1; i < units.length; i++) {
                if (units[i].type.tabPriority > this.unitTypeWithCurrentTabPrio.tabPriority) {
                  this.unitTypeWithCurrentTabPrio = units[i].type;
                }
              }
            }

            for (var i = 0; i < this.buttons.length; i++) {
              if (this.buttons[i].isVisible(this.unitTypeWithCurrentTabPrio)) {
                this.buttons[i].draw(keyManager.x, keyManager.y);
              }
            }
          }

          // fps
          if (show_fps) {
            drawText(c, `${Math.round(fps)} fps`, 'white', '30px LCDSolid', 20, HEIGHT - INTERFACE_HEIGHT - 114);
            if (network_game) {
              const pingText = `ping: ${Math.round(network.pings.reduce((a, c) => a + c, 0) / network.pings.length)}`;
              drawText(c, pingText, 'white', '30px LCDSolid', 20, HEIGHT - INTERFACE_HEIGHT - 144);
            }
          }

          // spectator stuff: show supply and gold
          if (PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) {
            // supply icon
            c.drawImage(miscSheet[0], imgs.supply.img.x, imgs.supply.img.y, imgs.supply.img.w, imgs.supply.img.h, WIDTH - 120, HEIGHT - 150, imgs.supply.img.w * 2, imgs.supply.img.h * 2);

            // gold icon
            c.drawImage(miscSheet[0], imgs.gold.img.x, imgs.gold.img.y, imgs.gold.img.w, imgs.gold.img.h, WIDTH - 60, HEIGHT - 150, imgs.gold.img.w * 2, imgs.gold.img.h * 2);

            var nr = 0;

            for (var i = 0; i < game.players.length && nr < 2; i++) {
              if (game.players[i]) {
                var p = game.players[i];

                if (p.controller != CONTROLLER.SPECTATOR && p.controller != CONTROLLER.NONE) {
                  // rect to indicate player nr
                  var arr = playerColors[p.number - 1][3];
                  c.fillStyle = 'rgb(' + arr[0] + ', ' + arr[1] + ', ' + arr[2] + ')';
                  c.fillRect(WIDTH - 354, HEIGHT - 96 + nr * 40, 342, 30);

                  // name
                  drawText(c, p.name, 'white', '20px LCDSolid', WIDTH - 340, HEIGHT - 74 + nr * 40, /* w=*/200, /* align=*/undefined, /* alpha=*/undefined, /* fillStyle=*/undefined, /* shadowStyle=*/undefined, /* height=*/undefined, /* overflow=*/'ellipses');

                  // supply
                  drawText(c, p.supply + ' / ' + p.maxSupply, 'white', '20px LCDSolid', WIDTH - 130, HEIGHT - 74 + nr * 40);

                  // gold
                  drawText(c, Math.floor(p.gold), 'white', '20px LCDSolid', WIDTH - 60, HEIGHT - 74 + nr * 40);

                  nr++;
                }
              }
            }
          }

          this.checkKeyEvents('hover');
        };

        Interface.prototype.drawUnitInfo = function (unit) {
          // img
          var img = unit.type.getTitleImage(unit.owner);
          var scale = Math.min(INTERFACE_UNIT_IMG_SIZE / img.w, INTERFACE_UNIT_IMG_SIZE / img.h);
          var x = (INTERFACE_UNIT_IMG_SIZE - img.w * scale) / 2;
          var y = (INTERFACE_UNIT_IMG_SIZE - img.h * scale) / 2;
          c.drawImage(img.file, img.x, img.y, img.w, img.h, (WIDTH - 780) / 2 + 78 - img.w * scale / 2, HEIGHT - 140 + y, img.w * scale, img.h * scale);

          // name
          var name = (unit.type.name == 'Archer' && unit.owner.getUpgradeLevel(lists.types.upgspeed) >= 2) ? 'Ranger' : unit.type.name; // special: if archer and speed upg at least 3, name is "Ranger"
          var fontSize = Math.max(Math.min(30 - (name.length - 6) * 3, 30), 14);
          drawText(c, name, 'white', 'bold ' + fontSize + 'px LCDSolid', (WIDTH - 783) / 2 + 78, HEIGHT - 14, 150, 'center', null, null, null, fontSize);
        };

        // draw a box at the bottom right (above the interface), where the button hover text for command buttons is placed in
        Interface.prototype.drawHoverBox = function () {
          // rect
          c.fillStyle = '#4E4A4E';
          c.lineWidth = 4;
          c.strokeStyle = '#757161';
          c.fillRect(WIDTH - 350, HEIGHT - INTERFACE_HEIGHT - 300, 342, 292);
          c.strokeRect(WIDTH - 350, HEIGHT - INTERFACE_HEIGHT - 300, 342, 292);

          // small black line below the top boarder
          c.lineWidth = 1;
          c.strokeStyle = 'rgba(0, 0, 0, 0.8)';
          c.beginPath();
          c.moveTo(WIDTH - 348, HEIGHT - INTERFACE_HEIGHT - 297.5);
          c.lineTo(WIDTH - 10, HEIGHT - INTERFACE_HEIGHT - 297.5);
          c.stroke();

          // small black line right the left border
          c.strokeStyle = 'rgba(0, 0, 0, 0.4)';
          c.beginPath();
          c.moveTo(WIDTH - 347.5, HEIGHT - INTERFACE_HEIGHT - 297.5);
          c.lineTo(WIDTH - 347.5, HEIGHT - INTERFACE_HEIGHT - 110);
          c.stroke();
        };

        Interface.prototype.rightClick = function (x, y) {
          for (var i = 0; i < this.buttons.length; i++) {
            var b = this.buttons[i];

            if (b.contains(x, y) && b.isVisible(this.unitTypeWithCurrentTabPrio) && b.command.hasAutocast) {
              if (game.humanUnitsSelected()) {
                soundManager.playSound(SOUND.INGAMECLICK);
                game.issueOrderToUnits(game.selectedUnits, b.command, null, null, true, !game.selectedUnits[0].autocast.contains(b.command.id));
              }

              return true;
            }
          }

          return this.checkKeyEvents('right');
        };

        // gets called on left click; check if a button was clicked, do stuff and return true, if yes
        Interface.prototype.leftClick = function (x, y) {
          // check, if a unit was clicked
          if (this.currentHoverUnit) {
            // Select all units of that type
            if (keyManager.interfaceHotkeyPressed('selectall')) {
              // Remove all units of that type, since they are by definition already selected
              if (keyManager.interfaceHotkeyPressed('toggleselection')) {
                for (var i = 0; i < game.selectedUnits.length; i++) {
                  if (game.selectedUnits[i].type == this.currentHoverUnit.type) {
                    game.selectedUnits.splice(i, 1);
                    i--;
                  }
                }
              }

              // if no shift pressed, select all units of that type
              else {
                var units = [];
                for (var i = 0; i < game.selectedUnits.length; i++) {
                  if (game.selectedUnits[i].type == this.currentHoverUnit.type) {
                    units.push(game.selectedUnits[i]);
                  }
                }
                game.selectedUnits = units;
                this.unitsTab = 0;
              }
            }

            // Remove the unit from the selection
            else if (keyManager.interfaceHotkeyPressed('toggleselection')) {
              game.selectedUnits.erease(this.currentHoverUnit);
            }

            // if nothing pressed, just select the clicked unit
            else {
              game.selectedUnits = [this.currentHoverUnit];
              this.unitsTab = 0;
            }

            soundManager.playSound(SOUND.INGAMECLICK);

            while (this.unitsTab * 27 + 1 > game.selectedUnits.length && this.unitsTab > 0) {
              this.unitsTab--;
            }
          } else if (game.selectedUnits.length > 27) {
            for (var i = 0; i * 27 < game.selectedUnits.length && i <= 4; i++) {
              var _x = (WIDTH - 780) / 2 + 594;
              var _y = HEIGHT - 139 + i * 24;

              if (keyManager.x > _x && keyManager.y > _y && keyManager.x < _x + 20 && keyManager.y < _y + 20) {
                this.unitsTab = i;
                soundManager.playSound(SOUND.INGAMECLICK);
              }
            }
          }

          for (var i = 0; i < this.buttons.length; i++) {
            var b = this.buttons[i];

            if (b.contains(x, y) && b.isVisible(this.unitTypeWithCurrentTabPrio)) {
              var requirement_text = PLAYING_PLAYER.getCommandRequirementText(b.command, game.selectedUnits, null, b.learn);

              // if requirements of the corresponding command are met
              if (!requirement_text) {
                keyManager.order(b.command, b.learn);
                soundManager.playSound(SOUND.INGAMECLICK, 0.7);
                return true;
              } else {
                soundManager.playSound(SOUND.NEGATIVE, 0.6);
                this.addMessage(requirement_text, 'red', imgs.attentionmark);
                return true;
              }
            }
          }

          // idleworkers button is active and has been clicked
          if (this.idleWorkersButtonIsActive && keyManager.x > 20 && keyManager.x < 90 && keyManager.y > HEIGHT - MINIMAP_HEIGHT - 93 && keyManager.y < HEIGHT - MINIMAP_HEIGHT - 23) {
            c.fillStyle = 'rgba(155, 155, 155, 0.5)';
            c.fillRect(20, HEIGHT - MINIMAP_HEIGHT - 93, 70, 70);

            // get all idle workers
            var workers = [];
            for (var i = 0; i < game.units.length; i++) {
              if (game.units[i].owner == PLAYING_PLAYER && game.units[i].type == lists.types.worker && game.units[i].order && game.units[i].order.type == COMMAND.IDLE) {
                workers.push(game.units[i]);
              }
            }

            if (workers.length > 0) {
              // Select all workers
              if (keyManager.interfaceHotkeyPressed('selectall')) {
                game.selectedUnits = workers;
                this.unitsTab = 0;

                var centerPosition = game.getCenterOfUnits(workers);

                // jump the camera to the worker
                game.setCameraX(centerPosition.px * FIELD_SIZE - WIDTH / 2);
                game.setCameraY(centerPosition.py * FIELD_SIZE - HEIGHT / 2);
              }

              // else, only select one worker
              else {
                // increase the index and select the worker
                IDLEWORKERINDEX = (IDLEWORKERINDEX + 1) % workers.length;
                var worker = workers[IDLEWORKERINDEX];
                game.selectedUnits = [worker];
                this.unitsTab = 0;

                // jump the camera to the worker
                game.setCameraX(worker.pos.px * FIELD_SIZE - WIDTH / 2);
                game.setCameraY(worker.pos.py * FIELD_SIZE - HEIGHT / 2);
              }
            }

            // play sound
            soundManager.playSound(SOUND.CLICK2);

            return true;
          }

          var unitNfoX = (WIDTH - 780) / 2;

          // if unit has cargo
          if (game.selectedUnits && game.selectedUnits.length == 1 && game.selectedUnits[0].cargo && game.selectedUnits[0].cargo.length > 0 && game.selectedUnits[0].owner == PLAYING_PLAYER) {
            var sortedCargo = _.sortBy(game.selectedUnits[0].cargo, function (e) {
              return -e.type.cargoUse;
            });

            var cargo = 0;

            for (var i = 0; i < sortedCargo.length && i < 10; i++) {
              if (cargo + sortedCargo[i].type.cargoUse <= 10) {
                var x = unitNfoX + 254 + Math.floor(cargo / 2) * 46;
                var y = HEIGHT - 94 + (cargo % 2) * 46;
                var w = Math.ceil((sortedCargo[i].type.cargoUse - 0.5) / 2) * 40;
                var h = sortedCargo[i].type.cargoUse <= 1 ? 40 : 80;

                if (keyManager.x > x && keyManager.y > y && keyManager.x < x + w && keyManager.y < y + h) {
                  for (var k = 0; k < game.selectedUnits[0].cargo.length; k++) {
                    if (game.selectedUnits[0].cargo[k] == sortedCargo[i]) {
                      game.issueOrderToUnits(game.selectedUnits, lists.types.directunload, k);
                      soundManager.playSound(SOUND.CLICK2);
                      return true;
                    }
                  }
                }

                cargo += sortedCargo[i].type.cargoUse;
              } else {
                i = sortedCargo.length;
              }
            }
          }

          return this.checkKeyEvents('left');
        };

        // gets called on key pressed
        Interface.prototype.keyPressed = function (key) {
          if (key == KEY.F10) {
            if ($('#optionsWindow')[0].style.display == 'none') {
              fadeIn($('#optionsWindow'));
            } else {
              fadeOut($('#optionsWindow'));
            }
          }

          if (key == KEY.F9) {
            if ($('#chatHistoryWindow')[0].style.display == 'none') {
              fadeIn($('#chatHistoryWindow'));
            } else {
              fadeOut($('#chatHistoryWindow'));
            }
          }

          // set current tab prio to the next lower one
          if (key == KEY.TAB && this.unitTypeWithCurrentTabPrio && game.humanUnitsSelected()) {
            var currentPrio = this.unitTypeWithCurrentTabPrio.tabPriority;

            var units = game.selectedUnits;

            var newType = null;
            for (var i = 0; i < game.selectedUnits.length; i++) {
              if (units[i].type.tabPriority < currentPrio && (!newType || units[i].type.tabPriority > newType.typPrio)) {
                newType = units[i].type;
              }
            }

            // the current prio is the lowest, so new use now the highest
            if (!newType) {
              newType = units[0];
              for (var i = 1; i < units.length; i++) {
                if (units[i].type.tabPriority > newType.typPrio) {
                  newType = units[i].type;
                }
              }
            }

            if (newType) {
              this.unitTypeWithCurrentTabPrio = newType;
            }
          }

          // check if a command button has this key as a hotkey, and press it in case
          for (var i = 0; i < this.buttons.length; i++) {
            var cmd = this.buttons[i].command;

            if (cmd.hotkey == key && this.buttons[i].isVisible(this.unitTypeWithCurrentTabPrio) && game.humanUnitsSelected()) {
              // if requirement met
              var requirement_text = PLAYING_PLAYER.getCommandRequirementText(cmd, game.selectedUnits);

              if (!requirement_text) {
                keyManager.order(cmd);
                soundManager.playSound(SOUND.INGAMECLICK, 0.7);
              } else {
                soundManager.playSound(SOUND.NEGATIVE, 0.6);
                this.addMessage(requirement_text, 'red', imgs.attentionmark);
              }
            }
          }
        };

        Interface.prototype.drawConstructionProgress = function (x, y, w, h, progress, total) {
          var percentage = progress / total;
          drawBar(x, y, w, h, Math.min(percentage, 1), 'rgba(0, 160, 230, 1)');

          var progressText = progress ? `${Math.round(progress)} / ${Math.round(total)}` : '';
          drawText(c, progressText, 'black', '16px LCDSolid', x + w / 2 - 18, y + h - 2);
        };

        Interface.prototype.updateFakeCursor = function () {
          // Hide them all by default to begin with
          for (const key in this.fakeCursors) {
            $(this.fakeCursors[key]).hide();
          }

          if (game_state != GAME.PLAYING) {
            return;
          }

          const cursor = keyManager.getCursor();
          const element = $(this.fakeCursors[cursor]);

          if (this.isPointerLocked()) {
            element.show();
            element.css({ left: keyManager.x, top: keyManager.y });
          }
        };

        // represents an ingame command button (attack, make unit, ...)
        function Button(command, learn) {
          this.init(command, learn);
        };

        Button.prototype.init = function (command, learn) {
          this.command = command; // the command, this buttons refers to
          this.learn = learn;
          this.refresh();
        };

        Button.prototype.refresh = function () {
          if (this.learn) {
            this.x = (5 - this.command.learnInterfacePosX) * 72 + 4; // x distance to the right screen border
            this.y = (2 - this.command.learnInterfacePosY) * 72 + 4; // x distance to the right screen border
            this.hotkey = this.command.learnHotkey;
          } else {
            this.x = (5 - this.command.interfacePosX) * 72 + 4; // x distance to the right screen border
            this.y = (2 - this.command.interfacePosY) * 72 + 4; // x distance to the right screen border
            this.hotkey = this.command.hotkey;
          }
        };

        Button.prototype.getCC = function () {
          return this.command.getValue(this.learn ? 'learnCommandCard' : 'commandCard', game.selectedUnits[0]);
        };

        Button.prototype.draw = function (mouseX, mouseY) {
          // if learn and all levels learned, dont draw shit
          if (this.learn) {
            var canLearn = false;
            for (var i = 0; i < game.selectedUnits.length; i++) {
              if (game.selectedUnits[i].type.commands[this.command.id_string] && game.selectedUnits[i].abilityLevels[this.command.id] < this.command.requiredLevels.length) {
                canLearn = true;
              }
            }

            if (!canLearn) {
              return;
            }
          }

          // check lvl
          var maxLvl = 0;
          if (this.command.requiredLevels && this.command.requiredLevels > 0) {
            for (var i = 0; i < game.selectedUnits.length; i++) {
              if (game.selectedUnits[i].abilityLevels) {
                maxLvl = Math.max(game.selectedUnits[i].abilityLevels[this.command.id], maxLvl);
              }
            }

            if (maxLvl == 0 && !this.learn) {
              return;
            }
          }

          // check if the button is pressed / active
          var pressed = (keyManager.command == this.command || ((keyManager.keys[this.hotkey] || (this.contains(mouseX, mouseY) && keyManager.leftMouse)) && keyManager.commandCardWhenPressStart == this.getCC()));

          // calculate total width / height of the image
          var d = imgs.button.img.w;

          // draw border img
          var borderImg = pressed ? imgs.button2.img : imgs.button.img;
          c.drawImage(miscSheet[0], borderImg.x, borderImg.y, borderImg.w, borderImg.h, WIDTH - this.x, HEIGHT - this.y, borderImg.w, borderImg.h);

          // check if requirement is met; if not, use greyscaled image
          var requirement_text = PLAYING_PLAYER.getCommandRequirementText(this.command, game.selectedUnits, null, this.learn);
          var img = this.command.getTitleImage(requirement_text ? (MAX_PLAYERS + 1) : PLAYING_PLAYER.number);

          // draw button img itself
          var scale = Math.min((d * 0.95) / img.w, (d * 0.95) / img.h);
          scale = scale > 1 ? Math.floor(scale) : scale;
          var x = Math.floor(WIDTH - this.x + (pressed ? 1 : 0) + (d - img.w * scale) / 2);
          var y = Math.floor(HEIGHT - this.y + (pressed ? 1 : 0) + (d - img.h * scale) / 2);

          c.drawImage(img.file, img.x, img.y, img.w, img.h, x, y, img.w * scale, img.h * scale);

          // if autocast is on
          if (!this.learn && this.command.hasAutocast && game.selectedUnits[0].autocast.contains(this.command.id)) {
            drawText(c, 'auto', 'yellow', 'bold 22px LCDSolid', x + (pressed ? 4 : 3), y + (pressed ? 50 : 49));
          }

          // draw hotkey
          drawText(c, '[' + getKeyName(this.hotkey) + ']', 'white', 'bold 20px LCDSolid', WIDTH - this.x + (pressed ? 4 : 3), HEIGHT - this.y + (pressed ? 22 : 21));

          // if cooldowning, draw cooldown
          if (!this.learn && this.command.cooldown2) {
            // get shortest cooldown
            var shortestCD = 9999999;
            for (var i = 0; i < game.selectedUnits.length; i++) {
              if (game.selectedUnits[i].type == interface_.unitTypeWithCurrentTabPrio) {
                shortestCD = Math.min(game.selectedUnits[i].lastTickAbilityUsed[this.command.id] + this.command.getValue('cooldown2', game.selectedUnits[i]) - ticksCounter, shortestCD);
              }
            }

            if (shortestCD < 9999999 && shortestCD > 0) {
              c.fillStyle = 'rgba(0, 0, 0, 0.55)';
              c.fillRect(pressed ? WIDTH - this.x + SCALE_FACTOR : WIDTH - this.x, pressed ? HEIGHT - this.y + SCALE_FACTOR : HEIGHT - this.y, d, d);
              drawText(c, Math.ceil(shortestCD / 20), 'white', 'bold 20px LCDSolid', WIDTH - this.x + (pressed ? 4 : 3) + 30, HEIGHT - this.y + (pressed ? 22 : 21) + 20, 60, 'center');
            }
          }

          // if hover
          if (this.contains(mouseX, mouseY)) {
            // draw button hover effect
            c.fillStyle = 'rgba(255, 255, 255, 0.15)';
            c.fillRect(pressed ? WIDTH - this.x + SCALE_FACTOR : WIDTH - this.x, pressed ? HEIGHT - this.y + SCALE_FACTOR : HEIGHT - this.y, d, d);

            interface_.drawHoverBox();

            // draw command name
            drawText(c, this.command.name, 'white', 'bold 26px LCDSolid', WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 270);

            // draw command description
            var offset = 0;
            var desc = interpreteString(this.command.description, game.selectedUnits[0]).split('#BR');
            for (var i = 0; i < desc.length; i++) {
              offset += 24 * drawText(c, desc[i], 'yellow', '16px LCDSolid', WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 234 + offset, 320, null, null, null, null, 16);
            }

            // mana cost
            var unit = null;
            for (var i = 0; i < game.selectedUnits.length; i++) {
              if (game.selectedUnits[i].type == interface_.unitTypeWithCurrentTabPrio) {
                unit = game.selectedUnits[i];
              }
            }

            if (unit && this.command.getValue('manaCost', unit)) {
              offset += 28 + 28 * drawText(c, 'Mana Cost: ' + this.command.getValue('manaCost', unit), 'rgba(200, 0, 200, 1)', '20px LCDSolid', WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 234 + offset, 320);
            }

            // draw condition (if not met)
            if (requirement_text) {
              offset += 28 * drawText(c, requirement_text, 'red', '20px LCDSolid', WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 234 + offset, 320);
            }

            // draw lvl
            if (maxLvl > 0 || this.learn) {
              offset += 28 * drawText(c, 'Level: ' + maxLvl, 'white', '20px LCDSolid', WIDTH - 340, HEIGHT - INTERFACE_HEIGHT - 234 + offset, 320);
            }
          }
        };

        // returns, if a button is visible; argument is the current selected unit type
        Button.prototype.isVisible = function (unitType) {
          if (unitType && game.selectedUnitsCanPerformOrder(this.command, unitType) && interface_.commandCard == this.getCC()) {
            if (this.command.upgrade && this.command.upgrade.maxLevel && (PLAYING_PLAYER.getUpgradeLevel(this.command.upgrade) + PLAYING_PLAYER.upgradeCountInResearch(this.command.upgrade)) >= this.command.upgrade.maxLevel) {
              return false;
            }

            if (this.command.type == COMMAND.BUILDING_UPGRADE && this.command.improvedBuilding) {
              for (var i = 0; i < game.selectedUnits.length; i++) {
                if (!game.selectedUnits[i].hasInQueue(this.command.improvedBuilding)) {
                  return true;
                }
              }
              return false;
            }

            return true;
          }

          return false;
        };

        // checks if button contains the specified coordinates
        Button.prototype.contains = function (x, y) {
          return x >= WIDTH - this.x && y >= HEIGHT - this.y && x <= WIDTH - this.x + imgs.button.img.w && y <= HEIGHT - this.y + imgs.button.img.h;
        };

        // does the flying white-yellow-green showish-looking stuff
        function Enviroment() {
          this.dots = [];
          this.img = null;
          this.countDots = 190;
          this.pixel = document.createElement('canvas');
          this.pixel.width = 1;
          this.pixel.height = 1;
        };

        Enviroment.prototype.draw = function () {
          for (var i = 0; i < this.dots.length; i++) {
            if (!this.dots[i].draw()) {
              this.dots.splice(i, 1);
            }
          }

          while (this.dots.length < this.countDots / SCALE_FACTOR) {
            this.dots.push(new Dot(Math.random() * WIDTH, Math.random() * HEIGHT, this.alpha));
          }
        };

        Enviroment.prototype.setFromTheme = function (theme) {
          this.pixel.getContext('2d').fillStyle = theme.particleColor;
          this.pixel.getContext('2d').fillRect(0, 0, 1, 1);
          this.countDots = theme.countDots;
        };


        function Dot(x, y, alpha) {
          this.x = x;
          this.y = y;
          this.vx = 4;
          this.vy = 4;
          this.timeToLive = 3 + Math.random() * 3;
          this.size = 1;
          this.alpha = alpha;
        };

        Dot.prototype.draw = function () {
          if (!game_paused) {
            this.alpha = Math.max(Math.min(this.alpha + Math.random() * 0.02 - 0.01, env.alpha + 0.15), env.alpha - 0.15);
            this.vx += (Math.random() - 0.5);
            this.vy += (Math.random() - 0.5);
            this.x += this.vx * gameTimeDiff * 10;
            this.y += this.vy * gameTimeDiff * 10;
            this.timeToLive -= gameTimeDiff;
          }

          var camX = game ? game.cameraX : 0;
          var camY = game ? game.cameraY : 0;

          while (this.x > camX + WIDTH) {
            this.x -= WIDTH;
          }

          while (this.x < camX) {
            this.x += WIDTH;
          }

          while (this.y > camY + HEIGHT) {
            this.y -= HEIGHT;
          }

          while (this.y < camY) {
            this.y += HEIGHT;
          }

          // draw
          c.globalAlpha = Math.max(Math.min(this.timeToLive, 1), 0);
          c.drawImage(env.pixel, this.x - camX, this.y - camY, this.size * SCALE_FACTOR, this.size * SCALE_FACTOR);
          c.globalAlpha = 1;
          return this.timeToLive > 0;
        };

        // does the flying white-yellow-green showish-looking stuff
        function Rain() {
          this.drops = [];
          this.img = null;
          this.countDrops = 500;

          this.middleX = 0;
          this.middleY = 0;

          this.lastRainSoundStart = -999;
        };

        Rain.prototype.draw = function () {
          if (interface_.noRain.get()) {
            musicManager.rain[0].volume = 0;
            musicManager.rain[1].volume = 0;
            return;
          }
          var time = ticksCounter / 20 / 60;

          var period = null;
          // Each tick, work out if we're in a rain period
          for (var i = 0; i < game.rainTime.length; i++) {
            if (game.rainTime[i].start < time && game.rainTime[i].end > time) {
              period = game.rainTime[i];
              i = game.rainTime.length;
            }
          }

          // If we're not in a rain period, disable the sound and exit
          if (!period) {
            musicManager.rain[0].volume = 0;
            musicManager.rain[1].volume = 0;
            return;
          }

          var dropCountDensity = 1;

          if (time < period.start + 0.1) {
            dropCountDensity = (time - period.start) / 0.1;
          } else if (time > period.end - 0.1) {
            dropCountDensity = (period.end - time) / 0.1;
          }

          // TODO: don't directly set variables in MusicManager
          musicManager.rain[0].volume = 0.6 * soundManager.volume.get() * dropCountDensity;
          musicManager.rain[1].volume = 0.6 * soundManager.volume.get() * dropCountDensity;

          if (this.lastRainSoundStart + 2000 < timestamp && (musicManager.rain[0].currentTime <= 0 || musicManager.rain[0].currentTime >= musicManager.rain[0].duration - 0.1) && (musicManager.rain[1].currentTime <= 0 || musicManager.rain[1].currentTime >= musicManager.rain[1].duration - 0.1)) {
            if (musicManager.rain[0].currentTime >= musicManager.rain[0].duration - 0.1) {
              musicManager.rain[1].play();
            } else {
              musicManager.rain[0].play();
            }

            this.lastRainSoundStart = timestamp;
          }

          c.strokeStyle = 'rgba(255, 255, 255, 1)';
          c.beginPath();

          var vert = (WIDTH > (HEIGHT * 2) ? WIDTH : (HEIGHT * 2));
          this.countDrops = Math.floor(WIDTH * 0.5 * dropCountDensity);
          vert *= 3 / SCALE_FACTOR;
          var hori = vert / 2;

          this.middleX = game.cameraX + WIDTH * 0.4;
          this.middleY = game.cameraY + hori * 0.3;

          for (var i = 0; i < this.drops.length; i++) {
            if (!this.drops[i].draw(this)) {
              this.drops.splice(i, 1);
            }
          }

          c.globalAlpha = 1;

          while (this.drops.length < this.countDrops / SCALE_FACTOR) {
            this.drops.push(new Drop());
          }
        };


        function Drop() {
          this.x = Math.random() * WIDTH;
          this.y = Math.random() * WIDTH;
          this.z = 1 + Math.random();
        };

        Drop.prototype.draw = function (rain) {
          if (!game_paused) {
            this.z -= gameTimeDiff * 1.0;
          }

          while (this.x > game.cameraX + WIDTH) {
            this.x -= WIDTH;
          }

          while (this.x < game.cameraX) {
            this.x += WIDTH;
          }

          while (this.y > game.cameraY + HEIGHT) {
            this.y -= HEIGHT;
          }

          while (this.y < game.cameraY) {
            this.y += HEIGHT;
          }

          // draw
          if (this.z > 0) {
            var z1 = this.z * SCALE_FACTOR / 3;

            var topX = this.x + (this.x - rain.middleX) * (0.7 - SCALE_FACTOR / 20);
            var topY = this.y + (this.y - rain.middleY) * 0.8;
            var z2 = z1 + 0.004 * SCALE_FACTOR;

            var x1 = (this.x + (topX - this.x) * z1) - game.cameraX;
            var y1 = (this.y + (topY - this.y) * z1) - game.cameraY - z1 * HEIGHT;

            if (y1 > -10 && y1 < (HEIGHT - INTERFACE_HEIGHT) && x1 > -10 && x1 < (WIDTH + 10)) {
              c.lineWidth = 1 + SCALE_FACTOR * 0.25 + SCALE_FACTOR * 0.25 * Math.min(this.z, 1);
              c.globalAlpha = 0.4 * Math.max(Math.min(z1 * 3, 1), 0.01);

              c.beginPath();
              c.moveTo(x1, y1);
              c.lineTo((this.x + (topX - this.x) * z2) - game.cameraX, (this.y + (topY - this.y) * z2) - game.cameraY - z2 * HEIGHT);
              c.stroke();
            }

            return true;
          }

          return false;
        };

        // the minimap at the bottom left of the screen
        function Minimap(game, x, y) {
          if (!game) {
            throw 'Game is not defined or null. Game must be defined when creating Minimap!';
          }

          this.game = game;
          this.x = x;
          this.y = y;

          this.mapPings = [];

          this.x_scale = MINIMAP_WIDTH / game.x;
          this.y_scale = MINIMAP_HEIGHT / game.y;

          // create additional canvas for fog
          this.canvas = document.createElement('canvas');
          this.canvas.width = MINIMAP_WIDTH;
          this.canvas.height = MINIMAP_HEIGHT;

          // create additional canvas for screen fog
          this.screenCanvas = document.createElement('canvas');
          this.screenCanvas.width = (game.x + DEAD_MAP_SPACE) * FIELD_SIZE / SCALE_FACTOR;
          this.screenCanvas.height = (game.y + DEAD_MAP_SPACE) * FIELD_SIZE / SCALE_FACTOR;

          // editor screen fog
          this.editorCanvas = document.createElement('canvas');
          this.editorCanvas.width = (game.x + DEAD_MAP_SPACE) * FIELD_SIZE / SCALE_FACTOR;
          this.editorCanvas.height = (game.y + DEAD_MAP_SPACE) * FIELD_SIZE / SCALE_FACTOR;

          // darker border
          this.screenCanvas.getContext('2d').fillStyle = 'rgba(0, 0, 0, 0.85)';
          this.screenCanvas.getContext('2d').fillRect(0, this.screenCanvas.height - (DEAD_MAP_SPACE + game.getHMValue2(1, 1) * CLIFF_HEIGHT) * 16, this.screenCanvas.width, DEAD_MAP_SPACE * 16); // bottom
          this.screenCanvas.getContext('2d').fillRect(this.screenCanvas.width - DEAD_MAP_SPACE * 16, 0, DEAD_MAP_SPACE * 16, this.screenCanvas.height - (DEAD_MAP_SPACE + game.getHMValue2(1, 1) * CLIFF_HEIGHT) * 16); // right

          // darker border screen fog
          this.editorCanvas.getContext('2d').fillStyle = 'rgba(0, 0, 0, 0.8)';
          this.editorCanvas.getContext('2d').fillRect(0, this.editorCanvas.height - DEAD_MAP_SPACE * 16, this.editorCanvas.width, DEAD_MAP_SPACE * 16); // bottom
          this.editorCanvas.getContext('2d').fillRect(this.editorCanvas.width - DEAD_MAP_SPACE * 16, 0, DEAD_MAP_SPACE * 16, this.editorCanvas.height - DEAD_MAP_SPACE * 16); // right

          // create additional canvas for tiles (groundtiles and doodads)
          this.canvasTiles = document.createElement('canvas');
          this.canvasTiles.width = MINIMAP_WIDTH;
          this.canvasTiles.height = MINIMAP_HEIGHT;

          // create additional canvas for default groundtiles
          this.groundTiles = document.createElement('canvas');
          this.groundTiles.width = MINIMAP_WIDTH;
          this.groundTiles.height = MINIMAP_HEIGHT;

          // attack ping stuff
          this.tickOfLastAttackPing = -999;
          this.positionOfLastAttackPing = null;
        };

        Minimap.prototype.refreshTilesCanvas = function () {
          var ctx = this.canvasTiles.getContext('2d');

          ctx.drawImage(this.groundTiles, 0, 0);

          var tiles = this.game.groundTiles2.concat(this.game.blockingTiles);

          for (var i = 1; i < tiles.length; i++) {
            if (!tiles[i].type.ignoreGrid || true) {
              ctx.fillStyle = tiles[i].type.minimapColor;
              ctx.fillRect(Math.floor((tiles[i].x - 1) * this.x_scale), Math.floor((tiles[i].y - 1) * this.y_scale), Math.ceil(this.x_scale * tiles[i].type.sizeX), Math.ceil(this.y_scale * tiles[i].type.sizeY));
            }
          }
        };

        // gets called when the player gets attacked, so he can display warning stuff
        Minimap.prototype.attackPingAt = function (pos) {
          // if last msg is more than 10 sec ago and msg is not in screen
          if (this.tickOfLastAttackPing + 200 < ticksCounter && !(pos.px > (game.cameraX / FIELD_SIZE) && pos.px < ((game.cameraX + WIDTH) / FIELD_SIZE) && pos.py > (game.cameraY / FIELD_SIZE) && pos.py < ((game.cameraY + HEIGHT) / FIELD_SIZE))) {
            this.tickOfLastAttackPing = ticksCounter;
            this.positionOfLastAttackPing = pos;

            // message
            interface_.addMessage('We are under attack', 'red', imgs.underAttack);
            soundManager.playSound(SOUND.UNDER_ATTACK);
          }
        };

        Minimap.prototype.getFieldFromClick = function (x, y) {
          return new Field(x / this.x_scale + 1, (y - HEIGHT + MINIMAP_HEIGHT) / this.y_scale);
        };

        Minimap.prototype.drawCameraBorder = function (y_start, x, y, width, height, field_size, color) {
          c.lineWidth = 2;
          c.strokeStyle = color;

          var x1 = this.x_scale * x / field_size;
          x1 -= x1 % this.x_scale;
          var y1 = this.y_scale * y / field_size;
          y1 -= y1 % this.y_scale;
          var x2 = this.x_scale * (x + width) / field_size;
          x2 -= x2 % this.x_scale;
          var y2 = this.y_scale * (y + height) / field_size;
          y2 -= y2 % this.y_scale;

          c.strokeRect(x1 + this.x, Math.max(y1, 0) + y_start, Math.min(x2 - x1, MINIMAP_WIDTH), Math.min(y2 - y1, MINIMAP_HEIGHT));
        };

        Minimap.prototype.draw = function () {
          var y_start = this.y < 0 ? HEIGHT + this.y : this.y;

          // draw tiles image
          c.drawImage(this.canvasTiles, this.x, y_start, MINIMAP_WIDTH, MINIMAP_HEIGHT);

          // buildings
          for (var i = 0; i < this.game.buildings2.length; i++) {
            if (this.game.buildings2[i].seenBy[PLAYING_PLAYER.team.number]) {
              var x = this.x_scale * (this.game.buildings2[i].x - 1);
              x -= x % this.x_scale;
              var y = this.y_scale * (this.game.buildings2[i].y - 1);
              y -= y % this.y_scale;
              c.fillStyle = (this.game.buildings2[i].owner.controller == CONTROLLER.NONE && !this.game.buildings2[i].type.startGold) ? 'rgba(77, 166, 174, 0.9)' : this.game.buildings2[i].owner.getAllyColor();
              c.fillRect(x + this.x, y + y_start, this.x_scale * this.game.buildings2[i].type.size, this.y_scale * this.game.buildings2[i].type.size);
            }
          }

          // units
          for (var i = 0; i < this.game.units.length; i++) {
            if (PLAYING_PLAYER.team.canSeeUnit(this.game.units[i]) && PLAYING_PLAYER.team.canSeeUnitInvisible(this.game.units[i])) {
              var x = this.x_scale * (this.game.units[i].pos.x - 1);
              x -= x % this.x_scale;
              var y = this.y_scale * (this.game.units[i].pos.y - 1);
              y -= y % this.y_scale;
              c.fillStyle = this.game.units[i].owner.getAllyColor();
              c.fillRect(x + this.x, y + y_start, this.x_scale * 1.5, this.y_scale * 1.5);
            }
          }

          // draw fog canvas
          if (game_state == GAME.PLAYING) {
            c.drawImage(this.canvas, this.x, y_start, MINIMAP_WIDTH, MINIMAP_HEIGHT);
          }

          // draw attack ping
          if (this.tickOfLastAttackPing + 100 > ticksCounter && this.positionOfLastAttackPing) {
            // calculate coords of pos on minimap
            var x = this.positionOfLastAttackPing.px * this.x_scale;
            var y = this.positionOfLastAttackPing.py * this.y_scale + y_start;
            var age = ticksCounter - this.tickOfLastAttackPing;

            // set drawing attributes
            c.strokeStyle = 'red';
            c.lineWidth = 2;

            // draw horizontal line
            c.beginPath();
            c.moveTo(0, y);
            c.lineTo(MINIMAP_WIDTH, y);
            c.stroke();

            // draw vertical line
            c.beginPath();
            c.moveTo(x, y_start);
            c.lineTo(x, WIDTH);
            c.stroke();

            var offset = Math.max(50 - age * 4, 7);
            c.strokeRect(Math.max(x - offset, 0), Math.max(y - offset, y_start), Math.min(offset * 2, MINIMAP_WIDTH - (x - offset)), Math.min(offset * 2, HEIGHT - (y - offset)));

            if (age > 10) {
              c.fillStyle = 'red';
              c.globalAlpha = 0.8 - (age / 10) % 0.8;
              c.fillRect(Math.max(x - 6, 0), Math.max(y - 6, y_start), Math.min(6 * 2, MINIMAP_WIDTH - (x - 6)), Math.min(6 * 2, HEIGHT - (y - 6)));
              c.globalAlpha = 1;
            }
          }

          // player pings
          for (var i = 0; i < this.mapPings.length; i++) {
            var age = Date.now() - this.mapPings[i].time;

            if (age > 7000) // ping is too old, kill it
            {
              this.mapPings.splice(i, 1);
              i--;
            } else {
              var ageAlpha = age > 5000 ? ((7000 - age) / 2000) : 1;

              c.globalAlpha = ageAlpha;

              var x = this.mapPings[i].field.x * this.x_scale;
              var y = this.mapPings[i].field.y * this.y_scale + y_start;

              c.strokeStyle = 'yellow';
              c.lineWidth = 2;
              c.beginPath();
              c.moveTo(0, y);
              c.lineTo(MINIMAP_WIDTH, y);
              c.stroke();
              c.beginPath();
              c.moveTo(x, y_start);
              c.lineTo(x, HEIGHT);
              c.stroke();
              var d = Math.max(50 - age / 15, 7);
              c.strokeRect(Math.max(x - d, 0), Math.max(y - d, y_start), Math.min(d * 2, MINIMAP_WIDTH - (x - d)), Math.min(d * 2, HEIGHT - (y - d)));

              if (age > 10) {
                c.fillStyle = 'yellow';
                c.globalAlpha = (0.8 - (age / 600) % 0.8) * ageAlpha;
                c.fillRect(Math.max(x - 6, 0), Math.max(y - 6, y_start), Math.min(6 * 2, MINIMAP_WIDTH - (x - 6)), Math.min(6 * 2, HEIGHT - (y - 6)));
                c.globalAlpha = 1;
              }
            }
          }

          // screen borders
          const ourBorderColor = game.followVision ? 'rgb(120, 120, 120)' : 'white';
          this.drawCameraBorder(
            y_start, game.cameraX, game.cameraY, WIDTH, HEIGHT, FIELD_SIZE, ourBorderColor,
          );
          if (PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) {
            for (const player of game.players) {
              if (!player) {
                continue;
              }
              if (game.visionSetting != 0 && game.visionSetting != player.number) {
                continue;
              }
              this.drawCameraBorder(
                y_start, player.cameraX, player.cameraY, player.cameraWidth,
                player.cameraHeight, player.fieldSize, player.getColor());
            }
          }


          if (game_state == GAME.EDITOR) {
            c.drawImage(miscSheet[0], imgs.interfaceMapBorder.img.x, imgs.interfaceMapBorder.img.y, imgs.interfaceMapBorder.img.w, imgs.interfaceMapBorder.img.h, -16, HEIGHT - 200, imgs.interfaceMapBorder.img.w * 2, imgs.interfaceMapBorder.img.h * 2);
          }
        };

        // true: fog, false: no fog
        Minimap.prototype.setFog = function (x, y, fog) {
          var alpha = (game.globalVars && game.globalVars.useDarkMask) ? darkFogMaskAlpha[fog] : fogMaskAlpha[fog];

          var h = this.game.getHMValue2(x, y);

          var x_ = (x - 1) * 16;
          var y_ = (y - 1 - h * CLIFF_HEIGHT) * 16;

          var h_ = 16;

          if (this.game.getHMValue2(x, y - 1) > h) {
            y_ -= CLIFF_HEIGHT * 16;
            h_ += CLIFF_HEIGHT * 16;
          }

          for (var i = 0; i < CLIFF_HEIGHT; i++) {
            if (this.game.getHMValue2(x, y + 1 + i) > h) {
              h_ = Math.max(h_ - (CLIFF_HEIGHT - i) * 16, 0);
            }
          }

          if (alpha == 0) {
            this.canvas.getContext('2d').clearRect(Math.floor((x - 1) * this.x_scale), Math.floor((y - 1) * this.y_scale), Math.ceil(this.x_scale), Math.ceil(this.y_scale));

            this.screenCanvas.getContext('2d').clearRect(x_, y_, 16, h_);
          } else {
            this.canvas.getContext('2d').fillStyle = 'rgba(0, 0, 0, ' + alpha + ')';
            this.canvas.getContext('2d').clearRect(Math.floor((x - 1) * this.x_scale), Math.floor((y - 1) * this.y_scale), Math.ceil(this.x_scale), Math.ceil(this.y_scale));
            this.canvas.getContext('2d').fillRect(Math.floor((x - 1) * this.x_scale), Math.floor((y - 1) * this.y_scale), Math.ceil(this.x_scale), Math.ceil(this.y_scale));

            this.screenCanvas.getContext('2d').fillStyle = 'rgba(0, 0, 0, ' + alpha + ')';
            this.screenCanvas.getContext('2d').clearRect(x_, y_, 16, h_);
            this.screenCanvas.getContext('2d').fillRect(x_, y_, 16, h_);
          }
        };

        function MapEditor(width = 64, height = 64, themeName = 'Grass', defaultHeight = 0) {
          game = new Game();

          let hm = '';
          for (let x = 1; x <= width; x++) {
            for (let y = 1; y <= height; y++) {
              hm += defaultHeight;
            }
          }

          const theme = getThemeByName(themeName);
          var map = {
            name: 'unnamed',
            x: width,
            y: height,
            units: [],
            buildings: [],
            tiles: [],
            theme: themeName,
            defaultTiles: theme.defaultTiles,
            heightmap: hm,
          };

          game.loadMap(map, null, null, null, true);
          worker.postMessage({
            what: 'start-game',
            map: map,
            network_game: false,
            game_state: game_state,
            networkPlayerName: networkPlayerName,
          });

          this.selectedItemType = null; // type of the selected unit / building / doodad (when clicked on a button in the interface)
          this.terrainModifier = 0;
          this.player = 1; // current selected player
          this.dragging = false;
          this.almostDragging = false;
          this.draggStartPos = null;
          this.draggingUnitsOriginalpositions = [];
          this.startHeight = 0;
          this.lastClickedField = null;
          this.randomTree = false;

          this.MirroringMode = Object.freeze({
            NONE: 0,
            DIAGONAL: 1,
            HORIZONTAL: 2,
            VERTICAL: 3,
            FOURWAYS: 4,
          });
          this.updateMirroringMode(this.MirroringMode.NONE);

          this.createButtons();

          // clipboard for history, copy and paste
          this.clipboard = new MapEditorClipboard();
        };

        MapEditor.prototype.createButtons = function () {
          this.trees = {
            fullList: [],
            // 1_1 : []
            // 2_2 : []
            // 3_3 : []
          };

          // ICONS (i could not use lists... 'lists' are empty, lists.buildingTypes for example are empty too..)
          this.unitsIcon = game.unitTypes[0]; // soldier
          this.buildingIcon = game.buildingTypes[4]; // house
          this.treeIcon = tileTypes[0]; // tree 1
          this.tileIcon = tileTypes[30]; // stone 4
          this.decorationIcon = tileTypes[69]; // grass 22

          // dividing tiles into blocking and non-blocking
          var blocking = [];
          var nonblocking = [];
          // building tree lists for the random trees as well

          for (var i = 0; i < tileTypes.length; i++) {
            if (tileTypes[i].blocking && !tileTypes[i].isTree) // if its not a tree
            {
              blocking.push(tileTypes[i]);
            } else if (tileTypes[i].isTree) {
              this.trees.fullList.push(tileTypes[i]);

              var listName = tileTypes[i].sizeX + '_' + tileTypes[i].sizeY;

              if (!this.trees[listName]) {
                this.trees[listName] = [];
              }

              this.trees[listName].push(tileTypes[i]);

              tileTypes[i].randomTree = true; // flag
            } else {
              nonblocking.push(tileTypes[i]);
            }
          }

          // create ui
          var types = [game.unitTypes, game.buildingTypes, this.trees.fullList, blocking, nonblocking];
          var typesDescription = ['Units', 'Buildings', 'Trees', 'Tiles', 'Decoration'];
          var icons = [this.unitsIcon, this.buildingIcon, this.treeIcon, this.tileIcon, this.decorationIcon];

          $('#typesWindow').remove();
          var typesWindows = document.createElement('div');
          typesWindows.style.cssText = 'position: absolute; left: 10px; top: 2px; height: 64px; right: 450px;';
          typesWindows.id = 'typesWindow';
          $('#mapEditorInterface').append(typesWindows);

          for (var i = 0; i < types.length; i++) {
            $('#mapEditorTypeButtons' + i).remove();
            var win = document.createElement('div');
            win.id = 'mapEditorTypeButtons' + i;
            win.className = 'editorTypeClass';
            win.style.cssText = 'position: absolute; left: 10px; top: ' + (1 * 64 + 6) + 'px; height: 128px; right: 500px; overflow: auto;';
            $('#mapEditorInterface').append(win);
            if (i != 0) {
              $(win).hide();
            }

            // creating the types buttons
            var firstElement = types[i][0];
            var typeButton = document.createElement('button');
            typeButton.id = 'editorTypeButton_' + i;
            typeButton.className = 'editorTypeButton';
            typeButton.title = typesDescription[i];
            if (i != 0) {
              $(typeButton).css('background-color', '#99cccc');
            } else {
              $(typeButton).css('background-color', '#ccffcc');
              $(typeButton).addClass('TabSelected');
            }

            var img = icons[i].getTitleImage();
            var w = img.w;
            var h = img.h;

            if (w > h) {
              h = 60 * (h / w);
              w = 60;
            } else {
              w = 60 * (w / h);
              h = 60;
            }

            var w2 = img.file.width * (w / img.w);
            var h2 = img.file.height * (h / img.h);
            var x = img.x * (w2 / img.file.width);
            var y = img.y * (h2 / img.file.height);

            typeButton.innerHTML = '<div style=\'width: ' + w + 'px; height: ' + h + 'px;\'><img style=\'position: absolute; left: ' + -x + 'px; top: ' + -y + 'px; width: ' + w2 + 'px; height: ' + h2 + 'px;\' src=\'' + (img.file.toDataURL ? img.file.toDataURL() : img.file.src) + '\' /></div>';
            $(typesWindow).append(typeButton);
            typeButton.onclick = function () {
              $('.TabSelected').css('background-color', '#99cccc');
              $('.editorTypeButton').removeClass('TabSelected');
              $(this).addClass('TabSelected');
              $(this).css('background-color', '#ccffcc');
              var id = this.id.split('_')[1];
              $('.editorTypeClass').hide();
              $('#mapEditorTypeButtons' + id).show();
              editor.selectedItemType = undefined;
              editor.randomTree = false;
              game.selectedUnits = [];
              soundManager.playSound(SOUND.CLICK);
            };

            for (var k = 0; k < types[i].length; k++) {
              if (!types[i][k].isDefault && types[i][k].getTitleImage) // not generate buttons for default (= default ground textures), they are created randomly at map load and can not be placed manually
              {
                var img = types[i][k].getTitleImage();
                var button = document.createElement('button');
                win.appendChild(button);
                button.id = 'editorTypeButton_' + i + '_' + k;
                button.className = 'editorTypeButton';
                button.title = types[i][k].name + (types[i][k].description ? ' - ' + types[i][k].description : '');
                button.type_ = types[i][k];

                var w = img.w;
                var h = img.h;
                if (w > h) {
                  h = 60 * (h / w);
                  w = 60;
                } else {
                  w = 60 * (w / h);
                  h = 60;
                }

                var w2 = img.file.width * (w / img.w);
                var h2 = img.file.height * (h / img.h);
                var x = img.x * (w2 / img.file.width);
                var y = img.y * (h2 / img.file.height);
                button.innerHTML = '<div style=\'width: ' + w + 'px; height: ' + h + 'px;\'><img style=\'position: absolute; left: ' + -x + 'px; top: ' + -y + 'px; width: ' + w2 + 'px; height: ' + h2 + 'px;\' src=\'' + (img.file.toDataURL ? img.file.toDataURL() : img.file.src) + '\' /></div>';

                button.onclick = function () {
                  editor.randomTree = false;
                  editor.selectedItemType = this.type_;
                  game.selectedUnits = [];
                  soundManager.playSound(SOUND.CLICK);
                };
              }
            }
          }

          for (var treeIndex in this.trees) {
            if (treeIndex != 'fullList') {
              var tree = this.trees[treeIndex][0];
              var treeSize = tree.sizeX;
              var treeIconIndex = 0;
              var button = document.createElement('button');
              if (treeSize == 1) {
                treeIconIndex = 0;
              } else if (treeSize == 2) {
                treeIconIndex = 5;
              } else if (treeSize == 3) {
                treeIconIndex = 7;
              }
              button.randomTree = true;
              button.title = 'Places a ' + treeSize + 'x' + treeSize + ' random tree!';
              button.className = 'editorTypeButton';
              button.randomTreeSize = treeSize;
              button.treeIconIndex = treeIconIndex;
              button.type_ = tree;

              $('#mapEditorTypeButtons2').append(button);

              var img = tree.getTitleImage();
              var w = img.w;
              var h = img.h;

              if (w > h) {
                h = 60 * (h / w);
                w = 60;
              } else {
                w = 60 * (w / h);
                h = 60;
              }
              var w2 = img.file.width * (w / img.w);
              var h2 = img.file.height * (h / img.h);
              var x = img.x * (w2 / img.file.width);
              var y = img.y * (h2 / img.file.height);
              button.innerHTML = '<div style=\'width: ' + w + 'px; height: ' + h + 'px;\'><img style=\'position: absolute; left: ' + -x + 'px; top: ' + -y + 'px; width: ' + w2 + 'px; height: ' + h2 + 'px;\' src=\'' + (img.file.toDataURL ? img.file.toDataURL() : img.file.src) + '\' /></div><span style=\'position: absolute; top: 0; left: 0; font-size: 16px;\'>Random ' + treeSize + 'x' + treeSize + ' tree</span>';

              button.onclick = function () {
                editor.randomTree = true;
                editor.selectedItemType = this.type_;
                game.selectedUnits = [];
                soundManager.playSound(SOUND.CLICK);
              };
            }
          }
        };

        MapEditor.prototype.reload = function (map = game.export_(false)) {
          game = new Game();
          game.loadMap(map, null, null, null, true);
          worker.postMessage({ what: 'start-game', editorLoad: true, game_state: GAME.EDITOR, map, players: null });
        };

        // remove a unity/entity/tile/building (MapObject) from all context
        // accepts a single entity or an array
        MapEditor.prototype.removeObjects = function (mapObjects, saveHistory) {
          var units = [];
          if (mapObjects.constructor === Array) {
            for (var i = 0; i < mapObjects.length; i++) {
              var u = mapObjects[i];

              if (saveHistory) {
                editor.clipboard.history.addObject(u, 'DeleteMapObject');
              }

              if (u.id) {
                units.push({ hasId: true, id: u.id });
              } else {
                units.push({ hasId: false, x: u.pos.px, y: u.pos.py, type: u.type.name });
              }

              if (u.type.isBuilding) {
                game.buildings.erease(u);
                game.buildings2.erease(u);
              } else if (u.type.isUnit) {
                game.units.erease(u);
              } else if (u.type.isGround) {
                game.groundTiles2.erease(u);
              } else if (u.type.blocking) {
                game.blockingTiles.erease(u);
              }

              // unblock fields in game block array (if building or tile and non-blocking)
              if ((u.type.isBuilding || u.type.isTile) && !u.type.ignoreGrid) {
                u.switchBlockingTotal(false);
              }
            }
            worker.postMessage({ what: 'deleteUnitEditor', units: units });
          } else {
            var u = mapObjects;
            if (u.id) {
              units.push({ hasId: true, id: u.id });
            } else {
              units.push({ hasId: false, x: u.pos.px, y: u.pos.py, type: u.type.name });
            }

            if (u.type.isBuilding) {
              game.buildings.erease(u);
              game.buildings2.erease(u);
            } else if (u.type.isUnit) {
              game.units.erease(u);
            } else if (u.type.isGround) {
              game.groundTiles2.erease(u);
            } else if (u.type.blocking) {
              game.blockingTiles.erease(u);
            }

            // unblock fields in game block array (if building or tile and non-blocking)
            if ((u.type.isBuilding || u.type.isTile) && !u.type.ignoreGrid) {
              u.switchBlockingTotal(false);
            }
            worker.postMessage({ what: 'deleteUnitEditor', units: units });
          }
        };

        // gets called every frame, newClick = true, when onmousedown
        MapEditor.prototype.click = function (x, y, newClick, code) {
          if (y < HEIGHT - 212) // if click in map
          {
            const mouseGameX = (x + game.cameraX) / FIELD_SIZE;
            const mouseGameY = (y + game.cameraY) / FIELD_SIZE;
            // TODO: Make field into const
            var field = game.getFieldFromPos(mouseGameX, mouseGameY, this.terrainModifier == 0 || this.selectedItemType);

            if (code == 1) // if left click
            {
              const fieldDiagonal = field.getExactCopy().mirror(game.x, game.y, true, true);
              const fieldHorizontal = field.getExactCopy().mirror(game.x, game.y, true, false);
              const fieldVertical = field.getExactCopy().mirror(game.x, game.y, false, true);

              let fields;
              switch (this.mirroring) {
                case this.MirroringMode.NONE:
                  fields = [field];
                  break;
                case this.MirroringMode.DIAGONAL:
                  fields = [field, fieldDiagonal];
                  break;
                case this.MirroringMode.HORIZONTAL:
                  fields = [field, fieldHorizontal];
                  break;
                case this.MirroringMode.VERTICAL:
                  fields = [field, fieldVertical];
                  break;
                case this.MirroringMode.FOURWAYS:
                  fields = [field, fieldDiagonal, fieldHorizontal, fieldVertical];
                  break;
              }

              // get field
              var blocked = false;

              if (this.clipboard.copyclipboard) {
                this.clipboard.copyclipboard = null;
                return; // wont need to waste
              }

              var tree = undefined;
              if (this.randomTree && this.selectedItemType) {
                var listName = this.selectedItemType.sizeX + '_' + this.selectedItemType.sizeY;
                tree = this.trees[listName][Math.floor(Math.random() * this.trees[listName].length)];
              }

              fields.forEach((element) => {
                var msg = {
                  what: 'editorClick',
                  x: element.px,
                  y: element.py,
                  type: this.selectedItemType ? this.selectedItemType.name : null,
                  playerIndex: this.player,
                  heightMod: this.terrainModifier,
                  startHeight: this.startHeight,
                  newClick: newClick,
                };

                if (tree) {
                  msg.type = tree.name;
                }
                worker.postMessage(msg);
              });

              // if we clicked on a unit, that is selected, enable dragging
              if (newClick) {
                var clickedUnit = game.getUnitAtPosition((x + game.cameraX) / FIELD_SIZE, (y + game.cameraY) / FIELD_SIZE);
                this.almostDragging = clickedUnit && clickedUnit.type.isUnit && game.selectedUnits.contains(clickedUnit);
                this.dragging = false;
                this.draggStartPos = new Field(x, y, true);

                // save all original positions
                this.draggingUnitsOriginalpositions = [];
                for (var i = 0; i < game.selectedUnits.length; i++) {
                  this.draggingUnitsOriginalpositions.push(game.selectedUnits[i].pos.getCopy());
                }
              }

              if (this.almostDragging && (x != this.draggStartPos.px || y != this.draggStartPos.py)) {
                this.almostDragging = false;
                this.dragging = true;
              }

              if (this.dragging) {
                var offsetp = new Field((x - this.draggStartPos.x) / FIELD_SIZE, (y - this.draggStartPos.y) / FIELD_SIZE, true);
                var offset = new Field(Math.floor((x - this.draggStartPos.x) / FIELD_SIZE), Math.floor((y - this.draggStartPos.y) / FIELD_SIZE));

                for (var i = 0; i < game.selectedUnits.length; i++) {
                  var unit = game.selectedUnits[i];
                  if (unit.type.isUnit) {
                    var field = unit.type.getNextFreePositionFrom(this.draggingUnitsOriginalpositions[i].add(offsetp));
                    worker.postMessage({ what: 'changeUnitPos', x: field.px, y: field.py, id: unit.id });
                  }
                }
              }
            } else if (code == 3) // right click (set waypoint, if possible)
            {
              for (var i = 0; i < game.selectedUnits.length; i++) {
                if (game.selectedUnits[i].type.canHaveWaypoint) {
                  var u = game.selectedUnits[i];

                  if (keyManager.interfaceHotkeyPressed('queue')) {
                    if (u.waypoint.length < 19) {
                      u.waypoint.push(field);
                    }
                  } else {
                    u.waypoint = [field];
                  }

                  var arr = [];
                  for (var k = 0; k < u.waypoint.length; k++) {
                    arr.push(u.waypoint.px, u.waypoint.py);
                  }

                  worker.postMessage({ what: 'setWP', id: game.selectedUnits[i].id, waypoint: arr });
                }
              }
            }
          }
        };

        function higherTerrain() {
          editor.selectedItemType = null;
          editor.terrainModifier = 1;
        };

        function lowerTerrain() {
          editor.selectedItemType = null;
          editor.terrainModifier = -1;
        };

        function addRamp() {
          editor.selectedItemType = null;
          editor.terrainModifier = 0.5;
        };

        function killRamp() {
          editor.selectedItemType = null;
          editor.terrainModifier = -0.5;
        };

        MapEditor.prototype.updateMirroringMode = function (mode) {
          if (!isNaN(mode)) {
            this.mirroring = mode;
          } else {
            this.mirroring = (this.mirroring + 1) % Object.keys(this.MirroringMode).length;
          }

          const mirrorButtonData = {
            [this.MirroringMode.NONE]: {
              image: '../play/imgs/mirror-none.png',
              title: `Mirroring mode is not enabled

			Click to mirror map object placement diagonally`,
            },
            [this.MirroringMode.DIAGONAL]: {
              image: '../play/imgs/mirror-diagonal.png',
              title: `Mirroring diagonally

			Click to mirror map object placement horizontally`,
            },
            [this.MirroringMode.HORIZONTAL]: {
              image: '../play/imgs/mirror-horizontal.png',
              title: `Mirroring horizontally

			Click to mirror map object placement vertically`,
            },
            [this.MirroringMode.VERTICAL]: {
              image: '../play/imgs/mirror-vertical.png',
              title: `Mirroring vertically

			Click to mirror map object placement four ways`,
            },
            [this.MirroringMode.FOURWAYS]: {
              image: '../play/imgs/mirror-4way.png',
              title: `Mirroring four ways

			Click to disable map mirroring`,
            },
          };

          $('#mirrorButton').css('background', `url(${mirrorButtonData[this.mirroring].image})`);
          $('#mirrorButton').css('background-size', '100% 100%');
          $('#mirrorButton').tooltip('option', 'content', mirrorButtonData[this.mirroring].title);
        };

        MapEditor.prototype.keyPressed = function (key) {
          switch (key) {
            case KEY.DELETE:
            case KEY.BACKSPACE:
            case KEY.E:
              this.removeObjects(game.selectedUnits, true);
              break;
            // case KEY.U: this.clipboard.history.undo(); break;
            // case KEY.Q: this.clipboard.history.debug(); break;
            case KEY.A: killRamp(); break;
            case KEY.S: addRamp(); break;
            case KEY.D: higherTerrain(); break;
            case KEY.F: lowerTerrain(); break;
            case KEY.Q: testMap(); break;
            case KEY.G: this.updateMirroringMode(); break;
            default: return;
          }

          soundManager.playSound(SOUND.CLICK);
        };

        MapEditor.prototype.draw = function () {
          game.draw();

          // if im with some copy on my clipboard
          // disabled for now, this will aways be null for now

          if (this.clipboard.copyclipboard) {
            /*
            var selected = this.clipboard.copyclipboard.units;
            var relativeUnit = this.clipboard.copyclipboard.relativeUnit; // this will be used to coordinates to other guys
            var references = this.clipboard.copyclipboard.reference;
        
            var ct = selected.length; // recursive while loop, way faster then for loops for JS. good for rendering
            while(ct--) {
        
              var thisUnit = selected[ct].type;
              var field = thisUnit.getFieldFromMousePos();
              var hm = game.getHMValue4(field.x, field.y);
        
              var difX = references[ct].x;
              var difY = references[ct].y;
              // if its a building or a doodle
              if(thisUnit.isBuilding || thisUnit.isTile)
              {
                c.globalAlpha = 0.5;
                thisUnit.draw(thisUnit.ignoreGrid ? keyManager.x + game.cameraX : field.x, thisUnit.ignoreGrid ? keyManager.y + game.cameraY : field.y - hm * CLIFF_HEIGHT);
                c.globalAlpha = 1;
              // its a unit
        
        
            }
            else
            {
              c.globalAlpha = 0.5;
              thisUnit.draw(keyManager.x + game.cameraX + difX, keyManager.y + game.cameraY + difY);
              c.globalAlpha = 1;
            }
        
            vtester called this
            i will remove when implemented
        
          }
          */
          }
          // draw current Item @ mouse pos, if we have selected a type
          else if (this.selectedItemType && keyManager.y < HEIGHT - 212) {
            // if its a building or doodad
            if (this.selectedItemType.isBuilding || this.selectedItemType.isTile) {
              var field = this.selectedItemType.getFieldFromMousePos();
              var hm = game.getHMValue4(field.x, field.y);

              // draw
              c.globalAlpha = 0.5;
              this.selectedItemType.draw(this.selectedItemType.ignoreGrid ? keyManager.x + game.cameraX : field.x, this.selectedItemType.ignoreGrid ? keyManager.y + game.cameraY : field.y - hm * CLIFF_HEIGHT);
              c.globalAlpha = 1;

              // draw red box with alpha over the image when blocked, otherwise white alpha, for every grid field the building covers
              if (!this.selectedItemType.ignoreGrid) {
                for (x = field.x; x < field.x + this.selectedItemType.sizeX; x++) {
                  for (y = field.y; y < field.y + this.selectedItemType.sizeY; y++) {
                    var f = new Field(x, y);
                    var distanceAllowed = true;
                    var nextGoldmine = game.getNextBuildingOfType(f, null, false, 'startGold');
                    var nextCC = game.getNextBuildingOfType(f, null, false, 'takesGold');

                    if (this.selectedItemType.takesGold && nextGoldmine && nextGoldmine.pos.distanceTo2(f) < game.getMineDistance()) {
                      distanceAllowed = false;
                    }

                    if (this.selectedItemType.startGold && nextCC && nextCC.pos.distanceTo2(f) < game.getMineDistance()) {
                      distanceAllowed = false;
                    }

                    c.fillStyle = (game.fieldIsBlockedForBuilding(f.x, f.y) || !distanceAllowed) ? 'rgba(200, 0, 0, 0.25)' : 'rgba(' + game.theme.line_red + ', ' + game.theme.line_green + ', ' + game.theme.line_blue + ', 0.3)';
                    c.fillRect((f.x - 1) * FIELD_SIZE - game.cameraX, (f.y - 1 - hm * CLIFF_HEIGHT) * FIELD_SIZE - game.cameraY, FIELD_SIZE, FIELD_SIZE);
                  }
                }
              }
            }

            // if its a unit
            else {
              c.globalAlpha = 0.5;
              this.selectedItemType.draw(keyManager.x + game.cameraX, keyManager.y + game.cameraY);
              c.globalAlpha = 1;
            }
          }
          // terrain editor transparent tile to show where its gonna be built
          else if (this.terrainModifier != 0) {
            var f = 'Tree 1'.toUnitType().getFieldFromMousePos();

            c.fillStyle = 'rgba(' + game.theme.line_red + ', ' + game.theme.line_green + ', ' + game.theme.line_blue + ', 0.3)';
            c.fillRect((f.x - 1) * FIELD_SIZE - game.cameraX, (f.y - 1 - game.getHMValue4(f.x, f.y) * CLIFF_HEIGHT) * FIELD_SIZE - game.cameraY, FIELD_SIZE, FIELD_SIZE);
          }

          // refresh mouse cursor pos display
          var field = game.getFieldFromPos();
          $('#cursorPosDiv').html('X: ' + (Math.round(field.px * 100) / 100) + '<br />Y: ' + (Math.round((field.py - 0.2) * 100) / 100));
        };

        function MapEditorClipboard() {
          this.history = new History();
          this.copyclipboard = null;
          this.date = new Date();
        }

        // controls history for mapeditor
        function History() {
          this.actions = [];
        }

        // places a Tile object (code/Tile.js) on a history to be removed on control.z later
        History.prototype.addObject = function (tileObject, actionType) {
          // // Disabled UNDO for height , as its not 100 %
          // if(actionType=="ChangeHeight")
          // return;
          if (actionType == null || actionType == undefined) {
            actionType = 'PlaceMapObject';
          }
          var historyObject = {
            obj: tileObject,
            type: actionType,
            time: editor.clipboard.date.getTime(),
          };
          this.actions.push(historyObject);
          if (this.actions.length > 100) { // max history saved
            this.actions.shift();
          }
        };

        // disabled, button is commented in UI
        // its not fully working yet
        MapEditorClipboard.prototype.copy = function () {
          if (game.selectedUnits == null || game.selectedUnits == undefined || game.selectedUnits.length == 0) {
            return;
          }
          // calculating X Y differences for reference
          var differences = [];
          for (var x = 0; x < game.selectedUnits.length; x++) {
            var unit = game.selectedUnits[x];
            differences.push({
              x: unit.pos.px - game.selectedUnits[0].pos.px,
              y: unit.pos.py - game.selectedUnits[0].pos.py,
            });
          }
          var copy = {
            multiSelect: true,
            units: game.selectedUnits,
            relativeUnit: game.selectedUnits[0],
            reference: differences,
          };
          this.copyclipboard = copy;
        };

        History.prototype.debug = function () {
          console.log('------------');
          for (var x = 0; x < this.actions.length; x++) {
            var action = this.actions[x];
            console.log(action);
          }
        };

        History.prototype.undo = function () {
          if (this.actions.length > 0) {
            var action = this.actions[this.actions.length - 1];
            var u = action.obj;
            if (action.type == undefined || action.type == 'PlaceMapObject') {
              editor.removeObjects(u);
              // undoing a delete action
            } else if (action.type == 'DeleteMapObject') {
              soundManager.playSound(SOUND.PLACE);
              var field = u.pos;
              var type = u.type;
              var owner = u.owner;
              var newObj = null;
              if (u.type.isUnit) {
                newObj = new Unit({ x: field.px, y: field.py, type: type, owner: owner, noHistory: true });
              } else if (u.type.isBuilding) {
                newObj = new Building({ x: field.x, y: field.y, type: type, owner: owner, noHistory: true });
              } else if (u.type.isGround || u.type.blocking) {
                newObj = new Tile({ x: field.x, y: field.y, type: type, dontRefreshNBs: false, noHistory: true });
                newObj.pos.px = u.pos.px;
                newObj.pos.py = u.pos.py;
                if (u.type.isGround) {
                  var img = u.type.getTitleImage();
                  game.groundTilesCanvas.getContext('2d').drawImage(img.file, img.x, img.y, img.w, img.h, Math.floor(u.drawPos.px * 16 - img.width / 2), Math.floor((u.drawPos.py + 2) * 16 - img.height / 2), img.w, img.h);
                } else if (u.type.blocking) {
                  game.refreshBlockingTilesCanvas(field.y);
                  game.sortTiles();
                }
              }

              // searching if this placement is in history
              // so the new created object keep tracks of its older action
              // with its new instance, so the undo will work as if the instance was the same
              for (var x = 0; x < this.actions.length; x++) {
                var action = this.actions[x];
                if (action.type == 'PlaceMapObject' || action.type == undefined) {
                  if (action.obj == u) {
                    this.actions[x] = {
                      obj: newObj, type: 'PlaceMapObject',
                    };
                  }
                }
              }
            } else if (action.type == 'ChangeHeight') {
              var change = u;
              game.setHMValue(change.x, change.y, change.oldHeight, true);
              worker.postMessage('setHMValue$' + change.x + '$' + change.y + '$' + change.oldHeight);
              worker.postMessage('cliffSBeenPlaced2$' + change.x + '$' + change.y + '$' + change.oldHeight);

              // a tricky part here
              // we are going to look for other HM changes in the past 100ms and undo them too !
              // because each change height, gets called about 5 times
              var ct = this.actions.length;
              ct -= 1; // removing this current action
              var indexesToRemove = [];
              while (ct--) {
                var older = this.actions[ct];
                if (older.type == 'ChangeHeight' && (editor.clipboard.date.getTime() - older.time) < 100) {
                  indexesToRemove.push(ct);
                  game.setHMValue(change.x, change.y, change.oldHeight, true);
                  worker.postMessage('setHMValue$' + change.x + '$' + change.y + '$' + change.oldHeight);
                  worker.postMessage('cliffSBeenPlaced2$' + change.x + '$' + change.y + '$' + change.oldHeight);
                }
              }
              // removing from history the undone HM changes
              for (var i = 0; i < indexesToRemove.length; i++) {
                this.actions.splice(indexesToRemove[i], 1);
              }
              game.makeCliffs(change.x - 2, change.y - 2, change.x + 2, change.y + 2);
              console.log(game.getHMValue(change.x, change.y));
              // worker.postMessage("setHMValue$" + change.x+ "$" + change.y+ "$" + change.oldHeight);
              // worker.postMessage("cliffSBeenPlaced2$" + change.x + "$" + change.y + "$" + change.oldHeight);
              // game.sortTiles();
            }
            var index = this.actions.indexOf(action);
            this.actions.splice(index, 1);
          }
        };

        // playes music
        function MusicManager() {
          this.volume = LocalConfig.registerValue('music_volume', DEFAULT_VOLUME);
          this.noMainMenuMusic = LocalConfig.registerValue('no_main_menu_music', false);

          soundManager.volume.onChange((volume) => this.setSoundVolume(volume));
          this.volume.onChange((volume) => this.setMusicVolume(volume));

          this.ingameMusic = [
            new Audio('music/ingame1.ogg'),
            new Audio('music/ingame3.ogg'),
            new Audio('music/ingame5.ogg'),
            new Audio('music/ingame6.ogg'),
            new Audio('music/opening.ogg'),
            new Audio('music/BrightGameTheme.ogg'),
            new Audio('music/TheOldGods.ogg'),
            new Audio('music/Vengeance.ogg'),
          ];

          this.defeatMusic = [
            new Audio('music/defeat.ogg'),
          ];

          this.victoryMusic = [
            new Audio('music/victory.ogg'),
          ];

          this.menuMusic = [
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu.ogg'),
            new Audio('music/menu2.ogg'),
          ];

          this.ambient = [
            new Audio('sounds/ambient/ambient1.ogg'),
          ];

          this.rain = [
            new Audio('sounds/ambient/rain.ogg'),
            new Audio('sounds/ambient/rain.ogg'),
          ];

          this.currentMusic = null;
          this.lastGameState = null;
          this.isMusicPlaying = false;
          this.bindEvents();
        };

        MusicManager.prototype.bindEvents = function () {
          _.each([this.ingameMusic, this.defeatMusic, this.menuMusic], function (musics) {
            for (var i = 0; i < musics.length; i++) {
              musics[i].addEventListener('ended', function () {
                setTimeout(function () {
                  musicManager.playMusic();
                }, 3000);
              });

              musics[i].addEventListener('canplaythrough', function () {
                if (!musicManager.currentMusic) {
                  musicManager.playMusic();
                }
              });

              musics[i].volume = 0.5;
              musics[i].loop = false;
            }
          });

          this.ambient[0].loop = true;
        };

        MusicManager.prototype.setMusicVolume = function (volume) {
          _.each([this.ingameMusic, this.defeatMusic, this.menuMusic, this.victoryMusic], function (musics) {
            for (var i = 0; i < musics.length; i++) {
              musics[i].volume = 0.7 * volume;
            }
          });
        };

        MusicManager.prototype.setSoundVolume = function (volume) {
          this.ambient[0].volume = 0.4 * volume;
        };

        // start playing a song; checks which song has to be played and plays it; gets called on game start or when music is turned on
        MusicManager.prototype.playMusic = function () {
          if (!(this.volume.get() > 0)) {
            return;
          }

          var music = this.getMusicFromGameState();

          if (!music) {
            return;
          }

          var rand = Math.floor(Math.random() * 1000) % music.length;
          for (var i = 0; i < music.length; i++) {
            var musicPiece = music[(rand + i) % music.length];
            if (musicPiece.readyState == 4) {
              musicPiece.currentTime = 0;
              const playAndRetry = () => {
                musicPiece.play()
                  .then(() => this.isMusicPlaying = true)
                  .catch(() => {
                    if (!this.isMusicPlaying) {
                      setTimeout(playAndRetry, 50);
                    }
                  });
              };
              playAndRetry();

              i = 999;
              this.currentMusic = music;
            }
          }
        };

        // stop playing music (called when music is turned off)
        MusicManager.prototype.stopMusic = function () {
          _.each([this.ingameMusic, this.defeatMusic, this.victoryMusic, this.menuMusic], function (musics) {
            for (var i = 0; i < musics.length; i++) {
              musics[i].pause();
            }
          });

          this.currentMusic = null;
          this.isMusicPlaying = false;
        };

        // return the array which holds the music that is to be played, depending on the current game state
        MusicManager.prototype.getMusicFromGameState = function () {
          if (game_state == GAME.SKIRMISH || game_state == GAME.LOBBY || game_state == GAME.LOGIN || game_state == GAME.REGISTER || game_state == GAME.RECOVERY) {
            return this.noMainMenuMusic.get() ? null : this.menuMusic;
          }

          if (game_state == GAME.EDITOR) {
            return null;
          }

          if (game_state == GAME.PLAYING && game.gameHasEnded && game.playingPlayerWon) {
            return this.victoryMusic;
          }

          if (game_state == GAME.PLAYING && game.gameHasEnded && !game.playingPlayerWon) {
            return this.defeatMusic;
          }

          return this.ingameMusic;
        };

        // is called every frame, doesnt really "draw" anythiing, but checks if music has to be switched
        MusicManager.prototype.draw = function () {
          // get state of game (regarding the music)
          var newMusic = this.getMusicFromGameState();

          var gameStateHasChangedAndItsIngameMusic = game_state != this.lastGameState && newMusic == this.ingameMusic;

          // ambient sound has to start (we entered a game)
          if (game_state == GAME.PLAYING && this.lastGameState != GAME.PLAYING && soundManager.volume.get() > 0) {
            this.ambient[0].play();
          }

          // ambient sound has to stop (we left a game)
          if (game_state != GAME.PLAYING && this.lastGameState == GAME.PLAYING) {
            this.ambient[0].pause();
            this.rain[0].pause();
            this.rain[1].pause();
          }

          // save this game state for next time
          this.lastGameState = game_state;

          if (!(this.volume.get() > 0)) {
            return;
          }

          // if game state has changed, music has to change
          if (newMusic != this.currentMusic || gameStateHasChangedAndItsIngameMusic) {
            this.stopMusic();

            if (newMusic) {
              this.playMusic();
            }
          }
        };

        const musicManager = new MusicManager();

        function Network() {
          this.pings = []; // contains the last ~10 ping values, when a new one comes, the oldest one gets killed
          this.EXTRA_DELAY = 2;

          this.onOpenCallbacks = [];
          this.onFirstOpenCallbacks = [];
          this.listeners = {};
          this.jsonListeners = {};

          Initialization.onDocumentReady(() => this.reset(true));
        };

        // Removes all information specific to the current player and reconnects to the server
        // Retains all of the callbacks and listeners and runs the onOpen callbacks upon connection
        Network.prototype.reset = function (firstConnection = false) {
          if (this.socket) {
            this.socket.close();
          }

          this.firstConnection = firstConnection;
          this.connected = false;
          this.onMapFile = () => { };

          // connect to server and define all the callbacks
          try {
            this.socket = new WebSocket(SERVER_ADRESS);
            this.socket.onmessage = (data) => this.onmessage(data);
            this.socket.onopen = () => this.onopen();
            this.socket.onclose = () => this.onclose();
            this.socket.onerror = () => this.onclose();
          } catch (e) {
            alert('You browser seems to not support Websockets. Websockets, however, are required to run this game.');
            throw new Error(e);
          }
        };

        // Registers a callback to be called whenever a new network connection is established
        Network.prototype.registerOnOpen = function (callback) {
          this.onOpenCallbacks.push(callback);
        };

        Network.prototype.registerOnFirstOpen = function (callback) {
          this.onFirstOpenCallbacks.push(callback);
        };

        // Registers a callback to be called when a message arrives with matching messageType and game_state matches requiredGameState
        // requiredGameState may be null, in which case the callback will be called regardless of game_state, or an array
        // Multiple listeners should not be registered to run at the same time!
        Network.prototype.registerListener = function (requiredGameState, messageType, callback) {
          let requiredGameStates;
          if (requiredGameState == null) {
            requiredGameStates = [-1];
          } else if (Array.isArray(requiredGameState)) {
            requiredGameStates = requiredGameState;
          } else {
            requiredGameStates = [requiredGameState];
          }

          requiredGameStates.forEach((gameState) => {
            if (!(gameState in this.listeners)) {
              this.listeners[gameState] = {};
            }

            this.listeners[gameState][messageType] = callback;
          });
        };

        // Same as above, but registers a json listener.
        // Registers a callback to be called when a message arrives with matching messageType and game_state matches requiredGameState
        // requiredGameState may be null, in which case the callback will be called regardless of game_state, or an array
        // Multiple listeners should not be registered to run at the same time!
        Network.prototype.registerJSONListener = function (requiredGameState, messageType, callback) {
          let requiredGameStates;
          if (requiredGameState == null) {
            requiredGameStates = [-1];
          } else if (Array.isArray(requiredGameState)) {
            requiredGameStates = requiredGameState;
          } else {
            requiredGameStates = [requiredGameState];
          }

          requiredGameStates.forEach((gameState) => {
            if (!(gameState in this.jsonListeners)) {
              this.jsonListeners[gameState] = {};
            }

            this.jsonListeners[gameState][messageType] = callback;
          });
        };

        // Invokes the registered listener corresponding to the incoming server message
        // Returns true if a callback was found and called, and false otherwise
        Network.prototype.invokeListener = function (splitMsg) {
          const messageType = splitMsg[0];

          // Check the listeners that don't care about game state, and those that care about the current game state
          const indices = [-1, game_state];
          let foundListener = false;
          for (let i in indices) {
            const index = indices[i];

            if (this.listeners[index] && messageType in this.listeners[index]) {
              this.listeners[index][messageType](splitMsg);
              foundListener = true;
            }
          }

          return foundListener;
        };

        Network.prototype.invokeJSONListener = function (json) {
          const messageType = json.message;
          const indices = [-1, game_state];
          let foundListener = false;
          for (const i in indices) {
            const index = indices[i];

            if (this.jsonListeners[index] && messageType in this.jsonListeners[index]) {
              this.jsonListeners[index][messageType](json.properties);
              foundListener = true;
              return foundListener;
            }
          }
          return foundListener;
        };

        Network.prototype.onopen = function () {
          this.connected = true;
          this.onOpenCallbacks.forEach((callback) => callback());
          if (this.firstConnection) {
            this.onFirstOpenCallbacks.forEach((callback) => callback());
          }

          const expVal = localStorage.exp;
          if (expVal) {
            this.send('exp-update<<$' + expVal + '<<$' + expVal);
          }
        };

        Network.prototype.onclose = function () {
          this.connected = false;
          this.failedConnection();
        };

        Network.prototype.onmessage = function (data, flags) {
          var msg = data.data;

          var splitMsg = msg.split('<<$');
          // console.log(`msg: ${splitMsg[0]} state ${game_state}`);

          this.invokeListener(splitMsg);

          // server msg
          if (splitMsg[0] == 'server-info') {
            displayInfoMsg(splitMsg[1]);
          }

          if (splitMsg[0] == 'setExp_') {
            localStorage.exp = splitMsg[1];
          } else if (splitMsg[0] == 'unlock-emotes') {
            unlockEmote(splitMsg[1], splitMsg[2]);
          } else if (splitMsg[0] == 'achivement-unlocked') {
            unlockAchivement(splitMsg[1]);
          } else if (splitMsg[0] == 'level-up') {
            levelUp(splitMsg);
          } else if (splitMsg[0] == 'custom-map-editor-file') {
            const canEditMap = splitMsg[2] == '1';
            if (!canEditMap) {
              displayInfoMsg('You can only edit your own maps or unlocked maps!');
              return;
            }

            this.onMapFile = (map) => {
              map.img = splitMsg[1];

              uimanager.showLoadingScreen(map);

              setTimeout(() => {
                game = new Game();
                game.loadMap(map, null, null, null, true);
                worker.postMessage({ what: 'start-game', editorLoad: true, map, network_game, game_state, networkPlayerName });
              }, 50);
            };
          } else if (splitMsg[0] == 'custom-map-replay-file') {
            this.onMapFile = async (map) => {
              if (map.timestamp != replayFile.mapVersion) {
                displayInfoMsg(
                  'This replay was made with an older map version so it might be buggy.',
                );
              } else if (replayFile.gameVersion != GAME_VERSION) {
                displayInfoMsg(
                  `This replay was recorded in version ${replayFile.gameVersion}. ` +
                  `The current game version is ${GAME_VERSION} so it might be buggy.`,
                );
              }

              const hasCustomAI = replayFile.players.some(
                (p) => p.ai_name && p.ai_name.startsWith('Custom AI'),
              );
              if (hasCustomAI) {
                displayInfoMsg(
                  'This replay was played with a custom AI. If the same custom AI ' +
                  'is not loaded, the replay may be buggy.',
                );
              }

              const customAINames = AIManager.getNames(/* includeRegularAI=*/false,
          /* includeCustomAI=*/true);
              for (const p of replayFile.players) {
                if (!p.controller == CONTROLLER.COMPUTER || !p.ai_name) continue;

                // Make sure there is _a_ custom AI loaded in the same slot
                if (p.ai_name.startsWith('Custom AI')) {
                  if (!customAINames.includes(p.ai_name)) {
                    displayInfoMsg(
                      'This replay was played with a custom AI, but there is no ' +
                      'custom AI loaded in the same slot.',
                    );
                    return;
                  }
                  continue;
                }

                // The AI may have to be loaded if it was on a different commit
                if (p.ai_name != 'Default') {
                  const success = await AIManager.loadAI(replayFile.aiCommit, p.ai_name);
                  if (!success) {
                    displayInfoMsg(`Failed to load AI with name ${p.ai_name} and commit ${replayFile.aiCommit} in replay file`);
                    return;
                  }
                }
              }

              network.send('cancel-ladder');
              fadeOut($('#ladderWindow'));

              const p = replayFile.players.concat([{ name: networkPlayerName, controller: CONTROLLER.SPECTATOR, team: 0, isPlayingPlayer: true }]);

              map.img = getImageFromMap(map);
              uimanager.showLoadingScreen(map, p);

              setTimeout(() => {
                game_state = GAME.PLAYING;

                game = new Game();
                game.loadMap(map, p, replayFile.aiRandomizer, replayFile.ticksCounter, false, false, replayFile.messages);
                worker.postMessage({
                  what: 'start-game',
                  map: map,
                  players: p,
                  network_game: network_game,
                  game_state: game_state,
                  networkPlayerName: networkPlayerName,
                  aiCommit: replayFile.aiCommit,
                  aiRandomizer: replayFile.aiRandomizer,
                  ticksCounter: replayFile.ticksCounter,
                  incomingOrders: replayFile.orders,
                  playerLefts: replayFile.playerLefts,
                });

                incomingOrders = replayFile.orders;
                playerLefts = replayFile.playerLefts;
                incomingCameraUpdates = replayFile.cameraUpdates ?? {};

                mapData = '';

                $('#replayShowSpeed').html('1x');
              }, 50);
            };
          } else if (splitMsg[0] == 'achivements-list') {
            showAchievementsWindow(splitMsg[1]);
          } else if (splitMsg[0] == 'gold-reward') {
            displayInfoMsgDarkBG('<p style=\'font-size: 44px;\'>You got <span style=\'color: rgb(255, 255, 99);\'>' + splitMsg[1] + '</span> gold</p><br /><br /><br /><img src=\'imgs/gold2.png\' class=\'pixelated\' style=\'height: 128px;\' />', true);
          }

          // Emotes info
          else if (splitMsg[0] == 'emotes-info') {
            Microtransactions.showEmotesInfo(splitMsg[1], splitMsg[2]);
          } else if (splitMsg[0] == 'skins-info') {
            let skinsObj = null;
            try {
              skinsObj = JSON.parse(splitMsg[2]);
            } catch (e) { }
            if (!skinsObj) {
              skinsObj = {};
            }

            Microtransactions.showSkinsDancesInfo(splitMsg[4], splitMsg[1], skinsObj, splitMsg[3]);
          } else if (splitMsg[0] == 'map-file') {
            // TODO: this is a bit of a hack, we really should have a better messaging format
            let mapData = '';
            for (let i = 1; i < splitMsg.length; i++) {
              mapData += splitMsg[i];
              if (i != splitMsg.length - 1) {
                mapData += '<<$';
              }
            }

            const map = JSON.parse(Compression.decompressFromString(mapData));
            this.onMapFile(map);
          } else if (game_state == GAME.EDITOR) {
            if (msg == 'map-upload-init') {
              var map = game.export_();
              this.send('uploading-map<<$' + JSON.stringify(map) + '<<$' + getImageFromMap(game.export_(true)) + '<<$' + getPlayerCountFromMap(map) + '<<$' + game.description);
            } else if (splitMsg[0] == 'personal-maps') {
              // clear window
              $('#mapWindowSubdiv').html('');

              // display maps
              for (var i = 1; i < splitMsg.length; i++) {
                var p = document.createElement('p');
                p.innerHTML = splitMsg[i] + ' ';

                var b = document.createElement('button');
                b.innerHTML = 'X';
                b.i_ = splitMsg[i];
                b.title = 'delete this map';
                b.onclick = function () {
                  network.send('map-delete-request<<$' + this.i_);
                  soundManager.playSound(SOUND.CLICK);
                };

                p.appendChild(b);
                $('#mapWindowSubdiv').append(p);
              }
            } else if (msg == 'map-has-been-deleted') {
              this.send('request-my-maps');
            }
          } else if (game_state == GAME.LOBBY || game_state == GAME.ACCEPT_AGB || game_state == GAME.SKIRMISH) {
            if (splitMsg[0] == 'start-game' && splitMsg.length >= 4) {
              network.send('cancel-ladder');
              fadeOut($('#ladderWindow'));

              // parse players object
              var obj = JSON.parse(splitMsg[3]);

              // set players object
              var players = obj.players;

              // set playing player
              players[splitMsg[1]].isPlayingPlayer = true;

              // random KI number
              var aiRandomizer = splitMsg[2];

              network_game = true;
              ladder_game = false;

              // show loading screen
              uimanager.showLoadingScreen(LobbyPlayerManager.map, players);

              setTimeout(function () {
                game = new Game();
                game.loadMap(LobbyPlayerManager.map, players, aiRandomizer);
                game_state = GAME.PLAYING;
                mapData = '';
                worker.postMessage({
                  what: 'start-game',
                  map: LobbyPlayerManager.map,
                  players: players,
                  aiCommit: AIManager.getAICommit(),
                  aiRandomizer: aiRandomizer,
                  network_game: network_game,
                  game_state: game_state,
                  networkPlayerName: networkPlayerName,
                });

                // send initial order cycle(s)
                for (var i = 0; i < TICKS_DELAY - 1; i++) {
                  network.send(JSON.stringify({ 'tick': i, 'orders': [] }));
                }
              }, 50);
            } else if (splitMsg[0] == 'custom-map-ladder-file' && splitMsg.length >= 3) {
              $('#ladderWindow')[0].style.display = 'inline';

              this.onMapFile = (map) => {
                map.img = splitMsg[1];

                const aiRandomizer = splitMsg[3];
                const players = JSON.parse(splitMsg[4]).players;
                players[splitMsg[2]].isPlayingPlayer = true;

                network_game = true;
                ladder_game = true;

                let counter = 10;
                new HTMLBuilder()
                  .add('<br><br><p style=\'font-size: 30px;\'>Opponent found, starting game in</p>')
                  .add(`<br><br><p id='ladderStartCounter'>${counter}</p>`)
                  .insertInto('#ladderWindow');

                soundManager.playSound(SOUND.LADDER_START);
                const decrementCounterAndStart = () => {
                  $('#ladderStartCounter').html(counter--);
                  if (counter > 0) {
                    setTimeout(decrementCounterAndStart, 1000);
                    return;
                  }

                  $('#ladderWindow').hide();

                  uimanager.showLoadingScreen(map, players);
                  network.send('load-ladder-map');

                  setTimeout(() => {
                    game = new Game();
                    game.loadMap(map, players, aiRandomizer);
                    game_state = GAME.PLAYING;
                    mapData = '';
                    worker.postMessage({ what: 'start-game', map, players, aiCommit: AIManager.getAICommit(), aiRandomizer, network_game, game_state, networkPlayerName });

                    // Send initial order cycle(s)
                    for (let i = 0; i < TICKS_DELAY - 1; i++) {
                      network.send(JSON.stringify({ tick: i, orders: [] }));
                    }
                  }, 50);
                };
                decrementCounterAndStart();
              };
            } else if (splitMsg[0] == 'bing-msg' && splitMsg.length >= 2) {
              bingMsg(splitMsg[1]);
            } else if (splitMsg[0] == 'lcg-battle') {
              littlechatgame(JSON.parse(splitMsg[1]));
            } else if (splitMsg[0] == 'lcg-rank') {
              var p = document.createElement('p');

              var time = document.createElement('span');
              time.className = 'time';
              time.innerHTML = getFormattedTime() + ' &nbsp;';

              var span = document.createElement('span');

              span.innerHTML = 'Server: Littlechatgame record for ' + splitMsg[1] + ': ' + splitMsg[2] + ' wins / ' + splitMsg[3] + ' losses. Rank: ' + getRankCode(splitMsg[4]) + ' &nbsp;(Global ranking #' + splitMsg[5] + ')';

              p.appendChild(time);
              p.appendChild(span);

              addToChatWindow(p);
            } else if (splitMsg[0] == 'lcg-top') {
              var p = document.createElement('p');

              var time = document.createElement('span');
              time.className = 'time';
              time.innerHTML = getFormattedTime() + ' &nbsp;';

              var span = document.createElement('span');

              span.innerHTML = 'Server: Littlechatgame top ranked players:';

              for (var i = 1; i < splitMsg.length; i += 2) {
                span.innerHTML += '<br />' + Math.ceil(i / 2) + '. ' + splitMsg[i] + ' (' + getRankCode(splitMsg[i + 1]) + ')';
              }

              p.appendChild(time);
              p.appendChild(span);

              addToChatWindow(p);
            } else if (splitMsg[0] == 'chat') {
              // split chat msg and add time
              var display = true;

              // its a command, (theres a "/" at the beginning, so dont display message, but execute command)
              if (splitMsg[3].indexOf('/') === 0) {
                display = false;

                // if its a ping command and we are the sending player
                if (splitMsg[3] == '/ping' && splitMsg[2] == networkPlayerName) {
                  display = true;
                  splitMsg[3] = 'ping: ' + (Date.now() - timeOfLastPingSent) + ' ms';
                }
              }

              if (display && !AccountInfo.ignores.contains(splitMsg[2].toLowerCase())) {
                addChatMsg(splitMsg[2], splitMsg[3], splitMsg[1]);
              }
            }
          } else if (game_state == GAME.PLAYING && network_game) {
            if (splitMsg[0] == 'order-missing') {
              var tickToSend = parseInt(splitMsg[1]);

              // if(lastSentTick >= tickToSend)
              network.send(JSON.stringify({ tick: tickToSend, orders: [] }));

              // console.log("missing order " + tickToSend + " resent");
            } else if (splitMsg[0] == 'chat') {
              if (!AccountInfo.ignores.contains(splitMsg[2].toLowerCase())) {
                var msg_ = splitMsg[2] + ': ' + splitMsg[3];
                game.addChatMsgToLog(msg_);
                // console.log(`Muted: ${game.chat_muted}`);
                if (!game.chat_muted) {
                  interface_.chatMsg(msg_);
                }
              }
            } else if (splitMsg[0] == 'chat-server') {
              soundManager.playSound(SOUND.POSITIVE);
              interface_.addMessage(splitMsg[1], 'yellow', imgs.attentionmarkYellow);
            } else if (splitMsg[0] == 'ping') {
              this.pings.push(Date.now() - timeOfLastPingSent);
              if (this.pings.length > 8) {
                this.pings.splice(0, 1);
              }

              var delayShouldBe = Math.ceil(Math.max.apply(null, this.pings) / TICK_TIME) + this.EXTRA_DELAY + ((PLAYING_PLAYER && PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR) ? 2 : 0);

              if (delayShouldBe > TICKS_DELAY) {
                game.increaseDelayOnNextTick = true;
              } else if (delayShouldBe < TICKS_DELAY) {
                game.reduceDelayOnNextTick = true;
              }
            } else if (splitMsg[0] == 'waiting-for') {
              interface_.addMessage('Waiting for player ' + splitMsg[1], 'yellow', imgs.attentionmarkYellow);
            } else if (msg == 'youve-been-kicked') {
              game_state = GAME.LOBBY;

              // set focus on input
              setChatFocus(true);

              keyManager.resetCommand();
            } else if (splitMsg[0] == 'game-paused') {
              game_paused = true;
              interface_.addMessage('Game paused by ' + splitMsg[1] + ' (' + splitMsg[2] + ' pauses left)', 'yellow', imgs.attentionmarkYellow);
              soundManager.playSound(SOUND.POSITIVE);
              worker.postMessage({ what: 'setPause', val: game_paused });
            } else if (splitMsg[0] == 'game-unpaused') {
              game_paused = false;
              interface_.addMessage('Game unpaused by ' + splitMsg[1], 'yellow', imgs.attentionmarkYellow);
              soundManager.playSound(SOUND.POSITIVE);
              worker.postMessage({ what: 'setPause', val: game_paused });
            } else if (splitMsg[0] == 'map-ping') {
              if (!AccountInfo.ignores.contains(splitMsg[3].toLowerCase())) {
                game.minimap.mapPings.push({ field: new Field(parseInt(splitMsg[1]), parseInt(splitMsg[2])), time: Date.now() });
                soundManager.playSound(SOUND.BING2);
              }
            }

            // orders
            else if (splitMsg[0] != 'dummy') {
              worker.postMessage({ what: 'orders', msg: msg });

              try {
                var parsedMsg = JSON.parse(msg);
                if (parsedMsg.tick !== undefined) {
                  incomingOrders[parsedMsg.tick] = parsedMsg.orders;
                  if (parsedMsg.playersLeft) {
                    playerLefts[parsedMsg.tick] = parsedMsg.playersLeft;
                  }
                  if (Object.keys(parsedMsg.cameraUpdates).length > 0) {
                    incomingCameraUpdates[parsedMsg.tick] = parsedMsg.cameraUpdates;
                  }
                }
              } catch (e) {
                console.log('main thread error parsing orders msg', msg);
              }
            }
          }
          let jsonMessage;
          try {
            jsonMessage = JSON.parse(msg);
          } catch (err) {
            // Fail silently
          }

          if (jsonMessage && jsonMessage.message) {
            this.invokeJSONListener(jsonMessage);
            return;
          }
        };

        function setChatFocus(show) {
          if (show) {
            $('#lobbyChatInput')[0].focus();
          } else {
            $('#lobbyGameChatInput')[0].focus();
          }
        }

        function currencyFormatter(currency) {
          for (let i = currency.length - 3; i > 0; i -= 3) {
            currency = currency.slice(0, i) + ',' + currency.slice(i, currency.length);
          }
          return currency;
        }

        Network.prototype.failedConnection = function () {
          // (id, condition, closeable, title, draggable, onKey)
          var optionsWindow = new UIWindow('NoConnectionWindow', function () {
            return true;
          }, false, 'Connection Error', false);
          optionsWindow.refreshVisibility();
          elements.push(optionsWindow);
          console.log('No connection.');
          if (!this.socket) {
            console.log('Websocket failed. Does your browser support it?');
          } else if (!this.connected) {
            console.log('Websocket success. Could not connect to server. Try again later.');
          } else {
            console.log('Websocket Success. Connected. Send Failed.');
          }
        };

        Network.prototype.send = function (data) {
          if (this.connected && this.socket) {
            this.socket.send(data);
            return;
          }
          this.failedConnection();
        };

        // TODO: move this somewhere where it better belongs
        Network.prototype.getClanLink = function (p) {
          const builder = new HTMLBuilder();
          builder.add('<span>');
          if (p.clan && p.clan.length > 0) {
            const clanLinkID = uniqueID('clanLink');
            builder.add(`[<a href='#' class='clanLink' id='${clanLinkID}'>${p.clan}</a>] `);

            const clan = p.clan; // Required so that link stays valid after p.clan changes
            builder.addHook(() => $(`#${clanLinkID}`).click(() => Clans.getClanInfo(clan)));
          }
          builder.add('</span>');
          return builder;
        };

        // TODO: move this somewhere where it better belongs
        Network.prototype.getPlayerLink = function (p, noStyle) {
          const builder = new HTMLBuilder();
          if (p.name == 'Server') {
            return builder.add('<span>Server</span>');
          }

          const linkID = uniqueID('playerLink');
          const linkClass = noStyle ?
            'underline' :
            (p.name != 'Server' ? ((p.premium && p.authLevel < AUTH_LEVEL.MOD) ? 'playerLinkPremium' : auth_level_css_classes[p.authLevel]) : '') + ' playerNameInList';

          builder.add(`<a id='${linkID}' class='${linkClass}' href='#'>${p.name}</a>`);

          if (p.name != 'Server' && (p.name != networkPlayerName || p.authLevel >= AUTH_LEVEL.PLAYER)) {
            if (p.authLevel >= AUTH_LEVEL.PLAYER) {
              builder.addHook(() => $(`#${linkID}`).click(
                addClickSound(() => network.send(JSON.stringify({ message: 'get-player-info', properties: { username: p.name } })))));
            } else {
              builder.addHook(() => $(`#${linkID}`).click(() => Chats.openChatFor(p.name, true)));
            }
          }

          return builder;
        };

        // just a "static js-class" (HA-HA) that has some image transform methods
        function ImageTransformer() {

        };

        // return a greyscaled version of a given image
        ImageTransformer.getGreyScaledImage = function (img) {
          var canv = document.createElement('canvas');
          canv.height = img.height;
          canv.width = img.width;
          if (img.width == 0 || img.height == 0) {
            throw Error(`Tried to transform image "${img.name}" (from ${img.src}) that has height or width 0.`);
          }
          var ctx = canv.getContext('2d');

          ctx.drawImage(img, 0, 0);

          var imgData = ctx.getImageData(0, 0, canv.width, canv.height);

          for (var i = 0; i < imgData.data.length; i += 4) {
            var newValue = (imgData.data[i] + imgData.data[i + 1] + imgData.data[i + 2]) / 3;
            imgData.data[i] = newValue;
            imgData.data[i + 1] = newValue;
            imgData.data[i + 2] = newValue;
          }

          ctx.putImageData(imgData, 0, 0);

          return canv;
        };

        // returns a image with some colors replaced, specified by search and replace, which are arrays of color arrays ([[255, 255, 255], [...], ...], )
        ImageTransformer.replaceColors = function (img, search, replace) {
          var canv = new Array(replace.length);
          var imgData = new Array(replace.length);

          // If we were sent an asset reference by mistake, fix it here.
          // if (typeof img == "string")
          // {
          // 	img = loadImage(`${img}.png`);
          // }
          if (img.width == 0 || img.height == 0) {
            throw Error(`Tried to transform image "${img.name}" (from ${img.src}) that has height or width 0.`);
          }
          for (var i = 0; i < replace.length; i++) {
            canv[i] = document.createElement('canvas');
            canv[i].height = img.height;
            canv[i].width = img.width;
            canv[i].getContext('2d').drawImage(img, 0, 0);
            imgData[i] = canv[i].getContext('2d').getImageData(0, 0, img.width, img.height);
          }

          var data0 = imgData[0].data;
          for (var i = 0; i < data0.length; i += 4) {
            if (data0[i + 3] > 0) {
              for (var k = 0; k < search.length; k++) {
                if (data0[i] == search[k][0] && data0[i + 1] == search[k][1] && data0[i + 2] == search[k][2]) {
                  for (var j = 0; j < replace.length; j++) {
                    imgData[j].data[i] = replace[j][k][0];
                    imgData[j].data[i + 1] = replace[j][k][1];
                    imgData[j].data[i + 2] = replace[j][k][2];
                  }
                }
              }
            }
          }

          for (var i = 0; i < replace.length; i++) {
            canv[i].getContext('2d').putImageData(imgData[i], 0, 0);
          }

          return canv;
        };

        // returns a image with all colors replaced with white
        ImageTransformer.replaceColorsWhite = function (img, color) {
          color = color ? color : [255, 255, 255];

          var canv = document.createElement('canvas');
          canv.height = img.height;
          canv.width = img.width;
          var ctx = canv.getContext('2d');

          ctx.drawImage(img, 0, 0);

          var imgData = ctx.getImageData(0, 0, canv.width, canv.height);

          for (var i = 0; i < imgData.data.length; i += 4) {
            if (imgData.data[i + 3] > 0) {
              imgData.data[i] = color[0];
              imgData.data[i + 1] = color[1];
              imgData.data[i + 2] = color[2];
            }
          }

          ctx.putImageData(imgData, 0, 0);

          return canv;
        };

        // return the average color of an image (used to get a color to represent the image on the minimap)
        ImageTransformer.getAverageColor = function (img) {
          c2.clearRect(0, 0, img.img.w, img.img.h);
          c2.drawImage(img.file[0], img.img.x, img.img.y, img.img.w, img.img.h, 0, 0, img.img.w, img.img.h);
          var data = c2.getImageData(0, 0, img.img.w, img.img.h).data;

          var p = [0, 0, 0];
          var count = 0.01;
          for (var i = 0; i < data.length; i += 4) {
            if (data[i + 3] > 0) // if not
            {
              count++;
              for (k = 0; k < 3; k++) {
                p[k] += data[i + k];
              }
            }
          }

          return 'rgba(' + Math.floor(p[0] / count) + ', ' + Math.floor(p[1] / count) + ', ' + Math.floor(p[2] / count) + ', ' + (count / (data.length / 4)) + ')';
        };

        // returns a canvas based on a spritesheet and coords in the form of {x = 5, y = 8, w = 3, h = 3}
        ImageTransformer.getImgFromSheet = function (sheet, coords) {
          // create new canvas
          var canv = document.createElement('canvas');
          canv.height = coords.h;
          canv.width = coords.w;

          // draw image on canvas
          canv.getContext('2d').drawImage(sheet, coords.x, coords.y, coords.w, coords.h, 0, 0, coords.w, coords.h);

          return canv;
        };

        // an UIElement, mostly a HTML Element, with some extra features
        function UIElement(type, id, condition, killOnHide, onKey) {
          this.id = id;
          this.domElement = document.createElement(type);
          this.domElement.id = id;

          if (killOnHide) {
            this.domElement.style.display = condition ? 'none' : 'block';
          } else {
            this.domElement.style.visibility = condition ? 'hidden' : 'visible';
          }

          document.body.appendChild(this.domElement);

          this.condition = condition; // function that returns true, if the element should be drawn
          this.wasActiveLastFrame = false;
          this.blocksCanvas = true; // if this is true and the element is active, clicks do not get delegated to the canvas
          this.killOnHide = killOnHide;

          this.onKey = onKey;
        };

        UIElement.prototype.refreshVisibility = function () {
          if (!this.condition) {
            return;
          }

          if (this.condition()) {
            if (this.wasActiveLastFrame) {
              return this.blocksCanvas;
            }

            this.wasActiveLastFrame = true;

            if (this.killOnHide) {
              this.domElement.style.display = 'block';
            } else {
              this.domElement.style.visibility = 'visible';
            }

            // if its an inout which gets just active in this frame, set focus to it
            if (this.domElement.tagName == 'INPUT') {
              this.domElement.focus();
              this.domElement.value = this.domElement.value; // re-set value, so cursor is at the end and not at the beginning
            }

            return this.blocksCanvas;
          }

          if (!this.wasActiveLastFrame) {
            return false;
          }

          this.wasActiveLastFrame = false;

          if (this.killOnHide) {
            this.domElement.style.display = 'none';
          } else {
            this.domElement.style.visibility = 'hidden';
          }

          return false;
        };

        const LobbyPlayerManager = (() => {
          const dedent = require('dedent');

          // Terminology:
          // Slot - either a player slot or spectator slot that slot bars are dragged into
          // Slot bar - the <li> elements that can be dragged between slots
          // Index - a 0-based index into slotContents where [0, MAX_PLAYERS) correspond to player slots
          //         and MAX_PLAYERS, or SPECTATOR_INDEX, corresponds to all the spectator slots together
          //         Used locally in the client
          // Position - a 1-based index into the list of players where [1, MAX_PLAYERS] correspond to player slots
          //            and MAX_PLAYERS+1, or SPECTATOR_POSITION, to MAX_PLAYERS+MAX_SPECTATORS (inclusive) correspond to each of the spec spots
          //            Used by the server
          // Settings (playerSettings) - the map-specific constraints on what slots are open/closed/CPU, what team they can be,
          //                             and what AI they can have
          // Contents - the data describing the player currently in a slot which is the backing data for the slot bars

          const MAX_SPECTATORS = 4;
          const SPECTATOR_INDEX = MAX_PLAYERS; // 0-based index for client
          const SPECTATOR_POSITION = MAX_PLAYERS + 1; // 1-based index for server

          // The default team assigned to CPUs when they are added
          const DEFAULT_CPU_TEAM = 2;

          // Enums used in playerSettings
          const SlotType = Object.freeze({ OPEN: 0, CLOSED: 1, COMPUTER: 2 });
          const AIType = Object.freeze({ NORMAL: 0, NONE: 1 });

          // Enum used in slotContents
          const PlayerType = Object.freeze({ PLAYER: 0, CPU: 1 });

          function LobbyPlayerManager_() {
            Initialization.onDocumentReady(() => this.init());

            this.active = false;
            this.map = null;

            let isMultiplayer = false;
            Object.defineProperty(this, 'isMultiplayer', {
              get: () => isMultiplayer,
              set: (value) => {
                isMultiplayer = value;
                $('#inviteButton').toggle(isHost && isMultiplayer);
              },
            });
            // Game ID for multiplayer games
            this.gameID = null;
            // Invites sent out for multiplayer games (Host only)
            this.invites = [];

            let isHost = false;
            Object.defineProperty(this, 'isHost', {
              get: () => isHost,
              set: (value) => {
                isHost = value;
                $('#changeMapButton').toggle(isHost);
                $('#startButton').toggle(isHost);
                $('#addCpuButton').toggle(isHost);
                $('#inviteButton').toggle(isHost && isMultiplayer);
                $('.connectedSortable').sortable(isHost ? 'enable' : 'disable');
                $('.invitePlayerButton').prop('disabled', false);
                this.invites = [];
                this.__updateSlots();
              },
            });

            // Array of settings for the 6 player slots
            // Each setting has the format {slot: SlotType, team: Int (where 0 represents any team), ai: AIType}
            this.playerSettings = [];

            // JQuery references to the player slots' <ul> elements and the colored player numbers
            this.slots = [];
            this.slotNumbers = [];

            // Contains the player(s) currently in each player slot
            // Slot SPECTATOR_INDEX contains an array of players that are spectators
            // Each element has the format {type: PlayerType, name: String, team: Int, ai_name: String?}
            //  ai_name is either:
            //  - null: there is no AI (AIType.NONE or spectator)
            //  - String from ["Default", "Random AI", or AI name]: CPU slot
            this.resetSlotContents = () => {
              this.slotContents = Array.from({ length: MAX_PLAYERS + 1 }, () => null);
              this.slotContents[SPECTATOR_INDEX] = [];
            };
            this.resetSlotContents();
          }

          LobbyPlayerManager_.prototype.init = function () {
            this.__initUI();
            this.__initNetworkListeners();
          };

          LobbyPlayerManager_.prototype.__initUI = function () {
            const SLOT_SPACING = 37;

            // Create the main window that contains the entire lobby
            const lobbyWindow = new UIWindow('gameLobbyWindow', () => this.active);
            UIManagerSingleton.registerUIElement(lobbyWindow);

            // Construct the contents of the game lobby
            const builder = new HTMLBuilder();
            builder
              .add('<img id=\'mapPreviewImg\' />')
              .add('<div id=\'mapDescriptionDiv\'>')
              .add('<div id=\'mapDescriptionTextArea\' class=\'textContainer\'>')
              .addHook(() => $('#changeMapButton').click(() => MapSelection.openWindow(MapSelection.SelectionAction.CHANGE_MAP)))
              .add('</div>')
              .add('<button id=\'changeMapButton\'>Change Map</button>') // Host only
              .add('</div>')
              .add(`
            <div id='lobbyGameChatWindow' class='ingameWindow'>
                <h2 class='windowTitle'>» Chat</h2>
                <div id='lobbyGameChatTextArea' class='textContainer'></div>
                <div id='lobbyGameInput'>
                    <input id='lobbyGameChatInput' type='text' maxLength='250' placeholder='enter text to chat' autocomplete='off'>
                </div>
            </div>
        `)
              .addHook(() => $('#lobbyGameChatInput').keydown((e) => {
                if (keyManager.getKeyCode(e) == KEY.ENTER && network.connected) {
                  uimanager.chatFunction($('#lobbyGameChatInput'));
                }
              }))
              .add('<button id=\'startButton\'>Start</button>') // Host only
              .addHook(() => $('#startButton').click(addClickSound(() => this.__startGame(false))))
              .add('<button id=\'backButton\'>Back</button>')
              .addHook(() => $('#backButton').click(addClickSound(() => {
                this.exitLobby();
              })));

            builder.add('<div id=\'playerManagerDiv\'>');
            {
              // Start position numbers
              builder.add('<div id=\'startPosDiv\'>');
              for (let i = 0; i < MAX_PLAYERS; i++) {
                const ID = uniqueID('playerNumber');
                const color = playerTextColors[i + 1];
                const top = SLOT_SPACING * i + 3;
                builder
                  .add(`<p id='${ID}' style='color: rgb(${color.join(', ')}); top: ${top}px'>${i + 1}.</p>`)
                  .addHook(() => this.slotNumbers.push($(`#${ID}`)));
              }
              builder.add('</div>');

              // Selectable player slots
              for (let i = 0; i < MAX_PLAYERS; i++) {
                const ID = uniqueID('playerSlot');
                const top = SLOT_SPACING * i + 35;
                builder
                  .add(`<ul id='${ID}' class='connectedSortable' style='top: ${top}px'></ul>`)
                  .addHook(() => this.slots.push($(`#${ID}`)));
              }

              builder
                .add('<p id=\'playersLabel\'>Players</p>')
                .add('<button id=\'inviteButton\'>Invite</button>') // Host only, Multiplayer only
                .addHook(() => $('#inviteButton').click(() => this.__showInviteWindow()))
                .add('<button id=\'addCpuButton\'>Add CPU</button>') // Host only
                .addHook(() => $('#addCpuButton').click(() => this.__addCPU()))
                .add('<p id=\'spectatorsLabel\'>Spectators</p>')
                .add('<ul id=\'listSpec\' class=\'connectedSortable\'></ul>')
                .add('<button id=\'moveMeToSpecBtn\'>Spectate</button>')
                .addHook(() => $('#moveMeToSpecBtn').click(addClickSound(() => this.__moveToSpec())));
            }
            builder.add('</div>');
            builder.insertInto('#gameLobbyWindow');

            this.__initSlotBarDragging();

            // Construct the invite window
            this.__initInviteWindow();
          };

          LobbyPlayerManager_.prototype.exitLobby = function () {
            this.active = false;
            network.send('leave-game');
            fadeOut($('#inviteWindow'));
            game_state = GAME.LOBBY;
            setChatFocus(true);
          };

          LobbyPlayerManager_.prototype.__initSlotBarDragging = function () {
            // Returns the position in the lobby given the <ul> object representing the slot and the player name
            // Always returns SPECTATOR_POSITION for a spectator
            const getLobbyPositionFromSlot = (holder, playerName) => {
              const isSpec = $('#listSpec').is(holder);
              if (isSpec) {
                return SPECTATOR_POSITION;
              } else {
                return this.slots.findIndex((slot) => $(holder).is(slot)) + 1;
              }
            };

            // Logic for when a player bar is dragged into a player slot or the spectator area
            $('.connectedSortable').sortable({
              connectWith: '.connectedSortable',
              placeholder: 'invis',
              receive: (event, ui) => {
                const el = ui.item[0];
                const playerName = $(el).attr('data-name');

                let oldPosition = getLobbyPositionFromSlot(ui.sender[0], playerName);
                if (oldPosition == SPECTATOR_POSITION) {
                  // Get the exact spectator number for the old position, since we need this to uniquely identify the player
                  oldPosition += this.slotContents[SPECTATOR_INDEX].findIndex((p) => p && p.name == playerName);
                }

                // Exact spectator number is not necessary to move into spectator slot, it will just go to the end
                const newPosition = getLobbyPositionFromSlot(el.parentNode, playerName);

                if (!this.__movePlayer(playerName, oldPosition, newPosition)) {
                  $(ui.sender).sortable('cancel');
                }
              },
            }).disableSelection();
          };

          LobbyPlayerManager_.prototype.__initInviteWindow = function () {
            const inviteWindow = new UIWindow('inviteWindow', () => true, true, 'Invite Players', true);
            inviteWindow.addScrollableSubDiv('inviteWindowContents');

            const refreshInviteWindow = () => {
              if (!this.active) {
                return;
              }

              const generateInviteButton = (name, isFriend) => {
                const p = PlayersList.players[name];
                if (!p) {
                  return '';
                }

                if (p.name == AccountInfo.playerName) {
                  return '';
                }
                if (p.location != PlayersList.Locations.LOBBY && p.location != PlayersList.Locations.SEARCHING) {
                  return '';
                }

                const ID = uniqueID();
                const btnClass = isFriend ? 'inviteFriendButton' : 'inviteRandomButton';
                const disabled = (() => {
                  if (this.invites.indexOf(p.name) >= 0) {
                    return 'disabled';
                  }
                  if (!isFriend && updateNumRandomInvites() >= MAX_RANDOM_INVITES) {
                    return 'disabled';
                  }
                  return '';
                })();

                return new HTMLBuilder()
                  .add('<div class=\'inviteDiv\'>')
                  .add(PlayersList.getPlayerLink(p.name, true))
                  .add(`<button id='${ID}' class='${btnClass}' ${disabled}>Invite</button>`)
                  .addHook(() => $(`#${ID}`).click(() => {
                    network.send(`invite<<$${p.name}<<$${this.gameID}`);
                    this.invites.push(p.name);

                    $(`#${ID}`).prop('disabled', true);
                  }))
                  .add('</div>');
              };

              const builder = new HTMLBuilder();

              if ([...FriendsList.onlineFriends()].length > 0) {
                builder.add('<p class=\'inviteLabel\' style=\'font-size: 20px\'>Friends</p>');

                // Add buttons for all online friends
                for (const name of FriendsList.onlineFriends()) {
                  builder.add(generateInviteButton(name, true));
                }

                builder.add('<hr>');
              } else if (AccountInfo.authedAndLogged) {
                builder.add('<p class=\'inviteLabel\' style=\'font-size: 20px\'>You have no online friends.</p>');
              } else {
                builder.add('<p class=\'inviteLabel\' style=\'font-size: 20px\'>Create an account to add friends and invite them to lobbies.</p>');
              }

              builder.insertInto('#inviteWindowContents');
            };

            PlayersList.onChange(refreshInviteWindow);
            FriendsList.onChange(refreshInviteWindow);
          };

          LobbyPlayerManager_.prototype.__initNetworkListeners = function () {
            // GAME.LOBBY when creating a new game, and GAME.SKIRMISH when changing map
            network.registerListener([GAME.LOBBY, GAME.SKIRMISH], 'singleplayer-game-created', (splitMsg) => {
              network.onMapFile = (map) => this.__joinLobby(false, 0, map, splitMsg[1], true);
            });

            network.registerListener(GAME.LOBBY, 'game-created', (splitMsg) => {
              network.onMapFile = (map) => this.__joinLobby(true, splitMsg[1], map, splitMsg[3], true);
            });

            network.registerListener(GAME.LOBBY, 'game-joined', (splitMsg) => {
              network.onMapFile = (map) => this.__joinLobby(true, splitMsg[1], map, splitMsg[4], false);
            });

            network.registerListener(GAME.LOBBY, 'you-are-new-host', () => this.isHost = true);

            network.registerListener(GAME.LOBBY, 'change-map-file', (splitMsg) => {
              network.onMapFile = (map) => {
                addChatMsg('Server', `Host changed map to ${splitMsg[1]}`);
                this.__setMapFromServer(map, splitMsg[2]);
              };
            });

            network.registerListener(GAME.LOBBY, 'youve-been-kicked', () => {
              this.active = false;
              game_state = GAME.LOBBY;
              setChatFocus(true);
            });

            // Message sent to all players whenever a multiplayer lobby changes
            network.registerListener(GAME.LOBBY, 'infostring', (splitMsg) => {
              const serverPlayers = JSON.parse(splitMsg[1]).players;

              const oldPlayersArr = this.__getPlayersInLobby();
              this.__refreshPlayersFromServer(serverPlayers);
              const newPlayersArr = this.__getPlayersInLobby();

              // Print a message for each joined / left player if we didn't join just now
              if (oldPlayersArr.length > 0) {
                const oldPlayers = new Multiset(oldPlayersArr);
                const newPlayers = new Multiset(newPlayersArr);

                oldPlayers.forEach((p) => {
                  for (let i = 0; i < oldPlayers.count(p) - newPlayers.count(p); i++) {
                    addChatMsg('Server', `Player ${p} left`);
                  }
                });

                newPlayers.forEach((p) => {
                  for (let i = 0; i < newPlayers.count(p) - oldPlayers.count(p); i++) {
                    addChatMsg('Server', `Player ${p} joined`);
                  }
                });
              }
              soundManager.playSound(SOUND.CLICK);
            });

            network.registerListener(GAME.LOBBY, 'start-game', () => this.active = false);
          };

          LobbyPlayerManager_.prototype.__getAllowedAIs = function () {
            let ai_names = ['Default'].concat(this.isModded ? [] : ['Random AI']);
            ai_names = ai_names.concat(AIManager.getNames(
        /* includeRegularAI=*/!this.isModded,
        /* includeCustomAI=*/!this.isMultiplayer,
            ));
            return ai_names;
          };

          // Generates the interactive bar that is inserted into the slot with the given position given a
          // reference to the corresponding contents object in this.slotContents
          LobbyPlayerManager_.prototype.__generateSlotBar = function (position, contents) {
            const barID = uniqueID('bar');
            const teamButtonID = uniqueID('team');
            const builder = new HTMLBuilder();
            builder.add(`<li id='${barID}' data-name='${contents.name}' class='draggable_'>${contents.name}`);
            if (this.playerSettings[position - 1] && this.playerSettings[position - 1].team != 0) {
              builder.add(` <button id='${teamButtonID}' style="float:right;">Team ${contents.team}</button>`);
            } else {
              if (this.playerSettings[position - 1]) {
                if (this.isHost) {
                  builder.add(`<select class='lobbyDropDown' id=${teamButtonID}>`);
                  for (let i = 0; i < MAX_PLAYERS; i++) {
                    if (contents.team == i + 1) {
                      builder.add(` <option selected value='${i + 1}'>Team ${i + 1}</option>`);
                    } else {
                      builder.add(` <option value='${i + 1}'>Team ${i + 1}</option>`);
                    }
                  }
                  builder.add(`</select>`);
                  builder.addHook(() => $(`#${teamButtonID}`).change(addClickSound(() => this.__changeTeamSpecific(position, contents, $(`#${teamButtonID}`).val(), teamButtonID))));
                } else {
                  builder.add(` <button id='${teamButtonID}' style="float:right;">Team ${contents.team}</button>`);
                }
              }
            }

            // Whether or not this slot can select AI
            // Set to false for now in multiplayer since it causes desyncs
            const aiEnabled = (position < SPECTATOR_POSITION) &&
              contents.type == PlayerType.CPU &&
              this.playerSettings[position - 1].ai != AIType.NONE &&
              !this.isMultiplayer;

            // Add a button to switch AIs if this slot can have AIs
            if (aiEnabled) {
              const aiButtonID = uniqueID('ai');
              builder.add(`<select class='lobbyDropDown' id=${aiButtonID}>`);
              const ai_names = this.__getAllowedAIs();
              for (const name of ai_names) {
                if (contents.ai_name === name) {
                  builder.add(` <option selected value='${name}'>${name}</option>`);
                } else {
                  builder.add(` <option value='${name}'>${name}</option>`);
                }
              }
              builder.add(`</select>`);
              builder.addHook(() => {
                $(`#${aiButtonID}`)
                  .change(addClickSound(() => {
                    this.__changeAI(position, contents, $(`#${aiButtonID}`).val());
                  }))
                  .prop('disabled', !this.isHost);
              });
            }

            // Add an X button if we are the host and the slot is not for us
            if (this.isHost && contents.name != networkPlayerName) {
              const removeButtonID = uniqueID('remove');
              builder
                .add(` <button id='${removeButtonID}'>x</button>`)
                .addHook(() => $(`#${removeButtonID}`).click(addClickSound(() => this.__removePlayer(position))));
            }

            return builder.add('</li>');
          };

          // Updates the UI with the player positions in this.slotContents
          LobbyPlayerManager_.prototype.__updateSlots = function () {
            // Add the bars into the player slots
            for (let i = 0; i < MAX_PLAYERS; i++) {
              if (this.slotContents[i]) {
                this.__generateSlotBar(i + 1, this.slotContents[i])
                  .insertInto(this.slots[i]);
              } else {
                this.slots[i].html('');
              }
            }

            // Add the spectators into the spectator slots
            $('#listSpec').html('');
            for (let i = 0; i < this.slotContents[SPECTATOR_INDEX].length; i++) {
              if (this.slotContents[SPECTATOR_INDEX][i]) {
                this.__generateSlotBar(SPECTATOR_POSITION + i, this.slotContents[SPECTATOR_INDEX][i])
                  .appendInto('#listSpec');
              }
            }
          };

          LobbyPlayerManager_.prototype.__getComputerName = function (ai_name) {
            return `Computer (${ai_name})`;
          };

          // Returns an object representing a default CPU to be inserted into this.slotContents at the given slot number
          LobbyPlayerManager_.prototype.__getDefaultCPU = function (slot, isMultiplayer) {
            // Set to DEFAULT_CPU_TEAM if the playerSettings has a 0 ("any")
            const team = this.playerSettings[slot].team || DEFAULT_CPU_TEAM;

            const ai_names = this.__getAllowedAIs();
            let chosenAI = interface_.lastChosenAI.get();
            if (isMultiplayer || !ai_names.includes(chosenAI)) {
              chosenAI = 'Default';
            }

            return {
              type: PlayerType.CPU,
              name: 'Computer',
              team: team,
              ai_name: chosenAI,
            };
          };

          // Adds a CPU to the earliest available player slot if possible
          LobbyPlayerManager_.prototype.__addCPU = function () {
            assert(this.isHost);

            // Find the first free player slot
            let freeSlotIndex = -1;
            for (let i = 0; i < MAX_PLAYERS; i++) {
              if (this.playerSettings[i].slot == SlotType.OPEN && !this.slotContents[i]) {
                freeSlotIndex = i;
                break;
              }
            }

            if (freeSlotIndex == -1) {
              bingMsg('No more free player slots', true);
              return;
            }

            // Add the CPU into slotContents
            const cpu = this.__getDefaultCPU(freeSlotIndex, this.isMultiplayer);
            this.slotContents[freeSlotIndex] = cpu;
            this.__updateSlots();

            if (this.isMultiplayer) {
              addChatMsg('Server', 'Player Computer joined');
              network.send(`add-cpu<<$${cpu.ai_name}`);
            }
          };

          // Takes the server position of a slot and a reference to the contents of the slot and increments the team
          // for the player in that slot if the team is changeable
          LobbyPlayerManager_.prototype.__changeTeam = function (position, contents) {
            assert(this.isHost);

            if (position < SPECTATOR_POSITION) {
              // Check the player settings to see if this slot can change teams (0 means any)
              if (this.playerSettings[position - 1].team != 0) {
                bingMsg('This player\'s team cannot be changed', true);
                return;
              }
            }

            if (this.isMultiplayer) {
              network.send(`change-team<<$${position}`);
            }

            // Update the team number
            contents.team = contents.team % 6 + 1;
            this.__updateSlots();
          };

          // Takes the server position of a slot and a reference to the contents of the slot and changes the team
          // for the player in that slot if the team is changeable
          LobbyPlayerManager_.prototype.__changeTeamSpecific = function (position, contents, teamNum, teamButtonID) {
            assert(this.isHost);

            if (position < SPECTATOR_POSITION) {
              // Check the player settings to see if this slot can change teams (0 means any)
              if (this.playerSettings[position - 1].team != 0) {
                bingMsg('This player\'s team cannot be changed', true);
                // reset dropdown to what it was before
                $(`#${teamButtonID}`).val(contents.team).change();
                return;
              }
            }

            if (this.isMultiplayer) {
              network.send(`change-team-specific<<$${position}<<$${teamNum}`);
            }

            // Update the team number
            contents.team = teamNum;
            this.__updateSlots();
          };

          // Takes a reference to the contents of a slot and increments the AI for the CPU in that slot
          LobbyPlayerManager_.prototype.__changeAI = function (position, contents, ai_name) {
            assert(position < SPECTATOR_POSITION && this.slotContents[position - 1].type == PlayerType.CPU);
            assert(this.playerSettings[position - 1].ai != AIType.NONE);

            contents.ai_name = ai_name;
            interface_.lastChosenAI.set(ai_name);

            if (this.isMultiplayer) {
              network.send(`change-ai<<$${position}<<$${ai_name}`);
            }

            this.__updateSlots();
          };

          // Removes the player at the given position
          LobbyPlayerManager_.prototype.__removePlayer = function (position) {
            assert(this.isHost);

            let playerName;
            if (position < SPECTATOR_POSITION) {
              playerName = this.slotContents[position - 1].name;
              this.slotContents[position - 1] = null;
            } else {
              const specIndex = position - SPECTATOR_POSITION;
              assert(specIndex < this.slotContents[SPECTATOR_INDEX].length);

              playerName = this.slotContents[SPECTATOR_INDEX][specIndex].name;
              this.slotContents[SPECTATOR_INDEX].splice(specIndex, 1);
            }

            if (this.isMultiplayer) {
              addChatMsg('Server', `Player ${playerName} left`);
              network.send(`kick-player<<$${position}`);
            }

            this.__updateSlots();
          };

          // Attempts to move the player with playerName from oldPosition to newPosition
          LobbyPlayerManager_.prototype.__movePlayer = function (playerName, oldPosition, newPosition) {
            // Early exit trivial case to avoid special case checks later
            if (oldPosition == newPosition || (oldPosition >= SPECTATOR_POSITION && newPosition >= SPECTATOR_POSITION)) {
              return true;
            }

            // Technically not valid if any of the positions exceeds SPECTATOR_POSITION, but we handle that case explicitly
            const oldIndex = oldPosition - 1;
            const newIndex = newPosition - 1;

            const contents = oldPosition >= SPECTATOR_POSITION ?
              this.slotContents[SPECTATOR_INDEX].find((p) => p.name == playerName) :
              this.slotContents[oldIndex];

            // Validate moving from a player slot to a spectator slot
            if (newPosition >= SPECTATOR_POSITION) {
              if (this.slotContents[SPECTATOR_INDEX].length >= MAX_SPECTATORS) {
                bingMsg(`Cannot have more than ${MAX_SPECTATORS} spectators`, true);
                return false;
              }

              if (this.slotContents[oldIndex].type == PlayerType.CPU) {
                bingMsg('CPUs cannot be spectators', true);
                return false;
              }

              // Perform the actual move
              this.slotContents[SPECTATOR_INDEX].push(contents);
              this.slotContents[oldIndex] = null;
            }

            // Validate moving to a player slot from either another player slot or from a spectator slot
            if (newPosition < SPECTATOR_POSITION) {
              if (this.slotContents[newIndex] && oldPosition >= SPECTATOR_POSITION) {
                bingMsg('Cannot swap a spectator with a player', true);
                return false;
              }

              // Either swap or move
              if (this.slotContents[newIndex]) {
                // The origin will be a player slot since we excluded the origin being a spectator slot earlier
                [this.slotContents[oldIndex], this.slotContents[newIndex]] = [this.slotContents[newIndex], this.slotContents[oldIndex]];
              } else {
                this.slotContents[newIndex] = contents;
                if (oldPosition >= SPECTATOR_POSITION) {
                  this.slotContents[SPECTATOR_INDEX].splice(oldPosition - SPECTATOR_POSITION, 1);
                } else {
                  this.slotContents[oldIndex] = null;
                }
              }

              // Fix the teams and AI to match the map settings
              [oldIndex, newIndex].filter((i) => i < MAX_PLAYERS && this.slotContents[i]).forEach((i) => {
                if (this.playerSettings[i].team) {
                  this.slotContents[i].team = this.playerSettings[i].team;
                }
                if (this.playerSettings[i].ai == AIType.NONE) {
                  this.slotContents[i].ai_name = null;
                }
              });
            }

            if (this.isMultiplayer) {
              network.send(`move-player<<$${oldPosition}<<$${newPosition}`);
            }

            this.__updateSlots();
            return true;
          };

          LobbyPlayerManager_.prototype.__moveToSpec = function () {
            if (this.slotContents[SPECTATOR_INDEX].length > MAX_SPECTATORS) {
              bingMsg('No more open spectator spots', true);
            } else if (this.isMultiplayer) {
              network.send('move-player-to-spec');
            } else {
              let index = this.slotContents.findIndex((p) => p && p.name == networkPlayerName);
              if (index >= 0) {
                this.__movePlayer(networkPlayerName, index + 1, SPECTATOR_POSITION);
              } else {
                displayInfoMsg('You\'re already spectating!');
              }
            }
          };

          LobbyPlayerManager_.prototype.__joinLobby = function (isMultiplayer, gameID, map, img, isHost) {
            this.active = true;
            this.isMultiplayer = isMultiplayer;
            this.gameID = gameID;
            this.isHost = isHost;

            // TODO: potentially move this elsewhere with other ladder stuff
            network.send('cancel-ladder');
            fadeOut($('#ladderWindow'));

            // TODO: add a game_state for multiplayer lobbies instead of overloading GAME.LOBBY or remove GAME.SKIRMISH
            if (!this.isMultiplayer) {
              game_state = GAME.SKIRMISH;
            }

            // Display lobby chat only for multiplayer lobbies
            $('#lobbyGameChatWindow').css('display', this.isMultiplayer ? 'block' : 'none');

            $('#lobbyGameChatTextArea').html('');
            $('#lobbyGameChatInput').text('');
            setChatFocus(false);

            this.__setMapFromServer(map, img);
          };

          LobbyPlayerManager_.prototype.__showInviteWindow = function () {
            fadeIn($('#inviteWindow'));
          };

          // Takes the "players" field of a map and uses it to fill in this.playerSettings
          // If the parameter is empty or if any of the fields are missing, they will be filled in with defaults
          LobbyPlayerManager_.prototype.__setPlayerSettings = function (rawSettings, countPlayers) {
            const slotMap = { 'open': SlotType.OPEN, 'closed': SlotType.CLOSED, 'computer': SlotType.COMPUTER };
            // Converts "any" to 0 and "Team #" to #
            const teamMap = (rawTeam) => rawTeam == 'any' ? 0 : parseInt(rawTeam.split(' ')[1]);
            const aiMap = { 'normal AI': AIType.NORMAL, 'no AI': AIType.NONE };

            this.playerSettings = [];
            for (let i = 0; i < MAX_PLAYERS; i++) {
              if (rawSettings && rawSettings[i]) {
                this.playerSettings.push({
                  slot: slotMap[rawSettings[i].slot],
                  team: teamMap(rawSettings[i].team),
                  ai: aiMap[rawSettings[i].ai],
                });
              } else {
                this.playerSettings.push({
                  slot: i < countPlayers ? SlotType.OPEN : SlotType.CLOSED,
                  team: 0,
                  ai: AIType.NORMAL,
                });
              }
            }
          };

          LobbyPlayerManager_.prototype.__setMapFromServer = function (map, img) {
            this.map = map;
            this.map.img = img;
            this.isModded = this.map.globalVars.isModded;
            this.__setPlayerSettings(this.map.players, this.map.countPlayers);
            this.resetSlotContents();

            // Set the map information in the UI
            $('#mapPreviewImg').attr('src', this.map.img);
            $('#mapDescriptionTextArea').text(dedent(`
        ${this.map.name}
        Size: ${this.map.x}x${this.map.y}
        ${this.map.countPlayers} Players

        ${this.map.description}

        Map by ${this.map.owner ?? '?'}
    `));

            // Set visibility of player slots
            for (let i = 0; i < MAX_PLAYERS; i++) {
              if (this.playerSettings[i].slot == SlotType.CLOSED) {
                this.slots[i].hide();
                this.slotNumbers[i].hide();
              } else {
                this.slots[i].show();
                this.slotNumbers[i].show();
              }
            }

            // Disable computer-only slots from being dragged / dragged into
            for (let i = 0; i < MAX_PLAYERS; i++) {
              // Should be enabled when isHost is set to true, so no need to manually enable here
              if (this.playerSettings[i].slot == SlotType.COMPUTER) {
                this.slots[i].sortable('disable');
              }
            }

            // Initialize the slots for the map if singleplayer
            // If multiplayer, the server will do it for us
            if (!this.isMultiplayer) {
              const self = { type: PlayerType.PLAYER, name: networkPlayerName, team: 1, ai_name: null };
              let insertedSelf = false;

              // Set up the slots and put the player in the earliest available slot
              for (let i = 0; i < MAX_PLAYERS; i++) {
                // Set the contents of the slot by slot type
                switch (this.playerSettings[i].slot) {
                  case SlotType.OPEN:
                    this.slotContents[i] = !insertedSelf ? self : this.__getDefaultCPU(i);
                    insertedSelf = true;
                    break;

                  case SlotType.COMPUTER:
                    this.slotContents[i] = this.__getDefaultCPU(i);
                    break;

                  case SlotType.CLOSED:
                    this.slotContents[i] = null;
                    break;
                }
              }

              // Insert into spectators if there was no player slot to insert into
              if (!insertedSelf) {
                this.slotContents[SPECTATOR_INDEX] = [self];
              }

              this.__updateSlots();
            }
          };

          LobbyPlayerManager_.prototype.__getPlayersInLobby = function () {
            const players = [];
            for (let i = 0; i < MAX_PLAYERS; i++) {
              if (this.slotContents[i]) {
                players.push(this.slotContents[i].name);
              }
            }
            for (let i = 0; i < this.slotContents[SPECTATOR_INDEX].length; i++) {
              if (this.slotContents[SPECTATOR_INDEX][i]) {
                players.push(this.slotContents[SPECTATOR_INDEX][i].name);
              }
            }
            return players;
          };

          LobbyPlayerManager_.prototype.__refreshPlayersFromServer = function (serverPlayers) {
            // Store this to check assertions
            const oldSlotContents = JSON.parse(JSON.stringify(this.slotContents));

            // Insert into the player slots
            for (let i = 0; i < MAX_PLAYERS; i++) {
              const player = serverPlayers.find((p) => p.nr == i + 1);
              if (!player) {
                this.slotContents[i] = null;
                continue;
              }
              this.slotContents[i] = {
                type: player.controller == CONTROLLER.COMPUTER ? PlayerType.CPU : PlayerType.PLAYER,
                name: player.name,
                team: player.team,
                ai_name: player.ai_name,
              };
            }

            // Insert into the spectator slots in order
            const numSpecs = serverPlayers.count((p) => p.controller == CONTROLLER.SPECTATOR);
            this.slotContents[SPECTATOR_INDEX] = [];

            for (let i = SPECTATOR_POSITION; i < SPECTATOR_POSITION + MAX_SPECTATORS; i++) {
              const spec = serverPlayers.find((p) => p.nr == i);
              if (!spec) {
                // The spectators must occupy the smallest numbers possible with no gap
                assert(i - SPECTATOR_POSITION == numSpecs);
                break;
              }

              this.slotContents[SPECTATOR_INDEX].push({
                type: PlayerType.PLAYER,
                name: spec.name,
                team: spec.team,
                ai_name: null,
              });
            }

            // Run some assertions to verify that the server logic is identical to the client logic
            if (this.isHost) {
              // Flags to toggle the strength of the assertions
              // Should be set to true unless debugging!
              const playersCanLeave = true; // Players may leave the game on their own
              const playersCanSpec = true; // Players may make themselves spectators

              const assertSlotEq = (s1, s2) => {
                assert(s1.type == s2.type);
                assert(s1.name == s2.name);
                assert(s1.team == s2.team);
                assert(s1.ai_name == s2.ai_name);
              };

              const oldNumPlayers = oldSlotContents.count((p, i) => p && i < MAX_PLAYERS) + oldSlotContents[SPECTATOR_INDEX].length;

              // Don't assert in cases the host can't control
              const playersJoined = serverPlayers.length > oldNumPlayers;
              const playersLeftOnTheirOwn = playersCanLeave && serverPlayers.length < oldNumPlayers;
              if (!playersJoined && !playersLeftOnTheirOwn) {
                // Check that the playing player slots are the same (minus one who may have become a spectator if playersCanSpec == true)
                let maybeBecameSpectator = null; // The player who might've become a spectator
                for (let i = 0; i < MAX_PLAYERS; i++) {
                  if (!this.slotContents[i]) {
                    // Either the player moved themselves to spec or there never was a player here
                    if (oldSlotContents[i] && playersCanSpec && !maybeBecameSpectator) {
                      maybeBecameSpectator = oldSlotContents[i];
                    } else {
                      assert(!oldSlotContents[i]);
                    }
                  } else {
                    assertSlotEq(oldSlotContents[i], this.slotContents[i]);
                  }
                }

                // Check that the spectator slots are the same
                if (maybeBecameSpectator) { // If we suspect someone moved themselves to spec, there must be one more spec now
                  assert(this.slotContents[SPECTATOR_INDEX].length == oldSlotContents[SPECTATOR_INDEX].length + 1);
                } else {
                  assert(this.slotContents[SPECTATOR_INDEX].length == oldSlotContents[SPECTATOR_INDEX].length);
                }

                for (let i = 0; i < this.slotContents[SPECTATOR_INDEX].length; i++) {
                  // Either a player moved themselves into this spec slot or they were already here
                  if (!oldSlotContents[SPECTATOR_INDEX][i] && playersCanSpec && maybeBecameSpectator) {
                    assertSlotEq(maybeBecameSpectator, this.slotContents[SPECTATOR_INDEX][i]);
                  } else {
                    assertSlotEq(oldSlotContents[SPECTATOR_INDEX][i], this.slotContents[SPECTATOR_INDEX][i]);
                  }
                }
              }
            }

            this.__updateSlots();
          };

          // Returns an array of JSON objects containing the information for each player in the lobby
          // The format matches that expected by game.loadMap
          LobbyPlayerManager_.prototype.getPlayerSettingsForGame = function () {
            const players = [];

            // Add the players in player slots
            for (let i = 0; i < MAX_PLAYERS; i++) {
              const p = this.slotContents[i];
              if (!p) {
                continue;
              }

              let ps = {
                name: p.name,
                controller: p.type == PlayerType.PLAYER ? CONTROLLER.HUMAN : CONTROLLER.COMPUTER,
                nr: i + 1,
                team: p.team,
                isPlayingPlayer: p.name == networkPlayerName,
              };

              if (p.type == PlayerType.CPU) {
                // TODO: support custom AI in multiplayer
                ps.ai_name = p.ai_name;
                ps.name = this.__getComputerName(ps.ai_name);
              }

              players.push(ps);
            }

            // Add the spectators
            for (let i = 0; i < this.slotContents[SPECTATOR_INDEX].length; i++) {
              const p = this.slotContents[SPECTATOR_INDEX][i];

              players.push({
                name: p.name,
                controller: CONTROLLER.SPECTATOR,
                nr: SPECTATOR_POSITION + i,
                team: p.team,
                isPlayingPlayer: p.name == networkPlayerName,
              });
            }

            return players;
          };

          LobbyPlayerManager_.prototype.__startGame = function (ignoreSameTeam = false) {
            // TODO: move this somewhere with other ladder stuff
            network.send('cancel-ladder');
            fadeOut($('#ladderWindow'));

            // Check if all players are on the same team
            let team = -1;
            let allSameTeam = true;
            for (let i = 0; i < MAX_PLAYERS; i++) {
              if (!this.slotContents[i]) {
                continue;
              }
              if (team == -1) {
                team = this.slotContents[i].team;
              } else if (team != this.slotContents[i].team) {
                allSameTeam = false;
              }
            }

            // Show a warning that all are on the same team unless we're overriding
            if (allSameTeam && !ignoreSameTeam) {
              displayInfoMsg(new HTMLBuilder()
                .add('<p>Everyone is on the same team!</p><br />')
                .add('<button id=\'startGameAnyway\'>Start anyway</button>')
                .addHook(() => $('#startGameAnyway').click(() => {
                  fadeOut($('#infoWindow'));
                  this.__startGame(true);
                })));
              return;
            }

            if (this.isMultiplayer) {
              network.send('start-game');
            } else {
              const ps = this.getPlayerSettingsForGame();

              this.active = false;
              uimanager.showLoadingScreen(this.map, ps);

              setTimeout(() => {
                game_state = GAME.PLAYING;
                mapData = '';

                var aiRandomizer = Math.ceil(Math.random() * 100000);
                game = new Game();
                game.loadMap(this.map, ps, aiRandomizer);

                worker.postMessage({
                  what: 'start-game',
                  map: this.map,
                  players: ps,
                  network_game: network_game,
                  game_state: game_state,
                  networkPlayerName: networkPlayerName,
                  aiCommit: AIManager.getAICommit(),
                  aiRandomizer: aiRandomizer,
                });
              }, 50);
            }
          };

          return new LobbyPlayerManager_();
        })();

        const ReplaysWindow = (() => {
          function ReplaysWindow_() {
            Initialization.onDocumentReady(() => this.createWindow());

            if (!localStorage.getItem('Replays')) {
              localStorage.setItem('Replays', Compression.compressToString('[]'));
            }

            const data = localStorage.getItem('Replays');
            const decompressed = Compression.decompressFromString(data);
            if (!decompressed) {
              // The data is either in the old uncompressed JSON format or corrupted.
              // Either way, parse it and update it to be compressed.
              try {
                this.replays = JSON.parse(data);
              } catch (e) {
                console.log(`Error loading replays: ${e}`);
                this.replays = [];
              }
              this.updateLocalStorage();
            } else {
              this.replays = JSON.parse(decompressed);
            }
          }

          ReplaysWindow_.prototype.createWindow = function () {
            const replaysListWindow = new UIWindow('replaysListWindow', null, true, 'Replays', true);
            replaysListWindow.addScrollableSubDiv('replaysListContent');
            $('#replaysListWindow').hide();

            // Add the button to load replays from disk
            new HTMLBuilder()
              .add('<button id=\'loadExternalReplayButton\' title=\'Load a replay from your computer\'>Load external</button>')
              .addHook(() => $('#loadExternalReplayButton').click(addClickSound(() => {
                fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.click();

                fileInput.onchange = () => {
                  const file = fileInput.files[0];
                  if (file) {
                    const reader = new FileReader();

                    reader.onload = (e) => {
                      replayFile = JSON.parse(e.target.result);
                      network.send(`get-map-for-replay<<$${replayFile.map}`);
                    };

                    reader.readAsBinaryString(file);
                  }
                };
                fadeOut($('#replaysListWindow'));
              })))
              .appendInto('#replaysListWindow');
          };

          ReplaysWindow_.prototype.openWindow = function () {
            this.refreshContents();
            fadeIn($('#replaysListWindow'));
          };

          ReplaysWindow_.prototype.refreshContents = function () {
            const builder = new HTMLBuilder().add('<br />');

            for (let i = 0; i < this.replays.length; i++) {
              const replay = this.replays[i];
              const parsed = JSON.parse(replay.replay);

              const duration = getFormattedDuration(parsed.ticksCounter * 50);
              const watchBtnID = uniqueID();
              const saveBtnID = uniqueID();
              const deleteBtnID = uniqueID();
              builder
                .add(`<div class='replayDiv'>`)

                .add(`<div class='replayName'>${replay.name}</div>`)

                .add('<div class=\'replayRider\'>')

                .add(`<p class='replayRiderDuration'>(${duration})</p>`)

                .add(`<button id='${watchBtnID}'>watch</button> `)
                .addHook(() => $(`#${watchBtnID}`).click(addClickSound(() => {
                  replayFile = JSON.parse(replay.replay);
                  network.send(`get-map-for-replay<<$${replayFile.map}`);
                  fadeOut($('#replaysListWindow'));
                })))

                .add(`<button id='${saveBtnID}'>save</button> `)
                .addHook(() => $(`#${saveBtnID}`).click(addClickSound(() => {
                  const blob = new Blob([replay.replay], { type: 'text/plain;charset=utf-8' });
                  saveAs(blob, replay.name + '.json');
                })))

                .add(`<button id='${deleteBtnID}'>X</button>`)
                .addHook(() => $(`#${deleteBtnID}`).click(addClickSound(() => {
                  this.replays.remove((r) => r.id == replay.id);
                  this.updateLocalStorage();
                  this.refreshContents();
                })))
                .add('</div>')

                .add('</div><hr />');
            }

            if (this.replays.length == 0) {
              builder.add('<p id=\'noReplaysP\'>No saved replays</p>');
            }

            builder.insertInto('#replaysListContent');
          };

          ReplaysWindow_.prototype.saveReplay = function () {
            // Insert the replay into the beginning of the list and save
            this.replays.unshift({
              id: Math.floor(performance.now() * 1000),
              name: game.getReplayName(),
              replay: game.getReplayFile(),
            });
            this.updateLocalStorage();
          };

          ReplaysWindow_.prototype.updateLocalStorage = function () {
            // Loop while we are unable to save to localStorage and there are still old replays to remove
            do {
              try {
                const raw = Compression.compressToString(JSON.stringify(this.replays));
                localStorage.setItem('Replays', raw);
                return;
              } catch (e) {
                // Try removing the oldest replay
                console.log('killing replay');
                this.replays.pop();
              }
            } while (this.replays.length > 0);

            // Something is wrong with their browser's localStorage
          };

          return new ReplaysWindow_();
        })();

        var elements = [];

        const UIManagerSingleton = (() => {
          function UIManager_() {
            // Map from ID to a UI elements (UIElement or UIWindow)
            this.registry = {};
          }

          UIManager_.prototype.registerUIElement = function (uielement) {
            this.registry[uielement.id] = uielement;
          };

          UIManager_.prototype.getUIElement = function (id) {
            return this.registry[id];
          };

          UIManager_.prototype.draw = function () {
            for (let i in this.registry) {
              this.registry[i].refreshVisibility();
            }
          };


          return new UIManager_();
        })(); // UIManagerSingleton

        // [DEPRECATE] Use the singleton UIManagerSingleton instead and remove this
        // manages all the HTML UIElements; constructor creates everything
        function UIManager() {
          const tipMessages = [
            'Try and get up to 10 workers per castle and gold mine for a high gold income.',
            'Building a second castle near a different gold mine early in the game can double your gold income and give you a big advantage.',
            'Scouting is key! Try and find out what your opponent is doing early game using a worker, wolf, bird, or raider.',
            'Your workers get less efficient after four workers on a mine, so spread them evenly on each gold mine to increase income.',
            'Refresh to get your tips!',
            'Remember to spend your gold! Gold doesn\'t earn interest sitting in your bank and would be more useful as buildings or units.',
            'Start building houses and castles before you get supply blocked, or else you will have to wait for them to complete.',
            'Invisible units can be slightly seen with your eyes, but that doesn\'t mean your units can see them.',
            'Invisible units killing your stuff? You can get detection with Birds by researching Bird Detection, with Airships by researching Airship Telescope Extension, or with Watchtowers by upgrading them.',
            'Mechanical units can be repaired with multiple workers at the same time, but buildings can only be repaired by one worker at a time.',
            'You can customize your hotkeys in the menu.',
            'You can change the volume levels in the menu.',
            'Check out LittleChatGame by typing \'/lcg help\' in the chat.',
            'Play 5 ranked games to be placed in a division.',
            'A handful of replays of your most recent games are automatically saved for you. View them using the Replays button.',
            'Did you just have a particularly amazing game? Save a replay of it by pressing \'Save Replay\' on the score screen.',
            'Are you interested in creating your own maps or mods? Check out the Editor.',
            'Join a clan and meet new friends! You can also create a clan if you want.',
          ];

          var tipsDiv = new UIElement('div', 'tipsDiv', function () {
            return game_state == GAME.LOBBY || game_state == GAME.LOGIN || game_state == GAME.REGISTER || game_state == GAME.RECOVERY;
          });
          $('#tipsDiv').html('Tip:   ' + _.sample(tipMessages));

          /*
            * Win / Loss Window
            */
          this.winLossWindow = new UIWindow('winLossWindow', function () {
            return game && game.gameHasEnded && game_state == GAME.PLAYING;
          }, true, 'Game Statistics', true);
          this.winLossWindow.addScrollableSubDiv('winLossTextArea');

          var quitLogo = document.createElement('img');
          quitLogo.id = 'quitLogo';
          quitLogo.src = 'imgs/Logo.png';
          quitLogo.className = 'quitLogo';
          $('#winLossWindow').append(quitLogo);

          // Quit Game Button
          $('#winLossWindow').append(this.createButton('winLossWindowQuitButton', 'Quit', () => exitGame()));

          /*
             * chat history window
             */
          var chatHistoryWindow = new UIWindow('chatHistoryWindow', function () {
            return true;
          }, true, 'Chat History');
          chatHistoryWindow.addScrollableSubDiv('chatHistorytextContainer');


          /*
             * Lobby div (invis, holds all teh elements)
             */
          var lobbyDiv = new UIElement('div', 'lobbyDiv', () => network.connected && game_state == GAME.LOBBY && !LobbyPlayerManager.active);

          /*
             * lobby chat window
             */
          var lobbyChatWindow = new UIWindow('lobbyChatWindow', null, false, 'Chat');
          lobbyChatWindow.addScrollableSubDiv('lobbyChatTextArea');
          $('#lobbyDiv').append(lobbyChatWindow.domElement);

          // TODO: move these to dedicated files for lobby chat and game lobby
          /*
             * lobby chat input
             */
          new HTMLBuilder()
            .add('<div id=\'lobbyInput\'>')
            .add('<input id=\'lobbyChatInput\' type=\'text\' maxlength=\'250\' placeholder=\'enter text to chat\' autocomplete=\'off\'>')
            .add('</div>')
            .appendInto('#lobbyDiv');

          // TODO: move this elsewhere
          // bind input to send text on enter
          this.chatFunction = (input) => {
            const value = input.val();

            if (value.length > 0) {
              if (value == '/ping') {
                timeOfLastPingSent = Date.now();
                network.send('chat<<$/ping');
              } else if (value == '/showfps') {
                show_fps = !show_fps;
              } else if (value.substr(0, 6) == '/stats') {
                var name = value.substring(7).toLowerCase();
                var types_ = basicUnitTypes.concat(basicBuildingTypes, basicCommands, basicModifiers, basicUpgrades);
                var fieldTypes = unit_fields.concat(building_fields, ability_fields, upgrade_fields, modifiers_fields);
                var found = false;

                for (var i = 0; i < types_.length; i++) {
                  if (types_[i].name.toLowerCase() == name) {
                    var fields_ = ['cost', 'hp', 'mana', 'supply', 'movementSpeed', 'weaponCooldown', 'dmg', 'armor', 'buildTime', 'manaCost', 'aoeRadius'];

                    var div = document.createElement('div');
                    var str = '<p>Stats for <span style=\'color: #FFFD92;\'>' + types_[i].name + '</span>';

                    for (var k = 0; k < fields_.length; k++) {
                      if (types_[i][fields_[k]]) {
                        var val = Object.prototype.toString.call(types_[i][fields_[k]]) === '[object Array]' ? types_[i][fields_[k]][0] : types_[i][fields_[k]];

                        if (val) {
                          for (var j = 0; j < fieldTypes.length; j++) {
                            if (fieldTypes[j].name == fields_[k] && fieldTypes[j].displayScale) {
                              val *= fieldTypes[j].displayScale;
                              j = fieldTypes.length;
                            }
                          }

                          // round val to two decimal places
                          val = Math.round(val * 100) / 100;
                          str += '<p>' + fields_[k] + ': ' + val + '</p>';
                        }
                      }
                    }

                    div.innerHTML = str;
                    addToChatWindow(div);

                    found = true;
                  }
                }

                if (!found) {
                  var p = document.createElement('p');
                  p.innerHTML = 'Sorry, ' + name + ' not found';
                  addToChatWindow(p);
                }
              } else if (value == '/help' || value == '/man' || value == '/info') {
                var div = document.createElement('div');
                var str = '<p><span style=\'color: #FFFD92;\'>Chat commands:</span>';
                str += '<p><span class=\'lcg_command\'>[/ping]</span> send a ping command to the server and see how good your connection is</p>';
                str += '<p><span class=\'lcg_command\'>[/stats]</span> get stats for a specific unit, building, ability or upgrade (for example: \'/stats soldier\')</p>';
                str += '<p><span class=\'lcg_command\'>[/ignore]</span> ignore a player (for example \'/ignore player123\')</p>';
                str += '<p><span class=\'lcg_command\'>[/unignore]</span> unignore a player (for example \'/unignore player123\')</p>';
                str += '<p><span class=\'lcg_command\'>[/ignorelist]</span> show your current ignorelist</p>';
                str += '<p><span class=\'lcg_command\'>[/lcg help]</span> show info about Littlechatgame, a small game you can play in the lobby chat</p>';
                div.innerHTML = str;
                addToChatWindow(div);
              } else if (value == '/ignorelist') {
                addChatMsg('Server', 'Your ignore list: ' + AccountInfo.ignores.join(', '));
              } else if (value.substr(0, 8) == '/ignore ') {
                network.send('ignore<<$' + value.split(' ')[1]);
              } else if (value.substr(0, 10) == '/unignore ') {
                network.send('unignore<<$' + value.split(' ')[1]);
              } else if (value == '/lcg help' || value == '/lcg man' || value == '/lcg info' || value == '/lch help' || value == '/lch man' || value == '/lch info') {
                var div = document.createElement('div');
                var str = '<p><span style=\'color: #FFFD92;\'>Littlechatgame</span> is a game taking place in lobby chat. Send an army of unit-emotes to fight an opponent. Comands:</p><p><span class=\'lcg_command\'>[/lcg fight]</span>';
                str += ' Send your army into battle. Type \'/lcg fight\' followed by the emotes you want to send, for example \'/lcg fight Catapult Archer Soldier Soldier\'. ';
                str += 'Valid emotes / units: Soldier, Archer, Wolf, Mage, Priest, Werewolf, Catapult, Ballista, Dragon, Worker. ';
                str += 'You can only send emotes that you have unlocked. The emotes you type first will stand in the back and the emotes you type last will stand in the front in battle. Your army can consist of max 16 supply of units. ';
                str += '<p><span class=\'lcg_command\'>[/lcg stats]</span> Get Littlechatgame related stats for a player. Example: \'/lcg stats player123\'</p>';
                str += '<p><span class=\'lcg_command\'>[/lcg top]</span> Get a list of the top ranked lcg players</p>';
                str += '<p><span class=\'lcg_command\'>[/lcg units]</span> Get information on all the available units / emotes</p>';
                div.innerHTML = str;
                addToChatWindow(div);
              } else if (value == '/modstuff' && (AccountInfo.isMod || AccountInfo.isAdmin)) {
                var div = document.createElement('div');
                var str = '<p><span style=\'color: #FFFD92;\'>Mod commands:</span></p>';
                str += '<p><span class=\'lcg_command\'>[/killgame]</span> kill a running game (for example when an offensive name is used). Type \'/killgame\' followed by the index of the game (beginning with 0 !!!), for example \'/killgame 2\' would kill the 3rd game in the list. It is possible to kill multiple games at once by typing for example \'/killgame 0 3 4\'</p>';
                if (AccountInfo.isMod2 || AccountInfo.isAdmin) {
                  str += '<p><span class=\'lcg_command\'>[/reward]</span> give gold to a player. Type \'/reward\' followed by the name of the player and then the amount of gold to reward, for example \'/reward mage 2000\'. Rewards can not be higher than 10000. Player will see popup notification (if he is online).</p>';
                }
                str += '<p><span class=\'lcg_command\'>[/killmap]</span> delete a map (for example when using offensive content or name). Type \'/killmap\' followed by the name of the map, for example \'/killmap la petite (deleted maps are not entirely deleted, theres still a backup stored, so no worries if you misstype or something, it can always be restored)</p>';
                str += '<p><span class=\'lcg_command\'>[/plinfo]</span> shows some information about a player. Works on guests, too (for example \'/plinfo player123\')</p>';
                str += '<p><span class=\'lcg_command\'>[/unban]</span> unbans a player account</p>';
                str += '<p><span class=\'lcg_command\'>[/setwelcomemessage]</span> (ADMIN) sets the welcome message to whatever follows the command</p>';
                div.innerHTML = str;
                addToChatWindow(div);
              } else if (value.startsWith('/setwelcomemessage')) {
                const msg = value.split(' ').slice(1).join(' ');
                const msgObject = { message: msg };
                network.send(`set-welcome-message<<$${JSON.stringify(msgObject)}`);
              } else {
                network.send('chat<<$' + value);
              }

              $(input).val('');
            }
          };

          $('#lobbyChatInput').keydown((e) => {
            if (keyManager.getKeyCode(e) == KEY.ENTER && network.connected) {
              this.chatFunction($('#lobbyChatInput'));
            }
          });

          /*
             * Options Window
             */
          var optionsWindow = new UIWindow('optionsWindow', function () {
            return true;
          }, true, 'Options', true, function (key) {
            if (key == KEY.N && (game_state == GAME.PLAYING || game_state == GAME.EDITOR)) {
              $('#optionsQuitButton')[0].click();
            }

            if (key == KEY.ESC) {
              fadeOut($('#optionsWindow'));
              soundManager.playSound(SOUND.CLICK);
            }
          });

          // Buttons at the top
          var optionsButtonsDiv = document.createElement('div');
          optionsButtonsDiv.id = 'optionsButtonsDiv';
          $('#optionsWindow').append(optionsButtonsDiv);

          // Toggle options
          var optionsChecklistDiv = document.createElement('div');
          optionsChecklistDiv.id = 'optionsChecklistDiv';
          $('#optionsWindow').append(optionsChecklistDiv);

          // Fullscreen Button
          $('#optionsButtonsDiv').append(this.createButton('optionsFullscreenButton', 'Fullscreen [<font class=\'redfont\'>F8</font>]', function () {
            toggleFullscreen(document.documentElement);
          }));


          // sound volume label
          var soundVolumeLabel = document.createElement('p');
          soundVolumeLabel.id = 'soundVolumeLabel';
          soundVolumeLabel.innerHTML = 'Sound Effects Volume';
          $('#optionsChecklistDiv').append(soundVolumeLabel);

          // sound volume slider
          var optionsSoundButton = document.createElement('div');
          optionsSoundButton.id = 'optionsSoundButton';
          $('#soundVolumeLabel').append(optionsSoundButton);
          $('#optionsSoundButton').slider({ slide: (event, ui) => soundManager.volume.set(ui.value / 100) });
          $('#optionsSoundButton').slider({ change: (event, ui) => soundManager.volume.set(ui.value / 100) });
          $('#optionsSoundButton').slider('value', soundManager.volume.get() * 100);

          // music volume label
          var musicVolumeLabel = document.createElement('p');
          musicVolumeLabel.id = 'musicVolumeLabel';
          musicVolumeLabel.innerHTML = 'Music Volume';
          $('#optionsChecklistDiv').append(musicVolumeLabel);

          // music volume slider
          var optionsMusicButton = document.createElement('div');
          optionsMusicButton.id = 'optionsMusicButton';
          $('#musicVolumeLabel').append(optionsMusicButton);
          $('#optionsMusicButton').slider({ slide: (event, ui) => musicManager.volume.set(ui.value / 100) });
          $('#optionsMusicButton').slider({ change: (event, ui) => musicManager.volume.set(ui.value / 100) });
          $('#optionsMusicButton').slider('value', musicManager.volume.get() * 100);

          // LCG volume label
          const lcgVolumeLabel = document.createElement('p');
          lcgVolumeLabel.id = 'lcgVolumeLabel';
          lcgVolumeLabel.innerHTML = 'LittleChatGame Volume';
          lcgVolumeLabel.title = 'Set the percentage of the total Sound Effects Volume that Littlechatgame sounds will play at.';
          $('#optionsChecklistDiv').append(lcgVolumeLabel);

          // LCG volume slider
          const lcgVolumeSlider = document.createElement('div');
          lcgVolumeSlider.id = 'lcgVolumeSlider';
          $('#lcgVolumeLabel').append(lcgVolumeSlider);
          $('#lcgVolumeSlider').slider({ slide: (event, ui) => lcgVolume.set(ui.value / 100) });
          $('#lcgVolumeSlider').slider({ change: (event, ui) => lcgVolume.set(ui.value / 100) });
          Initialization.onDocumentReady(() => $('#lcgVolumeSlider').slider('value', lcgVolume.get() * 100));

          // scroll speed label
          var scrollSpeedLabel = document.createElement('p');
          scrollSpeedLabel.id = 'scrollSpeedLabel';
          scrollSpeedLabel.innerHTML = 'Scroll Speed';
          $('#optionsChecklistDiv').append(scrollSpeedLabel);

          // scroll speed slider
          var scrollSpeedButton = document.createElement('div');
          scrollSpeedButton.id = 'scrollSpeedButton';
          $('#scrollSpeedLabel').append(scrollSpeedButton);
          $('#scrollSpeedButton').slider({ slide: (event, ui) => interface_.scrollSpeed.set(ui.value * 50) });
          $('#scrollSpeedButton').slider({ change: (event, ui) => interface_.scrollSpeed.set(ui.value * 50) });
          Initialization.onDocumentReady(() => $('#scrollSpeedButton').slider('value', interface_.scrollSpeed.get() / 50));

          // Setting for when messages can pop up
          const popupMsgsBuilder = new HTMLBuilder();
          {
            const selectID = uniqueID();
            popupMsgsBuilder
              .add('<p title=\'Set when new messages can pop up.\'>Message pop-ups')
              .add(`<select id='${selectID}'>`);
            for (let i in Chats.POPUP_CHATS_CAPTIONS) {
              popupMsgsBuilder.add(`<option value='${i}'>${Chats.POPUP_CHATS_CAPTIONS[i]}</option>`);
            }
            popupMsgsBuilder
              .add('</select></p>')
              .addHook(() => $(`#${selectID}`).val(Chats.popupChats.get()))
              .addHook(() => $(`#${selectID}`).change(() => Chats.popupChats.set($(`#${selectID}`).val())))
              .appendInto('#optionsChecklistDiv');
          }

          // Mouse scroll on off Checkbox
          var scrollLabel = document.createElement('p');
          scrollLabel.id = 'scrollLabel';
          scrollLabel.innerHTML = 'Enable mouse scroll in non fullscreen mode';
          scrollLabel.title = 'When this option is deactivated, the screen will not scroll when you move the cursor to the border of the screen when you are not in fullscreen mode.';
          $('#optionsChecklistDiv').append(scrollLabel);

          var scrollCheckbox = document.createElement('input');
          scrollCheckbox.id = 'scrollCheckbox';
          scrollCheckbox.type = 'checkbox';
          scrollCheckbox.onclick = addClickSound(() => interface_.mouseScrollWhenWindowed.set(scrollCheckbox.checked));
          Initialization.onDocumentReady(() => scrollCheckbox.checked = interface_.mouseScrollWhenWindowed.get());
          $('#scrollLabel').append(scrollCheckbox);

          // Pointer lock
          var pointerLockLabel = document.createElement('p');
          pointerLockLabel.id = 'pointerLockLabel';
          pointerLockLabel.innerHTML = 'Lock mouse pointer to screen ingame';
          pointerLockLabel.title = 'The mouse pointer will stay locked inside the game screen after the first click. This may cause the cursor to be slightly laggy.';
          $('#optionsChecklistDiv').append(pointerLockLabel);

          var pointerLockCheckbox = document.createElement('input');
          pointerLockCheckbox.id = 'pointerLockCheckbox';
          pointerLockCheckbox.type = 'checkbox';
          pointerLockCheckbox.onclick = addClickSound(() => {
            interface_.setPointerLockEnabled(pointerLockCheckbox.checked);
          });
          Initialization.onDocumentReady(() => {
            pointerLockCheckbox.checked = interface_.pointerLockEnabled.get();
          });
          $('#pointerLockLabel').append(pointerLockCheckbox);

          // Middle Mouse invert scroll
          var mmLabel = document.createElement('p');
          mmLabel.id = 'mmLabel';
          mmLabel.innerHTML = 'Invert middle mouse button scrolling';
          mmLabel.title = 'Invert the middle mouse scrolling (you can press and hold middle mouse button ingame to scroll).';
          $('#optionsChecklistDiv').append(mmLabel);

          var mmCheckbox = document.createElement('input');
          mmCheckbox.id = 'mmCheckbox';
          mmCheckbox.type = 'checkbox';
          mmCheckbox.onclick = addClickSound(() => keyManager.mmScrollInvert.set(mmCheckbox.checked));
          Initialization.onDocumentReady(() => mmCheckbox.checked = keyManager.mmScrollInvert.get());
          $('#mmLabel').append(mmCheckbox);

          // HP bars only when not full hp
          var hpBarsLabel = document.createElement('p');
          hpBarsLabel.id = 'hpBarsLabel';
          hpBarsLabel.innerHTML = 'Show HP bars when full HP';
          hpBarsLabel.title = 'Show a unit or building\'s HP bars when it has full HP.';
          $('#optionsChecklistDiv').append(hpBarsLabel);

          var hpBarsCheckbox = document.createElement('input');
          hpBarsCheckbox.id = 'hpBarsCheckbox';
          hpBarsCheckbox.type = 'checkbox';
          hpBarsCheckbox.onclick = addClickSound(() => interface_.showFullHPBars.set(hpBarsCheckbox.checked));
          Initialization.onDocumentReady(() => hpBarsCheckbox.checked = interface_.showFullHPBars.get());
          $('#hpBarsLabel').append(hpBarsCheckbox);

          // no main manu music
          var noMainMenuMusicLabel = document.createElement('p');
          noMainMenuMusicLabel.id = 'noMainMenuMusicLabel';
          noMainMenuMusicLabel.innerHTML = 'No menu / lobby music';
          noMainMenuMusicLabel.title = 'Don\'t play music in the menus / lobby.';
          $('#optionsChecklistDiv').append(noMainMenuMusicLabel);

          var noMainMenuMusicCheckbox = document.createElement('input');
          noMainMenuMusicCheckbox.id = 'noMainMenuMusicCheckbox';
          noMainMenuMusicCheckbox.type = 'checkbox';
          noMainMenuMusicCheckbox.onclick = addClickSound(() => musicManager.noMainMenuMusic.set(noMainMenuMusicCheckbox.checked));
          noMainMenuMusicCheckbox.checked = musicManager.noMainMenuMusic.get();
          $('#noMainMenuMusicLabel').append(noMainMenuMusicCheckbox);

          // no rain
          var noRainLabel = document.createElement('p');
          noRainLabel.id = 'noRainLabel';
          noRainLabel.innerHTML = 'No rain effects';
          noRainLabel.title = 'Disable in-game rain effects';
          $('#optionsChecklistDiv').append(noRainLabel);

          var noRainCheckbox = document.createElement('input');
          noRainCheckbox.id = 'noRainCheckbox';
          noRainCheckbox.type = 'checkbox';
          noRainCheckbox.onclick = addClickSound(() => interface_.noRain.set(noRainCheckbox.checked));
          Initialization.onDocumentReady(() => noRainCheckbox.checked = interface_.noRain.get());
          $('#noRainLabel').append(noRainCheckbox);

          // no guest direct messages
          var noGuestDMLabel = document.createElement('p');
          noGuestDMLabel.id = 'noGuestDMLabel';
          noGuestDMLabel.innerHTML = 'No direct messages from guests';
          noGuestDMLabel.title = 'Disable direct messages from guests';
          $('#optionsChecklistDiv').append(noGuestDMLabel);

          var noGuestDMCheckbox = document.createElement('input');
          noGuestDMCheckbox.id = 'noGuestDMCheckbox';
          noGuestDMCheckbox.type = 'checkbox';
          noGuestDMCheckbox.onclick = addClickSound(() => interface_.noGuestDM.set(noGuestDMCheckbox.checked));
          Initialization.onDocumentReady(() => noGuestDMCheckbox.checked = interface_.noGuestDM.get());
          $('#noGuestDMLabel').append(noGuestDMCheckbox);

          // open custom hotkeys window
          $('#optionsButtonsDiv').append(this.createButton('hotkeyWindowButton', 'Hotkeys', function () {
            Hotkeys.showWindow();
            fadeOut($('#optionsWindow'));
            soundManager.playSound(SOUND.CLICK);
          }));

          // open FAQ window
          $('#optionsButtonsDiv').append(this.createButton('openFaqButton', 'F.A.Q.', function () {
            fadeIn($('#faqWindow'));
            soundManager.playSound(SOUND.CLICK);
          }));

          // open window to load custom AI
          $('#optionsButtonsDiv').append(this.createButton('loadAIButton', 'Load custom AI', function () {
            // create new input and simulate a click on it and set function (we have to make a new one, so onchange works when the same replay is loaded 2 times in a row)
            fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.click();

            fileInput.onchange = function () {
              var file = fileInput.files[0];
              if (file) {
                var reader = new FileReader();
                reader.onload = (e) => {
                  AIManager.sendCustomAIToWorker(e.target.result);
                };
                reader.readAsBinaryString(file);
              }
            };

            soundManager.playSound(SOUND.CLICK);
          }));
          $('#loadAIButton')[0].title = 'Load custom AI file (you can write your own AI and load it into the game. For more information on that, check the blog)';

          this.optionsPauseButton = new UIElement('button', 'optionsPauseButton', function () {
            return game_state == GAME.PLAYING;
          });
          this.optionsPauseButton.domElement.innerHTML = 'Pause [<font color=\'red\'>Pause</font>]';
          $('#optionsButtonsDiv').append(this.optionsPauseButton.domElement);
          this.optionsPauseButton.domElement.onclick = function () {
            pauseGame();
          };
          //
          this.quitGameButton = new UIElement('button', 'optionsQuitButton', function () {
            return game_state == GAME.PLAYING || game_state == GAME.EDITOR;
          });
          this.quitGameButton.domElement.innerHTML = 'Quit [<font color=\'red\'>N</font>]';
          $('#optionsWindow').append(this.quitGameButton.domElement);
          this.quitGameButton.domElement.onclick = () => {
            fadeOut($('#optionsWindow'));

            // Exiting the editor into the lobby
            if (game_state == GAME.EDITOR) {
              game_state = GAME.LOBBY;
              soundManager.playSound(SOUND.CLICK);
              network.send('leave-game');
              worker.postMessage({ what: 'end-game' });
            } else {
              exitGame();
            }
          };

          /*
             * Queries Window
             */
          var queriesWindow = new UIWindow('queriesWindow', function () {
            return true;
          }, true, 'Friends', true);
          queriesWindow.addScrollableSubDiv('chatListSubDiv');
          queriesWindow.addScrollableSubDiv('friendsSubdiv');
          queriesWindow.addSubDiv('addFriendSubDiv');

          var p = document.createElement('p');
          p.innerHTML = '&raquo; Messages';
          p.id = 'queriesTitle';
          $('#queriesWindow').append(p);

          // button daddy
          var buttonDaddy = document.createElement('div');
          buttonDaddy.id = 'buttonDaddy';
          $('#lobbyDiv').append(buttonDaddy);

          // Create Multi Button
          $('#buttonDaddy').append(this.createButton('lobbyCreateButton', 'Play', function () {
            MapSelection.openWindow(MapSelection.SelectionAction.MULTIPLAYER);
          }));
          $('#lobbyCreateButton').prop('title', 'Click here to create a new multiplayer game. Alternatively you can join an existing game by simply clicking it (you find them in the games window on the left).');

          // Create Single Button
          $('#buttonDaddy').append(this.createButton('singleplayerButton', 'Play vs CPU', function () {
            MapSelection.openWindow(MapSelection.SelectionAction.SINGLEPLAYER);
          }));
          $('#singleplayerButton').prop('title', 'Click here to create a new singleplayer game and play vs computer opponents.');

          // Ladder Button
          $('#buttonDaddy').append(this.createButton('ladderButton', 'Ranked Match', function () {
            network.send(JSON.stringify({ message: 'get-ladder-maps' }));
            soundManager.playSound(SOUND.CLICK);
          }));
          $('#ladderButton')[0].title = 'Play a ranked 1v1 match via auto matchmaking.';

          // Map Editor Button
          $('#buttonDaddy').append(this.createButton('mapEditorButton', 'Editor', function () {
            network.send('cancel-ladder');
            fadeOut($('#ladderWindow'));

            game_state = GAME.EDITOR;
            editor = new MapEditor();
            soundManager.playSound(SOUND.CLICK);
            network.send('leave-lobby');
          }));
          $('#mapEditorButton')[0].title = 'The editor is a powerful tool that allows you to create your own maps and mods.';

          // Replay Button
          $('#buttonDaddy').append(this.createButton('replayButton', 'Replays', addClickSound(() => {
            ReplaysWindow.openWindow();
          })));
          $('#replayButton')[0].title = 'View replays of your recently played games and load replays that you saved on your computer.';

          // Create Tutorial Button
          if (!hideTutorials.get()) {
            var tutorialButtonSpan = document.createElement('span');
            tutorialButtonSpan.id = 'tutorialButtonSpan';
            $('#buttonDaddy').append(tutorialButtonSpan);

            $('#tutorialButtonSpan').append(this.createButton('tutorialButton', 'Tutorials', () => {
              MapSelection.openWindow(MapSelection.SelectionAction.TUTORIAL);
            }));
            $('#tutorialButton').prop('title', 'Here you can play several tutorials, that will introduce you to the game\'s basic features');

            $('#tutorialButtonSpan').append(this.createButton('killTutorialButtonButton', 'x', addClickSound(() => {
              displayConfirmPrompt(
                'Hide this button? You will still be able to play the tutorials by clicking \'Play vs CPU\' and searching for \'tutorial\'',
                killTutorialButton,
                () => { },
              );
            })));

            $('#killTutorialButtonButton')[0].title = 'Hide this button and dont show it again. You will still be able to play the tutorials by clicking \'Play vs CPU\' and searching for \'tutorial\'.';
          }

          /*
             * ingame Chat Input
             */
          this.ingameInput = new UIElement('input', 'ingameChatInput', function () {
            return game_state == GAME.PLAYING && this.active;
          });
          $('#ingameChatInput')[0].type = 'text';
          $('#ingameChatInput')[0].onkeydown = function (e) {
            if (keyManager.getKeyCode(e) == KEY.ENTER && uimanager.ingameInput.active) {
              if (this.value.length > 0) {
                if (network_game && network && network.socket) {
                  const chatCommand = game.commands.find((c) => c.chat_str == this.value);
                  if (chatCommand) {
                    game.issueOrderToUnits(game.selectedUnits, chatCommand);
                  } else if (this.value.substr(0, 8) == '/ignore ') {
                    network.send('ignore<<$' + this.value.split(' ')[1]);
                  } else if (this.value.substr(0, 10) == '/unignore ') {
                    network.send('unignore<<$' + this.value.split(' ')[1]);
                  } else {
                    if (this.value == '/ping') {
                      timeOfLastPingSent = Date.now();
                    }

                    network.send('chati<<$' + $('#ingameChatDropdown')[0].value + '<<$' + this.value);
                  }
                } else {
                  var msg = PLAYING_PLAYER.name + ': ' + this.value;
                  interface_.chatMsg(msg);
                  game.addChatMsgToLog(msg);
                }

                this.value = '';
              }

              uimanager.ingameInput.active = false;
            }

            // tab between ally chat and all chat
            else if (keyManager.getKeyCode(e) == KEY.TAB) {
              $('#ingameChatDropdown')[0].selectedIndex = $('#ingameChatDropdown')[0].selectedIndex == 0 ? 1 : 0;
              return false;
            }

            // close input on ESC
            else if (keyManager.getKeyCode(e) == KEY.ESC) {
              uimanager.ingameInput.active = false;
            }
          };

          // allies / all dropdown for ingame chat
          var ingameChatDropdown = new UIElement('select', 'ingameChatDropdown', function () {
            return game_state == GAME.PLAYING && uimanager.ingameInput.active;
          });
          $('#ingameChatDropdown').html('<option value=\'*\'>All</option><option value=\'~\'>Allies</option>');


          /*
             * Info Window & Info Window 2
             */
          this.infoWindow = new UIWindow('infoWindow', function () {
            return true;
          }, true, null, true);
          this.infoWindow.addScrollableSubDiv('infoWindowTextArea');

          var infoWindow2 = new UIWindow('infoWindow2', function () {
            return true;
          }, true, null, true);
          infoWindow2.addScrollableSubDiv('infoWindowTextArea2');


          /*
             * Ladder Window
             */
          var ladderWindow = new UIWindow('ladderWindow', function () {
            return true;
          }, false, null, true);
          $('#ladderWindow')[0].style.display = 'none';


          /*
             * Replay control panel
             */
          const replayControlWindow = new UIWindow('replayControlWindow', function () {
            return game_state == GAME.PLAYING && game.replay_mode;
          }, false, null, false, function (key) {
            if (key == KEY.PLUS) {
              $('#replayPlusButton')[0].click();
            } else if (key == KEY.MINUS) {
              $('#replayMinusButton')[0].click();
            }
          });
          replayControlWindow.blocksCanvas = false;

          const replayPlusButton = this.createButton('replayPlusButton', '+', function () {
            setReplaySpeed(replaySpeedIndex + 1);
            soundManager.playSound(SOUND.CLICK);
          });

          const replayMinusButton = this.createButton('replayMinusButton', '-', function () {
            setReplaySpeed(replaySpeedIndex - 1);
            soundManager.playSound(SOUND.CLICK);
          });

          const replayShowSpeed = document.createElement('p');
          replayShowSpeed.id = 'replayShowSpeed';
          replayShowSpeed.innerHTML = '1x';

          const replayPlayButton = this.createButton('replayPlayButton', '>', function () {
            pauseGame();
            soundManager.playSound(SOUND.CLICK);

            if (game_paused) {
              $('#replayPlayButton').text('||').css({ 'font-size': '10px' });
            } else {
              $('#replayPlayButton').text('>').css({ 'font-size': '' });
            }
          });

          $('#replayControlWindow').append(replayPlusButton);
          $('#replayControlWindow').append(replayMinusButton);
          $('#replayControlWindow').append(replayShowSpeed);
          $('#replayControlWindow').append(replayPlayButton);


          /*
             * Map Editor New Map Window
             */
          var newMapWindow = new UIWindow('newMapWindow', function () {
            return true;
          }, true, 'New Map', true);
          newMapWindow.addScrollableSubDiv('newMapWindowSubdiv');

          const newMapBuilder = new HTMLBuilder();
          newMapBuilder
            .add('<br />Size <input type=\'text\' id=\'newMapSizeX\' value=\'64\' /> : ')
            .addHook(() => $('#newMapSizeX').change(() => checkNewMapInputs()))
            .add('<input type=\'text\' id=\'newMapSizeY\' value=\'64\' />')
            .addHook(() => $('#newMapSizeY').change(() => checkNewMapInputs()))
            .add('<br /><br />Theme: <select id=\'themeSelecter\'>');
          mapThemes.forEach((t) => newMapBuilder.add(`<option value='${t.name}'>${t.name}</option>`));
          newMapBuilder
            .add('</select><br /><br />Default height level: <select id=\'heightLevelSelect\'>')
            .add('<option value=\'0\'>0</option><option value=\'1\'>1</option><option value=\'2\'>2</option></select>')
            .insertInto('#newMapWindowSubdiv');

          // OK Button
          $('#newMapWindowSubdiv').append(this.createButton('createMapOKButton', 'OK', addClickSound(() => {
            const validMapDimensions = checkNewMapInputs();
            if (validMapDimensions) {
              fadeOut($('#newMapWindow'));

              const theme = $('#themeSelecter')[0].value;
              const x = parseInt($('#newMapSizeX')[0].value);
              const y = parseInt($('#newMapSizeY')[0].value);
              const defaultHeight = $('#heightLevelSelect').val();

              uimanager.showLoadingScreen();
              setTimeout(() => editor = new MapEditor(x, y, theme, defaultHeight), 50);
            }
          })));

          /*
             * Map Editor Interface
             */
          var mapEditorInterface = new UIWindow('mapEditorInterface', function () {
            return game_state == GAME.EDITOR;
          });
          mapEditorInterface.blocksCanvas = false;

          // Select button
          $('#mapEditorInterface').append(this.createButton('editorSelectButton', '', function () {
            editor.selectedItemType = null;
            editor.terrainModifier = 0;
            soundManager.playSound(SOUND.CLICK);
          }));
          $('#editorSelectButton')[0].title = 'Select Mode';

          // Mouse Cursor pos div
          var cursorPosDiv = document.createElement('div');
          cursorPosDiv.id = 'cursorPosDiv';
          $('#mapEditorInterface').append(cursorPosDiv);

          // Higher Terrain Button
          $('#mapEditorInterface').append(this.createButton('editorHigherTerrainButton', '<span class=\'mapEditorHotkey\'>[D]</span>', addClickSound(higherTerrain)));
          $('#editorHigherTerrainButton')[0].title = 'Higher cliff level';

          // Lower Terrain Button
          $('#mapEditorInterface').append(this.createButton('editorLowerTerrainButton', '<span class=\'mapEditorHotkey\'>[F]</span>', addClickSound(lowerTerrain)));
          $('#editorLowerTerrainButton')[0].title = 'Lower cliff level';

          // Add Ramp Button
          $('#mapEditorInterface').append(this.createButton('addRampButton', '<span class=\'mapEditorHotkey\'>[S]</span>', addClickSound(addRamp)));
          $('#addRampButton')[0].title = 'Add ramp';

          // Kill Ramp Button
          $('#mapEditorInterface').append(this.createButton('killRampButton', '<span class=\'mapEditorHotkey\'>[A]</span>', addClickSound(killRamp)));
          $('#killRampButton')[0].title = 'Remove ramp';

          // Mirror Button
          $('#mapEditorInterface').append(this.createButton('mirrorButton', '<span class=\'mapEditorHotkey\'>[G]</span>', addClickSound(() => editor.updateMirroringMode())));
          $('#mirrorButton').tooltip();
          $('#mirrorButton')[0].title = 'Mirroring modes';

          $('#mapEditorInterface').append(this.createButton('editorUndoButton', '<span class=\'mapEditorHotkey\'>[U]</span>', function () {
            editor.clipboard.history.undo();
            soundManager.playSound(SOUND.CLICK);
          }));
          $('#editorUndoButton')[0].title = 'Undo last action';

          // player select dropdown
          const createPlayerSelectDropdown = (playerSettings) => {
            $('#playerDropdown').remove();

            const playerDropdownBuilder = new HTMLBuilder()
              .add('<select id=\'playerDropdown\'>')
              .add('<option value=\'0\'>Neutral</option>');

            let selectedValue = 0;
            playerSettings.forEach((setting, i) => {
              if (setting.slot != 'closed') {
                if (selectedValue == 0) {
                  selectedValue = i + 1;
                }
                playerDropdownBuilder.add(`<option value='${i + 1}'>Player ${i + 1}</option>`);
              }
            });

            playerDropdownBuilder
              .add('</select>')
              .addHook(() => $('#playerDropdown').change(() => {
                if (game_state != GAME.EDITOR || !editor) {
                  return;
                }

                editor.player = $('#playerDropdown').val();

                // Change owner of selected units
                game.selectedUnits.forEach((u) => {
                  if (u && !u.type.alwaysNeutral && (u.type.isBuilding || u.type.isUnit)) {
                    u.owner = game.players[editor.player];
                    worker.postMessage({ what: 'unitChangeOwner', unit: u.id, owner: editor.player });
                  }
                });
              }))
              .addHook(() => {
                $('#playerDropdown').val(selectedValue);
                $('#playerDropdown').change();
              })
              .appendInto('#mapEditorInterface');
          };
          MapEditorSettings.onPlayerSettingsChange(createPlayerSelectDropdown);

          // show grid checkbox
          var showGridCheckbox = document.createElement('input');
          showGridCheckbox.type = 'checkbox';
          showGridCheckbox.id = 'showGridCheckbox';
          showGridCheckbox.onchange = function () {
            soundManager.playSound(SOUND.CLICK);
          };
          $('#mapEditorInterface').append(showGridCheckbox);

          // show grid label
          var showGridLabel = document.createElement('label');
          showGridLabel.id = 'showGridLabel';
          showGridLabel.innerHTML = 'Show grid';
          showGridLabel.htmlFor = 'showGridCheckbox';
          $('#mapEditorInterface').append(showGridLabel);

          // Play button
          $('#mapEditorInterface').append(this.createButton('editorPlayButton', 'Test [Q]', addClickSound(testMap)));

          // Save button
          $('#mapEditorInterface').append(this.createButton('editorSaveButton', 'Save', function () {
            var blob = new Blob([JSON.stringify(game.export_())], { type: 'text/plain;charset=utf-8' });
            saveAs(blob, `${game.name}.json`);
            soundManager.playSound(SOUND.CLICK);
          }));

          // Load button
          $('#mapEditorInterface').append(this.createButton('editorLoadButton', 'Load', () => {
            MapSelection.openWindow(MapSelection.SelectionAction.EDITOR);
          }));

          // New Map button
          $('#mapEditorInterface').append(this.createButton('editorNewButton', 'New', function () {
            fadeIn($('#newMapWindow'));
            soundManager.playSound(SOUND.CLICK);
          }));

          // Upload map button
          $('#mapEditorInterface').append(this.createButton('uploadMapButton', 'Upload', function () {
            if (AccountInfo.authedAndLogged) {
              if (game.name != 'unnamed' && game.name.length > 0) {
                network.send('upload-map-request<<$' + game.name);
                displayInfoMsg('uploading...');
              } else {
                displayInfoMsg('You need to set a map name first');
              }
            } else {
              displayInfoMsg('You need to be logged in to upload your map!');
            }

            soundManager.playSound(SOUND.CLICK);
          }));

          // Map settings button
          $('#mapEditorInterface').append(this.createButton('mapSettingsButton', 'Settings', function () {
            fadeIn($('#mapSettingsWindow'));
            soundManager.playSound(SOUND.CLICK);
          }));

          // Manage uploaded Maps button
          $('#mapEditorInterface').append(this.createButton('manageMapsButton', 'My Maps', function () {
            fadeIn($('#manageMapsWindow'));

            network.send('request-my-maps');

            soundManager.playSound(SOUND.CLICK);
          }));

          // Data Button
          $('#mapEditorInterface').append(this.createButton('dataButton', 'Data', () => {
            const toggleDataWindow = addClickSound(() => {
              if ($('#mapEditorData')[0].style.display == 'none') {
                fadeIn($('#mapEditorData'));
              } else {
                fadeOut($('#mapEditorData'));
              }

              mapEditorData.window.active = !mapEditorData.window.active;
            });

            if (!MapEditorSettings.isModded()) {
              displayConfirmPrompt(
                'Continuing will convert this map into a modded map. ' +
                'This means that you can modify almost all of the gameplay to create a customized experience. ' +
                'Would you like to continue?',
                () => {
                  MapEditorSettings.setModded(true);
                  toggleDataWindow();
                },
                () => { },
              );
            } else {
              toggleDataWindow();
            }
          }));

          $('#mapEditorInterface').append(this.createButton('customGraphicsButton', 'Graphics', function () {
            if ($('#customGraphicsWindow')[0].style.display == 'none') {
              fadeIn($('#customGraphicsWindow'));
              refreshCustomImgs();
            } else {
              fadeOut($('#customGraphicsWindow'));
            }
            soundManager.playSound(SOUND.CLICK);
          }));

          var customGraphicsWindow = new UIWindow('customGraphicsWindow', () => true, true, 'Graphics', true);
          customGraphicsWindow.addScrollableSubDiv('customGraphicsWindowSubdiv');
          customGraphicsWindow.setTitleText('Graphics');
          customGraphicsWindow.setHeadRider(new HTMLBuilder()
            .add('<button id=\'saveGraphics\'>Ok</button>')
            .addHook(() => $('#saveGraphics').click(saveCustomGraphics)));

          new HTMLBuilder()
            .add('<button id=\'loadGraphicButton\'>Import graphic</button>')
            .addHook(() => $('#loadGraphicButton').click(importGraphic))
            .add('<div id=\'customGraphicsDiv\'></div>')
            .insertInto('#customGraphicsWindowSubdiv');

          /*
             * Uploaded Maps Management Window
             */
          var manageMapsWindow = new UIWindow('manageMapsWindow', function () {
            return true;
          }, true, 'Manage Maps', true);
          manageMapsWindow.addScrollableSubDiv('mapWindowSubdiv');

          // Menu button
          var ingameMenuButton = new UIElement('button', 'ingameMenuButton', function () {
            return game_state != GAME.LOGIN && game_state != GAME.RECOVERY && game_state != GAME.REGISTER;
          });
          ingameMenuButton.blocksCanvas = false;
          ingameMenuButton.domElement.className = 'menuButtons';
          ingameMenuButton.domElement.title = 'Options';
          $('#ingameMenuButton')[0].onclick = function () {
            if ($('#optionsWindow')[0].style.display == 'none') {
              fadeIn($('#optionsWindow'));
            } else {
              fadeOut($('#optionsWindow'));
            }

            soundManager.playSound(SOUND.CLICK);
          };

          // ingame Chat History Window button
          var ingameChatHistoryButton = new UIElement('button', 'ingameChatHistoryButton', function () {
            return game_state == GAME.PLAYING;
          });
          ingameChatHistoryButton.blocksCanvas = false;
          ingameChatHistoryButton.domElement.className = 'menuButtons';
          ingameChatHistoryButton.domElement.title = 'Chat History';
          ingameChatHistoryButton.domElement.onclick = function () {
            if ($('#chatHistoryWindow')[0].style.display == 'none') {
              fadeIn($('#chatHistoryWindow'));
            } else {
              fadeOut($('#chatHistoryWindow'));
            }
            soundManager.playSound(SOUND.CLICK);
          };

          // clans button
          var clansButton = new UIElement('button', 'clansButton', function () {
            return game_state == GAME.LOBBY && AccountInfo.authedAndLogged;
          });
          clansButton.blocksCanvas = false;
          clansButton.domElement.className = 'menuButtons';
          clansButton.domElement.title = 'Clans';
          $('#clansButton')[0].onclick = function () {
            network.send('request-my-clan-info');
            soundManager.playSound(SOUND.CLICK);
          };

          // friends button
          var friendsButton = new UIElement('button', 'friendsButton', function () {
            return game_state != GAME.LOGIN && game_state != GAME.RECOVERY && game_state != GAME.REGISTER;
          });
          friendsButton.blocksCanvas = false;
          friendsButton.domElement.className = 'menuButtons';
          friendsButton.domElement.title = 'Friends & Messages';
          $('#friendsButton')[0].onclick = addClickSound(() => {
            if ($('#queriesWindow')[0].style.display == 'none') {
              fadeIn($('#queriesWindow'));
            } else {
              fadeOut($('#queriesWindow'));
            }

            $('#friendsButton').removeClass('blinkBGRed');
          });

          // emotes button
          var emotesButton = new UIElement('button', 'emotesButton', function () {
            return game_state == GAME.LOBBY && AccountInfo.authedAndLogged;
          });
          emotesButton.blocksCanvas = false;
          emotesButton.domElement.className = 'menuButtons';
          emotesButton.domElement.title = 'Unlockable Items';
          $('#emotesButton')[0].onclick = function () {
            Microtransactions.showMicroTransWindow();
            soundManager.playSound(SOUND.CLICK);
          };

          // achivements button
          var achivementsButton = new UIElement('button', 'achivementsButton', function () {
            return game_state == GAME.LOBBY && AccountInfo.authedAndLogged;
          });
          achivementsButton.blocksCanvas = false;
          achivementsButton.domElement.className = 'menuButtons';
          achivementsButton.domElement.title = 'Achievements';
          $('#achivementsButton')[0].onclick = function () {
            network.send('get-achivements');
            soundManager.playSound(SOUND.CLICK);
          };


          // Bing message
          var bingMessage = document.createElement('div');
          bingMessage.id = 'bingMessageWindow';
          bingMessage.className = 'ingameWindow';
          document.body.appendChild(bingMessage);


          // Player Info Window
          this.playerInfoWindow = new UIWindow('playerInfoWindow', function () {
            return true;
          }, true, 'Player Info', true);
          // Add a rider div <<<<<
          var riderDiv = document.createElement('div');
          riderDiv.id = 'riderDiv';
          $('#playerInfoWindow')[0].appendChild(riderDiv);
          this.playerInfoWindow.addScrollableSubDiv('addScrollableSubDivTextArea');
          $('#addScrollableSubDivTextArea').addClass('nodrag');

          // Player Info Window 2
          this.playerInfoWindow2 = new UIWindow('playerInfoWindow2', function () {
            return true;
          }, true, ' ', true);
          this.playerInfoWindow2.addScrollableSubDiv('addScrollableSubDivTextArea2');
          $('#addScrollableSubDivTextArea2').addClass('nodrag');

          // Version number display
          var versionNumber = new UIElement('div', 'versionNumber', function () {
            return game_state == GAME.LOGIN || game_state == GAME.REGISTER || game_state == GAME.LOBBY || game_state == GAME.RECOVERY;
          });
          $('#versionNumber').html('<a title=\'This is the current version of the game. Click for a complete version log.\' id=\'versionNumber\' target=\'_blank\'>' + GAME_VERSION + '</a>');
          $('#versionNumber')[0].onclick = function () {
            Changelog.tryShow(true);
            soundManager.playSound(SOUND.CLICK);
          };
          // faq container
          var faqContainer = new UIElement('div', 'faqContainer', function () {
            return game_state == GAME.LOGIN || game_state == GAME.REGISTER || game_state == GAME.LOBBY || game_state == GAME.RECOVERY;
          });
          $('#faqContainer').html('');

          // F.A.Q. Window
          var faqWindow = new UIWindow('faqWindow', function () {
            return true;
          }, true, 'F.A.Q.', true);
          faqWindow.addScrollableSubDiv('faqWindowSubDivTextArea');


          jQuery.get(`FAQ.txt`, function (faqstr) {
            $('#faqWindowSubDivTextArea')[0].innerHTML = faqstr;
          });


          // links menu
          var linksMenu = new UIElement('div', 'linksMenu', function () {
            return game_state == GAME.LOGIN || game_state == GAME.REGISTER || game_state == GAME.LOBBY || game_state == GAME.RECOVERY;
          });
          linksMenu.domElement.innerHTML = '<p id=\'links-title\'>Quick Links</p>';

          var linksMenu2 = document.createElement('div');
          linksMenu2.innerHTML += '<p><a href=\'https://www.paypal.com/donate/?hosted_button_id=JT3EVHGMQ7M46\' target=\'_blank\'>Donate</a></p>';
          linksMenu2.innerHTML += '<p><a href=\'https://discord.gg/y334eXGQ8J\' target=\'_blank\'>Discord</a></p>';
          linksMenu2.innerHTML += '<p><a href=\'http://www.reddit.com/r/Littlewargame\' target=\'_blank\'>Subreddit</a></p>';
          linksMenu2.innerHTML += '<p><a href=\'http://littlewargame.gamepedia.com/Little_War_Game_Wiki\' target=\'_blank\'>Wiki</a></p>';
          linksMenu2.innerHTML += '<p><a href=\'https://www.youtube.com/user/LittleWarGameRTS\' target=\'_blank\'>Youtube</a></p>';
          linksMenu2.innerHTML += '<p><a href=\'https://iogames.space/\' target=\'_blank\'>More Games</a></p>';

          linksMenu.domElement.appendChild(linksMenu2);

          // legalities
          const legalities = new UIElement('div', 'legalities', () => game_state == GAME.LOGIN || game_state == GAME.REGISTER || game_state == GAME.LOBBY || game_state == GAME.RECOVERY);
          new HTMLBuilder()
            .add('<a id=\'imprintLink\'>Imprint</a> | ').addHook(() => $('#imprintLink').click(showImprint))
            .add('<a id=\'agbLink\'>Terms & Conditions</a> | ').addHook(() => $('#agbLink').click(showAGB))
            .add('<a id=\'dseLink\'>Privacy Policy</a>').addHook(() => $('#dseLink').click(showDSE))
            .insertInto('#legalities');

          // loading window
          var loadingWindow = document.createElement('div');
          loadingWindow.id = 'loadingWindow';
          document.body.appendChild(loadingWindow);

          // loading text
          var loadingText = document.createElement('p');
          loadingWindow.appendChild(loadingText);
          loadingText.id = 'loadingText';
          loadingText.innerHTML = 'loading...';

          // map preview img
          var loadingScreenMapImg = document.createElement('img');
          loadingScreenMapImg.id = 'loadingScreenMapImg';
          loadingWindow.appendChild(loadingScreenMapImg);

          // map name
          var mapScreenName = document.createElement('p');
          mapScreenName.id = 'mapScreenName';
          loadingWindow.appendChild(mapScreenName);

          // players display
          var playersDisplay = document.createElement('p');
          playersDisplay.id = 'playersDisplay';
          loadingWindow.appendChild(playersDisplay);

          // dark screen div
          var darkScreenDiv = document.createElement('div');
          darkScreenDiv.id = 'darkScreenDiv';
          document.body.appendChild(darkScreenDiv);

          // put elements in array
          elements.push(
            this.winLossWindow,
            lobbyDiv,
            this.ingameInput,
            ingameChatDropdown,
            mapEditorInterface,
            ingameMenuButton,
            ingameChatHistoryButton,
            replayControlWindow,
            this.quitGameButton,
            this.optionsPauseButton,
            versionNumber,
            tipsDiv,
            linksMenu,
            clansButton,
            friendsButton,
            achivementsButton,
            emotesButton,
            legalities,
            faqContainer,
          );

          this.onKeyElements = [
            replayControlWindow,
            optionsWindow,
          ];


          // add hover sound events to all buttons
          $('button').mouseenter(function () {
            soundManager.playSound(SOUND.ZIP, 0.3);
          });


          Initialization.onUIGenerated(() => {
            // make windows draggable (with jquery ui)
            $('.draggable').draggable({
              drag: onDrag,
              cancel: 'p, input, select, textarea, button, #personalTextDiv, .nodrag',
            });
          });
        };

        // is called every frame, checks for all elements if they should be drawn and saves the number of active elements (that block canvas input)
        UIManager.prototype.draw = function () {
          for (let i = 0; i < elements.length; i++) {
            elements[i].refreshVisibility();
          }
        };

        // is calles onkey; calls onkey on all active ui elements
        UIManager.prototype.onKey = function (key) {
          for (var i = 0; i < this.onKeyElements.length; i++) {
            if (this.onKeyElements[i].domElement.style.display == 'inline' || (this.onKeyElements[i].domElement.style.display != 'none' && this.onKeyElements[i].domElement.style.visibility == 'visible')) {
              this.onKeyElements[i].onKey(key);
            }
          }
        };

        // create a new html button
        UIManager.prototype.createButton = function (id, caption, onclick) {
          var button = document.createElement('button');

          if (id) {
            button.id = id;
          }

          button.innerHTML = caption;
          button.onclick = onclick;

          return button;
        };

        UIManager.prototype.showLoadingScreen = function (map, players) {
          if (map && map.img) {
            $('#loadingScreenMapImg')[0].src = map.img;
            $('#loadingScreenMapImg')[0].style.display = 'inline';
          } else {
            $('#loadingScreenMapImg')[0].style.display = 'none';
          }

          if (map && map.name) {
            $('#mapScreenName')[0].innerHTML = map.name;
            $('#mapScreenName')[0].style.display = 'inline';
          } else {
            $('#mapScreenName')[0].style.display = 'none';
          }


          // show players
          if (players) {
            var str = '';

            for (var i = 0; i < players.length; i++) {
              if (players[i].controller != CONTROLLER.SPECTATOR) {
                if (players[i].clan) {
                  str += '[' + players[i].clan + '] ';
                }

                str += players[i].name;

                if (players[i + 1] && players[i + 1].team == players[i].team && players[i + 1].controller != CONTROLLER.SPECTATOR) {
                  str += ' &amp; ';
                } else if (players[i + 1] && players[i + 1].team != players[i].team && players[i + 1].controller != CONTROLLER.SPECTATOR) {
                  str += ' vs ';
                }
              }
            }

            $('#playersDisplay')[0].innerHTML = str;
            $('#playersDisplay')[0].style.display = 'inline';
          } else {
            $('#playersDisplay')[0].style.display = 'none';
          }

          $('#loadingWindow')[0].style.display = 'inline';
        };

        function exitGame() {
          worker.postMessage({ what: 'end-game' });
          game.end();
          document.exitPointerLock();

          // Exiting from a test map into the editor
          if (game_state != GAME.EDITOR && mapData) {
            // Show loading screen
            uimanager.showLoadingScreen(mapData);
            keyManager.resetCommand();

            setTimeout(() => {
              game_state = GAME.EDITOR;
              game = new Game();
              game.loadMap(mapData, null, null, null, true);
              worker.postMessage({ what: 'start-game', editorLoad: true, map: mapData, players: null, network_game: network_game, game_state: game_state, networkPlayerName: networkPlayerName });
            }, 50);
          }

          // Exiting from a regular game to the lobby
          else if (game_state == GAME.PLAYING || game_state == GAME.SKIRMISH) {
            keyManager.resetCommand();

            setChatFocus(true);
            StatsWindow.showGameStatistics(game);
            network.send('leave-game');

            game_state = GAME.LOBBY;
            network_game = false;

            setTimeout(() => showAchievement(), 2000);
          }
        }

        function MapEditorData() {
          $('#mapEditorData').remove();
          $('#dataAddListWindow').remove();
          $('#dataNewObjectWindow').remove();

          this.window = new UIWindow('mapEditorData', function () {
            return game_state == GAME.EDITOR;
          }, true, 'Data', true);
          elements.push(this.window);
          this.window.addScrollableSubDiv('mapEditorDataSubDiv');


          // make windows draggable (with jquery ui)
          $('#mapEditorData').draggable({
            drag: onDrag,
            cancel: 'p, input, select, textarea, button, #personalTextDiv, .nodrag',
          });


          // create riders
          var riders = document.createElement('div');
          riders.id = 'dataRiders';

          riders.appendChild(uimanager.createButton('dataUnitsButton', 'Units', function () {
            mapEditorData.switchRider(0);
            soundManager.playSound(SOUND.CLICK);
          }));

          riders.appendChild(uimanager.createButton('dataBuildingsButton', 'Buildings', function () {
            mapEditorData.switchRider(1);
            soundManager.playSound(SOUND.CLICK);
          }));

          riders.appendChild(uimanager.createButton('dataCommandsButton', 'Abilities', function () {
            mapEditorData.switchRider(2);
            soundManager.playSound(SOUND.CLICK);
          }));

          riders.appendChild(uimanager.createButton('dataUpgradesButton', 'Upgrades', function () {
            mapEditorData.switchRider(3);
            soundManager.playSound(SOUND.CLICK);
          }));

          riders.appendChild(uimanager.createButton('dataModifiersButton', 'Modifiers', function () {
            mapEditorData.switchRider(4);
            soundManager.playSound(SOUND.CLICK);
          }));

          riders.appendChild(uimanager.createButton('dataGraphicsButton', 'Graphics', function () {
            mapEditorData.switchRider(5);
            soundManager.playSound(SOUND.CLICK);
          }));

          $('#mapEditorDataSubDiv').append(riders);

          this.types = [
            game.unitTypes,
            game.buildingTypes,
            game.commands,
            game.upgrades,
            game.modifiers,
            game.graphics,
          ];

          this.fields = [
            unit_fields,
            building_fields,
            ability_fields,
            upgrade_fields,
            modifiers_fields,
            imgs_fields,
          ];


          this.type = null;
          this.listIndex = 0;
          this.switchRider(0);


          // create types list
          var typesList = document.createElement('div');
          typesList.id = 'typesList';
          $('#mapEditorDataSubDiv').append(typesList);

          // create fields table
          var fieldsTable = document.createElement('div');
          fieldsTable.id = 'dataFieldsTable';
          $('#mapEditorDataSubDiv').append(fieldsTable);

          // create new object window
          var dataNewObjectWindow = new UIWindow('dataNewObjectWindow', function () {
            return true;
          }, true, 'New Object', true);
          var dataNewObjectWindowSubdiv = dataNewObjectWindow.addScrollableSubDiv('dataNewObjectWindowSubdiv');
          dataNewObjectWindowSubdiv.innerHTML = '<br />Clone from <select id=\'dataNewObjectSelect\'></select><br />';
          dataNewObjectWindowSubdiv.innerHTML += '<span title=\'A unique string (only lower case letters) to refer to the unit\'>ID String: </span><input id=\'dataNewObjectInput\' type=\'text\' /><br />';
          dataNewObjectWindowSubdiv.innerHTML += '<span title=\'The unit\'s name, has to be unique\'>Name: </span><input id=\'dataNewObjectInputName\' type=\'text\' /></br /><br />';
          var newObjectOKButton = uimanager.createButton('newObjectOKButton', 'create', function () {
            mapEditorData.createNewInstance();
            soundManager.playSound(SOUND.CLICK);
          });
          dataNewObjectWindowSubdiv.appendChild(newObjectOKButton);

          // new button
          var newButton = uimanager.createButton('dataNewButton', 'new', function () {
            fadeIn($('#dataNewObjectWindow'));
            soundManager.playSound(SOUND.CLICK);

            var html = '';
            var types = mapEditorData.types[mapEditorData.listIndex];
            for (var i = 0; i < types.length; i++) {
              html += '<option value=\'' + types[i].id_string + '\'>' + types[i].name + '</option>';
            }
            $('#dataNewObjectSelect').html(html);
          });
          newButton.title = 'Create a new type';
          $('#mapEditorData').append(newButton);

          // delete button
          var dataDeleteButton = uimanager.createButton('dataDeleteButton', 'delete', function () {
            soundManager.playSound(SOUND.CLICK);
            var typeToDelete = mapEditorData.type;

            if (typeToDelete.getBasicType()) {
              displayInfoMsg('You can\'t delete basic units');
              return;
            }

            const ID = uniqueID();
            displayInfoMsg(new HTMLBuilder()
              .add(`Delete type?<br /><br /><button id='${ID}'>delete</button>`)
              .addHook(() => $(`#${ID}`).click(() => mapEditorData.killType())));
          });
          dataDeleteButton.title = 'Delete the current selected type';
          $('#mapEditorData').append(dataDeleteButton);


          // reset button
          var dataResetButton = uimanager.createButton('dataResetButton', 'reset', function () {
            soundManager.playSound(SOUND.CLICK);
            var typeToReset = mapEditorData.type;

            if (!typeToReset.getBasicType()) {
              displayInfoMsg('you can only reset basic units');
              return;
            }

            const ID = uniqueID();
            displayInfoMsg(new HTMLBuilder()
              .add(`Reset type?<br /><br /><button id='${ID}'>reset</button>`)
              .addHook(() => $(`#${ID}`).click(() => mapEditorData.resetType())));
          });
          dataResetButton.title = 'Reset the current selected type';
          $('#mapEditorData').append(dataResetButton);

          // add list item window
          var dataAddListWindow = new UIWindow('dataAddListWindow', function () {
            return true;
          }, true, 'Add', true);
          var dataAddListWindowSubdiv = dataAddListWindow.addScrollableSubDiv('dataAddListWindowSubdiv');

          this.previewImages = [];
          this.switchRider(0);
        };

        // TODO: move this elsewhere when we have better lifecycle management
        Initialization.onDocumentReady(() => {
          setInterval(() => {
            if (mapEditorData) {
              // Remove images that don't have divs to be displayed in anymore
              mapEditorData.previewImages = mapEditorData.previewImages.filter((img) => document.querySelector(img.element));

              mapEditorData.previewImages.forEach((img) => {
                img.currentStep += 1;
                img.currentStep = img.currentStep % img.frames;
                img.currentX = img.x + Math.floor(img.step * img.currentStep);
                document.querySelector(img.element).style['background-position'] = `${-img.currentX}px ${-img.y}px`;
              });
            }
          }, 1000 / 6);
        });

        // Removes all custom data and resets all basic types back to defaults
        MapEditorData.prototype.resetAllData = function () {
          const map = game.export_(false);
          map.globalVars.isModded = false;
          map.globalVars.isFrozen = false;
          editor.reload(map);
        };

        MapEditorData.prototype.killType = function (t, skipRedraw) {
          // Default to the current type
          if (!t) {
            t = this.type;
          }
          soundManager.playSound(SOUND.CLICK);

          if (t.getBasicType()) {
            displayInfoMsg('You can\'t delete basic units');
            return;
          }

          fadeOut($('#infoWindow'));

          game.unitTypes.erease(t);
          game.buildingTypes.erease(t);
          game.commands.erease(t);
          game.upgrades.erease(t);
          game.modifiers.erease(t);
          game.graphics.erease(t);

          // find all references 'n' delete 'em
          _.each(lists.types, function (type) {
            _.each(type.getDataFields(), function (field) {
              if (type[field.name] == t) {
                type[field] = null;
              } else if (field.isArray && Object.prototype.toString.call(type[field.name]) === '[object Array]') {
                type[field.name].erease(t);
              } else if (field.isObject) {
                _.each(type[field.name], function (element, key) {
                  if (element == t) {
                    delete type[field.name][key];
                  }
                });
              }
            });
          });

          if (mapEditorData.listIndex != 5) {
            delete lists.types[t.id_string];
            delete lists.unitTypes[t.id_string];
            delete lists.buildingTypes[t.id_string];
            delete lists.buildingsUpgrades[t.id_string];
            delete lists.modifiers[t.id_string];
            delete lists.upgrades[t.id_string];
            delete lists.commands[t.id_string];
          } else {
            delete lists.imgs[t.id_string];
          }

          if (!skipRedraw) {
            this.switchRider(mapEditorData.listIndex);
            editor.createButtons();
          }
        };

        MapEditorData.prototype.createNewInstance = function () {
          var id_string = $('#dataNewObjectInput').val();
          var type = this.listIndex == 5 ? lists.imgs[$('#dataNewObjectSelect').val()] : lists.types[$('#dataNewObjectSelect').val()];
          var name = $('#dataNewObjectInputName').val();

          if ((this.listIndex != 5 && !typeNameIsUnique(name)) || (this.listIndex == 5 && !graphicNameIsUnique(name))) {
            displayInfoMsg('there is already a unit with this name');
            return;
          }

          if (!name.match(/^[A-Za-z]+[A-Za-z ]*$/)) {
            displayInfoMsg('invalid name (only letters)');
            return;
          }

          if (lists.types[id_string] || lists.imgs[id_string]) {
            displayInfoMsg('this id string already exists');
            return;
          }

          if (!id_string.match(/^[a-z\_]+$/)) {
            displayInfoMsg('invalid id string (only lower case letters and underscores)');
            return;
          }

          if (!type) {
            displayInfoMsg('invalid unit type');
            return;
          }

          fadeOut($('#dataNewObjectWindow'));

          var o = null;

          if (this.listIndex == 0) {
            o = new UnitType(type);
          } else if (this.listIndex == 1) {
            o = new BuildingType(type);
          } else if (this.listIndex == 2) {
            o = new Command(type);
          } else if (this.listIndex == 3) {
            o = new Upgrade(type);
          } else if (this.listIndex == 4) {
            o = new Modifier(type);
          } else if (this.listIndex == 5) {
            o = new Graphic(type);
          }

          o.id_string = id_string;
          o.name = name;

          this.types[this.listIndex].push(o);

          o.addToLists();

          calculateTypesTickValues();

          this.switchRider(this.listIndex);

          editor.createButtons();

          if (!o.noLogic) {
            worker.postMessage({ what: 'newType', type: type.id_string, id_string: id_string, name: name, listIndex: this.listIndex });
          }
        };

        MapEditorData.prototype.showDataAddListWindow = function () {
          const builder = new HTMLBuilder();

          builder.add('<select id=\'dataAddList\'>');
          for (let i = 0; i < game.commands.length; i++) {
            builder.add(`<option name='${game.commands[i].id_string}'>${game.commands[i].name}</option>`);
          }
          builder.add('</select><br />');

          const ID = uniqueID();
          builder
            .add(`<button id='${ID}'>add</button>`)
            .addHook(() => $(`#${ID}`).click(addClickSound(() => mapEditorData.saveListData())));

          builder.insertInto('#dataAddListWindowSubdiv');
          fadeIn($('#dataAddListWindow'));
        };

        MapEditorData.prototype.saveListData = function () {
          var index = $('#dataAddList')[0].selectedIndex;

          const ID = uniqueID();
          new HTMLBuilder()
            .add(`<p name='${game.commands[index].id_string}'>${game.commands[index].name} `)
            .add(`<button id='${ID}'>X</button></p>`)
            .addHook(() => $(`#${ID}`).click(() => deleteMapEditorDataElement(ID)))
            .appendInto('.d_data_commands_div');

          fadeOut($('#dataAddListWindow'));
          this.saveUnit();
        };

        MapEditorData.prototype.switchRider = function (type) {
          if (type < 0) {
            type = 0;
          }

          if (type > this.types.length - 1) {
            type = this.types.length - 1;
          }

          $('#typesList').html('');

          this.listIndex = type;
          this.type = null;

          var types = _.sortBy(this.types[type], function (type) {
            return type.name;
          });

          for (var i = 0; i < types.length; i++) {
            if (!types[i].isCommand || _.contains(EDITOR_COMMANDS, types[i].type)) {
              var div = document.createElement('div');
              div.textContent = types[i].name;
              div.title = 'ID String: ' + types[i].id_string;
              div.className = 'dataTypeListDiv';
              div.index_ = types[i].id_string;

              if (!this.type) {
                this.type = types[i];
                div.className = 'dataTypeListDivActive';
              }

              div.onclick = function () {
                mapEditorData.saveUnit(true);
                // reset active class
                soundManager.playSound(SOUND.CLICK);
                var children = $('#typesList').children();
                for (var k = 0; k < children.length; k++) {
                  children[k].className = 'dataTypeListDiv';
                }
                mapEditorData.type = mapEditorData.types[mapEditorData.listIndex] == game.graphics ? lists.imgs[this.index_] : lists.types[this.index_];
                mapEditorData.refreshFieldsTable(mapEditorData.type);
                this.className = 'dataTypeListDivActive';
              };
              $('#typesList').append(div);
            }
          }

          this.refreshFieldsTable(this.type);
        };

        function deleteMapEditorDataElement(id) {
          const el = document.getElementById(id);
          el.parentNode.parentNode.removeChild(el.parentNode);
          mapEditorData.saveUnit();
          soundManager.playSound(SOUND.CLICK);
        };

        MapEditorData.prototype.fieldIsDefault = function (field, type) {
          var value = type[field.name];
          var originValue = type.getBasicType ? type.getBasicType()[field.name] : '';

          if (typeof value === 'undefined') {
            value = field.isArray ? field.default2_ : field.default_;
          }

          if (typeof originValue === 'undefined') {
            originValue = field.isArray ? field.default2_ : field.default_;
          }

          if (field.type == 'complex') {
            for (var field in value) {
              if (Object.prototype.toString.call(value[field]) === '[object Array]' && value[field].length == 0) {
                delete value[field];
              }
            }

            for (var field in originValue) {
              if (Object.prototype.toString.call(originValue[field]) === '[object Array]' && originValue[field].length == 0) {
                delete originValue[field];
              }
            }

            value = JSON.stringify(value);
            originValue = JSON.stringify(originValue);
          } else if (field.isArray) {
            if (value && value.length > 0 && value[0].id_string) {
              value = value.slice();
              for (var i = 0; i < value.length; i++) {
                value[i] = value[i].id_string;
              }
            }

            return arraysAreSame(value, originValue);
          } else if (field.type == 'commands') {
            var arr1 = [];
            var arr2 = [];

            _.each(value, function (val, key) {
              arr1.push(key);
            });

            _.each(originValue, function (val, key) {
              arr2.push(key);
            });

            return arraysAreSame(arr1, arr2);
          } else if (field.name == 'img' && isObject(value)) {
            originValue = lists.imgs[originValue];
          } else if (field.name == 'unitImg' && isObject(value)) {
            value = value.id_string;
          } else if ((field.name == 'getTitleImage' || field.name == 'image') && value && {}.toString.call(value) === '[object Function]') {
            value = value();
            originValue = lists.imgs[originValue] ? lists.imgs[originValue]() : originValue;
          } else if (isObject(value) && typeof originValue == 'string') {
            value = value.id_string;
          } else if (field.type == 'float') {
            value = Math.floor(value * 1000000) / 1000000;
            originValue = Math.floor(originValue * 1000000) / 1000000;
          }

          return value == originValue;
        };

        // Shows an animated preview image for the provided Graphic type in the div given by divID
        // Action defines which animation is shown (idle, walk, die, etc) and defaults to "img" (which not all graphics have)
        MapEditorData.prototype.showPreviewImg = function (type, divID, action = 'img', angle = 0) {
          // Quit if the requested animation does not exist
          if (!type[action]) {
            return;
          }

          const frameWidth = type[action].frameWidth;
          const imgWidth = type[action].w;
          const imgHeight = type[action].h;
          const frameHeight = type._angles ? imgHeight / type._angles : imgHeight;
          const imgOffsetX = type[action].x;
          const imgOffsetY = type[action].y;

          const previewObj = getPreviewImgObj(type.id_string);
          $(`#${divID}`).attr('style', previewObj.css);

          this.previewImages.push({
            element: `#${divID}`,
            x: imgOffsetX * previewObj.scale,
            y: (imgOffsetY + (angle * frameHeight)) * previewObj.scale,
            step: frameWidth * previewObj.scale,
            frames: (imgWidth / frameWidth) || 1,
            currentStep: 0,
            currentX: 0,
          });
        };

        function getPreviewImgObj(img_key) {
          var img = lists.imgs[img_key] ? lists.imgs[img_key].getTitleImage(1) : null;
          var file = null;

          if (!img) {
            return { css: '', scale: 0 };
          }

          if (img.file.toDataURL) {
            file = img.file.toDataURL();
          } else if (img.file.src) {
            file = img.file.src;
          } else {
            return { css: '', scale: 0 };
          }

          var w = img.w || 60;
          var h = img.h || 60;
          var w2 = img.file.width * (w / img.w);
          var h2 = img.file.height * (h / img.h);

          if (w > h) {
            h = 60 * (h / w);
            w = 60;
          } else {
            w = 60 * (w / h);
            h = 60;
          }

          var scale = w / (img.w || 60);
          var x = img.x * scale;
          var y = img.y * scale;

          return {
            css: 'background: url(' + file + '); background-position: ' + -x + 'px ' + -y + 'px; background-size: ' + (img.file.width * scale) + 'px ' + (img.file.height * scale) + 'px; width: ' + w + 'px; height: ' + h + 'px; display: inline-block',
            scale,
          };
        }

        /** For a given type, create an element in main_data_table for each field it has. */
        MapEditorData.prototype.refreshFieldsTable = function (type) {
          // The properties this type(Building|Command|Unit|etc) has (Name|isBuilding|cost|etc)
          var fields = this.fields[this.listIndex];

          const builder = new HTMLBuilder();
          builder.add('<table id=\'main_data_table\'>');

          for (let i = 0; i < fields.length; i++) {
            // abilities dont always show all fields, but only some depending on their type
            if (!type || !type.isCommand || ability_type_fields[type.type].indexOf(fields[i].name) >= 0) {
              var field = fields[i];
              var startGroup = field.group;
              let startI = i;
              var vals = field.isArray ? (Object.prototype.toString.call(type[field.name]) === '[object Array]' ? type[field.name] : []) : [type[field.name]];

              builder.add('<tr><td title=\'' + (field.groupDescription ? field.groupDescription : field.description) + '\'><span ' + (this.fieldIsDefault(field, type) ? '' : 'class=\'notDefault\'') + '>');
              builder.add((startGroup ? startGroup : field.name) + (field.isArray ? ' (list)' : '') + '</span></td><td ' + (startGroup ? ('class=\'gr_' + startGroup + '\'') : '') + 'id=\'dataSpan' + i + '\'>');

              for (var j = 0; j < vals.length; j++) {
                builder.add('<span>');

                while (startI == i || (startGroup && fields[i] && fields[i].group == startGroup)) {
                  var vals2 = fields[i].isArray ? (Object.prototype.toString.call(type[fields[i].name]) === '[object Array]' ? type[fields[i].name] : []) : [type[fields[i].name]];
                  builder
                    .add((fields[i].subName ? ('<span title=\'' + fields[i].description + '\'>' + fields[i].subName + '</span>: ') : '') + '<span class=\'d_' + fields[i].name + '\'>')
                    .add(this.getFieldHTMLCode(fields[i], vals2[j], j, type))
                    .add('</span> ');
                  i++;
                }

                // Allow user to remove the field
                if (field.isArray) {
                  const ID = uniqueID();
                  builder.add(`<button id='${ID}'>X</button></span><br />`);
                  builder.addHook(() => $(`#${ID}`).click(() => deleteMapEditorDataElement(ID)));
                }

                i = startI;
              }

              while (startGroup && fields[i + 1] && fields[i + 1].group == startGroup) {
                i++;
              }

              if (field.isArray) {
                const ID = uniqueID();
                builder.add(`<button id='${ID}'>add</button>`);
                builder.addHook(() => $(`#${ID}`).click(() => mapEditorData.addField_(startI, i)));
              }

              builder.add('</td></tr>');
            }
          }

          builder.add('</table>');
          builder.insertInto('#dataFieldsTable');
        };

        MapEditorData.prototype.addField_ = function (i, i2) {
          soundManager.playSound(SOUND.CLICK);

          const builder = new HTMLBuilder();

          // TODO: this entire function is absolutely bonkers
          // The UI that is generated here is never actually visible to the user and actually gets overwritten by saveUnit
          // It is used ONLY to communicate the fact that a new field was added to saveUnit, which parses the HTML to realize this
          // Clean up this garbage heap!
          builder.add('<span>');
          for (let k = i; k <= i2; k++) {
            builder.add('<span class=\'d_' + this.fields[this.listIndex][k].name + '\'>');
            builder.add(mapEditorData.getFieldHTMLCode(this.fields[this.listIndex][k]));
            builder.add('</span> ');
          }

          const ID = uniqueID();
          builder.add(`<button id='${ID}'>X</button></span>`);
          builder.addHook(() => $(`#${ID}`).click(() => deleteMapEditorDataElement(ID)));
          builder.appendInto(`#dataSpan${i}`);
          mapEditorData.saveUnit();
        };

        MapEditorData.prototype.addField2_ = function (elID, fieldName) {
          soundManager.playSound(SOUND.CLICK);
          const inputID = uniqueID();
          const buttonID = uniqueID();
          new HTMLBuilder()
            .add('<span>')
            .add(`<input id='${inputID}' name='data_holding_field' data-fieldname='${fieldName}' type='text' value='0' />`)
            .addHook(() => $(`#${inputID}`).change(() => mapEditorData.saveUnit()))
            .add(`<button id='${buttonID}'>X</button>`)
            .addHook(() => $(`#${buttonID}`).click(() => deleteMapEditorDataElement(buttonID)))
            .add('</span>')
            .appendBefore($(`#${elID}`));
          mapEditorData.saveUnit();
        };


        MapEditorData.prototype.getFieldHTMLCode = function (field, value, index, type) {
          if (value === undefined) {
            value = field.default_;
          }

          const builder = new HTMLBuilder();

          // if a selection field, display all da single values
          if (field.type == 'selection') {
            const showPreview = field.special == 'imgPreview';
            const selectID = uniqueID();
            const previewID = uniqueID();

            // Display the image preview corresponding the currently selected option
            // Only used if showPreview is true
            const doShowPreview = () => {
              const imgID = $(`#${selectID}`).find(':selected').text();
              if (!imgID) {
                return;
              }

              // TODO: this magic number refers to the index containing graphics types, add a constant for the indices
              const type = this.types[5].find((graphic) => graphic.id_string == imgID);
              if (!type) {
                return;
              }

              this.showPreviewImg(type, previewID, type.isUnit ? 'idle' : 'img');
            };

            builder
              .add(`<select id='${selectID}' name='data_holding_field' class='dataSelect'>`)
              .addHook(() => $(`#${selectID}`).change(() => {
                mapEditorData.saveUnit();
                if (showPreview) {
                  doShowPreview();
                }
              }));

            let selected_key = '';
            _.each(field.values, (val, key) => {
              const title = field.descriptions ? field.descriptions[key] : '';
              if (value == val && showPreview) {
                selected_key = key;
              }
              builder.add(`<option title='${title}' ${value == val ? 'selected=\'selected\'' : ''}>${key}</option>`);
            });
            builder.add('</select>');

            // Create div to show an image preview if applicable
            if (showPreview) {
              builder
                .add(` <div class='pixelated' id='${previewID}'></div>`)
                .addHook(doShowPreview); // Show the preview for the default option
            }
          } else if (field.type == 'complex') {
            for (let i = 0; i < field.values.length; i++) {
              var field2 = field.values[i];
              var value2 = value[field2.name] ?? field2.default_;

              builder.add(`<span title='${field2.description}'>${field2.name}: </span>`);

              if (field2.isArray) {
                for (let k = 0; k < value2.length; k++) {
                  const inputID = uniqueID();
                  const deleteBtnID = uniqueID();
                  builder
                    .add('<span>')
                    .add(`<input id='${inputID}' class='numberWidth' name='data_holding_field' data-fieldname='${field2.name}' type='text' value='${value2[k]}' />`)
                    .addHook(() => $(`#${inputID}`).change(() => mapEditorData.saveUnit()))
                    .add(`<button id='${deleteBtnID}'>X</button> `)
                    .addHook(() => $(`#${deleteBtnID}`).click(() => deleteMapEditorDataElement(deleteBtnID)))
                    .add('</span>');
                }

                const addBtnID = uniqueID();
                builder
                  .add(`<button id='${addBtnID}'>add</button>`)
                  .addHook(() => $(`#${addBtnID}`).click(() => mapEditorData.addField2_(addBtnID, field2.name)));
              } else {
                const ID = uniqueID();
                builder
                  .add(`<input id='${ID}' name='data_holding_field' data-fieldname='${field2.name}' type='text' class='numberWidth' value='${value2}' /> `)
                  .addHook(() => $(`#${ID}`).change(() => mapEditorData.saveUnit()));
              }
            }

            builder.add('<div style=\'display: block\'>');
            for (let i = 0; i < type._angles; i++) {
              // Push all preview animations to a ticker
              const divID = uniqueID();
              const title = `This is what the ${field.name} animation will look like ingame`;
              builder
                .add(`<div id='${divID}' title='${title}' class='pixelated'></div>`)
                .addHook(() => this.showPreviewImg(type, divID, field.name, i));
            }
            builder.add('</div>');
          }

          // if boolean, just make a checkbox
          else if (field.type == 'bool') {
            const ID = uniqueID();
            const checked = value ? ' checked=checked ' : '';
            builder
              .add(`<input id='${ID}' name='data_holding_field' type='checkbox' ${checked}>`)
              .addHook(() => $(`#${ID}`).change(() => mapEditorData.saveUnit()));
          }

          // if commands array
          else if (field.type == 'commands') {
            builder.add('<div class=\'d_data_commands_div\'>');

            _.each(value, (val) => {
              const ID = uniqueID();
              builder
                .add(`<p name='${val.id_string}'>${val.name} <button id='${ID}'>X</button></p>`)
                .addHook(() => $(`#${ID}`).click(() => deleteMapEditorDataElement(ID)));
            });

            const addBtnID = uniqueID();
            builder
              .add(`</div><p><button id='${addBtnID}'>add</button></p>`)
              .addHook(() => $(`#${addBtnID}`).click(addClickSound(() => mapEditorData.showDataAddListWindow())));
          }

          // else (single string, float or int, make a simple input)
          else {
            // set default val, if undfined
            var val = typeof value === 'undefined' ? field.default_ : value;

            if (field.displayScale) {
              val *= field.displayScale;
            }

            if (field.name == 'effectsModifications' && type) {
              var type2 = type.effectsTypes ? type.effectsTypes[index] : null;
              var fieldName = type.effectsFields ? type.effectsFields[index] : null;

              var dataField = type2 ? type2.getDataFields() : null;

              if (dataField && dataField[fieldName] && dataField[fieldName].displayScale) {
                val *= dataField[fieldName].displayScale;
              }
            }

            if (field.name == 'modifications' && type) {
              var fieldName = type.fields ? type.fields[index] : null;
              var dataField = lists.types.soldier.getDataFields();

              if (dataField && dataField[fieldName] && dataField[fieldName].displayScale) {
                val *= dataField[fieldName].displayScale;
              }
            }

            var htmlAttributes = 'type=\'text\'';

            if (field.type == 'string' && field.max_len) {
              htmlAttributes += ' maxlength=\'' + field.max_len + '\' style=\'width: ' + Math.min(field.max_len * 8, 400) + 'px;\' ';
            }

            var realTimeCompileTitle = '';
            if (field.realTimeCompile) {
              var compile = Command.prototype.compileCondition(val);
              realTimeCompileTitle = ' title=\'' + (compile[0] ? 'condition is ok' : compile[1]) + '\' ';
            }

            const doRealTimeCompile = field.realTimeCompile ? realTimeCompile : () => { };

            const ID = uniqueID();
            builder
              .add(`<input id='${ID}' ${realTimeCompileTitle} name='data_holding_field' ` +
                `class='mapDataInput ${(field.type == 'string' ? 'strWidth' : 'numberWidth')}' ` +
                `${htmlAttributes} value='${(val.replace ? val.replace(/'/g, '') : val)}' />`)
              .addHook(() => $(`#${ID}`).change(() => {
                mapEditorData.saveUnit();
                doRealTimeCompile(ID);
              }))
              .addHook(() => $(`#${ID}`).keypress(() => doRealTimeCompile(ID)))
              .addHook(() => $(`#${ID}`).keyup(() => doRealTimeCompile(ID)))
              .addHook(() => $(`#${ID}`).on('load', () => doRealTimeCompile(ID)));
          }

          return builder;
        };

        MapEditorData.prototype.resetType = function (type, skipRedraw) {
          // Default to the current type
          if (!type) {
            type = this.type;
          }
          soundManager.playSound(SOUND.CLICK);

          fadeOut($('#infoWindow'));

          var fields = type.getDataFields();
          var basicType = type.getBasicType();

          if (!basicType) {
            displayInfoMsg('only basic units can be reset to default');
            return;
          }

          _.each(fields, function (field) {
            if (field.name in basicType) {
              type[field.name] = basicType[field.name];
            } else if (fields[field.name]) {
              type[field.name] = fields[field.name].default2_ ? fields[field.name].default2_ : (fields[field.name].isArray ? [] : fields[field.name].default_);
            }

            if (Object.prototype.toString.call(type[field.name]) === '[object Array]') {
              type[field.name] = type[field.name].slice();
            } else if (isObject(type[field.name])) {
              type[field.name] = copyObject(type[field.name]);
            }
          });

          type.replaceReferences();

          if (!skipRedraw) {
            this.refreshFieldsTable(type);
            editor.createButtons();
          }
        };

        MapEditorData.prototype.saveUnit = function (skipRedraw = false) {
          var type = this.type;
          var fields = this.fields[this.listIndex];

          for (var i = 0; i < fields.length; i++) {
            if ($('#dataSpan' + i)[0] || (fields[i].group && $('.gr_' + fields[i].group)[0])) {
              var field = fields[i];

              if (field.type == 'commands') {
                type[field.name] = {};
                var arr = [];

                var children = $('.d_data_commands_div').children();
                for (var k = 0; k < children.length; k++) {
                  var name = children[k].getAttribute('name');
                  if (name !== null) {
                    type[field.name][name] = lists.types[name];
                    arr.push(name);
                  }
                }

                if (field.logic) {
                  worker.postMessage({ what: 'updateDataField', type: type.id_string, field: field.name, val: arr, commands: true });
                }
              } else {
                var vals = $('.d_' + field.name).find('*[name=data_holding_field]').toArray();
                var toSend = null;

                if (field.isArray) {
                  toSend = [];
                  type[field.name] = [];

                  for (var k = 0; k < vals.length; k++) {
                    var val = field.type == 'bool' ? vals[k].checked : vals[k].value;

                    if (field.type == 'selection') {
                      val = field.values[val];
                    }

                    val = checkField(field, val);

                    if (field.displayScale) {
                      val /= field.displayScale;
                    }

                    if (field.name == 'effectsModifications') {
                      var typeName = $('.d_effectsTypes').find('*[name=data_holding_field]').eq(k).val();
                      var fieldName = $('.d_effectsFields').find('*[name=data_holding_field]').eq(k).val();

                      var dataField = lists.types[typeName] ? lists.types[typeName].getDataFields() : null;

                      if (dataField && dataField[fieldName] && dataField[fieldName].displayScale) {
                        val /= dataField[fieldName].displayScale;
                      }
                    }

                    if (field.name == 'modifications' && type) {
                      var fieldName = $('.d_fields').find('*[name=data_holding_field]').eq(k).val();
                      var dataField = lists.types.soldier.getDataFields();

                      if (dataField && dataField[fieldName] && dataField[fieldName].displayScale) {
                        val /= dataField[fieldName].displayScale;
                      }
                    }

                    type[field.name].push(val);

                    if (isObject(val) && val.isTargetRequirement) {
                      toSend.push(val.funcName);
                    } else {
                      toSend.push((isObject(val) && val.id_string) ? val.id_string : val);
                    }
                  }
                } else if (field.type == 'complex') {
                  var obj = {};
                  for (var k = 0; k < vals.length; k++) {
                    var fieldName = vals[k].getAttribute('data-fieldname');
                    var field_ = null;
                    for (var j = 0; j < field.values.length; j++) {
                      if (field.values[j].name == fieldName) {
                        field_ = field.values[j];
                      }
                    }

                    if (field_ && field_.isArray) {
                      if (obj[field_.name]) {
                        obj[field_.name].push(checkField(field_, vals[k].value));
                      } else {
                        obj[field_.name] = [checkField(field_, vals[k].value)];
                      }
                    } else {
                      obj[field_.name] = checkField(field_, vals[k].value);
                    }
                  }

                  type[field.name] = obj;
                } else {
                  var val = field.type == 'bool' ? vals[0].checked : vals[0].value;

                  if (field.type == 'selection') {
                    val = field.values[val];
                  } else {
                    val = checkField(field, val);

                    if (field.displayScale) {
                      val /= field.displayScale;
                    }
                  }

                  if (field.name == 'name' && !typeNameIsUnique(val)) {
                    val = type[field.name];
                    $('.d_name').children('*[name=data_holding_field]').toArray()[0].value = val;
                  }

                  type[field.name] = val;
                  toSend = (isObject(val) && val.id_string) ? val.id_string : val;
                }

                if (field.logic) {
                  worker.postMessage({ what: 'updateDataField', type: type.id_string, field: field.name, val: toSend });
                }
              }
            }
          }

          calculateTypesTickValues();

          // replacing references
          _.each(lists.types, function (t) {
            if (t.replaceReferences) {
              t.replaceReferences();
            }
          });

          // update button
          for (var k = 0; k < interface_.buttons.length; k++) {
            if (interface_.buttons[k].command == type) {
              interface_.buttons[k].init(type);
            }
          }

          if (!skipRedraw) {
            this.refreshFieldsTable(this.type);
          }
        };

        const MapEditorSettings = (() => {
          // Takes an object of type {name: String, key: String, description: String, default: String|Number|Bool, placeholder: String|Number|Bool}
          // where default or placeholder determines the type of input generated
          // A String or Number will generate a text field, and a Bool will generate a checkbox
          function Setting(spec) {
            this.name = spec.name;
            this.key = spec.key;
            this.description = spec.description;
            this.default = spec.default;
            this.placeholder = spec.placeholder;
            this.type = typeof this.default == 'undefined' ? typeof this.placeholder : typeof this.default;
            this.inputType = this.type == 'boolean' ? 'checkbox' : 'text';
            this.id = uniqueID();
          }

          // Disables the setting unless callback returns true
          Setting.prototype.disableUnless = function (callback) {
            this.disableUnless = callback;
            return this;
          };

          // The callback has signature (String) => Bool, where the String parameter is the ID of the HTML element corresponding
          // to this setting, and the return value determines whether or not the value should be set
          Setting.prototype.addValidation = function (callback) {
            this.validate = callback;
            return this;
          };

          Setting.prototype.generateUI = function (updatedGlobalVars) {
            const disabled = this.disableUnless && !this.disableUnless();

            const builder = new HTMLBuilder();
            const spanID = uniqueID();
            builder
              .add(`<span id='${spanID}'><label for='${this.id}'>${this.name} </label>`)
              .add(`<input id='${this.id}' ${this.inputType == 'text' ? 'size=\'5\'' : ''} type='${this.inputType}' /></span>`)
              .addHook(() => $(`#${spanID}`).prop('title', this.description))
              .addHook(() => $(`#${this.id}`).prop('disabled', disabled));

            if (this.placeholder) {
              builder.addHook(() => $(`#${this.id}`).prop('placeholder', this.placeholder));
            }

            if (!disabled) {
              // Set the value from game.globalVars or the default if not specified
              builder.addHook(() => {
                const defaultVal = this.default ?? '';
                if (this.inputType == 'checkbox') {
                  $(`#${this.id}`).prop('checked', game.globalVars[this.key] ?? defaultVal);
                } else if (this.inputType == 'text') {
                  $(`#${this.id}`).val(game.globalVars[this.key] ?? defaultVal);
                }
              });

              // Refresh the global variables whenever there is a change
              builder.addHook(() => $(`#${this.id}`).change(() => {
                if (!this.validate || this.validate(this.id)) {
                  // Set the values if the validation function allows us to, or if there is none
                  if (this.inputType == 'checkbox') {
                    game.globalVars[this.key] = $(`#${this.id}`).prop('checked');
                  } else if (this.inputType == 'text') {
                    game.globalVars[this.key] = $(`#${this.id}`).val();
                  }
                }

                updatedGlobalVars();
              }));
            } else {
              builder.addHook(() => $(`#${spanID}`).addClass('disabledEditorSetting'));
            }

            return builder;
          };

          function MapEditorSettings_() {
            Initialization.onDocumentReady(() => this.init());
            this.__playerSettingsChangeListeners = [];

            const clamp = (jqEl, min, max) => {
              const val = parseInt(jqEl.val());
              if (!isNaN(val)) {
                jqEl.val(Math.min(Math.max(min, val), max));
              } else {
                jqEl.val('');
              }
              return true;
            };

            // Constant object that determines the layout and behavior of the inputs corresponding to game.globalVars
            this.__globalVarsSpec = [
              new Setting({
                name: 'Black fog',
                key: 'useDarkMask',
                description: 'Black fog will make the unexplored parts of the map 100% black, so the player doesn\'t see the terrain.',
                default: false,
              }),

              new Setting({
                name: 'Unlocked',
                key: 'isOpen',
                description: 'If this is activated, other players will be able to load this map to the editor. ' +
                  'They will NOT be able to overwrite your map, but they can edit and upload their own versions.',
                default: true,
              }),

              new Setting({
                name: 'Automine',
                key: 'automine',
                description: 'Selecting this option will cause workers to mine at the nearest goldmine at the start of the game.',
                default: true,
              }),

              new Setting({
                name: 'Passive neutral',
                key: 'isPassiveNeutral',
                description: 'Selecting this will cause neutral units to not attack',
                default: true,
              }),

              new Setting({
                name: 'Modded',
                key: 'isModded',
                description: 'Modded maps can have custom unit and game data.',
                default: false,
              })
                .addValidation((id) => {
                  // It went from being true to false
                  if (!$(`#${id}`).prop('checked')) {
                    const unfrozenWarning = game?.globalVars?.isFrozen ? 'Your map will also be unfrozen. ' : '';

                    // Ask the user to make sure, since this can potentially delete their data
                    displayConfirmPrompt(
                      `You have marked your map as unmodded. ${unfrozenWarning} This will delete ALL ` +
                      'custom unit data and reset basic types back to their defaults. Are you sure?',
                      () => this.setModded(false), () => this.setModded(true),
                    );
                    return false;
                  }
                  return true;
                }),

              new Setting({
                name: 'Frozen data',
                key: 'isFrozen',
                description: 'Maps with frozen map data will store all unit and game data and never change on game updates. ' +
                  'This option is only recommended if you want to create a completely new game with its own unique gameplay.',
                default: false,
              })
                .disableUnless(() => this.isModded())
                .addValidation((id) => {
                  if ($(`#${id}`).prop('checked')) {
                    displayConfirmPrompt(
                      'You have marked your map as frozen. If you continue, your map will also be marked as a modded map ' +
                      'and you will NOT be able to unfreeze your map without losing ALL custom unit data. Are you sure?',
                      () => this.setFrozen(true), () => this.setFrozen(false),
                    );
                  } else {
                    assert(this.isModded());
                    displayConfirmPrompt(
                      'You have marked your map as unfrozen. If you continue, ALL custom unit data will be deleted ' +
                      'and basic types will be reset back to their defaults. Are you sure? ' +
                      // TODO: remove this after a while when things have settled down
                      'If you did not set this yourself, please contact a moderator to safely unfreeze your map.',
                      () => this.setFrozen(false), () => this.setFrozen(true),
                    );
                  }
                  return false;
                }),

              new Setting({
                name: 'Max supply',
                key: 'maxSupply',
                description: 'The maximum amount of supply a player can have',
                placeholder: MAX_SUPPLY,
              })
                .disableUnless(() => this.isModded())
                .addValidation((id) => clamp($(`#${id}`), 0, 500)),

              new Setting({
                name: 'Start gold',
                key: 'startGold',
                description: 'The amount of gold players have when the game starts',
                placeholder: START_GOLD,
              })
                .disableUnless(() => this.isModded())
                .addValidation((id) => clamp($(`#${id}`), 0, 999999)),

              new Setting({
                name: 'Start workers',
                key: 'startWorkers',
                description: 'The number of workers each player starts with',
                placeholder: START_WORKERS,
              })
                .disableUnless(() => this.isModded())
                .addValidation((id) => clamp($(`#${id}`), 0, 50)),


              new Setting({
                name: 'Minimum mining distance',
                key: 'mineDist',
                description: 'The minimum distance a castle can be from a goldmine',
                placeholder: MINE_DIST,
              })
                .disableUnless(() => this.isModded())
                .addValidation((id) => clamp($(`#${id}`), 0, 999999)),
            ];

            // Constant object which determines the layout and behavior of the player settings columns
            this.__playerSettingsSpec = [{
              name: 'Slot',
              key: 'slot',
              description: 'Open slots can be joined by players or filled with computers. ' +
                'Computer slots will always have a computer in this slot and can not be joined by a player.',
              options: ['open', 'computer', 'closed'],
              display: (setting) => true,
              validate: (value, i) => {
                if (value == 'closed') {
                  return this.__tryCloseSlot(i);
                } else if (this.__playerSettings[i].slot == 'closed' && value != 'closed') {
                  setTimeout(() => editor.reload(), 0);
                }
                return true;
              },
            }, {
              name: 'Team',
              key: 'team',
              description: 'Select this player\'s team. If you choose "any", then the host will be able to choose any team for this player in the game lobby.',
              options: ['any', ...Array.from({ length: 6 }, (_, i) => `Team ${i + 1}`)],
              display: (setting) => setting.slot != 'closed',
            }, {
              name: 'AI',
              key: 'ai',
              description: 'Only available for "Computer" slots. If you select "no AI", then this player will not be controlled by the default AI. ' +
                'This often makes sense for custom mods, where the normal AI doesn\'t work well.',
              options: ['normal AI', 'no AI'],
              display: (setting) => setting.slot == 'computer',
            }];

            // Contains the settings objects, where each element at index i corresponds to the settings for player i
            // Each element has type {key: String, team: String, ai: String} corresponding to this.__playerSettingsSpec
            this.__playerSettings = [];
          }

          MapEditorSettings_.prototype.init = function () {
            const mapSettingsWindow = new UIWindow('mapSettingsWindow', () => true, true, 'Map Settings', true, null);
            mapSettingsWindow.addScrollableSubDiv('mapSettingsWindowSubdiv');

            new HTMLBuilder()
              .add('Name<br /><input type=\'text\' id=\'mapNameInput\' /><br /><br />')
              .addHook(() => $('#mapNameInput').change(() => game.name = $('#mapNameInput').val()))
              .add('Description<br /><textarea id=\'mapDescriptionInput\'></textarea><br /><br />')
              .addHook(() => $('#mapDescriptionInput').change(() => game.description = $('#mapDescriptionInput').val()))
              .add('<div id=\'globalVarsDiv\'></div>')
              .add('<div id=\'playerSettingsDiv\'></div>')
              .insertInto('#mapSettingsWindowSubdiv');
          };

          // Must be called before the settings UI is used to initialize fields and UI
          MapEditorSettings_.prototype.loadFromMap = function (map) {
            game.name = map?.name ?? '';
            game.description = map?.description ?? '';
            this.__refreshNameAndDescription();

            // Initialize globalVars
            if (!game.globalVars) {
              game.globalVars = {};
            }

            this.__globalVarsSpec.forEach((spec) => {
              if (is(map?.globalVars?.[spec.key])) {
                game.globalVars[spec.key] = map?.globalVars?.[spec.key];
              } else if (is(spec.default)) {
                game.globalVars[spec.key] = spec.default;
              }
            });
            this.__updatedGlobalVars();

            // Initialize player settings
            if (map?.players) {
              this.__playerSettings = map?.players;
            } else {
              const countPlayers = parseInt(map?.countPlayers) || MAX_PLAYERS;
              this.__playerSettings = Array.from({ length: MAX_PLAYERS }, (_, i) => ({
                slot: i < countPlayers ? 'open' : 'closed',
                team: 'any',
                ai: 'normal AI',
              }));
            }
            this.__updatedPlayerSettings();
          };

          MapEditorSettings_.prototype.__refreshNameAndDescription = function () {
            $('#mapNameInput').val(game.name);
            $('#mapDescriptionInput').val(game.description);
          };

          // Updates the worker thread with the new globalVars and refreshes the UI
          MapEditorSettings_.prototype.__updatedGlobalVars = function () {
            worker.postMessage({ what: 'updateGlobalVars', globalVars: game.globalVars });
            this.__refreshGlobalVarsUI();
          };

          MapEditorSettings_.prototype.__refreshGlobalVarsUI = function () {
            const builder = new HTMLBuilder();
            const fieldsPerLine = 4;

            this.__globalVarsSpec.forEach((spec, i) => {
              builder.add(spec.generateUI(() => this.__updatedGlobalVars()));
              builder.add('&nbsp;&nbsp;&nbsp;');
              if ((i + 1) % fieldsPerLine == 0) {
                builder.add('<br /><br />');
              }
            });

            builder.insertInto('#globalVarsDiv');
          };

          // Redraws the UI and triggers events listening for player settings updates
          MapEditorSettings_.prototype.__updatedPlayerSettings = function () {
            this.__playerSettingsChangeListeners.forEach((l) => l(this.__playerSettings));

            const builder = new HTMLBuilder();

            builder.add('<p id=\'playerSettingsDivHeader\'>» Player Settings</p><br />');
            builder.add('<table>');

            builder.add('<tr><td></td>');
            this.__playerSettingsSpec.forEach((c) => builder.add(`<td title='${c.description}'>&nbsp; ${c.name}</td>`));
            builder.add('</tr>');

            const addTD = (column, playerIndex) => {
              if (!column.display(this.__playerSettings[playerIndex])) {
                return;
              }

              const ID = uniqueID();
              builder.add(`<td><select id='${ID}' class='playerSettingsTD'>`);
              column.options.forEach((option) => builder.add(`<option>${option}</option>`));
              builder
                .add('</select></td>')
                // Set the value to be the value in this.__playerSettings and save and refresh the UI when it's changed
                .addHook(() => $(`#${ID}`).val(this.__playerSettings[playerIndex][column.key]))
                .addHook(() => $(`#${ID}`).change(() => {
                  const value = $(`#${ID}`).val();
                  if (!column.validate || column.validate(value, playerIndex)) {
                    this.__playerSettings[playerIndex][column.key] = value;
                  }

                  this.__updatedPlayerSettings();
                }));
            };

            for (let i = 0; i < MAX_PLAYERS; i++) {
              builder.add(`<tr><td>Player ${i + 1}</td>`);
              this.__playerSettingsSpec.forEach((c) => addTD(c, i));
              builder.add('</tr>');
            }

            builder.add('</table>');
            builder.insertInto('#playerSettingsDiv');
          };

          MapEditorSettings_.prototype.isModded = function () {
            return game.globalVars.isModded;
          };

          MapEditorSettings_.prototype.setModded = function (value) {
            // If we are going from modded to unmodded
            if (game.globalVars.isModded && !value) {
              // Unfreeze the map
              this.setFrozen(false, true);
              mapEditorData.resetAllData();
            }

            game.setModded(value);
            this.__updatedGlobalVars();
          };

          MapEditorSettings_.prototype.setFrozen = function (value, skipReset) {
            // If we are going from frozen to unfrozen, and not skipping the reset, reset all data
            if (game.globalVars.isFrozen && !value && !skipReset) {
              mapEditorData.resetAllData();
            }

            game.globalVars.isFrozen = value;
            this.__updatedGlobalVars();
          };

          // Returns true if the slot for playerIndex can be safely closed (no units or buildings to delete)
          // Returns false if not, and prompts the user to choose
          // If the user chooses to close the slot anyway, all units and buildings for that player are deleted
          MapEditorSettings_.prototype.__tryCloseSlot = function (playerIndex) {
            // Check if there are any units or buildings for this player
            const ownedUnits = [...game.units, ...game.buildings].filter((u) => u.owner.number == playerIndex + 1);

            // If the player owns nothing, go ahead and close the slot
            if (ownedUnits.length == 0) {
              return true;
            }

            displayConfirmPrompt(
              'Marking this slot as closed will delete all units and buildings on the map owned by this player. Are you sure?',
              () => {
                editor.removeObjects(ownedUnits);
                this.__playerSettings[playerIndex].slot = 'closed';
                this.__updatedPlayerSettings();
              },
              () => { },
            );
            return false;
          };

          MapEditorSettings_.prototype.getPlayerSettings = function () {
            return JSON.parse(JSON.stringify(this.__playerSettings));
          };

          MapEditorSettings_.prototype.onPlayerSettingsChange = function (cb) {
            this.__playerSettingsChangeListeners.push(cb);
          };

          return new MapEditorSettings_();
        })();

        window.settings = MapEditorSettings;

        // a team pretty much only holds information regarding the vision
        function Team(nr) {
          this.number = nr;

          // fog mask & block array
          this.mask = [];
          this.blockArray = [];
          for (var x = 0; x <= game.x + 1; x++) {
            this.blockArray[x] = [];
            this.mask[x] = [];
            for (var y = 0; y <= game.y + 1; y++) {
              this.mask[x][y] = 0;
              this.blockArray[x][y] = true;
              if (x < 1 || x > game.x || y < 1 || y > game.y) // if outside borders
              {
                this.blockArray[x][y] = false;
              }
            }
          }
        };

        Team.prototype.fieldIsBlocked = function (x, y) {
          return !(x > 0 && x <= game.x && y > 0 && y <= game.y && this.blockArray[x][y] && game.fields[x][y].hm == parseInt(game.fields[x][y].hm));
        };

        Team.prototype.fieldIsBlockedForBuilding = function (x, y) {
          return this.fieldIsBlocked(x, y);
        };

        Team.prototype.canSeeField = function (x, y) {
          return this.mask[x] && this.mask[x][y] > 1;
        };

        Team.prototype.canSeeUnitInvisible = function (unit) {
          return (unit.owner.team == this || !unit.getValue('isInvisible') || unit.isDetectedUntil >= ticksCounter || unit.owner.team.number == 0) && !unit.getValue('noShow');
        };

        // returns true, if the team can see a specific unit (if onlyNow is flagged, only return true, if the unit is currently in the LoS of the team)
        Team.prototype.canSeeUnit = function (unit, onlyNow) {
          // if the team owns this unit, return true of course
          if (unit.owner.team == this || game_state == GAME.EDITOR) {
            return true;
          }

          // if its a unit, return true when the units is inside of the line of sight of the team
          if (!unit.type.isBuilding) {
            return this.mask[unit.pos.x][unit.pos.y] > 1 || unit.revealedToTeamUntil[this.number] >= ticksCounter;
          }

          // if its a building
          else {
            if (unit.owner.isRevealed) {
              return true;
            }

            // if not only now, just return seenBy
            if (!onlyNow) {
              return unit.seenBy[this.number];
            }

            // if only now, check line of sight for all the fields, the building contains; also set seen by = true, if it is seen
            for (var x = unit.x; x < unit.x + unit.type.size; x++) {
              for (var y = unit.y; y < unit.y + unit.type.size; y++) {
                if (this.mask[x][y] > 1) {
                  return unit.seenBy[this.number];
                }
              }
            }

            return false;
          }
        };

        const Chats = (() => {
          function Chats_() {
            this.__chatWindows = {};
            this.__chatButtons = {};

            Initialization.onDocumentReady(() => {
              this.init();

              const clearChats = () => {
                for (let i in this.__chatWindows) {
                  this.__chatWindows[i].kill();
                }
                this.__chatWindows = {};
                for (let i in this.__chatButtons) {
                  this.__chatButtons[i].remove();
                }
                this.__chatButtons = {};
                $('#noMessagesP').css('display', 'inline-block');
              };

              Login.registerOnLogin(clearChats);
              Login.registerOnLogout(clearChats);
            });

            this.POPUP_CHATS = Object.freeze({
              ALWAYS: 0,
              NEVER: 1,
              NOT_INGAME: 2,
            });

            this.POPUP_CHATS_CAPTIONS = Object.freeze({
              [this.POPUP_CHATS.ALWAYS]: 'Always pop up messages',
              [this.POPUP_CHATS.NEVER]: 'Never pop up messages',
              [this.POPUP_CHATS.NOT_INGAME]: 'Don\'t pop up messages ingame',
            });

            this.popupChats = LocalConfig.registerValue('popup_chats', this.POPUP_CHATS.ALWAYS);
          }

          Chats_.prototype.init = function () {
            this.__initNetworkListeners();

            $('#chatListSubDiv').append('<p id=\'noMessagesP\'>No Messages</p>');
          };

          Chats_.prototype.__initNetworkListeners = function () {
            network.registerListener(null, 'query', (splitMsg) => {
              const rawMsg = splitMsg[7];
              const sender = {
                name: splitMsg[3],
                emojiPermissions: splitMsg[1],
                authLevel: splitMsg[5],
                isPremium: splitMsg[6],
              };
              const conversationPartner = splitMsg[2];
              const msgStatus = splitMsg[4];

              if (AccountInfo.ignores.contains(conversationPartner.toLowerCase()) && conversationPartner == sender.name) {
                if (msgStatus == 0) {
                  network.send('query-ignore<<$' + splitMsg[2]);
                }
                return;
              }

              if (interface_.noGuestDM.get() && conversationPartner == sender.name && sender.authLevel == 1) {
                if (msgStatus == 0) {
                  network.send('query-ignore-guests<<$' + splitMsg[2]);
                }
                return;
              }

              this.addMessage(conversationPartner, rawMsg, sender, msgStatus);
            });
          };

          Chats_.prototype.__chatsWindowOpen = function () {
            return $('#queriesWindow')[0].style.display != 'none';
          };

          Chats_.prototype.__getChatWindow = function (name) {
            // Check if the chat window already exists and return if so
            if (this.__chatWindows[name]) {
              return this.__chatWindows[name];
            }

            // Otherwise, create a new chat window
            const chatWindow = new ChatWindow(name);
            this.__chatWindows[name] = chatWindow;

            // Create a chat button for this window
            const chatButtonID = uniqueID('chatButton');
            generateButton(chatButtonID, 'queryButtonLink', null, addClickSound(() => this.openChatFor(name)), name)
              .appendInto('#chatListSubDiv');
            this.__chatButtons[name] = $(`#${chatButtonID}`);

            // Remove the message saying there are no chats
            $('#noMessagesP').css('display', 'none');

            return chatWindow;
          };

          Chats_.prototype.openChatFor = function (name, focus) {
            this.__getChatWindow(name).show();
            if (focus) {
              this.focusChat(name);
            }

            // Remove blinking because the chat has now been opened
            this.__chatButtons[name].removeClass('blinkBorderRed');

            // Check if there are any remaining pending chats
            const chatsPending = Object.values(this.__chatWindows).some((chatWindow) => chatWindow.pending);

            // If there are no pending chats, remove the blinking from the friends button
            if (!chatsPending) {
              $('#friendsButton').removeClass('blinkBGRed');
            }
          };

          Chats_.prototype.addMessage = function (name, rawMsg, sender, msgStatus = '0') {
            const chatWindow = this.__getChatWindow(name);
            chatWindow.addMessage(rawMsg, sender, msgStatus);

            const neverOpen = this.popupChats.get() == this.POPUP_CHATS.NEVER;
            const dontOpenBecauseIngame = this.popupChats.get() == this.POPUP_CHATS.NOT_INGAME && game_state == GAME.PLAYING;

            const shouldOpenChat = !neverOpen && !dontOpenBecauseIngame;

            if (shouldOpenChat) {
              // Play a different sound based on whether or not the chat window was already open
              soundManager.playSound(chatWindow.hidden ? SOUND.BING : SOUND.ZIP3, 0.8);
              this.openChatFor(name);
            } else if (chatWindow.hidden) {
              // If the chats window is not visible, blink the icon
              if (!this.__chatsWindowOpen()) {
                $('#friendsButton').addClass('blinkBGRed');
              }

              // Make the chat button blink as well
              this.__chatButtons[name].addClass('blinkBorderRed');
            }
          };

          Chats_.prototype.focusChat = function (name) {
            for (let i in this.__chatWindows) {
              if (i == name) {
                this.__chatWindows[i].sendToFront();
                this.__chatWindows[i].focusInput();
              } else {
                this.__chatWindows[i].sendToBack();
              }
            }
          };

          return new Chats_();
        })();

        function ChatWindow(name) {
          this.name = name;
          this.minimized = false;
          this.hidden = true; // The chat window will not be visible when created
          this.pending = false; // Whether or not there are messages that haven't been seen yet

          // Construct the chat window itself
          const windowID = uniqueID('chat');
          const windowLeft = Math.floor(Math.random() * 100 + 100) + 'px';
          const windowTop = Math.floor(Math.random() * 100 + 100) + 'px';
          new HTMLBuilder()
            .add(`<div id='${windowID}' class='query ingameWindow' style='left: ${windowLeft}; top: ${windowTop}'></div>`)
            .appendInto(document.body);

          this.window = $(`#${windowID}`);
          this.window.css('display', 'none');

          // Make the chat window draggable
          this.window.draggable({
            drag: onDrag,
            cancel: 'p, input',
          });

          // Make the chat window close when the ESC button is pressed
          this.window.keydown((e) => {
            if (keyManager.getKeyCode(e) == KEY.ESC) {
              soundManager.playSound(SOUND.CLICK);
              this.hide();
            }
          });

          // Construct the contents of the chat window
          const textAreaID = uniqueID('chatText');
          const closeButtonID = uniqueID('closeButton');
          const minimizeButtonID = uniqueID('minimizeButton');
          const chatInputID = uniqueID('chatInput');
          const banButtonID = uniqueID('ban');

          new HTMLBuilder()
            .add(`<h2 class='windowTitle'>&raquo; Chat: ${name}</h2>`)
            .add(generateButton(closeButtonID, 'closeButton', null, addClickSound(() => this.hide()), 'X'))
            .add(generateButton(minimizeButtonID, 'minimizeButton', null, addClickSound(() => {
              if (!this.minimized) {
                this.window.css('height', '70px');
                $(`#${minimizeButtonID}`).text('□');
                $(`#${chatInputID}`).hide();
              } else {
                this.window.css('height', '400px');
                $(`#${minimizeButtonID}`).text('_');
                $(`#${chatInputID}`).show();
              }
              this.minimized = !this.minimized;
            }), '_'))

            .add(`<div id='${textAreaID}' class='textContainer queryTextContainer'></div>`)

            .add(`<input id='${chatInputID}' type='text' class='queryInput' maxLength='250'>`)
            .addHook(() => $(`#${chatInputID}`).keydown((e) => {
              const value = $(`#${chatInputID}`).val();

              if (keyManager.getKeyCode(e) == KEY.ENTER && value) {
                $(`#${chatInputID}`).val('');

                if (value == '/ping') {
                  timeOfLastPingSent = Date.now();
                }

                network.send('query<<$' + name + '<<$' + value);
              }
            }))

            .appendInto(this.window);

          this.textArea = $(`#${textAreaID}`);
          this.chatInput = $(`#${chatInputID}`);

          // Add the ban button if we are mod or admin
          if (AccountInfo.isMod || AccountInfo.isAdmin) {
            generateButton(banButtonID, 'inlineBanButton2', null, () => reallyBan(name), 'ban').appendInto(this.window);
          }
        }

        ChatWindow.prototype.addMessage = async function (rawMsg, sender, msgStatus) {
          if (this.hidden) {
            this.pending = true;
          }

          const builder = new HTMLBuilder();
          builder.add('<p>');

          // Print different messages depending on the msgStatus
          if (msgStatus == '2') {
            builder.add('<span class=\'msgFailedStatus\'>This player does not exist.</span>');
          } else if (msgStatus == '9') {
            builder.add('<span class=\'msgFailedStatus\'>This player ignores you.</span>');
          } else if (msgStatus == '8') {
            builder.add('<span class=\'msgFailedStatus\'>This player does not accept messages from guests.</span>');
          } else if (msgStatus == '3') {
            builder.add('<span class=\'msgFailedStatus\'>You\'re sending messages too quickly.</span>');
          } else if (msgStatus == '4') {
            // Retry until the game is loaded into GamesList
            await retry(() => {
              if (sender.name == AccountInfo.playerName) {
                builder.add(`<span>You sent an invitation to join ${GamesList.games[rawMsg].map}</span>`);
              } else {
                const ID = uniqueID();
                const [gameID, inviteID] = rawMsg.split(',');
                builder
                  .add(`
                        <span>${sender.name} is inviting you to join
                            <a id='${ID}' style='cursor: pointer' class='yellowfont' target='_blank'>
                                ${GamesList.games[gameID].map}
                            </a>
                        </span>
                    `)
                  .addHook(() => $(`#${ID}`).click(() => GamesList.joinGame(gameID, inviteID)));
              }
            }, 500, 4000);
          } else {
            // The message was sent successfully
            const isOffline = msgStatus == '1';

            // Print the name of the person who sent the message
            if (sender.name.length > 0) {
              builder.add(PlayersList.getPlayerLink(escapeHtml(sender.name), true, false, sender.authLevel));
            }

            // Print the message itself, after cleaning it up and inserting emojis
            const msg = rawMsg ? kappa(escapeHtml(rawMsg), sender.emojiPermissions) : '';
            builder.add(': ').add(msg);

            // If the user sent a message to an offline user, tell them the message will be delivered
            if (isOffline) {
              const offlineMsg = ' (This player is offline. The message will be delivered when they come online.)';
              builder.add(`<span class='msgFailedStatus'>${offlineMsg}</span>`);
            }
          }

          builder.add('</p>');
          builder.appendInto(this.textArea);
          this.textArea.scrollTop(this.textArea.prop('scrollHeight'));
        };

        ChatWindow.prototype.sendToBack = function () {
          this.window.css('z-index', 101);
        };

        ChatWindow.prototype.sendToFront = function () {
          this.window.css('z-index', topZIndex++);
        };

        ChatWindow.prototype.focusInput = function () {
          setTimeout(() => this.chatInput.focus(), 50);
        };

        ChatWindow.prototype.show = function () {
          this.pending = false;
          this.hidden = false;
          fadeIn(this.window);
        };

        ChatWindow.prototype.hide = function () {
          this.hidden = true;
          fadeOut(this.window);
        };

        // Destroys the window, making this class unusable afterwards
        ChatWindow.prototype.kill = function () {
          this.window.remove();
        };

        function Effect() {
          this.isEffect = true;
        };

        Effect.prototype.getYDrawingOffset = function () {
          return this.pos.py;
        };

        // return true if building / tile is inside a drawn box on the screen
        Effect.prototype.isInBox = function (x1, y1, x2, y2) {
          return this.borderRight >= x1 && this.borderBottom >= y1 && this.borderLeft <= x2 && this.borderTop <= y2 + (this.height ? this.height : 0);
        };

        Effect.prototype.isInBoxVisible = Effect.prototype.isInBox;

        Effect.prototype.isExpired = function () {
          return ticksCounter > this.tickOfDeath;
        };

        Effect.prototype.attach = function (attachToUnit) {
          if (attachToUnit && this.unit) {
            this.unit.effectsToDraw.push(this);
          }

          game.addToObjectsToDraw(this);
        };


        Arrow.prototype = new Effect();
        function Arrow(data) {
          if (!data.to) {
            data.to = data.from;
          }

          this.from = data.from.drawPos.getCopy();
          var targetPos = data.to.type ? data.to.drawPos.add3(0, -data.to.type.height) : data.to;
          this.pos = this.from;
          this.to = data.to;
          this.dist = this.from.distanceTo2(targetPos);
          this.len = (data.from && data.from.type) ? data.from.type.projectileLen : 0.2;
          this.tickStart = ticksCounter;
          this.lifeTime = this.dist / data.speed * 20;
          this.height = (data.from && data.from.type) ? data.from.type.projectileStartHeight : 0.25;
          this.tickOfDeath = ticksCounter + this.lifeTime;

          this.borderLeft = Math.min(this.from.px, targetPos.px);
          this.borderRight = Math.max(this.from.px, targetPos.px);
          this.borderTop = Math.min(this.from.py, targetPos.py);
          this.borderBottom = Math.max(this.from.py, targetPos.py);

          this.attach(data.attachToUnit);

          this.modId = data.modId;
        };

        Arrow.prototype.draw = function () {
          var targetPos = this.to.type ? this.to.drawPos.add3(0, -this.to.type.height) : this.to;

          this.dist = this.from.distanceTo2(targetPos);

          var percentageDone = (ticksCounter + percentageOfCurrentTickPassed - this.tickStart) / (this.lifeTime + 0.75);

          var maxHeight = Math.max(this.dist - 1.5, 0) / 6;
          var stg = Math.max(Math.min((-(percentageDone * this.dist) + this.dist / 2) * maxHeight * 0.05, this.len / 2), -this.len / 2);
          height = (1 - percentageDone) * this.height - Math.pow((2 / this.dist) * (percentageDone * this.dist) - 1, 2) * maxHeight + maxHeight;

          var len = Math.sqrt(this.len * this.len - stg * stg);

          var pos1 = this.from.addNormalizedVector(targetPos, percentageDone * this.dist - len / 2);
          var pos2 = this.from.addNormalizedVector(targetPos, percentageDone * this.dist + len / 2);

          this.pos = pos1;

          if (PLAYING_PLAYER.team.canSeeField(this.pos.x, this.pos.y)) {
            c.lineWidth = 0.75 * SCALE_FACTOR;
            c.strokeStyle = (game.theme && game.theme.arrowColor) ? game.theme.arrowColor : '#111111';
            c.beginPath();
            c.moveTo(pos1.px * FIELD_SIZE - game.cameraX, (pos1.py - height) * FIELD_SIZE - game.cameraY);
            c.lineTo(pos2.px * FIELD_SIZE - game.cameraX, (pos2.py - height - stg) * FIELD_SIZE - game.cameraY);
            c.stroke();
            c.closePath();
          }
        };


        CustomProjectile.prototype = new Effect();
        function CustomProjectile(data) {
          var targetPos = data.to.type ? data.to.drawPos.add3(0, -data.to.type.height) : data.to.add3(0, -game.getHMValue2(data.to.x, data.to.y) * CLIFF_HEIGHT);

          this.from = data.from.drawPos.getCopy();
          this.pos = this.from;
          this.to = data.to;
          this.dist = this.from.distanceTo2(targetPos);
          this.tickStart = ticksCounter;
          this.lifeTime = this.dist / data.speed * 20;
          this.height = data.from.type.projectileStartHeight;
          this.tickOfDeath = ticksCounter + this.lifeTime;
          this.playerNumber = (data.from.owner && data.from.owner.number) ? data.from.owner.number : 0;
          this.scale = data.scale ? data.scale : 1;

          this.borderLeft = Math.min(this.from.px, targetPos.px);
          this.borderRight = Math.max(this.from.px, targetPos.px);
          this.borderTop = Math.min(this.from.py, targetPos.py);
          this.borderBottom = Math.max(this.from.py, targetPos.py);

          this.addExplosion = data.addExplosion;

          var angle = this.from.getAngleTo(targetPos);
          this.direction = '';

          angle += angle < -Math.PI ? Math.PI * 2 : 0;
          angle -= angle > Math.PI ? Math.PI * 2 : 0;

          if (angle >= Math.PI * 3 / 8 && angle <= Math.PI * 5 / 8) {
            this.direction = 's';
          } else if (angle <= -Math.PI * 3 / 8 && angle >= -Math.PI * 5 / 8) {
            this.direction = 'n';
          } else if (angle >= Math.PI * 7 / 8 || angle <= -Math.PI * 7 / 8) {
            this.direction = 'w';
          } else if ((angle <= Math.PI * 1 / 8 && angle >= 0) || (angle >= -Math.PI * 1 / 8 && angle <= 0)) {
            this.direction = 'e';
          } else if (angle <= Math.PI * 7 / 8 && angle >= Math.PI * 5 / 8) {
            this.direction = 'sw';
          } else if (angle <= Math.PI * 3 / 8 && angle >= Math.PI * 1 / 8) {
            this.direction = 'se';
          } else if (angle >= -Math.PI * 7 / 8 && angle <= -Math.PI * 5 / 8) {
            this.direction = 'nw';
          } else {
            this.direction = 'ne';
          }

          this.attach(data.attachToUnit);

          this.modId = data.modId;

          this.imgs = [imgs.fire1.img, imgs.fire2.img, imgs.fire3.img, imgs.fire4.img, imgs.fire5.img];
        };

        CustomProjectile.prototype.draw = function () {
          var targetPos = this.to.type ? this.to.drawPos.add3(0, -this.to.type.height) : this.to.add3(0, -game.getHMValue2(this.to.x, this.to.y) * CLIFF_HEIGHT);

          this.dist = this.from.distanceTo2(targetPos);

          var percentageDone = (ticksCounter + percentageOfCurrentTickPassed - this.tickStart) / (this.lifeTime + 0.75);

          var maxHeight = Math.max(this.dist - 1.5, 0) / 6;
          height = ((1 - percentageDone) * this.height - Math.pow((2 / this.dist) * (percentageDone * this.dist) - 1, 2) * maxHeight + maxHeight) * 0.6;

          this.pos = this.from.addNormalizedVector(targetPos, percentageDone * this.dist);
          var img = arrowImg[this.direction][percentageDone > 0.5 ? 1 : 0];

          var scale = SCALE_FACTOR * this.scale;

          if (PLAYING_PLAYER.team.canSeeField(this.pos.x, this.pos.y)) {
            c.drawImage(buildingSheet[this.playerNumber], img.x, img.y, img.w, img.h, this.pos.px * FIELD_SIZE - game.cameraX - img.w * scale / 2, (this.pos.py - height) * FIELD_SIZE - game.cameraY - img.h * scale / 2, img.w * scale, img.h * scale);
          }

          if (!this.addExplosion || !this.isExpired()) {
            return;
          }

          soundManager.playSound(SOUND.FLAK, game.getVolumeModifier(targetPos));

          // crate explosion
          for (var i = 0; i < 10; i++) {
            new Sprite({
              from: targetPos.add2(Math.random() * Math.PI * 2, Math.random() * 1.5).add3(0, 6.5),
              img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
              scaleFunction: function (age) {
                return (1.5 / (age + 0.25) + age - 4) * (-1) + this.r1;
              },
              age: 0.6 + Math.random() * 0.5,
              r1: 1.0 + Math.random() / 2,
              height: 6.5,
            });
          }

          // crate zmoke
          for (var i = 0; i < 6; i++) {
            new Sprite({
              from: targetPos.add2(Math.random() * Math.PI * 2, Math.random() * 1.5).add3(0, 6.5),
              img: lists.imgs.dust1,
              scaleFunction: function (age) {
                return (1.5 / (age + 0.25) + age - 4) * (-1) + this.r1;
              },
              age: 1.6 + Math.random() * 0.5,
              r1: 1.0 + Math.random() / 2,
              alphaFunction: function (age) {
                return 0.4;
              },
              height: 6.5,
            });
          }
        };


        DragonAttack.prototype = new Effect();
        function DragonAttack(data) {
          var targetPos = data.to.type ? data.to.drawPos.getCopy() : data.to;

          this.from = data.from.drawPos.addNormalizedVector(targetPos, data.from.type.size / 3);
          this.pos = this.from;
          this.to = data.to;
          this.dist = this.from.distanceTo2(targetPos);
          this.tickStart = ticksCounter;
          this.lifeTime = this.dist / (data.speed ? data.speed : 6) * 20;
          this.actualLifeTime = this.lifeTime;
          this.height = data.from.type ? data.from.type.height : 0;
          this.targetHeight = (this.to.type && this.to.type.isUnit) ? this.to.type.height : (game.getHMValue2(this.to.x, this.to.y) * CLIFF_HEIGHT + 0.3);
          this.scale = data.scale ? data.scale : 1;

          // if were shooting a building, make the "hit" a little bit earlier (when the projectile hit the wall of the building)
          if (this.to.type && this.to.type.isBuilding) {
            var angle = this.from.getAngleTo(this.to.pos);
            var size = this.to.type.size / 2;

            var distMinimization = Math.min(
              Math.sqrt(
                Math.pow(Math.tan(angle) * size, 2) + Math.pow(size, 2),
              ),
              Math.sqrt(
                Math.pow((1 / Math.tan(angle)) * size, 2) + Math.pow(size, 2),
              ),
            );

            this.actualLifeTime = (this.dist - distMinimization - 0.4) / (data.speed ? data.speed : 6) * 20;
          }

          this.tickOfDeath = ticksCounter + this.actualLifeTime;

          this.borderLeft = Math.min(this.from.px, targetPos.px);
          this.borderRight = Math.max(this.from.px, targetPos.px);
          this.borderTop = Math.min(this.from.py, targetPos.py);
          this.borderBottom = Math.max(this.from.py, targetPos.py);

          this.attach(data.attachToUnit);

          this.modId = data.modId;

          this.imgs = [imgs.fire1.img, imgs.fire2.img, imgs.fire3.img, imgs.fire4.img];
        };

        DragonAttack.prototype.draw = function () {
          var targetPos = this.to.type ? this.to.drawPos.getCopy() : this.to;

          this.dist = this.from.distanceTo2(targetPos);

          var percentageDone = (ticksCounter + percentageOfCurrentTickPassed - this.tickStart) / (this.lifeTime + 1);
          var height = this.height + (this.targetHeight - this.height) * percentageDone;
          this.pos = this.from.addNormalizedVector(targetPos, percentageDone * this.from.distanceTo2(targetPos));

          if (PLAYING_PLAYER.team.canSeeField(this.pos.x, this.pos.y)) {
            var scale = SCALE_FACTOR * this.scale;
            var drawX = this.pos.px * FIELD_SIZE - (imgs.fire5.img.w / 2) * scale - game.cameraX;
            var drawY = (this.pos.py - height) * FIELD_SIZE - (imgs.fire5.img.h / 2) * scale - game.cameraY;
            c.drawImage(miscSheet[0], imgs.fire5.img.x, imgs.fire5.img.y, imgs.fire5.img.w, imgs.fire5.img.h, drawX, drawY, imgs.fire5.img.w * scale, imgs.fire5.img.h * scale);
          }

          // randomly create flames
          for (var i = 0; i < tickDiff; i++) {
            new Sprite({
              from: this.pos.add2(Math.random() * Math.PI * 2, 0.15),
              img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
              scaleFunction: function (age) {
                return (age + 1) * this.scale_;
              },
              age: Math.random() + 0.5,
              height: height,
              scale_: this.scale,
            });
          }

          // randomly create smoke / dust
          for (var i = 0; i < tickDiff; i++) {
            if (Math.random() > 0.5) {
              new Dust({ from: this.pos.add2(Math.random() * Math.PI * 2, 0.15), scale: 1 + Math.random(), ageScale: 2 + Math.random(), height: height });
            }
          }

          if (!this.isExpired()) {
            return;
          }

          var pos = (this.to.type && this.to.type.isBuilding) ? this.pos.add3(0, 0.5) : targetPos.add3(0, 0.5);

          if (this.to.type && this.to.type.flying) {
            pos = pos.add3(0, 3);
            height += 3;
          }

          // create impact flames
          for (var i = 0; i < 4; i++) {
            new Sprite({
              from: pos.add2(Math.random() * Math.PI * 2, Math.random() * 0.75),
              img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
              scaleFunction: function (age) {
                return (1 / (age + 0.25) + age - 4) * (-1) * this.scale_;
              },
              age: 1 + Math.random() * 2,
              height: height,
              scale_: this.scale,
            });
          }

          // create impact smoke
          for (var i = 0; i < 2; i++) {
            new Dust({ from: pos.add2(Math.random() * Math.PI * 2, Math.random() * 1), scale: 1.5 + Math.random(), ageScale: 2 + Math.random(), height: height });
          }

          // create soot
          if (this.to.type && this.to.type.isUnit && !this.to.type.flying) {
            pos = pos.add3(0, -0.5).add2(Math.random() * Math.PI * 2, Math.random() * 0.25);

            game.groundTilesCanvas.getContext('2d').globalAlpha = 0.35;
            game.groundTilesCanvas.getContext('2d').drawImage(miscSheet[0], imgs.soot.img.x, imgs.soot.img.y, imgs.soot.img.w, imgs.soot.img.h, pos.px * FIELD_SIZE / SCALE_FACTOR - imgs.soot.img.w / 4, (pos.py + 2) * FIELD_SIZE / SCALE_FACTOR - imgs.soot.img.h / 4, imgs.soot.img.w / 2, imgs.soot.img.h / 2);
            game.groundTilesCanvas.getContext('2d').globalAlpha = 1;
          }
        };


        Dust.prototype = new Effect();
        function Dust(data) {
          _.extend(this, data);

          this.height = this.height ? this.height : 0;
          this.scale = this.scale ? this.scale : 1;

          this.pos = this.from;

          this.x = this.pos.px;
          this.y = this.pos.py - this.height;

          this.particle = {
            x: Math.random() / 3 - 0.166,
            y: Math.random() / 20 - 1 / 40,
            vz: this.vz ? this.vz : Math.random() / 3 + 0.166,
            alpha: 0.75,
            img: Math.random() > 0.5 ? imgs.dust1.img : imgs.dust2.img,
            scale: Math.random() * 4 + 2,
            tickOfCreation: ticksCounter,
            timeToLive: (Math.random() * 650 + 800) * (this.ageScale ? this.ageScale : 1),
          };

          this.tickOfDeath = ticksCounter + this.particle.timeToLive / 50;

          this.borderLeft = this.pos.px;
          this.borderRight = this.pos.px;
          this.borderTop = this.pos.py;
          this.borderBottom = this.pos.py;

          this.attach(data.attachToUnit);

          this.modId = data.modId;
        };

        Dust.prototype.draw = function () {
          var age = ((ticksCounter + percentageOfCurrentTickPassed) - this.particle.tickOfCreation) * 50;
          var percentageDone = age / this.particle.timeToLive;

          var y = this.particle.vz * (age / 1000) * this.scale;
          var scale = this.particle.scale * (percentageDone * 0.5 + 0.5) * this.scale * (SCALE_FACTOR / 4);

          if (this.yFunction) {
            y += this.yFunction(age / 1000) * 0.75;
          }

          var x = 0;
          if (this.xFunction) {
            x = this.xFunction(age / 1000);
          }

          if (PLAYING_PLAYER.team.canSeeField(this.pos.x, this.pos.y)) {
            c.globalAlpha = Math.max(this.particle.alpha * (1 - percentageDone), 0);
            c.drawImage(miscSheet[0], this.particle.img.x, this.particle.img.y, this.particle.img.w, this.particle.img.h, (this.x + this.particle.x + x) * FIELD_SIZE - game.cameraX - this.particle.img.w * scale / 2, (this.y + this.particle.y - y) * FIELD_SIZE - game.cameraY - this.particle.img.w * scale / 2, this.particle.img.w * scale, this.particle.img.h * scale);
            c.globalAlpha = 1;
          }
        };


        Flame.prototype = new Effect();
        function Flame(data) {
          this.unit = (data.from && data.from.type) ? data.from : null;

          this.pos = this.unit ? this.unit.drawPos : data.from;
          this.tickOfDeath = ticksCounter + (Math.random() * 3 + 0.5) * 20;

          this.borderLeft = this.pos.px - 0.5;
          this.borderRight = this.pos.px + 0.5;
          this.borderTop = this.pos.py + 1.5;
          this.borderBottom = this.pos.py - 0.5;

          this.attach(data.attachToUnit);

          this.modId = data.modId;

          this.imgs = [imgs.fire1.img, imgs.fire2.img, imgs.fire3.img, imgs.fire4.img];
        };

        Flame.prototype.draw = function () {
          if (this.unit) {
            this.pos = this.unit.drawPos;
          }

          for (var i = 0; i < tickDiff; i++) {
            if (Math.random() < 0.06) {
              new Sprite({
                from: this.pos.add2(Math.random() * Math.PI * 2, 0.1),
                img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
                scaleFunction: function (age) {
                  return 1 + age;
                },
                alphaFunction: function (age) {
                  return 0.5;
                },
              });
            }
          }

          for (var i = 0; i < tickDiff; i++) {
            if (Math.random() < 0.1) {
              new Dust({ from: this.pos, scale: 1 + Math.random(), ageScale: 2 + Math.random() });
            }
          }
        };


        Flamestrike.prototype = new Effect();
        function Flamestrike(data) {
          var targetPos = data.to.type ? data.to.pos.getCopy() : data.to;

          this.from = data.from.pos.getCopy();
          this.pos = this.from;
          this.to = data.to;
          this.dist = this.from.distanceTo2(targetPos);
          this.tickStart = ticksCounter;
          this.lifeTime = this.dist / (data.speed ? data.speed : 7) * 20;
          this.tickOfDeath = ticksCounter + this.lifeTime;
          this.noFinalBlow = data.noFinalBlow;
          this.scale = data.scale ? data.scale : 1;
          this.lastTimeSoot = ticksCounter;
          this.startHeight = data.from.type.height;
          this.endHeight = data.to.type ? data.to.type.height : 0.3;

          this.borderLeft = Math.min(this.from.px, targetPos.px);
          this.borderRight = Math.max(this.from.px, targetPos.px);
          this.borderTop = Math.min(this.from.py, targetPos.py);
          this.borderBottom = Math.max(this.from.py, targetPos.py);

          this.attach(data.attachToUnit);

          this.modId = data.modId;

          this.imgs = [imgs.fire1.img, imgs.fire2.img, imgs.fire3.img, imgs.fire4.img, imgs.fire5.img];
        };

        Flamestrike.prototype.draw = function () {
          var targetPos = this.to.type ? this.to.pos.getCopy() : this.to;
          this.dist = this.from.distanceTo2(targetPos);

          this.vec = this.from.vectorTo(targetPos).normalize(0.7);

          var percentageDone = (ticksCounter + percentageOfCurrentTickPassed - this.tickStart) / (this.lifeTime + 1);
          this.pos = this.from.addNormalizedVector(targetPos, percentageDone * this.dist);

          var height = this.startHeight * (1 - percentageDone) + this.endHeight * percentageDone;

          var hm = game.getHMValue3(this.pos) * CLIFF_HEIGHT;

          var drawX = (this.pos.px + Math.random() * 0.1 - 0.05) * FIELD_SIZE - (imgs.fire5.img.w / 2) * SCALE_FACTOR * this.scale * (Math.random() * 0.2 + 0.9) - game.cameraX;
          var drawY = ((this.pos.py + Math.random() * 0.1 - 0.05 - height - hm) + Math.sin((ticksCounter + percentageOfCurrentTickPassed) * 0.4) * this.scale * 0.04) * FIELD_SIZE - (imgs.fire5.img.h / 2) * SCALE_FACTOR * this.scale * (Math.random() * 0.2 + 0.9) - game.cameraY;

          if (this.noFinalBlow && this.tickOfDeath - 10 < ticksCounter) {
            c.globalAlpha = Math.max((this.tickOfDeath - ticksCounter) / 10, 0);
          }

          if (PLAYING_PLAYER.team.canSeeField(this.pos.x, this.pos.y)) {
            if (this.noFinalBlow) {
              var oldGlobalAlpha = c.globalAlpha;
              c.globalAlpha *= 0.15;
              var scale = SCALE_FACTOR * this.scale * 1.5 * (Math.random() * 0.2 + 0.9);
              var drawX2 = (this.pos.px + Math.random() * 0.1 - 0.05) * FIELD_SIZE - imgs.lightGround.img.w / 2 * scale - game.cameraX;
              var drawY2 = (this.pos.py + 0.5 + Math.random() * 0.1 - 0.05 - height - hm) * FIELD_SIZE - imgs.lightGround.img.h / 2 * scale - game.cameraY;
              c.drawImage(miscSheet[0], imgs.lightGround.img.x, imgs.lightGround.img.y, imgs.lightGround.img.w, imgs.lightGround.img.h, drawX2, drawY2, imgs.lightGround.img.w * scale, imgs.lightGround.img.h * scale);
              c.globalAlpha = oldGlobalAlpha;
            }

            c.drawImage(miscSheet[0], imgs.fire5.img.x, imgs.fire5.img.y, imgs.fire5.img.w, imgs.fire5.img.h, drawX, drawY, imgs.fire5.img.w * SCALE_FACTOR * this.scale, imgs.fire5.img.h * SCALE_FACTOR * this.scale);

            // soot
            if (this.noFinalBlow && this.lastTimeSoot < ticksCounter && height < 1) {
              var ctx = game.groundTilesCanvas.getContext('2d');
              ctx.globalAlpha = 0.05;
              ctx.drawImage(miscSheet[0], imgs.soot2.img.x, imgs.soot2.img.y, imgs.soot2.img.w, imgs.soot2.img.h, this.pos.px * FIELD_SIZE / SCALE_FACTOR - imgs.soot2.img.w / 2, (this.pos.py - hm + 2) * FIELD_SIZE / SCALE_FACTOR - imgs.soot2.img.h / 2, imgs.soot2.img.w, imgs.soot2.img.h);
              this.lastTimeSoot = ticksCounter;
              ctx.globalAlpha = 1;
            }
          }

          if (this.noFinalBlow && this.tickOfDeath - 10 < ticksCounter) {
            c.globalAlpha = 1;
          }

          // randomly create flames
          for (var i = 0; i < tickDiff; i++) {
            new Sprite({
              from: this.pos.add2(Math.random() * Math.PI * 2, 0.15).add3(0, -hm),
              img: this.imgs[Math.floor(Math.random() * 4)],
              scaleFunction: function (age) {
                return (age + 1) * this.var1;
              },
              var1: Math.sqrt(this.scale),
              rX: Math.random() - 0.5 + this.vec.px,
              rY: Math.random() - 0.5 + this.vec.py,
              alphaFunction: function (age) {
                return 1;
              },
              xFunction: function (age) {
                return this.rX * Math.sqrt(age);
              },
              yFunction: function (age) {
                return this.rY * Math.sqrt(age);
              },
              height: height,
            });
          }

          // randomly create smoke / dust
          for (var i = 0; i < tickDiff; i++) {
            if (Math.random() > 0.5) {
              new Dust({ from: this.pos.add2(Math.random() * Math.PI * 2, 0.15).add3(0, -hm), scale: 1 + Math.random(), ageScale: 2 + Math.random(), height: height });
            }
          }

          if (!this.isExpired() || this.noFinalBlow) {
            return;
          }

          // impact
          new Sprite({
            from: this.pos.add2(Math.random() * Math.PI * 2, Math.random() / 2).add3(0, -hm),
            img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
            scaleFunction: function (age) {
              return (1 / (age + 0.25) + age - 4) * (-1) + 2;
            },
            age: 2,
            height: height,
          });

          // create impact flames
          for (var i = 0; i < 13; i++) {
            new Sprite({
              from: this.pos.add2(Math.random() * Math.PI * 2, Math.random() * 1.75).add3(0, -hm),
              img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
              scaleFunction: function (age) {
                return (1 / (age + 0.25) + age - 4) * (-1) + this.r1;
              },
              age: 1 + Math.random() * 2,
              r1: Math.random(),
              height: height,
            });
          }

          // create impact zmoke
          for (var i = 0; i < 7; i++) {
            new Dust({ from: this.pos.add2(Math.random() * Math.PI * 2, Math.random() * 2).add3(0, -hm), scale: 1.5 + Math.random(), ageScale: 2 + Math.random(), height: height });
          }

          // create soot
          if (height < 1) {
            game.groundTilesCanvas.getContext('2d').globalAlpha = 0.5;
            game.groundTilesCanvas.getContext('2d').drawImage(miscSheet[0], imgs.soot.img.x, imgs.soot.img.y, imgs.soot.img.w, imgs.soot.img.h, this.pos.px * FIELD_SIZE / SCALE_FACTOR - imgs.soot.img.w / 2, (this.pos.py - hm) * FIELD_SIZE / SCALE_FACTOR - imgs.soot.img.h / 2, imgs.soot.img.w, imgs.soot.img.h);
            game.groundTilesCanvas.getContext('2d').globalAlpha = 1;

            // create flames
            for (var i = 0; i < 2; i++) {
              new Flame({ from: this.pos.add2(Math.random() * Math.PI * 2, Math.random() * 2).add3(0, -hm) });
            }
          }
        };


        GroundOrder.prototype = new Effect();
        function GroundOrder(data) {
          this.pos = data.from;
          this.time = timestamp;
          this.tickOfDeath = ticksCounter + 6;

          this.borderLeft = this.pos.px;
          this.borderRight = this.pos.px;
          this.borderTop = this.pos.py;
          this.borderBottom = this.pos.py;

          this.attach(data.attachToUnit);

          this.modId = data.modId;
        };

        GroundOrder.prototype.draw = function () {
          var age = timestamp - this.time; // effect age in sec
          var randomYOffsetPixels = (age * 0.05) % 4 - 2;

          c.strokeStyle = 'rgba(' + game.theme.line_red + ', ' + game.theme.line_green + ', ' + game.theme.line_blue + ', ' + (1 - age / 400) + ')';
          c.lineWidth = 2;

          // draw "ring"
          c.beginPath();
          c.ellipse(this.pos.px * FIELD_SIZE - game.cameraX, this.pos.py * FIELD_SIZE - game.cameraY + randomYOffsetPixels, Math.abs(age / 10), Math.abs(age / 10) * 0.8, 0, 2 * Math.PI, false);
          c.stroke();

          // draw point
          c.beginPath();
          c.ellipse(this.pos.px * FIELD_SIZE - game.cameraX, this.pos.py * FIELD_SIZE - game.cameraY + randomYOffsetPixels, 1, 0.8, 0, 2 * Math.PI, false);
          c.stroke();
        };


        PlasmaShield.prototype = new Effect();
        function PlasmaShield(data) {
          this.pos = data.from.type ? data.from.drawPos : data.from;
          this.radius = (data.from.type ? data.from.type.size : 1) * 0.85;
          this.to = data.to;
          this.time = timestamp;
          this.tickOfDeath = ticksCounter + 10;

          this.borderLeft = this.pos.px;
          this.borderRight = this.pos.px;
          this.borderTop = this.pos.py;
          this.borderBottom = this.pos.py;

          this.attach(data.attachToUnit);

          this.modId = data.modId;
        };

        PlasmaShield.prototype.draw = function () {
          var age = timestamp - this.time; // effect age in sec
          var randomYOffsetPixels = (age * 0.05) % 4 - 2;
          var angle = this.pos.getAngleTo(this.to);

          c.strokeStyle = 'rgba(' + game.theme.line_red + ', ' + game.theme.line_green + ', ' + game.theme.line_blue + ', ' + ((1 - age / 400) * 0.6) + ')';
          c.lineWidth = 1.5 * SCALE_FACTOR;

          c.beginPath();
          c.ellipse(this.pos.px * FIELD_SIZE - game.cameraX, (this.pos.py - 0.2) * FIELD_SIZE - game.cameraY + randomYOffsetPixels, this.radius * FIELD_SIZE, this.radius * FIELD_SIZE * 0.8, angle - 0.5, angle + 0.5, false);
          c.ellipse(this.pos.px * FIELD_SIZE - game.cameraX, (this.pos.py - 0.3) * FIELD_SIZE - game.cameraY + randomYOffsetPixels, this.radius * FIELD_SIZE, this.radius * FIELD_SIZE * 0.8, angle - 0.5, angle + 0.5, false);
          c.ellipse(this.pos.px * FIELD_SIZE - game.cameraX, (this.pos.py - 0.4) * FIELD_SIZE - game.cameraY + randomYOffsetPixels, this.radius * FIELD_SIZE, this.radius * FIELD_SIZE * 0.8, angle - 0.5, angle + 0.5, false);
          c.stroke();
        };


        FloatingText.prototype = new Effect();
        function FloatingText(data) {
          this.unit = data.from.type ? data.from : null;

          this.pos = this.unit ? this.unit.drawPos.add3(0, -u.type.size - u.type.height + 1.5 + (u.type.isBuilding ? 2 : 0)) : data.from;
          this.tickOfCreation = ticksCounter;
          this.tickOfDeath = ticksCounter + (data.duration ? data.duration : 40);
          this.size = (data.scale ? data.scale : 20) / 3;
          this.content = data.content;
          this.color = data.color ? data.color : 'white';

          this.borderLeft = this.pos.px - 2;
          this.borderRight = this.pos.px + 2;
          this.borderTop = this.pos.py + 2;
          this.borderBottom = this.pos.py - 1;

          this.attach(data.attachToUnit);

          this.modId = data.modId;
        };

        FloatingText.prototype.draw = function () {
          if (this.tickOfDeath <= ticksCounter) {
            return false;
          }

          var age = ticksCounter + percentageOfCurrentTickPassed - this.tickOfCreation;

          var alpha = (this.tickOfDeath - ticksCounter < 10) ? Math.max(c.globalAlpha = (this.tickOfDeath - (ticksCounter + percentageOfCurrentTickPassed)) / 10, 0) : 1;

          drawText(c, this.content, this.color, 'bold ' + (this.size * SCALE_FACTOR) + 'px LCDSolid', this.pos.px * FIELD_SIZE - game.cameraX, (this.pos.py - 0 - age / 40) * FIELD_SIZE - game.cameraY, 200, 'center', alpha);
        };


        Heal.prototype = new Effect();
        function Heal(data) {
          this.unit = data.from.type ? data.from : null;

          this.pos = this.unit ? this.unit.drawPos.add3(0, 0.3 - this.unit.type.height) : data.from;
          this.x = this.pos.px;
          this.y = this.pos.py;
          this.tickOfCreation = ticksCounter;
          this.size = data.scale ? data.scale : 1;
          this.duration = data.duration ? data.duration : ((data.originPos.distanceTo2(this.pos) / (data.speed ? data.speed : 7)) * 20);
          if (!data.duration && !data.speed) {
            this.duration = 0;
          }
          this.tickOfDeath = ticksCounter + this.duration + 24;
          this.borderLeft = this.pos.px;
          this.borderRight = this.pos.px;
          this.borderTop = this.pos.py;
          this.borderBottom = this.pos.py;

          this.attach(data.attachToUnit);

          this.modId = data.modId;

          this.imgs = [imgs.heal2.img, imgs.heal3.img, imgs.heal4.img];
        };

        Heal.prototype.draw = function () {
          if (this.tickOfCreation + this.duration > ticksCounter) {
            return;
          }

          if (this.unit) {
            this.pos = this.unit.drawPos.add3(0, 0.3 - this.unit.type.height);
          }

          var age = ((ticksCounter + percentageOfCurrentTickPassed) - (this.tickOfCreation + this.duration)) * 50;

          if (age < 1000) {
            for (var i = 0; i < tickDiff; i++) {
              new Sprite({
                from: this.pos.add2(Math.random() * Math.PI * 2, Math.random() * 0.4 * this.size).add3(0, 6.6),
                img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
                scaleFunction: function (age) {
                  return ((1 / ((age * 5) + 0.25) + (age * 5) - 4) * (-0.7) + 0.6) * this.var1 * 1.15;
                },
                age: 0.6 + Math.random() * 0.5,
                var1: this.size,
                zFunction: function (age) {
                  return -age * 1 - 0.5;
                },
                height: 6.5,
              });
            }
          }

          // draw circle
          c.globalAlpha = Math.max(1 - age / 1200, 0.01);
          drawCircle(this.x * FIELD_SIZE - game.cameraX, this.y * FIELD_SIZE - game.cameraY - 0.5, (age / 1400) * FIELD_SIZE * this.size, '#9DE9A4', false, false, 1.5);

          // draw circle 2
          var age2 = Math.max(0.01, age - 400);
          c.globalAlpha = Math.max(1 - age2 / 800, 0.01);
          drawCircle(this.x * FIELD_SIZE - game.cameraX, this.y * FIELD_SIZE - game.cameraY - 0.5, (age2 / 1200) * FIELD_SIZE * this.size, 'white', false, false, 1.5);

          c.globalAlpha = 1;
        };


        LaunchedRock.prototype = new Effect();
        function LaunchedRock(data) {
          var targetPos = data.to.type ? data.to.drawPos.getCopy() : data.to;

          this.speed = data.speed ? data.speed : 7;
          this.from = data.from.drawPos.getCopy().add3(0, 0.3);
          this.pos = data.from;
          this.to = data.to;
          this.dist = this.from.distanceTo2(targetPos);
          this.tickStart = ticksCounter;
          this.lifeTime = this.dist / this.speed / 50 * 1000;
          this.actualLifeTime = (this.dist - 0.05) / this.speed * 20;
          this.startHeight = data.from.type.height;
          this.endHeight = data.to.type ? data.to.type.height : 0;
          this.scale = data.scale ? data.scale : 1;

          // if were shooting a building, make the "hit" a little bit earlier (when the rock hit the wall of the building)
          if (data.to.type && data.to.type.isBuilding) {
            this.endHeight -= 1;

            var angle = this.from.getAngleTo(targetPos);
            var size = data.to.type.size / 2;

            var distMinimization = Math.min(
              Math.sqrt(
                Math.pow(Math.tan(angle) * size, 2) + Math.pow(size, 2),
              ),
              Math.sqrt(
                Math.pow((1 / Math.tan(angle)) * size, 2) + Math.pow(size, 2),
              ),
            );

            this.actualLifeTime = (this.dist - distMinimization) / this.speed * 20;
          }

          this.tickOfDeath = ticksCounter + this.actualLifeTime;

          this.borderLeft = Math.min(this.from.px, targetPos.px);
          this.borderRight = Math.max(this.from.px, targetPos.px);
          this.borderTop = Math.min(this.from.py, targetPos.py);
          this.borderBottom = Math.max(this.from.py, targetPos.py);

          this.attach(data.attachToUnit);

          this.modId = data.modId;

          this.imgs = [imgs.flyingRock1.img, imgs.flyingRock2.img, imgs.flyingRock3.img, imgs.flyingRock4.img, imgs.flyingRock5.img, imgs.flyingRock6.img, imgs.flyingRock7.img, imgs.flyingRock8.img];
        };

        LaunchedRock.prototype.draw = function (x1, x2, y1, y2, volume) {
          var targetPos = this.to.type ? this.to.drawPos.getCopy() : this.to;

          this.dist = this.from.distanceTo2(targetPos);

          var percentageDone = (ticksCounter + percentageOfCurrentTickPassed - this.tickStart) / (this.lifeTime + 1);
          this.pos = this.from.addNormalizedVector(targetPos, percentageDone * this.dist);

          var height = this.startHeight * (1 - percentageDone) + this.endHeight * percentageDone;

          var img = this.imgs[Math.floor(this.tickStart + ticksCounter / 2) % this.imgs.length];

          // calculate additional heigh
          var y = Math.pow((percentageDone * 16.5 - 6 - this.dist / 10) / (9.6 + Math.pow(0.11 * (this.dist - 9), 2) - (3 * this.dist) / 9), 2) - 0.7 - this.dist / 6;

          var drawPos = this.pos.add3(0, y);

          var scale = this.scale * SCALE_FACTOR;

          var drawX = drawPos.px * FIELD_SIZE - (img.w / 2) * scale - game.cameraX;
          var drawY = (drawPos.py - height) * FIELD_SIZE - (img.h / 2) * scale - game.cameraY;
          if (PLAYING_PLAYER.team.canSeeField(this.pos.x, this.pos.y)) {
            c.drawImage(miscSheet[0], img.x, img.y, img.w, img.h, drawX, drawY, img.w * scale, img.h * scale);
          }

          var flyVec = this.from.vectorTo(this.to).normalize(0.5);

          // randomly create particle images
          for (var i = 0; i < tickDiff; i++) {
            if (Math.random() > 0.5) {
              new Sprite({
                from: drawPos.add2(Math.random() * Math.PI * 2, 0.1),
                img: imgs.particle.img,
                scaleFunction: function (age) {
                  return ((this.r1 + 1.4) - age) * this.scale_;
                },
                age: 1.5 + Math.random() * 0.7,
                r1: Math.random(),
                rX: flyVec.px,
                rY: flyVec.py,
                zFunction: function (age) {
                  return Math.pow(age * 1.15, 2.5) * 0.5;
                },
                xFunction: function (age) {
                  return this.rX * Math.sqrt(age);
                },
                yFunction: function (age) {
                  return this.rY * Math.sqrt(age);
                },
                height: height,
                scale_: this.scale,
              });
            }
          }

          if (!this.isExpired()) {
            return;
          }

          // play sound
          if (PLAYING_PLAYER.team.canSeeField(this.pos.x, this.pos.y)) {
            soundManager.playSound(SOUND.CATA_IMPACT, game.getVolumeModifier(this.pos));
          }

          // create impact dust
          for (var i = 0; i < 5; i++) {
            new Dust({ from: this.pos.add2(Math.random() * Math.PI * 2, Math.random() * 0.6), scale: Math.random() * 1.5 + 0.5, height: height - y });
          }

          // create impact sprites / particles
          for (var i = 0; i < 12; i++) {
            new Sprite({
              from: this.pos.add2(Math.random() * Math.PI * 2, Math.random() * 0.3),
              img: imgs.particle.img,
              scaleFunction: function (age) {
                return 2 * this.scale_;
              },
              age: 0.5 + Math.random(),
              r1: Math.random() * 0.4,
              r2: -y,
              rX: Math.random() * 3.5 - 1.75,
              rY: Math.random() * 3.5 - 1.75,
              zFunction: function (age) {
                return Math.min(Math.pow(age * 1.6 - 0.8 + this.r1, 2) - 0.7 - this.r2, 0);
              },
              xFunction: function (age) {
                return this.rX * Math.sqrt(age);
              },
              yFunction: function (age) {
                return this.rY * Math.sqrt(age);
              },
              height: height,
              scale_: this.scale,
            });
          }
        };


        Mageattack.prototype = new Effect();
        function Mageattack(data) {
          var targetField = data.to.isField ? data.to : data.to.drawPos;

          this.from = data.from.drawPos.getCopy().add3(0, -0.1 - (data.from.type ? data.from.type.projectileStartHeight : 0));
          this.pos = data.from.drawPos.getCopy();
          this.to = data.to.isField ? data.to.getCopy() : data.to;
          this.dist = this.from.distanceTo2(targetField);
          this.tickStart = ticksCounter;
          this.lifeTime = this.dist / (data.speed ? data.speed : 10) / 50 * 1000;
          this.tickOfDeath = ticksCounter + this.lifeTime;
          this.startHeight = data.from.type.height;
          this.endHeight = this.to.type ? this.to.type.height : (game.getHMValue2(this.to.x, this.to.y) * CLIFF_HEIGHT + 0.3);
          this.scale = data.scale ? data.scale : 1;

          this.borderLeft = Math.min(this.from.px, targetField.px);
          this.borderRight = Math.max(this.from.px, targetField.px);
          this.borderTop = Math.min(this.from.py, targetField.py);
          this.borderBottom = Math.max(this.from.py, targetField.py);

          this.attach(data.attachToUnit);

          this.modId = data.modId;

          this.imgs = [imgs.mageAttack1.img, imgs.mageAttack2.img, imgs.mageAttack3.img, imgs.mageAttack4.img];
        };

        Mageattack.prototype.draw = function () {
          var targetField = this.to.isField ? this.to : this.to.drawPos.getCopy();

          this.dist = this.from.distanceTo2(targetField);

          var percentageDone = (ticksCounter + percentageOfCurrentTickPassed - this.tickStart) / (this.lifeTime + 1);
          this.pos = this.from.addNormalizedVector(targetField, percentageDone * this.dist);

          var height = this.startHeight * (1 - percentageDone) + this.endHeight * percentageDone;

          var scale = SCALE_FACTOR + SCALE_FACTOR * (Math.random() * 0.4 + 0.8) * 0.55;
          var drawX = (this.pos.px + Math.random() * 0.15 - 0.075) * FIELD_SIZE - (imgs.mageAttack4.img.w / 2) * scale - game.cameraX;
          var drawY = (this.pos.py - height + 0.3 + Math.random() * 0.15 - 0.075) * FIELD_SIZE - (imgs.mageAttack4.img.h / 2) * scale - game.cameraY;
          if (PLAYING_PLAYER.team.canSeeField(this.pos.x, this.pos.y)) {
            c.drawImage(miscSheet[0], imgs.mageAttack4.img.x, imgs.mageAttack4.img.y, imgs.mageAttack4.img.w, imgs.mageAttack4.img.h, drawX, drawY, imgs.mageAttack4.img.w * scale, imgs.mageAttack4.img.h * scale);
          }

          var flyVec = this.from.vectorTo(targetField).normalize(0.5);

          // randomly create magic stuff
          for (var i = 0; i < tickDiff; i++) {
            new Sprite({
              from: this.pos.add2(Math.random() * Math.PI * 2, 0.1),
              img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
              scaleFunction: function (age) {
                return 1 - age;
              },
              age: 0.7,
              varX: flyVec.px,
              varY: flyVec.py,
              zFunction: function (age) {
                return Math.pow(age * 1.5, 2) * 0.33 + 0.2;
              },
              xFunction: function (age) {
                return this.varX * Math.sqrt(age);
              },
              yFunction: function (age) {
                return this.varY * Math.sqrt(age);
              },
              height: height,
            });
          }

          if (!this.isExpired()) {
            return;
          }

          // impact
          new Sprite({
            from: targetField.add2(Math.random() * Math.PI * 2, Math.random() / 2).add3(0, 0.9),
            img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
            scaleFunction: function (age) {
              return (1 / (age + 0.25) + age - 4) * (-1);
            },
            age: 1,
            zFunction: function () {
              return -0.9;
            },
            height: height,
          });

          // create impact magic stuff
          for (var i = 0; i < 3; i++) {
            new Sprite({
              from: targetField.add2(Math.random() * Math.PI * 2, Math.random() * 0.3).add3(0, 0.9),
              img: this.imgs[Math.floor(Math.random() * this.imgs.length)],
              scaleFunction: function (age) {
                return (1 / (age + 0.25) + age - 4) * (-0.5);
              },
              age: 0.5 + Math.random() * 0.5,
              zFunction: function () {
                return -0.9;
              },
              height: height,
            });
          }
        };


        Shockwave.prototype = new Effect();
        function Shockwave(data) {
          this.pos = data.from;
          this.tickOfCreation = ticksCounter;
          this.duration = data.duration ? data.duration : ((data.originPos.distanceTo2(this.pos) / data.speed) * 20);
          this.durationInMS = this.duration * 50;
          this.tickOfDeath = ticksCounter + this.duration + 40;

          this.borderLeft = this.pos.px - 2;
          this.borderRight = this.pos.px + 2;
          this.borderTop = this.pos.py - 2;
          this.borderBottom = this.pos.py + 2;

          this.circleDuration = 900;
          this.circleOffsets = [0, 300, 600];

          this.attach(data.attachToUnit);

          this.modId = data.modId;
        };

        Shockwave.prototype.draw = function () {
          var age = ((ticksCounter + percentageOfCurrentTickPassed) - this.tickOfCreation) * 50;

          if (age < this.durationInMS) {
            for (var i = 0; i < tickDiff * 1; i++) {
              new Sprite({
                from: this.pos.add2(Math.random() * Math.PI * 2, Math.random() * 1.5),
                img: imgs.whitePixel.img,
                scaleFunction: function (age) {
                  return this.var1;
                },
                age: 3 + Math.random() * 1,
                var1: 1 + Math.random(),
                var2: Math.random() * 2 - 1,
                var3: Math.random() * 2 - 1,
                ageLeft: (this.durationInMS - age) / (this.durationInMS / 2),
                startHeight: Math.random() * 0.5 + 1.5,
                alphaFunction: function (age) {
                  return Math.min(0.7, age);
                },
                zFunction: function (age) {
                  return (age < this.ageLeft) ? Math.min(-this.startHeight + age * 1, 0) : ((-this.startHeight + this.ageLeft * 1) - (-1 / ((age - this.ageLeft) + 0.5) + 2 - (age - this.ageLeft) * 1.5));
                },
                xFunction: function (age) {
                  return (age < this.ageLeft) ? 0 : ((-1 / ((age - this.ageLeft) / 2 + 0.2) + 5) * this.var2);
                },
                yFunction: function (age) {
                  return (age < this.ageLeft) ? 0 : ((-1 / ((age - this.ageLeft) / 2 + 0.2) + 5) * this.var3);
                },
              });
            }

            for (var i = 0; i < tickDiff * 2; i++) {
              new Sprite({
                from: this.pos.add2(Math.random() * Math.PI * 2, Math.random() * 0.5),
                img: imgs.whitePixel.img,
                scaleFunction: function (age) {
                  return this.var1;
                },
                age: 3 + Math.random() * 1,
                var1: 1 + Math.random(),
                var2: Math.random() * 2 - 1,
                var3: Math.random() * 2 - 1,
                ageLeft: (this.durationInMS - age) / (this.durationInMS / 2),
                alphaFunction: function (age) {
                  return Math.min(0.7, age);
                },
                zFunction: function (age) {
                  return (age < this.ageLeft) ? 0 : -(-1 / ((age - this.ageLeft) + 0.5) + 2 - (age - this.ageLeft) * 1.5);
                },
                xFunction: function (age) {
                  return (age < this.ageLeft) ? ((this.ageLeft - age) * this.var2 * 3) : ((-1 / ((age - this.ageLeft) / 2 + 0.2) + 5) * this.var2);
                },
                yFunction: function (age) {
                  return (age < this.ageLeft) ? ((this.ageLeft - age) * this.var3 * 3) : ((-1 / ((age - this.ageLeft) / 2 + 0.2) + 5) * this.var3);
                },
              });
            }

            // circles
            for (var i = 0; i < this.circleOffsets.length; i++) {
              if (age > this.circleOffsets[i] && age < (this.durationInMS - ((this.durationInMS - this.circleOffsets[i]) % this.circleDuration))) {
                var state = (this.circleDuration - (age - this.circleOffsets[i]) % this.circleDuration) / this.circleDuration;

                c.globalAlpha = (1 - state) * 0.2;
                drawCircle(this.pos.px * FIELD_SIZE - game.cameraX, this.pos.py * FIELD_SIZE - game.cameraY - 0.5, state * FIELD_SIZE * 3, 'white', 'white');
              }
            }

            c.globalAlpha = 1;
          }

          if (age > this.durationInMS) {
            if (age < this.durationInMS * 1.4) {
              var state = (age - this.durationInMS) / (this.durationInMS * 0.4);
              c.globalAlpha = (1 - state) * 0.3;
              drawCircle(this.pos.px * FIELD_SIZE - game.cameraX, this.pos.py * FIELD_SIZE - game.cameraY - 0.5, state * FIELD_SIZE * 5, 'white', 'white');
              c.globalAlpha = 1;
            }
          }
        };


        Spell.prototype = new Effect();
        function Spell(data) {
          this.pos = data.from;
          this.x = this.pos.px;
          this.y = this.pos.py;
          this.tickOfCreation = ticksCounter;
          this.tickOfDeath = ticksCounter + 20;
          this.scale = data.scale ? data.scale : 1;
          this.density = data.density ? data.density : 1;

          soundManager.playSound(SOUND.SPELL, game.getVolumeModifier(this.pos));

          this.borderLeft = this.x;
          this.borderRight = this.x;
          this.borderTop = this.y;
          this.borderBottom = this.y;

          this.attach(data.attachToUnit);

          this.modId = data.modId;
        };

        Spell.prototype.draw = function () {
          var age = ((ticksCounter + percentageOfCurrentTickPassed) - this.tickOfCreation) * 50;

          for (var i = 0; i < tickDiff * this.density; i++) {
            if (Math.random() < 0.75) {
              new Sprite({
                from: new Field(this.x, this.y + 0.5, true).add2(Math.random() * Math.PI * 2, Math.random() * 0.4 * this.scale),
                img: imgs.heal1.img,
                scaleFunction: function (age) {
                  return ((1 / ((age * 5) + 0.25) + (age * 5) - 4) * (-0.6) + this.var1 * 0.4) * this.var2;
                },
                age: 0.6 + Math.random() * 0.5,
                var1: Math.random() + 0.5,
                var2: this.scale,
                zFunction: function (age) {
                  return -age * 1 - 0.5 * this.var2;
                },
              });
            }
          }
        };


        Sprite.prototype = new Effect();
        function Sprite(data) {
          _.extend(this, data);

          this.pos = data.from;
          this.basePos = this.pos.getCopy();

          this.tickOfBirth = ticksCounter;

          this.ticksToLive = this.age ? this.age * 20 : (Math.random() + 1) * 20;
          this.timeToLive = this.ticksToLive / 20;
          this.tickOfDeath = ticksCounter + this.ticksToLive;

          this.alphaFunction = this.alphaFunction ? this.alphaFunction : function () {
            return 1;
          };
          this.zFunction = this.zFunction ? this.zFunction : function (age) {
            return -age * 0.5;
          };

          this.height = this.height ? this.height : 0;

          this.borderLeft = this.pos.px;
          this.borderRight = this.pos.px;
          this.borderTop = this.pos.py;
          this.borderBottom = this.pos.py;

          this.attach(data.attachToUnit);

          this.modId = data.modId;
        };

        Sprite.prototype.draw = function () {
          var age = (ticksCounter + percentageOfCurrentTickPassed - this.tickOfBirth) / 20;

          alpha = age < this.timeToLive * 0.5 ? 1 : Math.max(1 - (age - this.timeToLive / 2) / (this.timeToLive / 2), 0);
          alpha *= this.alphaFunction(age);

          var scale = Math.max(this.scaleFunction(age) * SCALE_FACTOR, 0);

          var z = this.zFunction(age);

          var x = this.basePos.px;
          if (this.xFunction) {
            x += this.xFunction(age);
          }

          var y = this.basePos.py;
          if (this.yFunction) {
            y += this.yFunction(age) * 0.75;
          }

          this.pos = new Field(x, y, true);

          var drawX = this.pos.px * FIELD_SIZE - (this.img.w / 2) * scale - game.cameraX;
          var drawY = (this.pos.py + z - this.height) * FIELD_SIZE - (this.img.h / 2) * scale - game.cameraY;

          if (PLAYING_PLAYER.team.canSeeField(this.pos.x, this.pos.y)) {
            c.globalAlpha = alpha;
            c.drawImage(miscSheet[0], this.img.x, this.img.y, this.img.w, this.img.h, drawX, drawY, this.img.w * scale, this.img.h * scale);
            c.globalAlpha = 1;
          }
        };


        Aura.prototype = new Effect();
        function Aura(data) {
          this.unit = (data.from && data.from.type) ? data.from : null;
          this.pos = this.unit ? this.unit.drawPos : data.from;
          this.realPos = this.pos;
          this.tickOfCreation = ticksCounter;
          this.tickOfDeath = (data.duration ? data.duration + ticksCounter + 40 : 99999999);
          this.radius = data.scale ? data.scale : 3;
          this.countParticles = data.density ? data.density : 20;

          this.borderLeft = this.pos.px - this.radius;
          this.borderRight = this.pos.px + this.radius;
          this.borderTop = this.pos.py - this.radius;
          this.borderBottom = this.pos.py + this.radius;

          this.particles = [];

          this.attach(data.attachToUnit);

          this.modId = data.modId;

          this.drawPos = this.pos;
          this.pos = this.pos.add3(0, 2);

          const toRGBAString = (color, alpha) => `rgba(${color.red}, ${color.green}, ${color.blue}, ${alpha ?? color.alpha})`;
          const defaultAuraColor = list_modifiers_fields.auraColor.default_;

          this.circleColor = toRGBAString(data.auraColor ?? defaultAuraColor);
          this.particleColor1 = toRGBAString(data.auraColor ?? defaultAuraColor, 0);
          this.particleColor2 = toRGBAString(data.auraColor ?? defaultAuraColor, 0.7);
          this.mode = data.mode ? data.mode : 1;

          // create vision offset circle array
          this.visionOffsetArray = visionOffsets[Math.max(0, Math.min(visionOffsets.length - 1, parseInt(this.radius)))];
        };

        Aura.prototype.draw = function () {
          var age = ((ticksCounter + percentageOfCurrentTickPassed) - this.tickOfCreation) * 50;

          if (this.unit) {
            this.drawPos = this.unit.drawPos;
            this.pos = this.drawPos.add3(0, 2);
            this.realPos = this.unit.pos;

            this.borderLeft = this.pos.px - this.radius;
            this.borderRight = this.pos.px + this.radius;
            this.borderTop = this.pos.py - this.radius;
            this.borderBottom = this.pos.py + this.radius;
          }

          var canSeeThis = false;
          for (var i = 0; i < this.visionOffsetArray.length; i++) {
            if (PLAYING_PLAYER.team.canSeeField(this.realPos.x + this.visionOffsetArray[i][0], this.realPos.y + this.visionOffsetArray[i][1])) {
              canSeeThis = true;
              i = this.visionOffsetArray.length;
            }
          }

          if (!canSeeThis && !PLAYING_PLAYER.team.canSeeField(this.realPos.x, this.realPos.y)) {
            return;
          }

          // circle
          if (ticksCounter + 40 > this.tickOfDeath) {
            c.globalAlpha = Math.max((this.tickOfDeath - ticksCounter) / 40, 0);
          }

          drawCircle(this.drawPos.px * FIELD_SIZE - game.cameraX, this.drawPos.py * FIELD_SIZE - game.cameraY, this.radius * FIELD_SIZE, null, this.circleColor, 0.85);

          drawCircle(this.drawPos.px * FIELD_SIZE - game.cameraX, this.drawPos.py * FIELD_SIZE - game.cameraY, this.radius * FIELD_SIZE, 'rgba(200, 200, 255, 0.2)', null, 0.85, 1);

          c.globalAlpha = 1;

          while (this.particles.length < this.countParticles && ticksCounter + 40 < this.tickOfDeath) {
            this.particles.push({
              pos: this.drawPos.add(new Field(0, 0, true).add2(Math.random() * Math.PI * 2, this.mode == 1 ? (Math.random() * this.radius) : (this.radius + 1)).mul(1, this.mode == 1 ? 0.6 : 0.85)),
              tickOfCreation: ticksCounter + percentageOfCurrentTickPassed,
              tickOfDeath: ticksCounter + percentageOfCurrentTickPassed + Math.random() * 40 + 20,
              speed: (Math.random() * 0.5 + 0.35) / 1000,
            });
          }

          c.lineWidth = FIELD_SIZE / 16;

          if (this.mode == 1) {
            for (var i = 0; i < this.particles.length; i++) {
              var particle = this.particles[i];

              if (particle.tickOfDeath <= ticksCounter + percentageOfCurrentTickPassed) {
                this.particles.splice(i, 1);
                i--;
              } else if (PLAYING_PLAYER.team.canSeeField(particle.pos.x, particle.pos.y)) {
                var age2 = (ticksCounter + percentageOfCurrentTickPassed - particle.tickOfCreation) * 50;

                var drawX = 0;
                var drawY = 0;
                var drawX2 = 0;

                var drawY1 = 0;
                var drawY2 = 0;

                if (this.mode == 1) {
                  drawX = particle.pos.px * FIELD_SIZE - game.cameraX;
                  drawX2 = drawX;
                  drawY = (particle.pos.py - 1) * FIELD_SIZE - game.cameraY;

                  drawY1 = drawY - particle.speed * age2 * FIELD_SIZE;
                  drawY2 = drawY - (particle.speed * age2 * 1.5 - 2.4) * FIELD_SIZE;
                } else if (this.mode == 2) {
                  var speed = (age2 / 1000) * (particle.pos.distanceTo2(this.drawPos) - 1) / ((particle.tickOfDeath - particle.tickOfCreation) / 20);

                  var f1 = particle.pos.addNormalizedVector(this.drawPos, speed);
                  var f2 = particle.pos.addNormalizedVector(this.drawPos, speed + 1);


                  drawX = f1.px * FIELD_SIZE - game.cameraX;
                  drawY1 = f1.py * FIELD_SIZE - game.cameraY;

                  drawX2 = f2.px * FIELD_SIZE - game.cameraX;
                  drawY2 = f2.py * FIELD_SIZE - game.cameraY;
                }

                if (age2 < 500) {
                  c.globalAlpha = age2 / 500;
                }

                if (particle.tickOfDeath - ticksCounter < 10) {
                  c.globalAlpha = (particle.tickOfDeath - ticksCounter) / 10;
                }

                var grad = c.createLinearGradient(drawX2, drawY2, drawX, drawY1);
                grad.addColorStop(0, this.particleColor1);
                grad.addColorStop(0.5, this.particleColor2);
                grad.addColorStop(1, this.particleColor1);
                c.strokeStyle = grad;

                c.beginPath();
                c.moveTo(drawX, drawY1);
                c.lineTo(drawX2, drawY2);
                c.stroke();

                c.globalAlpha = 1;
              }
            }
          } else if (this.mode == 2) {
            var gABase = 1;
            if (ticksCounter + 40 > this.tickOfDeath) {
              gABase = Math.max((this.tickOfDeath - ticksCounter) / 40, 0);
            }

            for (var i = this.radius - ((ticksCounter + percentageOfCurrentTickPassed) / 30) % 1; i > 0; i -= 1) {
              c.globalAlpha = (i > this.radius - 1) ? ((this.radius - i) * 1 * gABase) : gABase;

              drawCircle(this.drawPos.px * FIELD_SIZE - game.cameraX, (this.drawPos.py - Math.pow(this.radius - i, 0.5) * 0.7) * FIELD_SIZE - game.cameraY, i * FIELD_SIZE, null, this.circleColor, 0.85);
            }

            c.globalAlpha = 1;
          }
        };

        Sound.prototype = new Effect();
        function Sound(data) {
          this.unit = (data.from && data.from.type) ? data.from : null;
          this.pos = this.unit ? this.unit.drawPos : data.from;
          this.tickOfCreation = ticksCounter;
          this.tickOfDeath = (data.duration ? data.duration + ticksCounter + 40 : 99999999);
          this.timeOFLastSound = -99999;
          this.soundDuration = data.soundDuration;
          this.sound = data.sound;
          this.volume = data.volume;

          this.borderLeft = this.pos.px - 5;
          this.borderRight = this.pos.px + 5;
          this.borderTop = this.pos.py - 5;
          this.borderBottom = this.pos.py + 5;

          this.attach(data.attachToUnit);

          this.modId = data.modId;
        };

        Sound.prototype.draw = function () {
          if (this.timeOFLastSound + this.soundDuration <= timestamp && ticksCounter + 40 < this.tickOfDeath) {
            this.timeOFLastSound = timestamp;
            soundManager.playSound(this.sound, this.unit ? game.getVolumeModifier(this.unit.drawPos) * this.volume : game.getVolumeModifier(this.pos) * this.volume);
          }
        };


        function startEffect(typeName, data) {
          if (typeName == 'arrow') {
            return new Arrow(data);
          }

          if (typeName == 'ballista') {
            return new CustomProjectile(data);
          }

          if (typeName == 'dragonAttack') {
            return new DragonAttack(data);
          }

          if (typeName == 'flame') {
            return new Flame(data);
          }

          if (typeName == 'flamestrike') {
            return new Flamestrike(data);
          }

          if (typeName == 'floatingText') {
            return new FloatingText(data);
          }

          if (typeName == 'heal') {
            return new Heal(data);
          }

          if (typeName == 'launchedRock') {
            return new LaunchedRock(data);
          }

          if (typeName == 'mageAttack') {
            return new Mageattack(data);
          }

          if (typeName == 'shockwave') {
            return new Shockwave(data);
          }

          if (typeName == 'spell') {
            return new Spell(data);
          }

          if (typeName == 'sprite') {
            return new Sprite(data);
          }

          if (typeName == 'aura') {
            return new Aura(data);
          }

          if (typeName == 'sound') {
            return new Sound(data);
          }
        }

        // Error tracking sentry https://sentry.io/
        // Only run when the value sentry_dsn has been set in environment-config.json
        if ('@@sentry_dsn' != '@' + '@sentry_dsn') {
          const Sentry = require('@sentry/browser');
          const { Integrations } = require('@sentry/tracing');
          Sentry.init({
            dsn: '@@sentry_dsn',
            integrations: [new Integrations.BrowserTracing()],

            // Set tracesSampleRate to 1.0 to capture 100%
            // of transactions for performance monitoring.
            // We recommend adjusting this value in production
            tracesSampleRate: 0.25,
          });
        }

        // set size and resize
        resize();
        window.onresize = resize;

        // Fill screen black
        c.fillStyle = 'black';
        c.fillRect(0, 0, WIDTH, HEIGHT);

        // check for ie and dont run game if ie
        if (window.navigator.userAgent.indexOf('MSIE ') > 0 || window.navigator.userAgent.indexOf('Trident/') > 0) {
          alert('Internet Explorer is currently not supported for Littlewargame. Please use a different browser.');
          throw 'IE used';
        }

        // custom jquery ui tooltip styling
        $(document).tooltip({
          show: { effect: 'fade', duration: 200 },
          hide: { effect: 'fade', duration: 100 },
          track: false,
        });

        // version
        const version = '5.0.0';

        // Ladder Season
        let ladderSeasonId;

        // Webworker
        var worker = new Worker(`Worker-${version}.js`);
        console.log('Version: ' + version);

        worker.onerror = function (e) {
          var e_msg = e.message + ' @' + e.filename + ':' + e.lineno + ':' + e.colno;
          // var e_stack_trace = e.stack;

          displayInfoMsg(new HTMLBuilder()
            .add(`Critical error: ${e_msg}`)
            // .add(`<brError stack trace: ${e_stack_trace}`)
            .add('<br /><br /><br /><span style=\'font-size: 24px;\'>Please reload your page.</span>'));
        };

        // TODO: clean this up into a separate module entirely
        const WorkerClient = (() => {
          let id = 0;
          const pendingMessages = {};

          async function call(name, payload) {
            worker.postMessage({
              what: 'workerRPC',
              id: ++id,
              name: name,
              payload: payload,
            });

            return new Promise((resolve, reject) => {
              pendingMessages[id] = { resolve, reject };
            });
          }

          function onResponse(data) {
            const { resolve, reject } = pendingMessages[data.id];
            const payload = data.payload;
            if ('error' in payload) {
              reject(payload.error);
            } else {
              resolve(payload.result);
            }
            delete pendingMessages[data.id];
          }

          return { call, onResponse };
        })();

        worker.addEventListener('message', function (e) {
          if (e.data.startsWith('workerRPC')) {
            const rest = e.data.slice('workerRPC'.length);
            WorkerClient.onResponse(JSON.parse(rest));
          }

          var msgs = e.data.split('~');

          for (var l = 0; l < msgs.length; l++) {
            var msg = msgs[l].split('$');

            if (msg[0] == 'uUpd') {
              var u = game.getUnitById(msg[1]);
              if (u) {
                u.lastTicksPosition = u.pos;
                u.pos = new Field(parseFloat(msg[2]), parseFloat(msg[3]), true);
              }
            } else if (msg[0] == 'uUpdFld') {
              var u = game.getUnitById(msg[1]);
              if (u) {
                u[msg[2]] = msg[2] == 'forcedAnimation' ? msg[3] : parseFloat(msg[3]);
              }
            } else if (msg[0] == 'update') {
              if (ticksCounter == 2) {
                game.automine();
              }

              timeOfLastUpdate = parseInt(msg[1]);

              // send orders
              if (network_game) {
                // send ping
                if (ticksCounter % 28 == 5) {
                  network.send('ping');
                  timeOfLastPingSent = Date.now();
                }

                // if delay needs to be lowered
                if (game.reduceDelayOnNextTick && TICKS_DELAY > MIN_DELAY) {
                  game.reduceDelayOnNextTick = false;
                  TICKS_DELAY--;
                } else {
                  // send newest orders to the server
                  var tickToSend = ticksCounter + TICKS_DELAY - 1;
                  var obj = {
                    tick: ticksCounter + TICKS_DELAY - 1,
                    orders: outgoingOrders,
                    cameraUpdate: outgoingCameraUpdate,
                  };
                  outgoingOrders = []; // empty outgoing orders storage
                  outgoingCameraUpdate = {};

                  if (tickToSend % 20 == 0) {
                    obj.cs = game.getGameStateCheckSum();
                  }

                  network.send(JSON.stringify(obj));

                  lastSentTick = tickToSend;
                }

                // if delay has to be highered, send additional orders msg
                if (game.increaseDelayOnNextTick && TICKS_DELAY < MAX_DELAY) {
                  network.send(JSON.stringify({ tick: ticksCounter + TICKS_DELAY, orders: [] }));
                  TICKS_DELAY++;
                  game.increaseDelayOnNextTick = false;
                }
              } else {
                // save the player's camera update
                if (Object.keys(outgoingCameraUpdate).length > 0) {
                  incomingCameraUpdates[ticksCounter] = {
                    [PLAYING_PLAYER.number]: outgoingCameraUpdate,
                  };
                }
              }

              // update unit offset y
              for (var i = 0; i < game.objectsToDraw.length; i++) {
                if (game.objectsToDraw[i].type && game.objectsToDraw[i].type.isUnit) {
                  game.objectsToDraw[i].setYDrawingOffset();
                }
              }

              // sort drawable units
              // Sort drawable units from least yDrawingOffset to greatest
              game.objectsToDraw.sort((a, b) => a.getYDrawingOffset() - b.getYDrawingOffset());

              var newTC = parseInt(msg[2]);
              if (!(ticksCounter == 0 && newTC > 1)) {
                ticksCounter = parseInt(msg[2]);
              }


              if (game.chat[ticksCounter]) {
                for (var j = 0; j < game.chat[ticksCounter].length; j++) {
                  if (!game.chat_muted) {
                    interface_.chatMsg(game.chat[ticksCounter][j]);
                  }
                  game.addChatMsgToLog(game.chat[ticksCounter][j]);
                }
              }

              for (var j = 1; j < game.players.length; j++) {
                if (game.players[j]) {
                  var p = game.players[j];

                  p.minedGoldAtTicks.splice(0, 0, 0);

                  if (p.minedGoldAtTicks.length > 200) {
                    p.currentMinedGold -= p.minedGoldAtTicks.pop();
                  }
                }
              }
            } else if (msg[0] == 'changeFog') {
              for (var k = 1; (k + 2) < msg.length; k += 3) {
                game.minimap.setFog(msg[k], msg[k + 1], msg[k + 2]);
                PLAYING_PLAYER.team.mask[msg[k]][msg[k + 1]] = msg[k + 2];
              }
            } else if (msg[0] == 'workload') {
              var workloads = JSON.parse(msg[1]);

              for (var i = 0; i < game.buildings.length; i++) {
                if (game.buildings[i].gold) {
                  var b = game.buildings[i];

                  if (b.id in workloads) {
                    b.countWorkingWorkers = workloads[b.id];

                    var usedMining = 0;
                    var unusedMining = 0;

                    for (var k = 0; k < b.type.maxWorkers; k++) {
                      if (b.countWorkingWorkers > k) {
                        usedMining += Math.max(Math.pow(b.type.miningEfficiencyCoefficient, k), b.type.minMiningRate);
                      } else {
                        unusedMining += Math.max(Math.pow(b.type.miningEfficiencyCoefficient, k), b.type.minMiningRate);
                      }
                    }

                    b.workload.push(unusedMining <= 0 ? 1 : (usedMining / (usedMining + unusedMining)));

                    b.lastCountWorkingWorkers = b.countWorkingWorkers;
                  } else {
                    b.countWorkingWorkers = b.lastCountWorkingWorkers;
                    b.workload.push(b.workload[b.workload.length - 1]);
                  }

                  b.workload_total += b.workload[b.workload.length - 1];

                  if (b.workload.length > 400) {
                    b.workload_total -= b.workload[0];
                    b.workload.splice(0, 1);
                  }
                }
              }
            } else if (msg[0] == 'creaU') {
              new Unit({ x: parseFloat(msg[2]), y: parseFloat(msg[3]), type: msg[1].toUnitType(), owner: game.players[msg[4]] });
            } else if (msg[0] == 'creaB') {
              new Building({ x: parseInt(msg[2]), y: parseInt(msg[3]), type: msg[1].toUnitType(), owner: game.players[msg[4]], dontRefreshNBs: true, buildFirst: parseInt(msg[5]) });
            } else if (msg[0] == 'cclB') {
              var b = game.getUnitById(msg[1]);
              if (b && b.owner) {
                b.owner.killProduction(b.type, b);
              }
            } else if (msg[0] == 'strtThr') {
              var u = game.getUnitById(msg[1]);
              var to = new Field(parseFloat(msg[2]), parseFloat(msg[3]), true);

              if (u) {
                u.lastTicksPosition = to.getCopy();
                u.isThrowedUntil = parseInt(msg[4]);
                u.throwStart = ticksCounter;
                u.throwFrom = u.pos.getCopy();
                u.throwTo = to;
                game.selectedUnits.erease(u);

                if (game.selectedUnits.length == 0) {
                  keyManager.resetCommand();
                }
              }
            } else if (msg[0] == 'addMsg') {
              interface_.addMessage(msg[1], msg[2], (msg[3] && imgs[msg[3]]) ? imgs[msg[3]] : null);
            } else if (msg[0] == 'uUpdArr') {
              var u = game.getUnitById(msg[1]);
              if (u && u[msg[2]]) {
                u[msg[2]][msg[3]] = parseFloat(msg[4]);
              }
            } else if (msg[0] == 'setUPos') {
              var u = game.getUnitById(msg[1]);
              if (u) {
                u[msg[2]] = msg[3] != -1 ? new Field(parseFloat(msg[3]), parseFloat(msg[4]), true) : null;
              }
            } else if (msg[0] == 'uUpdU') {
              var u = game.getUnitById(msg[1]);
              if (u) {
                u[msg[2]] = msg[3] != -1 ? game.getUnitById(msg[3]) : null;
              }
            } else if (msg[0] == 'uUpdOdr') {
              var u = game.getUnitById(msg[1]);

              if (u) {
                u[msg[2]] = lists.types[msg[3]];
              }
            } else if (msg[0] == 'updUPath') {
              var u = game.getUnitById(msg[1]);
              if (u) {
                u.path = msg[2] == -1 ? null : new Field(parseFloat(msg[2]), parseFloat(msg[3]), true);
              }
            } else if (msg[0] == 'pushOdrQ') {
              var u = game.getUnitById(msg[1]);
              if (u) {
                u.queueOrder.push(game.commands[msg[2]]);

                if (msg[3] != -1) {
                  u.queueTarget.push(new Field(parseFloat(msg[3]), parseFloat(msg[4]), true));
                } else if (msg[5] != -1) {
                  u.queueTarget.push(game.getUnitById(msg[5]));
                } else {
                  u.queueTarget.push(null);
                }
              }
            } else if (msg[0] == 'killOdrQ') {
              var u = game.getUnitById(msg[1]);
              if (u) {
                u.queueOrder = [];
                u.queueTarget = [];
              }
            } else if (msg[0] == 'aplMods') {
              var u = game.getUnitById(msg[1]);
              var u2 = game.getUnitById(msg[2]);

              if (u && u2) {
                for (var k = 3; k < msg.length; k++) {
                  u.applyModifier(lists.types[msg[k]], u2);
                }
              }
            } else if (msg[0] == 'setModTm') {
              var u = game.getUnitById(msg[1]);

              if (u && u.modifiers[msg[2]]) {
                u.modifiers[msg[2]].removeAt = parseInt(msg[3]);
              }
            } else if (msg[0] == 'rmvMod') {
              var u = game.getUnitById(msg[1]);

              if (u) {
                u.removeModifier(msg[2]);
              }
            } else if (msg[0] == 'killCrg') {
              var u = game.getUnitById(msg[1]);
              var target = game.getUnitById(msg[2]);

              if (u && target) {
                u.cargo.erease(target);
                target.isActive = true;
                game.units.push(target);
                target.pos = new Field(msg[3], msg[4], true);
                target.lastTicksPosition = target.pos;
                game.addToObjectsToDraw(target);
              }
            } else if (msg[0] == 'addCrg') {
              var u = game.getUnitById(msg[1]);
              var target = game.getUnitById(msg[2]);

              if (u && target) {
                u.cargo.push(target);
                game.objectsToDraw.erease(target);
              }
            } else if (msg[0] == 'killQEl') {
              var u = game.getUnitById(msg[1]);
              if (u) {
                u.queueOrder.splice(msg[2], 1);
                u.queueTarget.splice(msg[2], 1);
              }
            } else if (msg[0] == 'pushQEl') {
              var u = game.getUnitById(msg[1]);
              if (u) {
                u.queueOrder.splice(0, 0, u.order);
                u.queueTarget.splice(0, 0, u.target);
              }
            } else if (msg[0] == 'bldQPsh') {
              var u = game.getUnitById(msg[1]);
              var target = game.getUnitById(msg[2]);

              if (u && target) {
                u.targetsQueue.push(target);
              }
            } else if (msg[0] == 'bldQKill') {
              var u = game.getUnitById(msg[1]);
              if (u) {
                u.targetsQueue = [];
              }
            } else if (msg[0] == 'qUFnsh') {
              const u = game.getUnitById(msg[1]);
              if (u) {
                u.popQueueFront();
              }
            } else if (msg[0] == 'addEl2Q') {
              var u = game.getUnitById(msg[1]);
              var type = lists.types[msg[2]];

              if (u && u.queue && type) {
                if (msg[3] == 0) {
                  u.queueFinish = type.getValue('buildTime', u.owner, true) + ticksCounter;
                  u.currentBuildTime = u.queueFinish - ticksCounter;
                  // u.owner.startProduction(type, u.queueFinish);
                  u.queueStarted = false;
                }

                u.queue[msg[3]] = type;
              }
            } else if (msg[0] == 'qStart') {
              var u = game.getUnitById(msg[1]);

              if (u && u.queue && u.queue[0]) {
                u.queueFinish = ticksCounter + u.currentBuildTime;
                u.owner.startProduction(u.queue[0], u.queueFinish);
                u.queueStarted = true;
              }
            } else if (msg[0] == 'killQEl2') {
              var u = game.getUnitById(msg[1]);

              if (u && u.queue) {
                let i = parseInt(msg[2]);
                if (i == 0) {
                  u.popQueueFront();
                  continue;
                }

                u.queue[i] = null;
                while (u.queue[i + 1]) {
                  u.queue[i] = u.queue[i + 1];
                  u.queue[i + 1] = null;
                  ++i;
                }
              }
            } else if (msg[0] == 'splTrgQ') {
              var u = game.getUnitById(msg[1]);
              if (u && u.targetsQueue) {
                u.targetsQueue.splice(msg[2], 1);
              }
            } else if (msg[0] == 'setUpg') {
              var player = game.players[msg[1]];

              if (player) {
                player.upgrades = JSON.parse(msg[2]);
                player.upgradeMods = JSON.parse(msg[3]);
              }
            } else if (msg[0] == 'setWP') {
              var u = game.getUnitById(msg[1]);
              if (u) {
                var arr = [];
                for (var i = 2; i < msg.length - 2; i += 3) {
                  arr.push(msg[i] != -1 ? new Field(parseFloat(msg[i]), parseFloat(msg[i + 1]), true) : game.getUnitById(msg[i + 2]));
                }

                u.waypoint = arr;
              }
            } else if (msg[0] == 'units2kill') {
              var u = game.getUnitById(msg[1]);
              var u2 = game.getUnitById(msg[2]);

              if (u) {
                if (u.type.isUnit) {
                  delete game.unitList[u.id];
                }
                u.isAlive = false;

                u.remove();

                if (u.type.isBuilding) {
                  if (u.isUnderConstruction) {
                    u.owner.killProduction(u.type, u);
                  }

                  if (u.queue && u.queue[0]) {
                    u.owner.killProduction(u.queue[0], u.queueFinish);
                  }
                }

                // remove the unit from ctrol groups
                for (var k = 0; k < keyManager.controlGroups.length; k++) {
                  keyManager.controlGroups[k].erease(u);
                }

                if (u2 && (u2.type.causesFlameDeath || msg[4] == 1) && u.type.isUnit && !u.type.flying) {
                  u.flameDeath = true;
                }

                if (u.type.isBuilding && PLAYING_PLAYER.team.canSeeUnit(u, true) && msg[3] == 0) {
                  createExplosion(u.drawPos.px, u.drawPos.py, u.type.size);

                  if (u.type.deathSound) {
                    soundManager.playSound(u.type.deathSound, game.getVolumeModifier(u.pos));
                  }
                } else if (u.type.isUnit && PLAYING_PLAYER.team.canSeeUnit(u, true) && msg[3] == 0) {
                  soundManager.playSound(u.type.deathSound, game.getVolumeModifier(u.pos));
                  u.bodyPower = (u2 && u2.type.bodyPower) ? (u2.type.bodyPower / (u.type.bodyPower ? u.type.bodyPower : 1)) : u.bodyPower;
                  game.addToObjectsToDraw(u);
                  u.tickOfDeath = ticksCounter;

                  if (u2) {
                    var pos2 = u.pos.addNormalizedVector(u2.pos, -((u2.type.bodyPower ? u2.type.bodyPower : 1) / (u.type.bodyPower ? u.type.bodyPower : 1)) * (Math.random() * 0.6 + 0.75));
                    var pos = u.pos;

                    // find farest pos to throw to
                    while (u.type.couldStandAt(pos) && pos.distanceTo2(pos2) > 0.3) {
                      pos = pos.addNormalizedVector(pos2, 0.5);
                    }

                    pos = pos.addNormalizedVector(u.pos, 0.5);

                    u.throwTo = pos;
                    u.throwFrom = u.pos.getCopy();
                    u.isThrowedUntil = ticksCounter + Math.max(Math.floor(u.pos.distanceTo2(pos) * 6), 1) + 5;
                    u.throwStart = ticksCounter;
                  } else {
                    u.throwTo = u.pos.getCopy();
                    u.throwFrom = u.pos.getCopy();
                    u.isThrowedUntil = ticksCounter + 1;
                    u.throwStart = ticksCounter;
                  }
                } else if (u.type.isUnit && !PLAYING_PLAYER.team.canSeeUnit(u, true)) {
                  game.objectsToDraw.erease(u);
                }

                if (u2 && u2.owner.isEnemyOfPlayer(u.owner)) {
                  if (u.type.isUnit) {
                    u2.kills++;
                    u2.owner.unitKills++;
                    u.owner.unitDeaths++;
                  } else if (u.type.isBuilding) {
                    u2.kills++;
                    u2.owner.buildingKills++;
                    u.owner.buildingDeaths++;
                  }
                }

                u.owner.unitDies(u);
              }
            } else if (msg[0] == 'killBld') {
              for (var k = 0; k < game.buildings2.length; k++) {
                if (game.buildings2[k].id == msg[1]) {
                  delete game.unitList[msg[1]];
                  game.objectsToDraw.erease(game.buildings2[k]);
                  game.buildings2.splice(k, 1);
                  k = game.buildings2.length;
                }
              }
            } else if (msg[0] == 'rmvU') {
              var u = game.getUnitById(msg[1]);
              if (u) {
                u.remove();
              }
            } else if (msg[0] == 'bldDstEff') {
              var u = game.getUnitById(msg[1]);

              if (u) {
                var drawPos = u.drawPos;

                for (var k = 0; k < 12; k++) {
                  new Dust({ from: drawPos.add2(Math.random() * Math.PI * 2, u.type.size / 1.5) });
                }

                for (var k = 0; k < 15; k++) {
                  new Sprite({
                    from: drawPos.add2(Math.random() * Math.PI * 2, Math.random()),
                    img: imgs.particle.img,
                    scaleFunction: k < 10 ? function () {
                      return 4;
                    } : function () {
                      return 5;
                    },
                    age: 1 + Math.random(),
                    r1: Math.random() * 0.4,
                    r2: Math.random() * 5 - 3,
                    r3: Math.random() * 5 - 3,
                    zFunction: function (age) {
                      return Math.min(Math.pow(age * 1.6 - 1.5 + this.r1, 2) - 2.2, 0);
                    },
                    xFunction: function (age) {
                      return Math.sqrt(age) * this.r2;
                    },
                    yFunction: function (age) {
                      return Math.sqrt(age) * this.r3;
                    },
                  });
                }
              }
            } else if (msg[0] == 'swpBldType') {
              var u = game.getUnitById(msg[1]);
              var type = msg[2];

              if (u && type) {
                u.type = type.toUnitType();
                u.autocast = u.initAutocast();;
              }
            } else if (msg[0] == 'modPlVal') {
              var p = game.players[msg[1]];

              if (p) {
                if (msg[2] == 'minedGold') {
                  p.minedGoldAtTicks[0] += parseInt(msg[3]) - p.minedGold;
                  p.currentMinedGold += parseInt(msg[3]) - p.minedGold;
                }

                p[msg[2]] = parseInt(msg[3]);
              }
            } else if (msg[0] == 'setHitOffs') {
              var u1 = game.getUnitById(msg[1]);
              var u2 = game.getUnitById(msg[2]);

              if (u1 && u2) {
                u1.hitOffsetTill = timestamp + 200;
                u1.hitOffsetPos = u2.pos.getCopy();
              }
            } else if (msg[0] == 'playSnd') {
              soundManager.playSound(msg[1], (msg[3] && msg[4]) ? game.getVolumeModifier(new Field(msg[3], msg[4], true)) * msg[2] : msg[2]);
            } else if (msg[0] == 'playYesSnd') {
              var u = game.getUnitById(msg[1]);
              if (u) {
                soundManager.playSound(u.type.yesSound, game.getVolumeModifier(u.drawPos) * u.type.yesSoundVolume);
              }
            } else if (msg[0] == 'attPing') {
              game.minimap.attackPingAt(new Field(msg[1], msg[2], true));
            } else if (msg[0] == 'killPsdBld') {
              for (var k = 0; k < game.objectsToDraw.length; k++) {
                if (game.objectsToDraw[k].pseudoBuildingId == msg[1]) {
                  game.objectsToDraw.splice(k, 1);
                  k = game.objectsToDraw.length;
                }
              }
            } else if (msg[0] == 'crtPsdBld') {
              new Building({ x: msg[2], y: msg[3], type: msg[5].toUnitType(), owner: game.players[msg[4]], buildFirst: false, isDummy: true, pseudoBuildingId: msg[1] });
            } else if (msg[0] == 'beamUnit') {
              var u = game.getUnitById(msg[1]);
              if (u) {
                u.pos = new Field(parseFloat(msg[2]), parseFloat(msg[3]), true);
                u.lastTicksPosition = u.pos;
              }
            } else if (msg[0] == 'massSmk') {
              var b = game.getUnitById(msg[1]);
              if (b) {
                b.massSmoke();
              }
            } else if (msg[0] == 'attEff' && msg[1] == 'spell') {
              var u = game.getUnitById(msg[2]);

              if (u) {
                new Spell({ from: u.drawPos, scale: msg[6], density: msg[8] });
              }
            } else if (msg[0] == 'attEff' && msg[1] == 'heal') {
              var u1 = game.getUnitById(msg[2]);
              var u2 = msg[3] != -1 ? game.getUnitById(msg[3]) : new Field(parseFloat(msg[4]), parseFloat(msg[5]), true);

              if (u1 && u2) {
                new Heal({ from: u2.drawPos ? u2.drawPos : u2, scale: u2.type ? u2.type.size : 2, duration: parseFloat(msg[9]), speed: parseFloat(msg[7]), originPos: u1.drawPos });
              }
            } else if (msg[0] == 'attEff' && msg[1] == 'mageAttack') {
              var u1 = game.getUnitById(msg[2]);
              var u2 = msg[3] != -1 ? game.getUnitById(msg[3]) : new Field(msg[4], msg[5], true);

              if (u1 && u2) {
                new Mageattack({ from: u1, to: u2, speed: msg[7], modId: msg[13] });
              }
            } else if (msg[0] == 'attEff' && msg[1] == 'flamestrike') {
              var u = game.getUnitById(msg[2]);
              var u2 = msg[3] != -1 ? game.getUnitById(msg[3]) : new Field(msg[4], msg[5], true);

              if (u && u2) {
                new Flamestrike({ from: u, to: u2, speed: msg[7], noFinalBlow: msg[12] == 1, scale: msg[6], modId: msg[13] });
              }
            } else if (msg[0] == 'attEff' && msg[1] == 'shockwave') {
              var targetPos = new Field(parseFloat(msg[4]), parseFloat(msg[5]), true);
              var originPos = new Field(parseFloat(msg[10]), parseFloat(msg[11]), true);
              new Shockwave({ from: targetPos.add3(0, -game.getHMValue3(targetPos)), duration: parseFloat(msg[9]), speed: parseFloat(msg[7]), originPos: originPos });
            } else if (msg[0] == 'attEff' && msg[1] == 'launchedRock') {
              var u1 = game.getUnitById(msg[2]);
              var target = msg[3] != -1 ? game.getUnitById(msg[3]) : new Field(msg[4], msg[5], true);

              if (target && target.isField) {
                target = new Field(target.px, target.py - game.getHMValue2(target.x, target.y) * CLIFF_HEIGHT, true);
              }

              if (u1 && target) {
                new LaunchedRock({ from: u1, to: target, scale: parseFloat(msg[6]), speed: msg[7], modId: msg[13] });
              }

              // create some random dust effects
              if (u1) {
                for (var k = 0; k < 5; k++) {
                  new Dust({ from: u1.drawPos.add2(Math.random() * Math.PI * 2, Math.random()), scale: 1 + Math.random(), ageScale: 1 + Math.random(), vz: Math.random() * 0.7 - 0.2 });
                }
              }
            } else if (msg[0] == 'attEff' && msg[1] == 'dragonAttack') {
              var u1 = game.getUnitById(msg[2]);
              var u2 = msg[3] != -1 ? game.getUnitById(msg[3]) : new Field(parseFloat(msg[4]), parseFloat(msg[5]), true);

              if (u1 && u2) {
                new DragonAttack({ from: u1, to: u2, scale: parseFloat(msg[6]), speed: parseFloat(msg[7]), modId: msg[13] });
              }
            } else if (msg[0] == 'attEff' && msg[1] == 'arrow') {
              var u1 = game.getUnitById(msg[2]);
              var u2 = msg[3] != -1 ? game.getUnitById(msg[3]) : new Field(parseFloat(msg[4]), parseFloat(msg[5]), true);

              if (u1 && u2) {
                new Arrow({ from: u1, to: u2, speed: parseFloat(msg[7]), modId: msg[13] });
              }
            } else if (msg[0] == 'attEff' && msg[1] == 'ballista') {
              var u1 = game.getUnitById(msg[2]);
              var u2 = msg[3] != -1 ? game.getUnitById(msg[3]) : new Field(parseFloat(msg[4]), parseFloat(msg[5]), true);

              if (u1 && u2) {
                new CustomProjectile({ from: u1, to: u2, speed: parseFloat(msg[7]), addExplosion: u1.getValue('aoeRadius') > 0.5, scale: parseFloat(msg[6]), modId: msg[13] });
              }
            } else if (msg[0] == 'attEff' && msg[1] == 'smoke') {
              var pos = new Field(parseFloat(msg[4]), parseFloat(msg[5]), true);
              pos = pos.add3(0, -game.getHMValue3(pos));

              for (var k = 0; k < Math.PI * 2; k += Math.random() * 1.5) {
                new Dust({
                  from: pos,
                  scale: Math.random() * 5 + 1.5,
                  ageScale: 2,
                  vz: 0.01,
                  xFunction: function (age) {
                    return ((-1) / (age + 0.3) + 3) * this.x_;
                  },
                  yFunction: function (age) {
                    return ((-1) / (age + 0.3) + 3) * this.y_;
                  },
                  x_: Math.cos(k),
                  y_: Math.sin(k),
                });
              }
            } else if (msg[0] == 'modPro') {
              var u = game.getUnitById(msg[6]);

              for (var i = 0; i < game.objectsToDraw.length; i++) {
                if (game.objectsToDraw[i] && game.objectsToDraw[i].isEffect && game.objectsToDraw[i].modId == msg[1]) {
                  var dist = game.objectsToDraw[i].from.distanceTo2(game.objectsToDraw[i].to);
                  var f1 = new Field(parseFloat(msg[2]), parseFloat(msg[3]), true);
                  game.objectsToDraw[i].from = f1;
                  game.objectsToDraw[i].to = f1.addNormalizedVector(new Field(parseFloat(msg[4]), parseFloat(msg[5]), true), dist);

                  // play sound and make shield effect
                  if (u) {
                    soundManager.playSound(SOUND.PLASMA_SHIELD, game.getVolumeModifier(u.pos));
                    game.addToObjectsToDraw(new PlasmaShield({ from: u, to: game.objectsToDraw[i].pos }));
                  }

                  i = game.objectsToDraw.length;
                }
              }
            } else if (msg[0] == 'killPro') {
              var u = game.getUnitById(msg[2]);

              for (var i = 0; i < game.objectsToDraw.length; i++) {
                if (game.objectsToDraw[i] && game.objectsToDraw[i].isEffect && game.objectsToDraw[i].modId == msg[1]) {
                  var eff = game.objectsToDraw.splice(i, 1)[0];

                  // play sound and make shield effect
                  if (u) {
                    soundManager.playSound(SOUND.PLASMA_SHIELD, game.getVolumeModifier(u.pos));
                    game.addToObjectsToDraw(new PlasmaShield({ from: u, to: eff.pos }));
                  }

                  i = game.objectsToDraw.length;
                }
              }
            } else if (msg[0] == 'tmBldVsnSt') {
              var u = game.getUnitById(msg[2]);
              var team = game.teams[msg[1]];

              if (u && team) {
                u.seenBy[team.number] = parseInt(msg[3]);
                if (msg[3] == BUILDING_STATE.DEAD) {
                  u.switchBlockingForTeam(false, team);
                }
              }
            } else if (msg[0] == 'tmBldSeenAs') {
              var u = game.getUnitById(msg[2]);
              var team = game.teams[msg[1]];

              if (u && u.seenByAsBuildingType && team) {
                u.seenByAsBuildingType[team.number] = u.type;
              }
            } else if (msg[0] == 'swBlck4Tm') {
              var u = game.getUnitById(msg[3]);
              var team = game.teams[msg[1]];

              if (u && team) {
                u.switchBlockingForTeam(msg[2], team);
              }
            } else if (msg[0] == 'autoCast') {
              var u = game.getUnitById(msg[3]);
              if (u) {
                u.setAutocast(msg[1], msg[2] == 1);
              }
            } else if (msg[0] == 'techUpd') {
              var p = game.players[msg[1]];

              if (p) {
                p.buildings = JSON.parse(msg[2]);
                p.buildingsUC = JSON.parse(msg[3]);
                p.pseudoBuildings = JSON.parse(msg[4]);

                if (p.isRevealed != (msg[5] == '1') && _.size(p.buildings) + _.size(p.buildingsUC) > 0 && game_state == GAME.PLAYING && ticksCounter > 50) {
                  interface_.addMessage(msg[5] == '1' ? ('player ' + p.name + ' is revealed') : ('player ' + p.name + ' is no longer revealed'), 'yellow', imgs.attentionmarkYellow);
                }

                p.isRevealed = msg[5] == '1';
              }
            } else if (msg[0] == 'fltTxt') {
              var u = game.getUnitById(msg[1]);

              if (u) {
                new FloatingText({ from: u.drawPos.add3(0, -u.type.size - u.type.height - 0.5 + (u.type.isBuilding ? 2 : 0)), scale: 18 + 8 * u.type.size, content: msg[2], color: '#A1B9FF' });
              }
            } else if (msg[0] == 'gameEnd') {
              game.gameHasEnded = true;
              game.playingPlayerWon = msg[1] == '1';
              uimanager.winLossWindow.setTitle(game.playingPlayerWon ? 'Victory!' : 'Defeat.');
              uimanager.winLossWindow.active = true;
              uimanager.winLossWindow.setTitleStyle(game.playingPlayerWon ? 'gameVictoryTitle' : 'gameLossTitle');
              uimanager.winLossWindow.setBackgroundStyle(game.playingPlayerWon ? 'ingameVictory' : 'ingameDefeat');
              $('#winLossWindowQuitButton')[0].className = game.playingPlayerWon ? 'ingameVictory' : 'ingameDefeat';
              uimanager.winLossWindow.setCloseButtonStyle(game.playingPlayerWon ? 'victoryclosebutton' : 'lossclosebutton');
              uimanager.winLossWindow.active = true;
              soundManager.playSound(game.playingPlayerWon ? SOUND.VICTORY : SOUND.DEFEAT);
              clearCache(game.playingPlayerWon);
              if (!game.playingPlayerWon) {
                PLAYING_PLAYER.team = game.teams[0];
              }
            } else if (msg[0] == 'displayInfoMsg') {
              displayInfoMsg(msg[1]);
            } else if (msg[0] == 'gameReady') {
              if (msg[1] && msg[2]) {
                var field = new Field(msg[1], msg[2], null);

                game.setCameraX(field.x * FIELD_SIZE - WIDTH / 2);
                game.setCameraY(field.y * FIELD_SIZE - HEIGHT / 2);
              }

              // hide loading screen
              $('#loadingWindow').css('display', 'none');

              // play game start sound
              soundManager.playSound(SOUND.GAME_START);
            } else if (msg[0] == 'editorUnitsKilled') {
              // redraw ground tiles canvas (we might have killed a ground tile)
              game.generateGroundTextureCanvas();

              // refresh the pre drawn blocking tiles canvasses
              game.generateTilesCanvasses();

              // re sort tiles
              game.sortTiles();

              // refresh minimap canvas, we might have killed a tile
              game.minimap.refreshTilesCanvas();

              game.selectedUnits = [];

              soundManager.playSound(SOUND.PLACE);
            } else if (msg[0] == 'createTile') {
              var type = msg[1].toUnitType();
              var x = parseFloat(msg[2]);
              var y = parseFloat(msg[3]);
              var f = new Field(x, y, true);

              if (type.isGround) {
                f = f.add3(0, -game.getHMValue2(Math.floor(x), Math.floor(y)) * CLIFF_HEIGHT);
              }

              new Tile({ x: f.px, y: f.py, type: type, dontRefreshNBs: true });

              soundManager.playSound(SOUND.PLACE);

              if (type.blocking) // if its a blocking tile (those are pre-drawn on "cache"-canvasses, refresh the corresponding cache canvas)
              {
                game.refreshBlockingTilesCanvas(y + type.sizeY - 1);
              }

              game.minimap.refreshTilesCanvas(); // when a tile is placed, minimap has to refresh its canvas

              // if its ground Tile, add it to background / groundtile canvas, so its drawn
              if (type.isGround) {
                var img = type.img.img;
                game.groundTilesCanvas.getContext('2d').drawImage(type.img.file[0], img.x, img.y, img.w, img.h, Math.floor(((x + game.cameraX) / FIELD_SIZE) * 16 - img.w / 2), Math.floor(((y + 2 + game.cameraY) / FIELD_SIZE) * 16 - img.h / 2), img.w, img.h);
              }

              // re-sort game tiles array (for the correct drawing order)
              game.sortTiles();

              // redraw ground tiles canvas
              if (type.isGround) {
                game.generateGroundTextureCanvas();
              }
            } else if (msg[0] == 'changeUnitPos') {
              var unit = game.getUnitById(msg[3]);
              var field = new Field(parseFloat(msg[1]), parseFloat(msg[2]), true);

              unit.pos = field;
              unit.lastTicksPosition = field;
              unit.setYDrawingOffset();
            } else if (msg[0] == 'chOwn') {
              var unit = game.getUnitById(msg[1]);
              unit.owner = game.players[msg[2]];
            } else if (msg[0] == 'plDie') {
              var p = game.players[msg[1]];

              if (p) {
                p.isAlive = false;
                interface_.addMessage((p.name == networkPlayerName ? 'you have' : ('player ' + p.name + ' has')) + ' been eliminated', 'yellow', imgs.attentionmarkYellow);
              }
            } else if (msg[0] == 'reviveUnit') {
              for (var i = 0; i < game.units4.length; i++) {
                if (game.units4[i].id == msg[1]) {
                  u = game.units4[i];
                  game.units4.splice(i, 1);
                  i = game.units4.length;

                  u.hp = u.getValue('hp');
                  u.pos = new Field(msg[2], msg[3], true);
                  u.drawPos = u.pos.getCopy();
                  u.lastTicksPosition = u.pos.getCopy();
                  u.order = lists.types.stop;
                  u.queueOrder = [];
                  u.queueTarget = [];
                  u.isActive = true;
                  u.isAlive = true;
                  u.owner.unitSpawns(u);

                  u.setYDrawingOffset();
                  game.objectsToDraw.erease(u);
                  game.objectsToDraw.erease(u);
                  game.addObject(u);
                }
              }
            } else if (msg[0] == 'cliffSBeenPlaced') {
              msg[1] = parseInt(msg[1]);
              msg[2] = parseInt(msg[2]);

              game.makeCliffs(msg[1] - 2, msg[2] - 2, msg[1] + 2, msg[2] + 2);

              game.minimap.refreshTilesCanvas(); // when a tile is placed, minimap has to refresh its canvas


              game.refreshBlockingTilesCanvas(msg[2] - 1);
              game.refreshBlockingTilesCanvas(msg[2]);
              game.refreshBlockingTilesCanvas(msg[2] + 1);
              game.refreshBlockingTilesCanvas(msg[2] + 2);

              game.sortTiles();
            } else if (msg[0] == 'setHMValue') {
              game.setHMValue(msg[1], msg[2], msg[3]);
            } else if (msg[0] == 'gameData') {
              incomingOrders = JSON.parse(msg[1]);

              // TODO: add a flag specifically for editor test mode instead of checking mapData
              if (game && !game.replay_mode && !game.isEditor && !mapData) {
                ReplaysWindow.saveReplay();
              }
            } else if (msg[0] == 'killRamp') {
              game.killRamp(msg[1], msg[2]);
              game.makeCliffs();
            } else if (msg[0] == 'cliffSBeenPlaced2') {
              msg[1] = parseInt(msg[1]);
              msg[2] = parseInt(msg[2]);

              game.makeCliffs(msg[1] - 2, msg[2] - 2, msg[1] + 2, msg[2] + 2);

              game.minimap.refreshTilesCanvas(); // when a tile is placed, minimap has to refresh its canvas

              game.generateTilesCanvasses();

              game.sortTiles();

              if (msg[3] == 0.5 || msg[3] == -0.5) {
                game.generateGroundTextureCanvas();
              }

              soundManager.playSound(SOUND.PLACE);
            } else if (msg[0] == 'printPath') {
              path2Print = JSON.parse(msg[1]);
            }
          }
        }, false);

        // draw loading bar border
        c.strokeStyle = 'white';
        c.fillStyle = 'white';
        c.lineWidth = 3;
        c.strokeRect(WIDTH / 2 - 300, HEIGHT - 150, 600, 50);

        // [DEPRECATE] use AccountInfo.playerName in favor of networkPlayerName
        var networkPlayerName = '';

        // create objects
        var interface_ = new Interface();
        var editor = null;
        var network = new Network();
        var game = null;
        var uimanager = new UIManager();
        var env = new Enviroment();
        var mapEditorData = null;

        // custom jquery ui tooltip styling
        $(function () {
          $(document).tooltip({});
        });

        // prompt before closing when ingame
        window.onbeforeunload = function () {
          if (game_state == GAME.PLAYING || game_state == GAME.EDITOR) {
            return 'Do you really want to quit ?';
          }
        };

        // parameter newTime is high-resolution timer, starting at 0 with first frame, not equal to Date.now() unix time.
        function mainLoop(newTime) {
          requestAnimationFrame(mainLoop);

          interface_.updateFakeCursor();

          // time stuff and fps output
          timeDiff = newTime - timestamp;

          // cap fps (limit varies between 25mspf=40fps and 40mspf=25fps, depending on load)
          if (timeDiff < mspfCap) {
            return;
          }

          frameTimes.unshift(timestamp);
          timestamp = newTime;

          if (frameTimes.length > 2) {
            const f3 = frameTimes[0] + frameTimes[1] + frameTimes[2];
            // divider = weighted sum of last three frame time differences, 3x last frame + 2x second last frame + 1x third last frame
            fps = 6000 / (3 * timestamp - f3);

            // adapt mspfCap (1000 / fps cap) for consistent performance
            if (mspfCap < 40 && fps < 1 / mspfCap) {
              mspfCap++;
            } else if (mspfCap > 25 && fps > 1 / mspfCap) {
              mspfCap--;
            }
            frameTimes.pop();
          }

          if (game_state != GAME.PLAYING && interface_.isPointerLocked()) {
            document.exitPointerLock();
          }

          if (game_state == GAME.PLAYING) {
            var oldPercentageOfCurrentTickPassed = percentageOfCurrentTickPassed;
            percentageOfCurrentTickPassed = Math.min((Date.now() - timeOfLastUpdate) / TICK_TIME, 1);

            // save, how many ticks passed since last rendered frame; we need that for some graphic stuff (particle emitters spawn amount of particles based on this for example)
            gameTimeDiff = Math.max(Math.min(((ticksCounter + percentageOfCurrentTickPassed) - (lastFramesTick + oldPercentageOfCurrentTickPassed)) / 20, 1), 0);
            tickDiff = ticksCounter - lastFramesTick;
            lastFramesTick = ticksCounter;

            if (PLAYING_PLAYER.controller == CONTROLLER.SPECTATOR && tickDiff > 0 && ticksCounter % 10 == 1) {
              game.refreshSpectatorTab();
            }

            // draw everything
            game.draw();
            keyManager.draw();
            interface_.draw();
          } else if (game_state == GAME.EDITOR) {
            gameTimeDiff = 0;
            editor.draw();
            keyManager.draw();
          } else // lobby or menu
          {
            c.fillStyle = 'black';
            c.fillRect(0, 0, WIDTH, HEIGHT);
          }

          musicManager.draw();
          uimanager.draw();
          UIManagerSingleton.draw();
        }

        // Start the main loop once all initialization is complete
        Initialization.onInitializationComplete(mainLoop);

        const AccountInfo = (() => {
          function AccountInfo_() {
            Initialization.onDocumentReady(() => {
              this.init();

              Login.registerOnLogout(() => {
                this.__initializeFields();
              });
            });

            this.__setupObservers();
            this.__initializeFields();
          }

          AccountInfo_.prototype.__initializeFields = function () {
            this.isMod = false;
            this.isMod2 = false;
            this.isAdmin = false;
            this.ignores = [];
            this.accId = 0;
            this.premiumExpiry = 0;
            this.authedAndLogged = false;
            this.gold = 0;
            this.xp = 0;
            this.playerName = '';
            this.clan = '';
          };

          AccountInfo_.prototype.__setupObservers = function () {
            let authedAndLogged = false; // true when logged in as a registered user
            Object.defineProperty(this, 'authedAndLogged', {
              get: () => authedAndLogged,
              set: (value) => {
                authedAndLogged = value;
                $('#loginPromptButton').text(authedAndLogged ? 'Log out' : 'Log in');
              },
            });

            let gold;
            Object.defineProperty(this, 'gold', {
              get: () => gold,
              set: (value) => {
                gold = value;
                $('#playerGold').html(currencyFormatter(gold));
              },
            });

            let xp;
            Object.defineProperty(this, 'xp', {
              get: () => xp,
              set: (value) => {
                xp = value;
                const lvl = getLvlFromXp(xp);
                const xp1 = getXPRequiredForLvl(lvl);
                const xp2 = getXPRequiredForLvl(lvl + 1);
                $('#mainExpLvl').text(lvl);
                $('#mainExpBar').css('width', `${(xp - xp1) / (xp2 - xp1) * 200}px`);
                $('#mainExpText').text(`${xp} / ${xp2}`);
              },
            });

            this.__setupPlayerNameClanObservers();
            this.__setupLeagueObserver();
          };

          AccountInfo_.prototype.__setupPlayerNameClanObservers = function () {
            // TODO: replace networkPlayerName with AccountInfo.playerName
            let playerName;
            let clan;

            const updateNameAndClan = () => {
              if (!this.authedAndLogged) {
                $('#playerNameDisplay').html(playerName);
                return;
              }

              const builder = new HTMLBuilder();
              builder.add(network.getClanLink({ clan: clan, name: playerName }));
              builder.add(network.getPlayerLink({ name: playerName, authLevel: 999, premium: false }, true));
              builder.insertInto('#playerNameDisplay');
            };

            Object.defineProperty(this, 'playerName', {
              get: () => playerName,
              set: (value) => {
                playerName = value;
                updateNameAndClan();
              },
            });

            Object.defineProperty(this, 'clan', {
              get: () => clan,
              set: (value) => {
                clan = value;
                updateNameAndClan();
              },
            });
          };

          AccountInfo_.prototype.__setupLeagueObserver = function () {
            let league = -1;
            let ladderGameCount = 0;

            const updateLeague = () => {
              if (league >= 0) {
                getLeagueLink(league, false, 4).insertInto('#mainLeagueLink');
                $('#mainLeagueLink').prop('title', 'This is your current league. ' +
                  'You can get promoted or demoted depending on your ladder match results.');
              } else {
                $('#mainLeagueLink').html('<div id=\'noRankingYetDiv\'>You have no ladder rank yet. ' +
                  `Play <span id='rankedGamesLeft'>${Math.max(5 - ladderGameCount, 1)}</span> ` +
                  'ranked matches to get placed into a division</div>');
                $('#mainLeagueLink').prop('title', '');
              }
            };

            Object.defineProperty(this, 'league', {
              get: () => league,
              set: (value) => {
                league = value;
                updateLeague();
              },
            });

            Object.defineProperty(this, 'ladderGameCount', {
              get: () => ladderGameCount,
              set: (value) => {
                ladderGameCount = value;
                updateLeague();
              },
            });
          };

          AccountInfo_.prototype.init = function () {
            this.__initPlayerGold();
            this.__initAccountInformationWindow();

            this.__initNetworkListeners();
          };

          AccountInfo_.prototype.__initPlayerGold = function () {
            const playerGoldWrap = new UIElement('div', 'playerGoldWrap', () => game_state == GAME.LOBBY && AccountInfo.authedAndLogged);
            playerGoldWrap.domElement.title = goldDescription;

            const disabledButton = MICROTRANSACTIONSENABLED ? '' : 'disabled';

            const getGoldButtonID = uniqueID('getGold');
            new HTMLBuilder()
              .add('<span id=\'playerGold\'></span> ')
              .add('<img src=\'imgs/gold2.png\' class=\'pixelated\' style=\'width: 32px;\' /> ')
              .add(`<button ${disabledButton} id='${getGoldButtonID}'>Get more!</button>`)
              .addHook(() => $(`#${getGoldButtonID}`).click(() => Microtransactions.showBuyGoldWindow(AccountInfo.accId)))
              .add(' <button id=\'freeGoldButton\' style=\'display: none\'>Get 400 gold for free!</button>')
              .insertInto('#playerGoldWrap');

            UIManagerSingleton.registerUIElement(playerGoldWrap);
          };

          AccountInfo_.prototype.__initAccountInformationWindow = function () {
            // Account info window will be placed inside lobby div, and is always visible whenever the lobby is
            const accInfoWindow = new UIWindow('accInfoWindow', () => true);

            // Link that shows the league of the currently logged in player along with an image of the league
            const mainLeagueLink = new UIElement('div', 'mainLeagueLink', () => AccountInfo.authedAndLogged, true);
            UIManagerSingleton.registerUIElement(mainLeagueLink);

            // XP information that shows up in the account information window when logged in as a player
            const mainExpDiv = new UIElement('div', 'mainExpDiv', () => AccountInfo.authedAndLogged, true);
            mainExpDiv.domElement.title = 'This is your current experience and the experience you need to reach the next level. ' +
              'You get experience from games you play. If you level up, new features will be unlocked.';
            new HTMLBuilder()
              .add('<div style=\'font-size: 26px\'>Level <font id=\'mainExpLvl\' class=\'greenfont\'></font></div>')
              .add('<div class=\'xpBarContainer\' style=\'width: 200px; height: 32px; margin: 0 auto\'>')
              .add('<div id=\'mainExpBar\' class=\'xpBar\' style=\'width: 0px\'></div>')
              .add('<div id=\'mainExpText\' style=\'position: absolute; width: 100%; top: 0px; font-size: 26px; height: 32px; line-height: 32px\'></div>')
              .add('</div>')
              .insertInto('#mainExpDiv');
            UIManagerSingleton.registerUIElement(mainExpDiv);

            // Notice that tells guests to log in to get XP
            const guestXPMsg = new UIElement('div', 'accGuestMsgDiv', () => !AccountInfo.authedAndLogged, true);
            $(guestXPMsg.domElement).text('Log in to get XP and gold rewards as well as access to friends and ranked play!');
            UIManagerSingleton.registerUIElement(guestXPMsg);

            // Build the account information window
            new HTMLBuilder()
              .add('<div id=\'accInfoTopDiv\'><div id=\'playerNameDisplay\'></div><button id=\'loginPromptButton\'>Log in</button></div>')
              .addHook(() => $('#loginPromptButton').click(addClickSound(() => {
                game_state = GAME.LOGIN;
                if (this.authedAndLogged) {
                  Login.logout();
                }
              })))
              .addDOM(mainLeagueLink.domElement)
              .addDOM(mainExpDiv.domElement)
              .addDOM(guestXPMsg.domElement)
              .insertInto('#accInfoWindow');
            $('#lobbyDiv').append(accInfoWindow.domElement);
            UIManagerSingleton.registerUIElement(accInfoWindow);
          };

          AccountInfo_.prototype.__initNetworkListeners = function () {
            const displayMsg = (msg) => {
              if (game_state == GAME.PLAYING) {
                interface_.chatMsg(`Server: ${msg}`);
              } else {
                addChatMsg('Server', msg);
              }
            };

            network.registerListener(null, 'add-ignore', (splitMsg) => {
              this.ignores.push(splitMsg[1].toLowerCase());
              displayMsg(`${splitMsg[1]} will be ignored`);
            });

            network.registerListener(null, 'no-ignore', (splitMsg) => displayMsg(`${splitMsg[1]} does not exist`));
            network.registerListener(null, 'already-ignore', (splitMsg) => displayMsg(`${splitMsg[1]} is already being ignored`));

            network.registerListener(null, 'unignore', (splitMsg) => {
              const wasIgnored = this.ignores.erease(splitMsg[1]);
              displayMsg(`${splitMsg[1]} ${wasIgnored ?
                'will no longer be ignored' :
                'not found on your ignore list (type /ignorelist to see full list)'}`);
            });

            network.registerListener(null, 'gold-update', (splitMsg) => this.gold = splitMsg[1]);
          };

          return new AccountInfo_();
        })();

        function colourText(str, col) {
          return `<font color="${col}">${str}</font>`;
        }

        const Login = (() => {
          function Login_() {
            Initialization.onDocumentReady(() => this.init());

            this.LoginStates = Object.freeze({
              NONE: 'NONE',
              GUEST: 'GUEST',
              PLAYER: 'PLAYER',
            });

            this.loginState = 'NONE';
            this.__instantLoginInProgress = false;
            // Set to true when autologin fails because we are logged into another tab
            // In this case, even though we will log in as a guest, the user doesn't intend to clear a saved login
            this.__dontClearSavedLogin = false;

            this.__storedUsername = '';
            this.__storedPassword = '';

            this.onLoginCallbacks = [];
            this.onLogoutCallbacks = [];

            // TODO: this is insecure in the case of an XSS
            this.username = LocalConfig.registerValue('username', '');
            this.password = LocalConfig.registerValue('password', '');
          }

          Login_.prototype.registerOnLogin = function (callback) {
            this.onLoginCallbacks.push(callback);
          };

          Login_.prototype.registerOnLogout = function (callback) {
            this.onLogoutCallbacks.push(callback);
          };

          Login_.prototype.logout = function () {
            this.onLogoutCallbacks.forEach((callback) => callback());
            network.reset();
            this.__clearLogin();
          };

          Login_.prototype.init = function () {
            this.__initLoginWindow();
            this.__initRecoveryWindow();
            this.__initRegisterWindow();

            /*
             * AGB accept
             */
            const agbAcceptDiv = new UIWindow('agbAcceptDiv', () => game_state == GAME.ACCEPT_AGB, false, '');
            agbAcceptDiv.addScrollableSubDiv('agbAcceptDivSubDiv');
            $('#agbAcceptDiv').append('<div>You have to read and accept the terms and conditions in order to continue</div>');

            $.ajax({
              dataType: 'text',
              url: 'agb.html',
            }).done((data) => {
              new HTMLBuilder()
                .add(`<div style='font-size: 14px'>${data}</div><br />`)
                .add('<button id=\'acceptAGBButton\'>I have read and accepted the terms and conditions</button>')
                .addHook(() => $('#acceptAGBButton').click(addClickSound(() => network.send('i-accept-agb'))))
                .insertInto('#agbAcceptDivSubDiv');
            });

            UIManagerSingleton.registerUIElement(agbAcceptDiv);
          };

          Login_.prototype.__initLoginWindow = function () {
            const loginWindow = new UIWindow(
              'loginWindow',
              () => game_state == GAME.LOGIN &&
                Initialization.getStage() == Initialization.Stage.INITIALIZATION_COMPLETE,
              false,
              'Login',
            );

            const savedPW = this.password.get();
            const loginWindowKeyDown = (e) => {
              if (keyManager.getKeyCode(e) == KEY.ENTER) {
                this.__formLogin();
              }
            };

            const loginWindowBuilder = new HTMLBuilder()
              .add('<p id=\'loginWindowState\'></p>') // Server response label
              .add(`<input id='loginWindowUsername' type='text' value='${networkPlayerName}'>`)
              .addHook(() => $('#loginWindowUsername').keydown(loginWindowKeyDown))
              .add(`<input id='loginWindowPassword' type='password' value='${savedPW}'>`)
              .addHook(() => $('#loginWindowPassword').keydown(loginWindowKeyDown))
              .add('<label id=\'loginWindowNameLabel\' for=\'loginWindowUsername\'>Name</label>')
              .add('<label id=\'loginWindowPwLabel\' for=\'loginWindowPassword\'>Password</label>')
              .add(`<input id='loginWindowPwCheckbox' type='checkbox' ${(savedPW.length > 0) ? 'checked' : ''}>`)
              .add('<p id=\'loginWindowSavePwLabel\'>save password</p>');

            loginWindowBuilder.add(generateButton('loginWindowLoginButton', null, null, () => this.__formLogin(), 'Login'));

            // Only allow the player to go back if they are a guest, because otherwise they have been logged out
            const backToLobbyButton = new UIElement('button', 'loginWindowBackButton', () => this.loginState == this.LoginStates.GUEST);
            $('#loginWindowBackButton').text('Back to Lobby').click(() => game_state = GAME.LOBBY);
            UIManagerSingleton.registerUIElement(backToLobbyButton);

            loginWindowBuilder.addDOM(backToLobbyButton.domElement);

            loginWindowBuilder.add(generateButton(
              'loginWindowGuestButton',
              null,
              'Login as a guest. You will be able to use most features, so this is perfectly fine for trying out the game.',
              addClickSound(() => network.send('login-guest<<$dummy-string')),

              'Play as a guest',
            ));

            loginWindowBuilder.add(generateButton('loginWindowCreateAccount', null, null, addClickSound(() => game_state = GAME.REGISTER), 'Create account'));
            loginWindowBuilder.add(generateButton('recoverPWButton', null, null, addClickSound(() => game_state = GAME.RECOVERY), 'Forgot password?'));

            loginWindowBuilder.insertInto(`#${loginWindow.id}`);
            UIManagerSingleton.registerUIElement(loginWindow);
          };

          Login_.prototype.__initRecoveryWindow = function () {
            const recoveryWindow = new UIWindow('recoveryWindow', () => game_state == GAME.RECOVERY, false, 'Forgot Password');

            const recoveryWindowBuilder = new HTMLBuilder()
              .add('<p id=\'recoveryWindow\'></p>')
              .add('<input id=\'recoveryWindowEmail\'>')
              .add('<p id=\'recoveryWindowEmailLabel\'>Email<p>')
              .add('<input id=\'recoveryWindowPW\' type=\'password\'>')
              .add('<p id=\'recoveryWindowPWLabel\'>New password</p>')
              .add('<p id=\'recoveryWindowState\'></p>');

            recoveryWindowBuilder.add(generateButton('recoveryWindowCreate', null, null, addClickSound(() => {
              const email = $('#recoveryWindowEmail').val();
              const password = $('#recoveryWindowPW').val();
              if (email && password) {
                network.send('email-recover<<$' + email + '<<$' + password);
                $('#recoveryWindowState').text('Waiting for server...');
              } else {
                $('#recoveryWindowState').text('You must fill in all the fields');
              }
            }), 'Recover'));

            recoveryWindowBuilder.add(generateButton('recoveryWindowBack', null, null, addClickSound(() => game_state = GAME.LOGIN), 'Back'));

            recoveryWindowBuilder.insertInto(`#${recoveryWindow.id}`);
            UIManagerSingleton.registerUIElement(recoveryWindow);
          };

          Login_.prototype.__initRegisterWindow = function () {
            const registerWindow = new UIWindow('registerWindow', function () {
              return game_state == GAME.REGISTER;
            }, false, 'Register');

            const termsAndConditionsLinkID = uniqueID('termsAndConditions');
            const registerWindowBuilder = new HTMLBuilder()
              .add('<p id=\'createAccLabel\'>Create new account</p><p id=\'registerWindowState\'></p><input type=\'text\' id=\'registerWindowUsername\'></input><input type=\'text\' id=\'registerWindowEmail\'></input>')
              .add('<input type=\'password\' id=\'registerWindowPassword\'></input><p id=\'registerWindowNameLabel\'>Name</p><p id=\'registerWindowEmailLabel\'>Email</p>')
              .add('<p id=\'registerWindowPwLabel\'>Password</p><input type=\'text\' id=\'registerWindowFirstName\'></input><input type=\'text\' id=\'registerWindowLastName\'></input>')
              .add('<p id=\'registerWindowFirstNameLabel\'>First Name</p><p id=\'registerWindowLastNameLabel\'>Last Name</p>')
              .add('<div id=\'registerAGBs\'><input type=\'checkbox\' id=\'registerAGBCheckbox\' /> I accept the ')
              .add(`<a class='underline' id='${termsAndConditionsLinkID}'>Terms &amp; Conditions</a>`)
              .addHook(() => $(`#${termsAndConditionsLinkID}`).click(() => showAGB()))
              .add('</div>');

            registerWindowBuilder.add(generateButton('registerWindowBack', null, null, addClickSound(() => game_state = GAME.LOGIN), 'Back'));
            registerWindowBuilder.add(generateButton('registerWindowCreate', null, null, addClickSound(() => {
              const agbChecked = $('#registerAGBCheckbox').prop('checked');
              const email = $('#registerWindowEmail').val();
              const username = $('#registerWindowUsername').val();
              const password = $('#registerWindowPassword').val();
              const firstName = $('#registerWindowFirstName').val();
              const lastName = $('#registerWindowLastName').val();

              if (!agbChecked) {
                $('#registerWindowState').text('You must accept the terms and conditions');
              } else if (email && username && password && firstName && lastName) {
                network.send('create-account<<$' + username + '<<$' + email + '<<$' + password + '<<$' + firstName + '<<$' + lastName);
                $('#registerWindowState').text('Waiting for server...');
              } else {
                $('#registerWindowState').text('You must fill in all the fields');
              }
            }), 'Create'));

            registerWindowBuilder.insertInto(`#${registerWindow.id}`);
            UIManagerSingleton.registerUIElement(registerWindow);
          };

          Login_.prototype.initNetworkListeners = function () {
            network.registerOnFirstOpen(() => this.__sendActivationCode());
            network.registerOnFirstOpen(() => this.__instantLogin());
            network.registerOnFirstOpen(() => network.send(JSON.stringify({ message: 'check-game-version', properties: { clientVersion: version } })));
            network.registerOnFirstOpen(() => network.send(JSON.stringify({ message: 'get-ladder-season' })));
            network.registerListener(GAME.ACCEPT_AGB, 'agb-accept-ok', () => game_state = GAME.LOBBY);
            network.registerListener(GAME.LOGIN, 'logged-in', (splitMsg) => this.__loggedInListener(splitMsg));
            network.registerListener(GAME.LOGIN, 'logged-in-guest', (splitMsg) => this.__loggedInGuestListener(splitMsg));
            network.registerListener(GAME.LOGIN, 'really-log-in', (splitMsg) => this.__reallyLoginListener(splitMsg));
            network.registerListener(GAME.LOGIN, 'register-state', (splitMsg) => {
              // Something was wrong with the login information
              if (!this.__instantLoginInProgress) {
                $('#loginWindowState').text(splitMsg[1]);
              } else {
                // Clear the login info if it's wrong
                this.__clearLogin();

                console.log('Autologin failed, logging in as guest');
                this.__instantLogin(true);
              }
            });
            network.registerListener(GAME.REGISTER, 'register-state', (splitMsg) => $('#registerWindowState').text(splitMsg[1]));
            network.registerListener(GAME.RECOVERY, 'register-state', (splitMsg) => $('#recoveryWindowState').html(splitMsg[1]));
            network.registerJSONListener(null, 'server-version-mismatch', (properties) => {
              const { clientVersion, currentVersion } = properties;

              displayInfoMsg(
                new HTMLBuilder()
                  .add(`Littlewargame has been updated!`)
                  .add(`<br>You are on version ${clientVersion}, which is outdated.`)
                  .add(`<br>Please update to version ${currentVersion} with the following controls: `)
                  .add('<br><br>Windows: ctrl + shift + R')
                  .add('<br><br>MacOS: cmd + shift +R')
              );
            });
            network.registerJSONListener(null, 'ladder-season-id', (properties) => {
              const { ladderSeasonId: seasonId } = properties;

              ladderSeasonId = seasonId;
              console.log(`Current Ladder Season: ${ladderSeasonId}`)
            })
          }

          Login_.prototype.__sendActivationCode = function () {
            const queryString = window.location.search;

            if (queryString.substr(0, 16) == '?activationCode=') {
              const code = (queryString.split('='))[1];
              network.send('activate-account<<$' + code);
            }

            if (queryString.substr(0, 14) == '?recoveryCode=') {
              const code = (queryString.split('='))[1];
              network.send('recover-account-2<<$' + code);
            }
          };

          Login_.prototype.__instantLogin = function (forceGuest = false) {
            this.__instantLoginInProgress = true;

            const username = this.username.get();
            const password = this.password.get();

            if (!forceGuest && username && password && !username.includes('guest_')) {
              console.log('logging in as user');
              network.send('login-user<<$' + username + '<<$' + password + '<<$' + '0');
            } else {
              console.log('logging in as guest');
              network.send('login-guest<<$dummy-string');
            }
          };

          Login_.prototype.__showFAQ = function () {
            const faqLinkID = uniqueID('faq');
            new HTMLBuilder()
              .add(`<span id='faqLink'>&nbsp;New here? Read the <a class='underline' id='${faqLinkID}'>FAQ</a> `)
              .addHook(() => $(`#${faqLinkID}`).click(addClickSound(() => fadeIn($('#faqWindow')))))
              .add(`<button id='killFaqMsgButton'>x</button></span>`)
              .addHook(() => $('#killFaqMsgButton').click(killFaqMsg0))
              .insertInto('#faqContainer');
          };

          Login_.prototype.__loggedInListener = function (splitMsg) {
            $('#loginWindowPassword').val('');
            this.loginState = this.LoginStates.PLAYER;
            this.__instantLoginInProgress = false;

            if (!hideFAQ.get()) {
              this.__showFAQ();
            }

            Changelog.tryShow();

            const response = JSON.parse(splitMsg[1]);
            networkPlayerName = response.name;
            AccountInfo.authedAndLogged = true;
            AccountInfo.isMod = response.isMod;
            AccountInfo.isAdmin = response.isAdmin;
            AccountInfo.isMod2 = response.isMod2;
            AccountInfo.ignores = response.ignores;
            AccountInfo.accId = response.id;
            AccountInfo.xp = response.exp;
            AccountInfo.gold = response.gold;
            AccountInfo.league = response.league;
            AccountInfo.ladderGameCount = response.ladderGameCount;
            AccountInfo.playerName = networkPlayerName;
            AccountInfo.clan = response.clanTag;

            if (response.agb_accepted == '0') {
              game_state = GAME.ACCEPT_AGB;
            } else {
              game_state = GAME.LOBBY;
            }

            this.__saveLogin();

            // Clear credentials from memory to minimize damage in case of an exploit
            this.__storedUsername = '';
            this.__storedPassword = '';

            // if has premium acc
            if (response.premiumExpiry > (Date.now() / 1000)) {
              AccountInfo.premiumExpiry = response.premiumExpiry;
            }

            this.onLoginCallbacks.forEach((callback) => callback());
          };

          Login_.prototype.__loggedInGuestListener = function (splitMsg) {
            this.loginState = this.LoginStates.GUEST;
            this.__instantLoginInProgress = false;

            if (!hideFAQ.get()) {
              this.__showFAQ();
            }

            Changelog.tryShow();

            networkPlayerName = splitMsg[1];
            AccountInfo.authedAndLogged = false;
            AccountInfo.playerName = splitMsg[1];

            game_state = GAME.LOBBY;

            // Clear the login unless otherwise specified
            if (!this.__dontClearSavedLogin) {
              this.__clearLogin();
            }
            this.__dontClearSavedLogin = false;

            // TODO: move this elsewhere
            $('#friendsSubdiv').html('<div id=\'noFriendsMessageDiv\'>If you register an account, you can add other players as friends</div>');

            this.onLoginCallbacks.forEach((callback) => callback());
          };

          Login_.prototype.__reallyLoginListener = function (splitMsg) {
            // If there is an existing tab open, offer to terminate that session
            if (!this.__instantLoginInProgress) {
              const forceLogoutID = uniqueID('forceLogout');
              new HTMLBuilder()
                .add('<br />There seem to be existing sessions for this account. Continuing will log out any existing sessions.')
                .add(` <button id='${forceLogoutID}'>Login</button>`)
                .addHook(() => $(`#${forceLogoutID}`).click(() => this.__formLogin(true)))
                .insertInto('#loginWindowState');
            } else {
              console.log('Autologin failed, logging in as guest');
              this.__dontClearSavedLogin = true;
              this.__instantLogin(true);
            }
          };

          // Log in as a user, optionally forcing old sessions to close
          Login_.prototype.__formLogin = function (killOldSessions) {
            const username = $('#loginWindowUsername').val();
            const password = $('#loginWindowPassword').val();

            if (username && password) {
              network.send('login-user<<$' + username + '<<$' + password + '<<$' + (killOldSessions ? '1' : '0'));
              $('#loginWindowState').html('Connecting...');

              if ($('#loginWindowPwCheckbox').prop('checked')) {
                this.__storedUsername = username;
                this.__storedPassword = password;
              } else {
                this.__storedUsername = '';
                this.__storedPassword = '';
              }
            } else {
              $('#loginWindowState').html('Please fill in all the fields');
            }

            soundManager.playSound(SOUND.CLICK);
          };

          Login_.prototype.__saveLogin = function () {
            if (this.__storedUsername && this.__storedPassword) {
              this.username.set(this.__storedUsername);
              this.password.set(this.__storedPassword);
            }
          };

          Login_.prototype.__clearLogin = function () {
            this.username.set('');
            this.password.set('');
          };

          return new Login_();
        })();

        Login.initNetworkListeners();

        const PlayersList = (() => {
          function PlayersList_() {
            Initialization.onDocumentReady(() => {
              this.init();

              Login.registerOnLogout(() => this.players = {});
            });

            // Map from player name to player information for all logged in players
            // Each entry has the format {name: String, location: Int, authLevel: String, clan: String, premium: Boolean}
            this.players = {};
            this.Locations = Object.freeze({
              LOBBY: 0,
              EDITOR: 1,
              SEARCHING: 2,
              RANKED: 3,
              MATCH: 4,
              MAP_LOBBY: 5,
              CPU_MATCH: 6,
              REPLAY: 7,
            });
            this.LocationStrings = Object.freeze({
              0: 'lobby',
              1: 'editor',
              2: 'searching',
              3: 'ranked',
              4: 'match',
              5: 'map lobby',
              6: 'cpu match',
              7: 'replay',
            });

            this.onChangeCallbacks = [];
          }

          PlayersList_.prototype.init = function () {
            this.__initPlayerWindow();

            this.__initNetworkListeners();
          };

          PlayersList_.prototype.__initPlayerWindow = function () {
            // Player list window in the lobby
            const playersWindow = new UIWindow('playersWindow', null, false, 'Players');
            playersWindow.addScrollableSubDiv('playersWindowTextArea');
            playersWindow.setTitleStyle('windowTitle2');

            // Search box to filter players
            new HTMLBuilder()
              .add('<input type=\'text\' id=\'playerSearchInput\' placeholder=\'filter players\' autocomplete=\'off\'></input>')
              .addHook(() => $('#playerSearchInput').keyup(() => this.__refreshPlayerWindow($('#playerSearchInput').val())))
              .appendInto('#playersWindow');

            $('#lobbyDiv').append(playersWindow.domElement);
            UIManagerSingleton.registerUIElement(playersWindow);
          };

          PlayersList_.prototype.__initNetworkListeners = function () {
            network.registerListener([GAME.LOBBY, GAME.ACCEPT_AGB], 'player-list', (splitMsg) => {
              this.players = {};

              for (let i = 1; i < splitMsg.length; i++) {
                const pl = splitMsg[i].split('<');
                const name = escapeHtml(pl[0]);
                this.players[name] = {
                  name: name,
                  location: parseInt(pl[1]),
                  authLevel: pl[2],
                  clan: pl[3],
                  premium: pl[4] == '1',
                };
              }

              this.__updatedPlayers();
            });

            network.registerListener([GAME.LOBBY, GAME.ACCEPT_AGB], 'player-joined', (splitMsg) => {
              const playerName = escapeHtml(splitMsg[1]);

              this.players[playerName] = {
                name: playerName,
                location: 0,
                authLevel: splitMsg[2],
                clan: splitMsg[3],
                premium: splitMsg[4] == 'true',
              };

              this.__updatedPlayers();
            });

            // Helper which factors out the common functionality of the following listeners
            const updatePlayer = (unescapedPlayerName, updateCallback) => {
              const playerName = escapeHtml(unescapedPlayerName);
              if (this.players[playerName]) {
                updateCallback(playerName);
                this.__updatedPlayers();
              }
            };

            network.registerListener([GAME.LOBBY, GAME.ACCEPT_AGB], 'player-location-update', (splitMsg) => {
              updatePlayer(splitMsg[1], (playerName) => this.players[playerName].location = parseInt(splitMsg[2]));
            });

            network.registerListener([GAME.LOBBY, GAME.ACCEPT_AGB], 'player-premium-update', (splitMsg) => {
              updatePlayer(splitMsg[1], (playerName) => this.players[playerName].premium = splitMsg[2] == '1');
            });

            network.registerListener([GAME.LOBBY, GAME.ACCEPT_AGB], 'player-clan-update', (splitMsg) => {
              updatePlayer(splitMsg[1], (playerName) => {
                if (playerName == networkPlayerName) {
                  AccountInfo.clan = splitMsg[2];
                }

                this.players[playerName].clan = splitMsg[2];
              });
            });

            network.registerListener([GAME.LOBBY, GAME.ACCEPT_AGB], 'player-left', (splitMsg) => {
              updatePlayer(splitMsg[1], (playerName) => delete this.players[playerName]);
            });
          };

          PlayersList_.prototype.onChange = function (cb) {
            this.onChangeCallbacks.push(cb);
          };

          PlayersList_.prototype.__getLocationString = function (locationID) {
            const string = this.LocationStrings[locationID] ?? '?';
            return ` ( ${string} )`;
          };

          PlayersList_.prototype.__updatedPlayers = function () {
            const sorted = alphabetizePlayers(this.players);
            this.onChangeCallbacks.forEach((cb) => cb(sorted));
            this.__refreshPlayerWindow();
          };

          PlayersList_.prototype.__refreshPlayerWindow = function (searchString = '') {
            // Show the total player count in the title
            const playersWindow = UIManagerSingleton.getUIElement('playersWindow');
            playersWindow.setTitleText(`» Players (${_.size(this.players)})`);

            // Construct the contents of the window
            const builder = new HTMLBuilder();

            // Sort the list of players and filter by search string if the user is searching
            const players = Object.values(alphabetizePlayers(this.players)).filter((player) => {
              if (searchString.length > 0) {
                return player.name.toLowerCase().indexOf(searchString.toLowerCase()) >= 0;
              }
              return true;
            });

            players.forEach((p) => {
              builder
                .add('<div>')
                .add(network.getClanLink(p))
                .add(network.getPlayerLink(p, false))
                .add(`<span class='lobbyLabel'>${this.__getLocationString(p.location)}</span></div>`);
            });
            builder.insertInto('#playersWindowTextArea');
          };

          PlayersList_.prototype.getPlayerLink = function (playerName, addColor = false, addClan = false, customAuthLevel = null) {
            const player = this.players[playerName];
            let className = (addColor && player) ? auth_level_css_classes[player.authLevel] : '';

            if (player && player.premium && player.authLevel < AUTH_LEVEL.MOD) {
              className = 'playerLinkPremium';
            }
            if (customAuthLevel && customAuthLevel >= 0) {
              className = auth_level_css_classes[customAuthLevel];
            }

            const builder = new HTMLBuilder();

            if (addClan && player) {
              const clanLinkID = uniqueID('clanLink');
              builder.add(`[<a class='clanLink' href='#' id='${clanLinkID}'>${player.clan}</a>] `);
              builder.addHook(() => $(`#${clanLinkID}`).click(() => Clans.getClanInfo(player.clan)));
            }

            const playerLinkID = uniqueID('playerLink');
            builder.add(`<a class='underline ${className}' href='#' id='${playerLinkID}'>${playerName}</a>`);
            builder.addHook(() => $(`#${playerLinkID}`).click(() => getPlNfo(playerName)));

            return builder;
          };

          return new PlayersList_();
        })();

        const FriendsList = (() => {
          const MAX_FRIENDS = 1000;

          function FriendsList_() {
            Initialization.onDocumentReady(() => this.init());
            Login.registerOnLogout(() => this.__friends = {});
            PlayersList.onChange(() => this.__refreshUI());

            // Map of friends of the current player
            // Each entry has the format name: String -> {pending: Boolean, incoming: Boolean}
            this.__friends = {};

            this.onChangeListeners = [];
          }

          FriendsList_.prototype.init = function () {
            this.__initNetworkListeners();
          };

          FriendsList_.prototype.__initNetworkListeners = function () {
            const registerUpdateListener = (msg, callback) => {
              network.registerListener(null, msg, (splitMsg) => {
                callback(splitMsg);
                this.onChangeListeners.forEach((cb) => cb());
                this.__refreshUI();
              });
            };

            registerUpdateListener('friends-list', (splitMsg) => this.__friends = JSON.parse(splitMsg[1]));
            registerUpdateListener('friend-pending', (splitMsg) => {
              this.__friends[splitMsg[1]] = { pending: true, incoming: splitMsg[2] == '1' };
            });
            registerUpdateListener('friend-added', (splitMsg) => this.__friends[splitMsg[1]].pending = false);
            registerUpdateListener('friend-removed', (splitMsg) => delete this.__friends[splitMsg[1]]);
          };

          FriendsList_.prototype.onChange = function (cb) {
            this.onChangeListeners.push(cb);
          };

          FriendsList_.prototype.isFriend = function (name) {
            return this.__friends[name] && !this.__friends[name].pending;
          };

          FriendsList_.prototype.friends = function* () {
            for (const name in this.__friends) {
              if (!this.__friends[name].pending) {
                yield name;
              }
            }
          };

          FriendsList_.prototype.onlineFriends = function* () {
            for (const name of this.friends()) {
              if (name in PlayersList.players) {
                yield name;
              }
            }
          };

          FriendsList_.prototype.pendingFriends = function* () {
            for (const name in this.__friends) {
              if (this.__friends[name].pending) {
                yield name;
              }
            }
          };

          FriendsList_.prototype.__refreshUI = function () {
            const builder = new HTMLBuilder();

            const onlineBuilder = new HTMLBuilder();
            const offlineBuilder = new HTMLBuilder();
            const outgoingBuilder = new HTMLBuilder();
            const incomingBuilder = new HTMLBuilder();

            let countFriends = 0;
            let countOnline = 0;
            let countIncoming = 0;
            let countOutgoing = 0;

            for (const name in this.__friends) {
              if (this.__friends[name].pending) {
                if (this.__friends[name].incoming) {
                  countIncoming++;
                  incomingBuilder.add(' &nbsp; ').add(PlayersList.getPlayerLink(name));

                  const acceptBtnID = uniqueID('acceptBtn');
                  const declineBtnID = uniqueID('declineBtn');
                  incomingBuilder
                    .add(` (<a href='#' class='yellowfont' id='${acceptBtnID}'>accept</a>)`)
                    .add(` (<a href='#' class='yellowfont' id='${declineBtnID}'>decline</a>)<br />`)
                    .addHook(() => $(`#${acceptBtnID}`).click(addClickSound(() => network.send(`add-friend<<$${name}`))))
                    .addHook(() => $(`#${declineBtnID}`).click(addClickSound(() => network.send(`cancel-friend<<$${name}`))));
                } else {
                  countOutgoing++;
                  outgoingBuilder.add(' &nbsp; ').add(PlayersList.getPlayerLink(name));

                  const cancelButtonID = uniqueID('cancelButton');
                  outgoingBuilder
                    .add(` (<a href='#' class='yellowfont' id='${cancelButtonID}'>cancel</a>)<br />`)
                    .addHook(() => $(`#${cancelButtonID}`).click(addClickSound(() => {
                      network.send(`cancel-friend<<$${name}`);
                    })));
                }
              } else {
                countFriends++;

                let curBuilder;
                const isOnline = name in PlayersList.players;
                if (isOnline) {
                  countOnline++;

                  curBuilder = onlineBuilder.add(' &nbsp; ')
                    .add(PlayersList.getPlayerLink(name))
                    .add(' <span class=\'online\'>online</span>');
                } else {
                  curBuilder = offlineBuilder.add(' &nbsp; ')
                    .add(PlayersList.getPlayerLink(name));
                }

                const removeButtonID = uniqueID('removeButton');
                curBuilder.add(` (<a href='#' class='yellowfont' id='${removeButtonID}'>remove</a>)<br />`);
                curBuilder.addHook(() => $(`#${removeButtonID}`).click(addClickSound(() => {
                  network.send(`cancel-friend<<$${name}`);
                })));
              }
            }

            builder.add(`<h2> &nbsp; Friends (${countFriends} / ${MAX_FRIENDS})</h2>`);
            if (countIncoming > 0) {
              builder.add(`<h2> &nbsp; Incoming requests (${countIncoming})</h2>`).add(incomingBuilder).add('<br />');
            }
            if (countOutgoing > 0) {
              builder.add(`<h2> &nbsp; Outgoing requests (${countOutgoing})</h2>`).add(outgoingBuilder).add('<br />');
            }
            if (countOnline > 0) {
              builder.add(`<h2> &nbsp; Online (${countOnline})</h2>`).add(onlineBuilder).add('<br />');
            }
            if (countFriends - countOnline > 0) {
              builder.add(`<h2> &nbsp; Offline (${countFriends - countOnline})</h2>`).add(offlineBuilder).add('<br />');
            }
            if (countOutgoing + countFriends == 0) {
              builder.add('<div id=\'noFriendsMessageDiv\'>Add someone as a friend to get notified when they come online and invite them to game lobbies.</div>');
            }
            builder.insertInto('#friendsSubdiv');

            // Add text + button to add a friend by username
            const newFriendButtonID = uniqueID('newFriendButton');
            new HTMLBuilder().add('<br /> &nbsp; <input type=\'text\' id=\'newFriendInput\' /> &nbsp; ')
              .add(`<button id='${newFriendButtonID}'>send new friend request</button><br /><br />`)
              .addHook(() => $(`#${newFriendButtonID}`).click(addClickSound(() => sendFriendRequest())))
              .insertInto('#addFriendSubDiv');

            // Update pending friends icon
            if (countIncoming) {
              $('#friendsButton').css('background-image', 'url(\'imgs/m_friends_active.png\')');
            } else {
              $('#friendsButton').css('background-image', 'url(\'imgs/m_friends.png\')');
            }
          };

          return new FriendsList_();
        })();

        const GamesList = (() => {
          function GamesList_() {
            Initialization.onDocumentReady(() => {
              this.init();
              Login.registerOnLogout(() => this.games = {});
            });

            // Map from game ID to game information
            this.games = {};

            this.onChangeCallbacks = [];
            this.onChange(() => this.__refreshGameWindow());
          }

          GamesList_.prototype.init = function () {
            const gamesWindow = new UIWindow('gamesWindow', null, false, 'Games');
            gamesWindow.title.title = 'This is the list of all current multiplayer games. ' +
              'Click on a game that hasn\'t started yet to join!';
            gamesWindow.addScrollableSubDiv('gamesWindowTextArea');
            $('#lobbyDiv').append(gamesWindow.domElement);

            network.registerListener(null, 'games-list', (splitMsg) => {
              this.games = {};
              for (let i = 1; i < splitMsg.length; i++) {
                const [id, name, numPlayers, maxPlayers, running, gameVersion, host, map, private, isMod] = splitMsg[i].split('<');
                this.games[id] = {
                  name, numPlayers, maxPlayers, gameVersion, host, map,
                  running: running == '1', private: private == '1', isMod: isMod == '1',
                };
              }

              this.onChangeCallbacks.forEach((cb) => cb(this.games));
            });
          };

          GamesList_.prototype.onChange = function (cb) {
            this.onChangeCallbacks.push(cb);
          };

          GamesList_.prototype.joinGame = function (gameID, inviteID = undefined) {
            const game = this.games[gameID];
            if (!game) {
              bingMsg('Game not found');
              return;
            }

            const aiCommit = AIManager.getAICommit();
            if (inviteID) {
              network.send(`join-game<<$${gameID}<<$${GAME_VERSION}<<$<<$${inviteID}<<$${aiCommit}`);
            } else if (game.private) {
              const pwID = uniqueID();
              const btnID = uniqueID();
              displayInfoMsg(new HTMLBuilder()
                .add('This game is password protected. Enter password:<br>')
                .add(`<input type='text' id='${pwID}' /><br><button id='${btnID}'>join</button>`)
                .addHook(() => $(`#${btnID}`).click(addClickSound(() => {
                  network.send(`join-game<<$${gameID}<<$${GAME_VERSION}<<$${$(`#${pwID}`).val()}<<$<<$${aiCommit}`);
                  fadeOut($('#infoWindow'));
                }))));
            } else {
              network.send(`join-game<<$${gameID}<<$${GAME_VERSION}<<$<<$<<$${aiCommit}`);
            }
          };

          GamesList_.prototype.__refreshGameWindow = function () {
            $('#gamesWindowTextArea').empty();

            for (const gameID in this.games) {
              const game = this.games[gameID];

              const ID = uniqueID();
              const title = `Host: ${game.host} | Game Version: ${game.gameVersion} | Map: ${game.map}`;
              let el = null;

              const gameBuilder = new HTMLBuilder();
              gameBuilder.add(`<p id='${ID}' title='${title}'>${escapeHtml(game.name)} [${game.numPlayers}/${game.maxPlayers}] `);
              if (game.running) {
                gameBuilder.add('<span class=\'running\'>running</span> ');
              }
              if (game.private) {
                gameBuilder.add('<img src=\'imgs/lock.png\' />');
              }
              gameBuilder
                .addHook(() => el = $(`#${ID}`))
                .addHook(() => el.mouseover(addZipSound(() => el[0].style.backgroundColor = 'rgba(255, 255, 255, 0.4)')))
                .addHook(() => el.mouseout(addZipSound(() => el[0].style.backgroundColor = 'rgba(0, 0, 0, 0)')))
                .addHook(() => el.click(addClickSound(() => this.joinGame(gameID))))
                .appendInto('#gamesWindowTextArea');
            }
          };

          return new GamesList_();
        })();

        const Clans = (() => {
          function Clans_() {
            Initialization.onDocumentReady(() => this.init());
          }

          Clans_.prototype.init = function () {
            this.__initNetworkListeners();
          };

          Clans_.prototype.__initNetworkListeners = function () {
            network.registerListener(null, 'clan-update', (splitMsg) => {
              this.setClan(splitMsg[1], splitMsg[2], splitMsg[3], splitMsg[4], splitMsg[5], splitMsg[6]);
              AccountInfo.clan = splitMsg[1];
            });

            network.registerListener(null, 'clan-wall', (splitMsg) => this.setClanWall(splitMsg));

            network.registerListener(null, 'clan-update-noclan', (splitMsg) => {
              this.setNoClan(splitMsg[1]);
              AccountInfo.clan = splitMsg[1];
            });

            network.registerListener(null, 'clan-info', (splitMsg) => {
              this.showClanInfo(splitMsg[1], splitMsg[2], splitMsg[3], splitMsg[4]);
            });

            network.registerListener(null, 'clans-list', (splitMsg) => {
              const oldSearchTerm = typeof ($('#clanSearchInput').val()) == 'undefined' ? '' : $('#clanSearchInput').val();

              const builder = new HTMLBuilder();

              const page = parseInt(splitMsg[1]) + 1;
              const totalPages = parseInt(splitMsg[2]);
              const clans = [];

              for (let i = 3; i < splitMsg.length - 1; i += 3) {
                clans.push({
                  tag: escapeHtml(splitMsg[i]),
                  name: escapeHtml(splitMsg[i + 1]),
                  members: escapeHtml(splitMsg[i + 2]),
                });
              }

              builder
                .add('<label id=\'clanSearchLabel\' for=\'clanSearchInput\'>Search Clans</label>')
                .add('<input type=\'text\' id=\'clanSearchInput\'><br/><br/>')
                .add('<div id=\'clanListTable\'></div>')
                .add('<div id=\'clanListPages\'></div>')
                .addHook(() => $('#clanSearchInput').keydown((e) => {
                  if (keyManager.getKeyCode(e) == KEY.ENTER) {
                    this.__requestClanPage(0);
                  }
                }));

              builder.insertInto('#addScrollableSubDivTextArea');
              uimanager.playerInfoWindow.setTitleText('Clans');

              $('#clanSearchInput').val(oldSearchTerm);

              // The window must already be open if this callback was triggered
              this.__populateClanWindow(page, totalPages, clans);

              $('#addScrollableSubDivTextArea')[0].scrollTop = 0;

              fadeIn($('#playerInfoWindow'));
            });
          };

          Clans_.prototype.__populateClanWindow = function (page, totalPages, clans) {
            // Draw the pagination tabs on the bottom
            $('#clanListPages').html('');
            if (totalPages > 1) {
              const paginationBuilder = new HTMLBuilder();
              const firstPage = page - (10 - Math.min(totalPages - page, 8));
              const lastPage = page + (10 - Math.min(page, 8));

              // Generates a button which will take us to a page of maps
              const generatePageButton = (pageNumber) => {
                const ID = uniqueID('pageButton');
                return new HTMLBuilder()
                  .add(`<button id='${ID}'>${pageNumber}</button> `)
                  .addHook(() => $(`#${ID}`).click(() => this.__requestClanPage(pageNumber - 1)));
              };

              // Insert a button for page 1 if it isn't already included, and a ... if we skip a page to reach firstPage
              if (firstPage > 1) {
                paginationBuilder.add(generatePageButton(1));
                if (firstPage - 1 > 1) {
                  paginationBuilder.add('...');
                }
              }

              // Insert the pages in the region around the current page
              for (let i = Math.max(firstPage, 1); i <= Math.min(lastPage, totalPages); i++) {
                paginationBuilder.add(i == page ? `<span>${i}</span> ` : generatePageButton(i));
              }

              // Insert a button for the last page if not already included, and a ... if there is a skip from lastPage
              if (lastPage < totalPages) {
                if (totalPages - lastPage > 1) {
                  paginationBuilder.add('...');
                }
                paginationBuilder.add(generatePageButton(totalPages));
              }

              paginationBuilder.insertInto('#clanListPages');
            }

            // Displaying the clans
            $('#clanListTable').html('');
            const builder = new HTMLBuilder();
            builder
              .add('<table><tr><td class=\'clanListTitleLine\'>Tag</td>')
              .add('<td class=\'clanListTitleLine\'>Name</td>')
              .add('<td class=\'clanListTitleLine\'>Members</td></tr><tr><td></td><td></td><td></td></tr>');

            clans.forEach((clan) => {
              const ID = uniqueID('clanLink');
              builder
                .add(`<tr><td>[<a href='#' id='${ID}' class='clanLink'>${clan.tag}</a>]</td>`)
                .add(`<td>${clan.name}</td>`)
                .add(`<td>${clan.members}</td></tr>`)
                .addHook(() => $(`#${ID}`).click(() => this.getClanInfo(`${clan.tag}`)));
            });

            builder
              .add('</table>')
              .appendInto('#clanListTable');
          };

          Clans_.prototype.__requestClanPage = function (page) {
            const search = $('#clanSearchInput').val().replace('<<$', '');

            network.send(`get-clan-list<<$${search}<<$${page}`);

            soundManager.playSound(SOUND.CLICK);
          };

          Clans_.prototype.__getClanRiders = function () {
            return new HTMLBuilder()
              .add(generateButton(null, 'riderButton', null, addClickSound(() => network.send('request-my-clan-info')), 'General'))
              .add(generateButton(null, 'riderButton', null, addClickSound(() => network.send('request-my-clan-wall')), 'Message Board'))
              .add(generateButton(null, 'riderButton', null, addClickSound(() => this.__getClanList()), 'Show All Clans'))
              .add(generateButton(null, 'riderButton', null, addClickSound(() => {
                displayConfirmPrompt('Are you sure you want to leave your clan?', () => network.send('leave-clan'), () => { });
              }), 'Leave Clan'));
          };

          Clans_.prototype.__createClanAttempt = function () {
            const tag = $('#createClanTagInput').val();
            const name = $('#createClanNameInput').val();

            if (tag.length > 0 && name.length > 0) {
              network.send('create-clan<<$' + tag + '<<$' + name);
            } else {
              displayInfoMsg('Please fill the tag and name fields');
            }
          };

          Clans_.prototype.__joinClanAttempt = function () {
            const tag = $('#joinClanTagInput').val();

            if (tag.length > 0) {
              network.send('join-clan<<$' + tag);
            } else {
              displayInfoMsg('Please fill the tag field');
            }
          };

          Clans_.prototype.setNoClan = function (applicationClanTag) {
            const div = $('#addScrollableSubDivTextArea');
            const builder = new HTMLBuilder();

            builder.add('You are not in a clan.<br /><br /><br />');

            if (applicationClanTag && applicationClanTag.length > 0) {
              builder.add(`You are currently applying to join clan [${applicationClanTag}] `);
              builder.add('(<a href=\'#\' class=\'yellowfont\' id=\'clanCancelApplication\'>cancel</a>)');
              builder.addHook(() => $('#clanCancelApplication').click(addClickSound(() => network.send('cancel-application'))));
            } else {
              builder.add('Join a clan.<br />Clan tag: [<input type=\'text\' id=\'joinClanTagInput\' maxlength=\'6\' size=\'6\' />]<br />');
              builder.add('<button id=\'clanJoinButton\'>join</button><br /><br /><br />');
              builder.addHook(() => $('#clanJoinButton').click(addClickSound(() => this.__joinClanAttempt())));

              builder.add('Create a new clan.<br />Clan tag: [<input type=\'text\' id=\'createClanTagInput\' maxlength=\'6\' size=\'6\' />]');
              builder.add('<br />Clan name: <input type=\'text\' id=\'createClanNameInput\' maxlength=\'30\' /><br />');
              builder.add('<button id=\'clanCreateButton\'>create</button>');
              builder.addHook(() => $('#clanCreateButton').click(addClickSound(() => this.__createClanAttempt())));
            }
            builder.add('<br /><br /><br /><button id=\'showAllClansButton\'>Show All Clans</button>');
            builder.addHook(() => $('#showAllClansButton').click(addClickSound(() => this.__getClanList())));

            builder.insertInto('#addScrollableSubDivTextArea');

            uimanager.playerInfoWindow.setTitleText('Your clan');
            uimanager.playerInfoWindow.setHeadRider(new HTMLBuilder());
            uimanager.playerInfoWindow.setRider(new HTMLBuilder());

            fadeIn($('#playerInfoWindow'));
          };

          Clans_.prototype.setClanWall = function (splitMsg) {
            const builder = new HTMLBuilder();

            builder.add('Clan members can post messages here for other clan members to read.<br /><br />');
            builder.add('<textarea id=\'clanWallMsgInput\' maxlength=\'800\'></textarea><br />');
            builder.add('<button id=\'clanPostWallButton\'>Send</button><br /><br />');
            builder.addHook(() => $('#clanPostWallButton').click(
              addClickSound(() => network.send('post-clan-wall<<$' + $('#clanWallMsgInput').val()))));

            for (let i = 2; i < splitMsg.length; i += 4) {
              builder.add(PlayersList.getPlayerLink(splitMsg[i]));
              builder.add(` <span class='ladderGameTimeTD'>${splitMsg[i + 3]}</span> `);

              if (splitMsg[1] > 0) {
                const buttonID = uniqueID('clanDeleteMessage');
                builder.add(`<button id='${buttonID}'>Delete</button>`);
                builder.addHook(() => $(`#${buttonID}`).click(
                  addClickSound(() => network.send(`kill-ally-msg<<$${splitMsg[i + 2]}`))));
              }

              builder.add(`<div class='profileTextDiv'>${escapeHtml(splitMsg[i + 1]).replace(/(?:\r\n|\r|\n)/g, '<br />')}</div><br />`);
            }

            builder.insertInto('#addScrollableSubDivTextArea');

            uimanager.playerInfoWindow.setTitleText('Your clan');
            uimanager.playerInfoWindow.setHeadRider(new HTMLBuilder());
            uimanager.playerInfoWindow.setRider(this.__getClanRiders());

            fadeIn($('#playerInfoWindow'));
          };

          Clans_.prototype.__editClanNameSubmit = function () {
            soundManager.playSound(SOUND.CLICK);
            network.send('change-clan-name<<$' + $('#clanNameInput')[0].value);
          };

          Clans_.prototype.__editClanName = function () {
            soundManager.playSound(SOUND.CLICK);
            $('#clanName').html(`<input type='text' id='clanNameInput' value='${$('#clanName').html()}' />`);
            $('#editClanNameButton').off('click').click(() => this.__editClanNameSubmit());
            $('#editClanNameButton').html('set');
          };

          Clans_.prototype.__editClanText = function () {
            const b = $('#clanTextButton');

            if (b.html() == 'edit') {
              $('#clanTextDiv').html('<textarea maxlength=\'800\' id=\'clanTextTextArea\'>' + $('#clanTextDiv').html().replace(/<br\s*[\/]?>/gi, '\n') + '</textarea>');
              b.html('save');
            } else {
              network.send('update-clan-text<<$' + $('#clanTextTextArea')[0].value);
              $('#clanTextDiv').html(escapeHtml($('#clanTextTextArea')[0].value).replace(/(?:\r\n|\r|\n)/g, '<br />'));
              b.html('edit');
            }

            soundManager.playSound(SOUND.CLICK);
          };

          Clans_.prototype.setClan = function (tag, name, desc, members, admin, apps) {
            const builder = new HTMLBuilder();
            const escapedDesc = desc ? escapeHtml(desc).replace(/(?:\r\n|\r|\n)/g, '<br />') : '';

            builder.add(`Tag: [${tag}]<br />Name: <span id='clanName'>${name}</span> `);
            if (admin >= 2) {
              builder.add('<button id=\'editClanNameButton\'>edit</button>');
              builder.addHook(() => $('#editClanNameButton').click(() => this.__editClanName()));
            }
            builder.add('<br />');
            builder.add(`<div id='clanTextDiv'>${escapedDesc}</div>`);
            if (admin >= 2) {
              builder.add('<button id=\'clanTextButton\'>edit</button>');
              builder.addHook(() => $('#clanTextButton').click(() => this.__editClanText()));
            }
            builder.add('<br /><br />');
            builder.add('<span class=\'biggerFont\'>Members:</span><br />');

            const membersArray = members.split(' ');
            for (let i = 0; i < membersArray.length; i += 2) {
              const memberName = membersArray[i];
              const memberRole = membersArray[i + 1];

              if (memberName.length == 0) {
                continue;
              }

              builder.add(PlayersList.getPlayerLink(memberName));
              builder.add(` <span class='lobbyLabel'>${clan_member_role_names[memberRole]}</span> `);

              if (memberName != networkPlayerName) {
                if ((admin >= 1 && memberRole == 0) || admin == 2) {
                  builder.add(` (<a href='#' id='clanMemberKick${i}' class='yellowfont'>kick</a>)`);
                  builder.addHook(() => $(`#clanMemberKick${i}`).click(
                    addClickSound(() => network.send(`kick-member<<$${memberName}`))));
                }

                if (admin >= 2 && memberRole != 0) {
                  builder.add(` (<a href='#' id='clanMemberMakeMember${i}' class='yellowfont'>make member</a>)`);
                  builder.addHook(() => $(`#clanMemberMakeMember${i}`).click(
                    addClickSound(() => network.send(`change-member-role<<$${memberName}<<$0`))));
                }

                if (admin >= 2 && memberRole != 1) {
                  builder.add(` (<a href='#' id='clanMemberMakeMod${i}' class='yellowfont'>make moderator</a>)`);
                  builder.addHook(() => $(`#clanMemberMakeMod${i}`).click(
                    addClickSound(() => network.send(`change-member-role<<$${memberName}<<$1`))));
                }

                if (admin >= 2 && memberRole != 2) {
                  builder.add(` (<a href='#' id='clanMemberMakeAdmin${i}' class='yellowfont'>make admin</a>)`);
                  builder.addHook(() => $(`#clanMemberMakeAdmin${i}`).click(
                    addClickSound(() => network.send(`change-member-role<<$${memberName}<<$2`))));
                }
              }

              builder.add('<br />');
            }

            builder.add('<br /><span class=\'biggerFont\'>Applicants:<span><br />');

            const appsArray = apps.split(' ');
            for (let i = 0; i < appsArray.length; i++) {
              if (appsArray[i].length == 0) {
                continue;
              }

              builder.add(PlayersList.getPlayerLink(appsArray[i]));

              if (admin >= 1) {
                builder.add(` (<a href='#' id='clanAcceptMember${i}' class='greenfont'>accept</a>)`);
                builder.addHook(() => $(`#clanAcceptMember${i}`).click(
                  addClickSound(() => network.send(`accept-member<<$${appsArray[i]}`))));

                builder.add(` (<a href='#' id='clanDeclineMember${i}' class='redfont'>decline</a>)`);
                builder.addHook(() => $(`#clanDeclineMember${i}`).click(
                  addClickSound(() => network.send(`decline-member<<$${appsArray[i]}`))));
              }

              builder.add('<br />');
            }

            builder.insertInto('#addScrollableSubDivTextArea');

            uimanager.playerInfoWindow.setTitleText('Your clan');
            uimanager.playerInfoWindow.setHeadRider(new HTMLBuilder());
            uimanager.playerInfoWindow.setRider(this.__getClanRiders());

            fadeIn($('#playerInfoWindow'));
          };

          Clans_.prototype.getClanInfo = function (tag) {
            soundManager.playSound(SOUND.CLICK);
            network.send('get-clan-info<<$' + tag);
          };

          Clans_.prototype.showClanInfo = function (tag, name, description, members) {
            const builder = new HTMLBuilder();

            builder.add(`Tag: [${tag}]<br />Name: ${name}<br />`);
            if (description) {
              builder.add(`<div class='profileTextDiv'>${escapeHtml(description).replace(/(?:\r\n|\r|\n)/g, '<br />')}</div>`);
            }
            builder.add('<br /><br /><span class=\'biggerFont\'>Members:</span><br />');

            const membersArray = members.split(' ');
            for (let i = 0; i < membersArray.length; i++) {
              if (membersArray[i].length > 0) {
                builder.add(PlayersList.getPlayerLink(membersArray[i]));
                builder.add('<br />');
              }
            }

            const showAllClansButtonID = uniqueID('showAllClans');
            builder.add(`<br /><br /><button id='${showAllClansButtonID}'>Show All Clans</button>`);
            builder.addHook(() => $(`#${showAllClansButtonID}`).click(
              addClickSound(() => this.__getClanList())));

            builder.insertInto('#addScrollableSubDivTextArea');

            fadeIn($('#playerInfoWindow'));

            uimanager.playerInfoWindow.setTitleText(name);
            uimanager.playerInfoWindow.setHeadRider(new HTMLBuilder());
            uimanager.playerInfoWindow.setRider(new HTMLBuilder());
          };

          Clans_.prototype.__getClanList = function () {
            network.send(`get-clan-list<<$<<$0`);
          };

          return new Clans_();
        })();

        const Microtransactions = (() => {
          // Returns a button that brings you back to the main microtransactions screen
          function getBackButton() {
            return generateButton(null, null, null, addClickSound(() => showMicroTransWindow()), 'back');
          }

          // Returns a button that, when clicked, will open a Paypal page for the item being purchased
          function getBuyWithPaypalButton(item_name, art_nr, price) {
            const builder = new HTMLBuilder();
            builder.add(' <form target="_blank" action="https://www.paypal.com/cgi-bin/webscr" method="post" id="buybutton_form">');
            builder.add('<input type="hidden" name="cmd" value="_xclick" />');
            builder.add('<input type="hidden" name="business" value="info@teachme.com" />');
            builder.add(`<input type="hidden" name="item_name" value="${item_name}" />`);
            builder.add(`<input type="hidden" id="buy_form_item_number" name="item_number" value="${art_nr}" />`);
            builder.add(`<input type="hidden" id="original_value" name="original_value" value="${art_nr}" />`);
            builder.add(`<input type="hidden" name="amount" value="${price}" />`);
            builder.add('<input type="hidden" name="no_shipping" value="1" />');
            builder.add('<input type="hidden" name="no_note" value="1"/ >');
            builder.add('<input type="hidden" name="currency_code" value="EUR" />');
            builder.add(' <button type=\'submit\' class=\'buy_button\'><span class=\'buy_button_buy\'>buy</span><span>&nbsp;for&nbsp;</span>');
            builder.add(`<span class='buy_button_price'>${price}€</span></button>`);
            builder.add('</form>');

            return builder;
          }

          // Shows a window allowing the user to purchase an item for real money for the item identified by artNr
          function showBuyForMoneyWindow(artNr, playerID) {
            let item = getItemFromArtNr(artNr);
            if (!item) {
              return;
            }

            soundManager.playSound(SOUND.CLICK);

            const builder = new HTMLBuilder();
            builder.add('<span style=\'font-size: 16px;\'><div class=\'legalDiv\'>');

            if (item.type == 'gold') {
              builder.add(`You are about to buy ${item.reward} gold for ${item.price}€. `);
              builder.add('Gold is a currency for Littlewargame. It can be used to buy emoticons, custom unit skins and more! ');
              builder.add('Gold cannot be changed back to money and it cannot be transferred to other Littlewargame accounts.');
            } else if (item.type == 'emotes') {
              builder.add(`You are about to buy the ${item.name} emote for ${item.price}€. The emote can be posted in the lobby chat.`);
            } else if (item.type == 'skins') {
              builder.add(`You are about to buy the ${item.name} skin for ${item.price}€. `);
              builder.add('This skin can be used as an alternate unit graphic in multiplayer games.');
            } else if (item.type == 'dances') {
              builder.add(`You are about to buy the ${item.name} dance for ${item.price}€. `);
              builder.add('This dance can be used to perform a dance move in multiplayer games.');
            }

            builder.add(' The bought item is fully usable for at least 3 months. After that, in rare cases, the usage might be limited or altered, for example when the game is modified through updates. ');
            builder.add('The payment will be handled via Paypal. The bought item will be activated and usable shortly after a successful payment. In rare cases, the activation can take longer up to several hours due to technical difficulties. ');
            builder.add('This is a one-time payment. No further costs are incurred.<br /><input type=\'checkbox\' id=\'check1\' /><label for=\'check1\'> I have read and accepted the above text</label></div>');

            // agb
            builder.add('<div class=\'legalDiv\'><input type=\'checkbox\' id=\'check2\' /><label for=\'check2\'>');
            builder.add(' I accept the <a class=\'underline\' id=\'termsAndConditions\'>Terms and Conditions</a></label></div>');
            builder.addHook(() => $('#termsAndConditions').click(showAGB));

            builder.add('<div class=\'legalDiv\'><input type=\'radio\' name=\'legal_radio\' id=\'check3\' value=\'1\' /><label for=\'check3\'>');
            builder.add(' I accept the <a class=\'underline\' id=\'cancellationPolicy\'>Cancellation policy</a> and explicitly demand that you start providing the demanded service right now, before the end of the cancellation period. I am aware that I lose my right of cancellation on complete fulfilment of the contract from your side.</label>');
            builder.addHook(() => $('#cancellationPolicy').click(showWRE));

            builder.add('<br /><input type=\'radio\' name=\'legal_radio\' id=\'check4\' value=\'2\' /><label for=\'check4\'> I do not accept and want to use the service only after the end of the cancellation period (3 months)</label></div><br />');

            builder.add(getBuyWithPaypalButton(item.name, item.artNr + '_' + playerID, item.price));
            builder.add('</span>');

            builder.insertInto('#addScrollableSubDivTextArea');

            fadeIn($('#playerInfoWindow'));
            uimanager.playerInfoWindow.setTitleText('Buy item');
            uimanager.playerInfoWindow.setHeadRider(new HTMLBuilder());
            uimanager.playerInfoWindow.setRider(new HTMLBuilder());

            $('#buybutton_form').on('submit', onSubmit);
          }

          // Generates a button that will open a window to allow the user to purcahse the item identified by artNr
          function getBuyForMoneyButton(artNr, price, playerID) {
            const builder = new HTMLBuilder();

            const disabledButton = MICROTRANSACTIONSENABLED ? '' : 'disabled';

            const buttonID = uniqueID('buyButton');
            builder.add(` <button ${disabledButton} id='${buttonID}' class='buy_button'>`);
            builder.add(`<span class='buy_button_buy'>buy</span> <span>for</span> <span class='buy_button_price'>${price}€</span></button>`);
            builder.addHook(() => $(`#${buttonID}`).click(() => showBuyForMoneyWindow(artNr, playerID)));

            return builder;
          }

          // Displays a dialog allowing the user to confirm they want to purchase the item identified by artNr
          function getItemForGold(artNr) {
            soundManager.playSound(SOUND.CLICK);

            let arch = emotes.concat(skins, dances, specials);
            let matchingItem = arch.find((item) => item.artNr == artNr);

            if (matchingItem) {
              displayInfoMsg(
                new HTMLBuilder()
                  .add(`Get ${matchingItem.name} for ${matchingItem.gold} gold?`)
                  .add('<br /><br /><br />')
                  .add('<button id=\'getItemForGoldButton\'>Get it!</button>')
                  .addHook(
                    () => $('#getItemForGoldButton').click(
                      addClickSound(() => {
                        network.send(`get-item-4-gold<<$${artNr}`);
                        fadeOut($('#infoWindow'));
                      }),
                    ),
                  ),
              );
            }
          }

          // Generates a button allowing the user to buy an item for gold, or an error message if they don't have enough
          //  verb - An imperative verb phrase describing the item for purchase
          //  itemGold - The cost of the item in gold
          //  artNr - The artNr that uniquely identifies the item
          function getBuyForGoldButton(verb, itemGold, artNr) {
            const builder = new HTMLBuilder();

            if (AccountInfo.gold >= itemGold) {
              const text = `${verb} for ${itemGold} gold`;
              const buttonID = uniqueID('buyButton');

              builder.add(`<button class='buy_button' id='${buttonID}'>${text}</button>`);
              builder.addHook(() => $(`#${buttonID}`).click(() => getItemForGold(artNr)));
            } else {
              builder.add(`<span class='redfont'>${itemGold} gold required</span>`);
            }

            return builder;
          }

          // Shows the requirement to continue with a transaction (level, division, gold, price, etc)
          // Generates a purchase option button if the requirement is gold or money
          function getTransRequirements(artNr, playerID, isUnlocked, price, gold, playerLvl, div, special, specialRequirementText) {
            const builder = new HTMLBuilder();

            if (isUnlocked) {
              builder.add('<font class=\'greenfont\'>unlocked</font>');
            } else if (price) {
              builder.add(getBuyForMoneyButton(artNr, price, playerID));
            } else if (gold) {
              builder.add(getBuyForGoldButton('Get', gold, artNr));
            } else if (playerLvl) {
              builder.add(`Level ${playerLvl} required`);
            } else if (div) {
              builder.add(`${leagueNames[div - 1]} required`);
            } else if (special) {
              builder.add(specialRequirementText);
            }

            return builder;
          }

          function showTreasureInfo() {
            const builder = new HTMLBuilder();

            builder.add('<div id=\'premium_window\'><img class=\'pixelated\' style=\'height: 120px;\' src=\'imgs/emotes/chest.png\'><br /><br />');

            builder.add('<p style=\'color: rgb(255, 248, 57); font-size: 22px;\'>Treasure Chest</p>');
            builder.add('<div class=\'profileTextDiv\'>Treasure chests contain random items, you never know what you will get. ');
            builder.add('You may get some gold, an item or something else. There may be even secret items in some treasure chests.</div>');
            builder.add('<br /><br />');

            const treasureChest = specials[1];
            builder.add(getBuyForGoldButton('Buy a treasure chest', treasureChest.gold, treasureChest.artNr));
            builder.add('</div>');

            builder.insertInto('#addScrollableSubDivTextArea');

            fadeIn($('#playerInfoWindow'));
            uimanager.playerInfoWindow.setTitleText('Treasure Chest');
            uimanager.playerInfoWindow.setHeadRider(getBackButton());
            uimanager.playerInfoWindow.setRider(new HTMLBuilder());
          }

          function showPremiumInfo() {
            const builder = new HTMLBuilder();
            const secLeft = (AccountInfo.premiumExpiry - parseInt(Date.now() / 1000));

            builder.add('<div id=\'premium_window\'><img class=\'pixelated\' style=\'height: 140px;\' src=\'imgs/emotes/premium.png\'><br /><br />');

            builder.add('<p>A premium account includes the following features:</p>');
            builder.add('<div class=\'profileTextDiv\'><div><span class=\'likePremiumColor\'>Green player name:</span> You name will show up in green instead of yellow</div>');
            builder.add('<div><span class=\'likePremiumColor\'>Bonus XP:</span> You will receive 25% more experience from games</div>');
            builder.add('<div><span class=\'likePremiumColor\'>Emotes:</span> Includes the following emotes:</div><div>');

            for (let i = 0; i < emotes.length; i++) {
              if (emotes[i].special && emotes[i].special == 'requires_premium') {
                builder.add(`<img class='buytableImgs' src='imgs/emotes/${emotes[i].img}' /> `);
              }
            }

            builder.add('</div></div><br />');

            if (secLeft > 0) {
              builder.add(`<div>Your premium account expires in <span class='ladderGameTimeTD'>${secToDate(secLeft)}</span></div><br />`);
            }

            const pr = specials[0];
            builder.add(getBuyForGoldButton(secLeft > 0 ? 'Extend by 30 days' : 'Get 30 days of premium', pr.gold, pr.artNr));

            builder.insertInto('#addScrollableSubDivTextArea');

            fadeIn($('#playerInfoWindow'));
            uimanager.playerInfoWindow.setTitleText('Premium Account');
            uimanager.playerInfoWindow.setHeadRider(getBackButton());
            uimanager.playerInfoWindow.setRider(new HTMLBuilder());
          }

          function showEmotesInfo(emotesHex32, playerID) {
            const playerGold = AccountInfo.gold;
            const emotesBin = hex32ToBin(emotesHex32);

            const builder = new HTMLBuilder();
            builder.add('<div><br />&nbsp; &nbsp;Emotes are small icons that can be used in lobby chat.<br /><br /></div>');

            for (let i = 0; i < emotes.length; i++) {
              const isUnlocked = emotes[i].free ||
                (emotes[i].dbPos && emotes[i].dbPos <= emotesBin.length && emotesBin.substr(emotesBin.length - emotes[i].dbPos, 1) == '1');

              let title = '';

              if (isUnlocked) {
                title = `Type ${emotes[i].text} in chat to use this emote`;
              } else if (emotes[i].price) {
                title = MICROTRANSACTIONSENABLED ? `Buy this emote for ${emotes[i].price}€` : 'In game purchases temporarily disabled';
              } else if (emotes[i].gold) {
                title = (playerGold >= emotes[i].gold) ?
                  `Get this emote for ${emotes[i].gold} gold` :
                  `You need ${emotes[i].gold} gold for this emote`;
              } else if (emotes[i].playerLvl) {
                title = `This emote will be unlocked when your account reaches level ${emotes[i].playerLvl}`;
              } else if (emotes[i].div) {
                title = `This emote will be unlocked when you reach ${leagueNames[emotes[i].div - 1]} or a higher league`;
              } else if (emotes[i].special) {
                title = emotes[i].requirementTitle;
              }

              builder.add(`<div class='buytable2' title='${title}'><p><img class='buytableImgs' src='imgs/emotes/${emotes[i].img}' /></p>`);
              builder.add(`<p class='buytableNames'>${emotes[i].name}</p><div class='buytablePurchased'>`);

              builder.add(getTransRequirements(
                emotes[i].artNr, playerID, isUnlocked, emotes[i].price, emotes[i].gold,
                emotes[i].playerLvl, emotes[i].div, emotes[i].special, emotes[i].requirementText,
              ));
              builder.add('</div></div>');
            }

            builder.insertInto('#addScrollableSubDivTextArea');

            fadeIn($('#playerInfoWindow'));

            uimanager.playerInfoWindow.setTitleText('Emotes');
            uimanager.playerInfoWindow.setHeadRider(getBackButton());
            uimanager.playerInfoWindow.setRider(new HTMLBuilder());
          }

          function showSkinsDancesInfo(playerID, skinsBin, skinsObj, dancesBin) {
            const playerGold = AccountInfo.gold;
            const builder = new HTMLBuilder();

            // Skins
            builder.add('<div>Purchase custom skins for your units!</div>');

            for (let k = 0; k < basicUnitTypes.length; k++) {
              // Scales width and height so it fits maximally in a 100x100 box while preserving aspect ratio
              const scaleWidthHeight = (w, h, maxDim) => {
                if (w > h) {
                  return { w: maxDim, h: maxDim * (h / w) };
                } else {
                  return { w: maxDim * (w / h), h: maxDim };
                }
              };

              // Helper method to set the currently active skin for a given unit type
              const setSkin = (artNr, unitType, skinNumber) => {
                for (let i = 0; i < 39; i++) {
                  $(`#skins_${unitType}_${i}`).removeClass('b_active').addClass('b_inactive');
                }
                $(`#skins_${unitType}_${skinNumber}`).removeClass('b_inactive').addClass('b_active');

                soundManager.playSound(SOUND.CLICK);
                network.send('set-skin<<$' + artNr + '<<$' + unitType);
              };

              // Helper method which adds a skin button to the list
              const addSkin = (img, isUnlocked, skinNumber, skin = {}) => {
                let dimensions = scaleWidthHeight(img.idle.frameWidth, img.idle.h / img._angles, 100);

                const w2 = img.file[1].width * (dimensions.w / img.idle.frameWidth);
                const h2 = img.file[1].height * (dimensions.h / (img.idle.h / img._angles));
                const x = img.idle.x * (w2 / img.file[1].width);
                const y = img.idle.y * (h2 / img.file[1].height);
                const name = skin.name || 'Default';

                const buttonID = `skins_${basicUnitTypes[k].id_string}_${skinNumber}`;
                const buttonClass = (() => {
                  // Default skin is enabled if none of the others are
                  if (skin == {}) {
                    return skinsObj[basicUnitTypes[k].id_string] ? 'b_inactive' : 'b_active';
                  }
                  // Otherwise, check skinsObj for a match with the current skin
                  else if (isUnlocked) {
                    return skinsObj[basicUnitTypes[k].id_string] == skin.artNr ? 'b_active' : 'b_inactive';
                  } else {
                    return 'b_disabled';
                  }
                })();
                const imgSrc = img.file[1].toDataURL ? img.file[1].toDataURL() : img.file[1].src;

                builder.add(`<div><button id='${buttonID}' class='buytableImgs2 ${buttonClass}'>`);
                if (isUnlocked) {
                  builder.addHook(() => $(`#${buttonID}`).click(() => setSkin(skin.artNr || null, basicUnitTypes[k].id_string, skinNumber)));
                }

                builder.add(`<div style='width: ${dimensions.w}px; height: ${dimensions.h}px; overflow: hidden; position: relative;'>`);
                builder.add(`<img style='position: absolute; left: ${-x}px; top: ${-y}px; width: ${w2}px; height: ${h2}px;' src='${imgSrc}' />`);
                builder.add('</div></button>');

                builder.add(`<p class='buytableNames'>${name}</p><p class='buytablePurchased'>`);

                builder.add(getTransRequirements(
                  skin.artNr, playerID, isUnlocked, skin.price, skin.gold,
                  skin.playerLvl, skin.div, null, null,
                ));
                builder.add('</p></div>');
              };

              // Add the skins for this unit type if they exist
              const matchingSkins = skins.filter((skin) => skin.unit_id_string == basicUnitTypes[k].id_string);
              if (matchingSkins.length > 0) {
                let skinNumber = 0;

                builder.add('<div class=\'buytable\'>');
                builder.add(`<p class='buytable_title'>${basicUnitTypes[k].name}</p>`);

                // Add default skin first
                addSkin(unit_imgs[basicUnitTypes[k].img], true, skinNumber++);

                // Add custom skins
                for (let i = 0; i < matchingSkins.length; i++) {
                  const skin = matchingSkins[i];
                  const isUnlocked = skin.free ||
                    (skin.dbPos && skin.dbPos <= skinsBin.length && skinsBin.substr(skinsBin.length - skin.dbPos, 1) == '1');

                  addSkin(unit_imgs[skin.img], isUnlocked, skinNumber++, skin);
                }
                builder.add('</div>');
              }
            }

            // Dances
            builder.add('<div style=\'clear: both;\'><br /><h2>&nbsp; &nbsp;Dances</h2></div><div>&nbsp; &nbsp;Some of your units can perform dance animations in game.<br /><br /></div>');

            const offsets = [];
            const maxs = [];
            const xs = [];
            const ys = [];
            let j = 0;

            for (let k = 0; k < basicUnitTypes.length; k++) {
              // Add the dances for this unit type if they exist
              const matchingDances = dances.filter((dance) => dance.unit_id_string == basicUnitTypes[k].id_string);
              if (matchingDances.length > 0) {
                builder.add('<div class=\'buytable\'>');
                builder.add(`<p class='buytable_title'>${basicUnitTypes[k].name}</p>`);

                for (let i = 0; i < matchingDances.length; i++) {
                  const dance = matchingDances[i];
                  const isUnlocked = dance.free ||
                    (dance.dbPos && dance.dbPos <= dancesBin.length && dancesBin.substr(dancesBin.length - dance.dbPos, 1) == '1');

                  const img = unit_imgs[basicUnitTypes[k].img][dance.animName];
                  const file = unit_imgs[basicUnitTypes[k].img].file[1];

                  offsets.push(img.frameWidth * 4);
                  maxs.push(img.w * 4);
                  xs.push(img.x * 4);
                  ys.push(img.y * 4);

                  const divTitle = isUnlocked ?
                    `Select units ingame and type ${dance.chat_str} in chat to make them perform this dance` : '';

                  builder.add(`<div title='${divTitle}'>`);
                  builder.add(`<div class='dancediv' style='width: ${img.frameWidth * 4}px;'>`);
                  builder.add(`<img id='dance_img_${j}' style='margin-left: 0; height: ${4 * file.height}px;' class='pixelated' src='${file.toDataURL()}' />`);
                  builder.add('</div>');
                  builder.add(`<p class='buytableNames'>${dance.name}</p><p class='buytablePurchased'>`);

                  builder.add(getTransRequirements(
                    dance.artNr, playerID, isUnlocked, dance.price, dance.gold,
                    dance.playerLvl, dance.div, null, null,
                  ));
                  builder.add('</p></div>');
                  j++;
                }

                builder.add('</div>');
              }
            }

            animateDances(offsets, maxs, xs, ys);

            builder.insertInto('#addScrollableSubDivTextArea');

            fadeIn($('#playerInfoWindow'));
            uimanager.playerInfoWindow.setTitleText('Skins & Dances');
            uimanager.playerInfoWindow.setHeadRider(getBackButton());
            uimanager.playerInfoWindow.setRider(new HTMLBuilder());
          }

          // Shows a window that allows the user to purchase gold for money
          function showBuyGoldWindow(myId) {
            const builder = new HTMLBuilder();

            builder.add(`<div style='margin: 14px;'>${goldDescription}</div>`);

            for (let i = 0; i < goldPacks.length; i++) {
              const g = goldPacks[i];
              builder.add(`<div class='gold_buy_div' title='Buy ${g.reward} gold for ${g.price} €'>`);
              builder.add(`<div class='buy_gold_title'>${g.name}</div>`);
              builder.add(`<div class='buy_gold_reward_div'><span class='buy_gold_span'>${g.reward}</span>`);
              builder.add(' <img src=\'imgs/gold2.png\' class=\'pixelated\' style=\'width: 48px;\' /></div>');

              builder.add('<div>');
              builder.add(getBuyForMoneyButton(g.artNr, g.price, myId));
              builder.add('</div></div>');
            }

            builder.insertInto('#addScrollableSubDivTextArea');

            uimanager.playerInfoWindow.setTitleText('Gold');
            uimanager.playerInfoWindow.setHeadRider(new HTMLBuilder());
            uimanager.playerInfoWindow.setRider(new HTMLBuilder());
            fadeIn($('#playerInfoWindow'));
            soundManager.playSound(SOUND.CLICK);
          }

          function showMicroTransWindow() {
            const builder = new HTMLBuilder();

            builder.add('<br /><button class=\'microTransButton\' id=\'microTransEmoteButton\'>Emotes</button>');
            builder.addHook(() => $('#microTransEmoteButton').click(
              addClickSound(() => network.send('request-emotes-info'))));

            builder.add('<button class=\'microTransButton\' id=\'microTransSkinsButton\'>Skins & Dances</button>');
            builder.addHook(() => $('#microTransSkinsButton').click(
              addClickSound(() => network.send('request-skins-info'))));

            builder.add('<button class=\'microTransButton\' id=\'microTransPremiumButton\'>Premium Account</button>');
            builder.addHook(() => $('#microTransPremiumButton').click(
              addClickSound(() => showPremiumInfo())));

            builder.add('<button class=\'microTransButton\' id=\'microTransTreasureButton\'>Treasure Chest</button>');
            builder.addHook(() => $('#microTransTreasureButton').click(
              addClickSound(() => showTreasureInfo())));

            builder.insertInto('#addScrollableSubDivTextArea');

            fadeIn($('#playerInfoWindow'));
            uimanager.playerInfoWindow.setTitleText('Unlockable Items');
            uimanager.playerInfoWindow.setHeadRider(new HTMLBuilder());
            uimanager.playerInfoWindow.setRider(new HTMLBuilder());
          }

          return {
            showEmotesInfo,
            showSkinsDancesInfo,
            showBuyGoldWindow,
            showMicroTransWindow,
          };
        })();

        const PlayerInfo_showLadderInfo = (function () {
          const ladderResultTableID = 'ladderResultTableID';

          const FILTER_TYPE = {
            // 'players' and 'map' _also_ both map to
            // property names in Match.
            // 'all' is used only for filter config
            players: 'players',
            map: 'map',
            all: 'all',
          };

          return PlayerInfo_showLadderInfo;

          function addFilterSectionByType(builder, userId, allMatchesInHistory, playerName, playerFilteredBy, mapSelectedToFilterBy, filterType, that) {
            const filteredValues = sortFilteredValuesByType(allMatchesInHistory, playerName, filterType);
            const popupMsgsBuilder = new HTMLBuilder();
            const selectID = uniqueID();

            builder
              .add(`<p>Filter by ${filterType}: `)
              .add(`<select class="filterRankedResultsByType" id='${selectID}'>`);

            builder.add(`<option value=${FILTER_TYPE.all}>ALL</option>`);
            filteredValues.forEach((playerName) => {
              builder.add(`<option value='${playerName}'>${playerName}</option>`);
            });

            let valueToInitializeOn = '';
            switch (filterType) {
              case FILTER_TYPE.players: {
                valueToInitializeOn = playerFilteredBy;
                break;
              }
              case FILTER_TYPE.map: {
                valueToInitializeOn = mapSelectedToFilterBy;
                break;
              }
              default: {
                console.error('filterType: ' + filterType);
              }
            }

            builder
              .add('</select>')
              .add('</p>')
              .addHook(() => $(`#${selectID}`).val(valueToInitializeOn)) // which value to initialize to
              .addHook(() => {
                $(`#${selectID}`).change(() => {
                  let newValueOfFilterType = $(`#${selectID}`).val();
                  switch (filterType) {
                    case FILTER_TYPE.players: {
                      that.__showLadderInfo(userId, playerName, allMatchesInHistory, 1, newValueOfFilterType, mapSelectedToFilterBy);
                      break;
                    }
                    case FILTER_TYPE.map: {
                      that.__showLadderInfo(userId, playerName, allMatchesInHistory, 1, playerFilteredBy, newValueOfFilterType);
                      break;
                    }
                    default: {
                      console.error('incorrect filter type provided');
                    }
                  }
                  soundManager.playSound(SOUND.CLICK);
                });
              });
          }

          function sortFilteredValuesByType(allMatchesInHistory, playerName, filterType) {
            switch (filterType) {
              case FILTER_TYPE.map: {
                // sort by ABC
                return _.sortBy(
                  Array.from(new Set(allMatchesInHistory.map((match) => match[filterType]).flat(Infinity))),
                  (val) => val.toLowerCase(),
                );
              }
              case FILTER_TYPE.players: {
                // matches are in 'most recent' ordering
                const playerNamesOnly = allMatchesInHistory.map((match) =>
                  // only 2 names provided here, profile being viewed player and their opponent
                  match.players.filter((player) => player !== playerName)[0],
                );
                // _.uniq preserves ordering
                return _.uniq(playerNamesOnly);
              }
              case FILTER_TYPE.all: {
                throw new Error('FILTER_TYPE.all not valid for this fn');
              }
            }
          }

          function getCurrentMatchesToDisplay(allMatchesInHistory, playerFilteredBy, mapSelectedToFilterBy) {
            let filteredMatches = [];
            if (playerFilteredBy === FILTER_TYPE.all) {
              filteredMatches = allMatchesInHistory;
            } else {
              filteredMatches = allMatchesInHistory.filter((match) => {
                return match.players.includes(playerFilteredBy);
              });
            }

            if (mapSelectedToFilterBy !== FILTER_TYPE.all) {
              filteredMatches = filteredMatches.filter((match) => {
                return match.map === mapSelectedToFilterBy;
              });
            }

            return filteredMatches;
          }

          function addWinLossForNonSelfProfileView(builder, currentMatchesToDisplay, playerName) {
            // render record caption against this player
            // get win/loss record vs player if logged in
            if (networkPlayerName && networkPlayerName != playerName) {
              let wins = 0;
              let losses = 0;
              currentMatchesToDisplay.forEach((match) => {
                if ((match.players[0] == networkPlayerName && match.players[1] == playerName) || (match.players[1] == networkPlayerName && match.players[0] == playerName)) {
                  // flipped because from your own perspective
                  if (match.result == 'win') {
                    losses++;
                  } else if (match.result == 'loss') {
                    wins++;
                  }
                }
              });
              builder.add(`<p style="padding-bottom: 10px">Your ladder record vs this player: <span class='greenfont'>${wins}</span> - <span class='redfont'>${losses}</span></p>`);
            }
          }

          function PlayerInfo_showLadderInfo(userId, playerName, allMatchesInHistory, currentPage, playerFilteredBy = FILTER_TYPE.all, mapSelectedToFilterBy = FILTER_TYPE.all) {
            const builder = new HTMLBuilder();
            let currentMatchesToDisplay = getCurrentMatchesToDisplay(allMatchesInHistory, playerFilteredBy, mapSelectedToFilterBy);

            addWinLossForNonSelfProfileView(builder, allMatchesInHistory, playerName);

            addFilterSectionByType(builder, userId, allMatchesInHistory, playerName, playerFilteredBy, mapSelectedToFilterBy, FILTER_TYPE.players, this);
            builder.add('<div style="margin-bottom: 2px"></div>');
            addFilterSectionByType(builder, userId, allMatchesInHistory, playerName, playerFilteredBy, mapSelectedToFilterBy, FILTER_TYPE.map, this);
            builder.add('<br />');
            buildLadderResultTable(currentMatchesToDisplay, currentPage, builder);

            this.__generatePlayerWindow(userId, playerName, builder);

            const totalPages = Math.ceil(currentMatchesToDisplay.length / 20);

            // Draw the pagination tabs on the bottom
            if (totalPages > 1) {
              const paginationBuilder = new HTMLBuilder();
              paginationBuilder.add(`<div style="text-align: center">`);
              const firstPage = currentPage - (10 - Math.min(totalPages - currentPage, 8));
              const lastPage = currentPage + (10 - Math.min(currentPage, 8));


              // Generates a button which will take us to a page of ladder history
              const generatePageButton = (pageNumber) => {
                const ID = uniqueID('pageButton');
                return new HTMLBuilder()
                  .add(`<button id='${ID}'>${pageNumber}</button> `)
                  .addHook(() => $(`#${ID}`).click(() => {
                    this.__showLadderInfo(userId, playerName, allMatchesInHistory, pageNumber, playerFilteredBy, mapSelectedToFilterBy);
                    soundManager.playSound(SOUND.CLICK);
                  }));
              };

              // Insert a button for page 1 if it isn't already included, and a ... if we skip a page to reach firstPage
              if (firstPage > 1) {
                paginationBuilder.add(generatePageButton(1));
                if (firstPage - 1 > 1) {
                  paginationBuilder.add('...');
                }
              }

              // Insert the pages in the region around the current page
              for (let i = Math.max(firstPage, 1); i <= Math.min(lastPage, totalPages); i++) {
                paginationBuilder.add(i == currentPage ? `<span>${i}</span> ` : generatePageButton(i));
              }

              // Insert a button for the last page if not already included, and a ... if there is a skip from lastPage
              if (lastPage < totalPages) {
                if (totalPages - lastPage > 1) {
                  paginationBuilder.add('...');
                }
                paginationBuilder.add(generatePageButton(totalPages));
              }

              paginationBuilder.add('</div>');

              paginationBuilder.appendInto('#addScrollableSubDivTextArea');

              $('#addScrollableSubDivTextArea')[0].scrollTop = 0;
            }
          }


          function buildLadderResultTable(matches, currentPage, builder) {
            builder.add(`
    <p>Ladder results:</p>
    <table id="${ladderResultTableID}">
    `);
            buildLadderResultRowsHTML(matches, currentPage, builder);
            builder.add(`</table>`);
          }

          function buildLadderResultRowsHTML(matches, currentPage, builder) {
            for (var i = (currentPage - 1) * 20; i < currentPage * 20; i++) {
              const match = matches[i];
              if (!match) {
                break;
              }
              buildLadderResultRowHTML(match, builder);
            }
          }

          /*
          type Match = {
            map: string,
            players: Array[string, string],
            result: 'win' | 'loss',
            time: '2024-1-30'
          }
          */
          function buildLadderResultRowHTML(match, builder) {
            builder.add('<tr>');
            buildLadderResultPlayerCell(match.players[0], builder);
            buildLadderResultVsCell(builder);
            buildLadderResultPlayerCell(match.players[1], builder);
            buildLadderResultOutcomeCellHTML(match, builder);
            buildLadderResultTimeCell(match, builder);
            buildLadderResultMapCell(match, builder);
            builder.add('</tr>');
          }

          function buildLadderResultMapCell(match, builder) {
            builder.add(`<td class='nowrap'> &nbsp; ${match.map}</td></tr>`);
          }

          function buildLadderResultVsCell(builder) {
            builder.add(`<td class='nowrap'> vs </td>`);
          }

          function buildLadderResultTimeCell(match, builder) {
            builder.add(`<td class='ladderGameTimeTD nowrap'> &nbsp; ${match.time}</td>`);
          }

          function buildLadderResultTimeCell(match, builder) {
            builder.add(`<td class='ladderGameTimeTD nowrap'> &nbsp; ${match.time}</td>`);
          }

          function buildLadderResultPlayerCell(player, builder) {
            builder.add('<td>');
            builder.add(PlayersList.getPlayerLink(player));
            builder.add('</td>');
          }

          function buildLadderResultOutcomeCellHTML(match, builder) {
            let cellHtml = `<td class='nowrap'>`;
            if (match.result == 'win') {
              cellHtml += '<span class=\'greenfont\'>win</span>';
            } else if (match.result == 'loss') {
              cellHtml += '<span class=\'redfont\'>loss</span>';
            } else {
              cellHtml += '<span style=\'color: yellow;\'>-</span>';
            }
            cellHtml += '</td>';
            builder.add(cellHtml);
          }
        })();



        const PlayerInfo = (() => {
          function PlayerInfo_() {
            Initialization.onDocumentReady(() => this.init());

            // Keeps track of which players are our friends, for the purposes of showing the add friend button
            // This information is dependent on server updates / when the add friend button is pressed
            // Since this information isn't sent on every player info request, it must be cached
            // TODO: currently, the server sends the information as-needed with the knowledge
            //  of how the UI operates (for example, you can't view ladder games without first
            //  viewing the main player-info screen, so the server doesn't send friend info on ladder games).
            //  Decouple the server and UI behavior!
            this.__cachedFriends = {};
          }

          PlayerInfo_.prototype.init = function () {
            this.__initNetworkListeners();
          };

          PlayerInfo_.prototype.__initNetworkListeners = function () {
            network.registerJSONListener(null, 'player-info', (properties) => this.showPlayerInfo(properties));
            network.registerJSONListener(null, 'player-info-ladder', (properties) => this.__playerInfoLadderListener(properties));
            network.registerJSONListener(null, 'player-info-friends', (properties) => this.__showFriends(properties));
            network.registerJSONListener(null, 'player-info-maps', (properties) => this.__showMaps(properties));
            network.registerJSONListener(null, 'player-info-achievements', (properties) => {
              const { userId, username, emotes, skins, dances, achievements } = properties;
              const playerAchievements = [];
              const playerEmotes = [];

              for (let i = 0; i < achivements.length; i++) {
                if (checkDBPos(achivements[i].dbPos, achievements)) {
                  playerAchievements.push(achivements[i]);
                }
              }

              const allEmotes = emotes.concat(_emotes2);
              for (let i = 0; i < allEmotes.length; i++) {
                const emote = allEmotes[i];
                if (emote.free || (emote.dbPos && emote.dbPos <= emotes.length && emotes.substr(emotes.length - emote.dbPos, 1) == '1')) {
                  playerEmotes.push(allEmotes[i]);
                }
              }

              this.__showAchievements(userId, username, playerAchievements, playerEmotes);
            });
          };

          PlayerInfo_.prototype.__playerInfoLadderListener = function (properties) {
            const { ladderGames, userId, username, seasonId } = properties;
            ladderGames.forEach((game) => {
              game.players = [game.player1Name, game.player2Name];

              if (game.winner === userId) {
                game.result = 'win';
              } else {
                game.result = 'loss';
              }
              const date = new Date(game.timestamp);
              game.time = `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`;
              game.map = game.mapName;
            });

            this.__showLadderInfo(userId, username, ladderGames, 1);
          };

          PlayerInfo_.prototype.__getPlayerTopRiders = function (player, addFriendButton) {
            const builder = new HTMLBuilder();

            if (player != networkPlayerName) {
              builder.add(generateButton(null, 'inlineChatButton', 'Chat with this player', () => Chats.openChatFor(player, true)), null);
            }

            if (addFriendButton) {
              builder.add(generateButton(
                'inlineFriendButton',
                'riderButton',
                'Add this player as a friend',
                addClickSound(() => {
                  network.send('add-friend<<$' + player);
                  this.__cachedFriends[player] = true;
                  $('#inlineFriendButton').remove();
                  bingMsg('Friendship request sent');
                }),
                null,
              ));
            }

            if (player != networkPlayerName && Login.loginState == Login.LoginStates.PLAYER) {
              const setVisibility = (isIgnored) => {
                if (isIgnored) {
                  $('#inlineUnignoreButton').show();
                  $('#inlineIgnoreButton').hide();
                } else {
                  $('#inlineIgnoreButton').show();
                  $('#inlineUnignoreButton').hide();
                }
              };

              const ignoreButton = generateButton('inlineIgnoreButton', 'riderButton', 'Ignore this player', () => {
                network.send('ignore<<$' + player);
                soundManager.playSound(SOUND.CLICK);
                setVisibility(true);
              }, 'ignore');

              const unignoreButton = generateButton('inlineUnignoreButton', 'riderButton', 'Unignore this player', () => {
                network.send('unignore<<$' + player);
                soundManager.playSound(SOUND.CLICK);
                setVisibility(false);
              }, 'unignore');

              builder.add(ignoreButton);
              builder.add(unignoreButton);

              // Initialize the button based on whether or not the player is currently ignored
              builder.addHook(() => setVisibility(AccountInfo.ignores.contains(player.toLowerCase())));
            }

            if (player != networkPlayerName && (AccountInfo.isMod || AccountInfo.isAdmin)) {
              builder.add(generateButton('banjaminButton', 'riderButton', null, () => reallyBan(player), 'ban'));
            }

            return builder;
          };

          PlayerInfo_.prototype.__getPlayerNavRiders = function (userId, player) {
            const generatePlayerInfoButton = (buttonText, networkMsg) => {
              const buttonID = uniqueID('playerInfoButton');
              return new HTMLBuilder()
                .add(`<button id='${buttonID}'>${buttonText}</button>`)
                .addHook(() => $(`#${buttonID}`).click(
                  addClickSound(() => {
                    network.send(JSON.stringify({ message: networkMsg, properties: { userId } }));
                  })));
            };

            return new HTMLBuilder()
              .add(generatePlayerInfoButton('General', 'get-player-info'))
              .add(generatePlayerInfoButton('Laddergames', 'get-ladder-history')) // Can use ladderSeasonId to get current season if necessary
              .add(generatePlayerInfoButton('Friends', 'get-player-friends'))
              .add(generatePlayerInfoButton('Maps', 'get-player-maps'))
              .add(generatePlayerInfoButton('Achievements', 'get-player-achievements'));
          };

          PlayerInfo_.prototype.__generatePlayerWindow = function (userId, playerName, builder) {
            uimanager.playerInfoWindow.setTitleText(`Player ${playerName}`);

            const addFriendButton = !this.__cachedFriends[playerName] && playerName != networkPlayerName && AccountInfo.authedAndLogged;
            uimanager.playerInfoWindow.setHeadRider(this.__getPlayerTopRiders(playerName, addFriendButton));
            uimanager.playerInfoWindow.setRider(this.__getPlayerNavRiders(userId, playerName));

            builder.insertInto('#addScrollableSubDivTextArea');
            fadeIn($('#playerInfoWindow'));
          };

          PlayerInfo_.prototype.showPlayerInfo = function (props) {
            const {
              id,
              username,
              countGames,
              isMod,
              isAdmin,
              league,
              wins,
              losses,
              profile,
              clanTag,
              isFriend,
              exp,
              isPremium,
              timeOfCreation,
              mmr,
              mmrVolatility, // TODO: probably don't implement this
              mmrDeviation, // TODO: probably don't implement this
              winsCurrent,
              lossesCurrent,
              leagueHistory,
            } = props;
            const builder = new HTMLBuilder();

            uimanager.playerInfoWindow.setTitleTitle(`Player since: ` + getFriendlyDate(timeOfCreation));

            // Level & Experience
            builder.add(`Level: <span class='greenfont'>${getLvlFromXp(exp)}</span><br />`);
            builder.add(`Experience: <span style='color: rgb(255, 255, 100);'>${exp}</span><br />`);

            // Clan
            if (clanTag && clanTag.length > 0) {
              const clanLinkID = uniqueID('clanLink');
              builder.add(`Clan: [<a href='#' id='${clanLinkID}' class='clanLink'>${clanTag}</a>]<br />`);
              builder.addHook(() => $(`#${clanLinkID}`).click(() => Clans.getClanInfo(clanTag)));
            }

            builder.add(`Unranked games: ${countGames}`);

            // Career Ladder
            builder.add(`<br />Career Ladder Record: <font class='greenfont'>${wins}</font> wins, <font class='redfont'>${losses}</font> losses<br />`);
            // Current ladder
            builder.add(`Current Ladder Record: <font class='greenfont'>${winsCurrent}</font> wins, `);
            builder.add(`<font class='redfont'>${lossesCurrent}</font> losses`);
            if (league >= 0) {
              builder.add('<br />Current Ladder Ranking: ');
              builder.add(getLeagueLink(league, false, 1, false));
              builder.add(` MMR: ${Math.max(Math.round(mmr), 0)}`);
            }
            builder.add('<br />');

            // Previous Seasons
            let previousSeasonFound = false;
            builder.add('Previous Ladder Seasons<br />');
            if (leagueHistory) {
              const secondSeason = leagueHistory.find((history) => history.id === 2);
              if (secondSeason && (secondSeason.wins || secondSeason.losses || secondSeason.league || secondSeason.mmr)) {
                previousSeasonFound = true;
                builder.add(`Second Ladder Season: `);
                if (secondSeason.league) {
                  builder.add(getLeagueLink(secondSeason.league - 1, false, 1, true));
                }
                builder.add(` <font class='greenfont'>${secondSeason.wins}</font> wins, <font class='redfont'>${secondSeason.losses}</font> losses, MMR: ${Math.round(secondSeason.mmr, 0)} <br />`);
              }
              const firstSeason = leagueHistory.find((history) => history.id === 1);
              if (firstSeason && (firstSeason.wins || firstSeason.losses || firstSeason.league)) {
                previousSeasonFound = true;
                builder.add(`First Ladder Season: `);
                if (firstSeason.league) {
                  builder.add(getLeagueLink(firstSeason.league - 1, false, 1, true));
                }
                builder.add(` <font class='greenfont'>${firstSeason.wins}</font> wins, <font class='redfont'>${firstSeason.losses}</font> losses<br />`);
              }
            }
            if (!previousSeasonFound) {
              builder.add('No previous ladder record<br />');
            }

            if (isAdmin) {
              builder.add('<br /><font style=\'color: #E84141;\'>Admin</font> ');
            } else if (isMod) {
              builder.add('<br /><font style=\'color: #F38F3C;\'>Moderator</font> ');
            }

            if (isPremium) {
              builder.add('<br /><font style=\'color: #5FFF39;\'>Premium User</font> ');
            }

            // Personal text
            if ((profile && profile.length > 0) || username === networkPlayerName) {
              builder.add('<br /><br />Personal Text:<div id=\'personalTextDiv\'>');
              builder.add(escapeHtml(profile).replace(/(?:\r\n|\r|\n)/g, '<br />'));
              builder.add('</div>');
              if (username === networkPlayerName) {
                builder.add('<br /><button id=\'profileTextButton\'>edit</button>');
                builder.addHook(() => $('#profileTextButton').click(() => editPersonalText()));
              }
            }
            this.__cachedFriends[username] = isFriend;
            this.__generatePlayerWindow(id, username, builder);
          };

          PlayerInfo_.prototype.__showLadderInfo = PlayerInfo_showLadderInfo;

          function buildLadderResultTable(matches, currentPage, builder) {
            builder.add(`
    <p>Ladder results:</p>
    <table>
    `);
            buildLadderResultRowsHTML(matches, currentPage, builder);
            builder.add(`</table>`);
          }

          function buildLadderResultRowsHTML(matches, currentPage, builder) {
            for (var i = (currentPage - 1) * 20; i < currentPage * 20; i++) {
              const match = matches[i];
              if (!match) {
                break;
              }
              buildLadderResultRowHTML(match, builder);
            }
          }

          /*
        type Match = {
            map: string,
            players: Array[string, string],
            result: 'win' | 'loss',
            time: '2024-1-30'
        }
        */
          function buildLadderResultRowHTML(match, builder) {
            builder.add('<tr>');
            buildLadderResultPlayerCell(match.players[0], builder);
            buildLadderResultVsCell(builder);
            buildLadderResultPlayerCell(match.players[1], builder);
            buildLadderResultOutcomeCellHTML(match, builder);
            buildLadderResultTimeCell(match, builder);
            buildLadderResultMapCell(match, builder);
            builder.add('</tr>');
          }

          function buildLadderResultMapCell(match, builder) {
            builder.add(`<td class='nowrap'> &nbsp; ${match.map}</td></tr>`);
          }

          function buildLadderResultVsCell(builder) {
            builder.add(`<td class='nowrap'> vs </td>`);
          }

          function buildLadderResultTimeCell(match, builder) {
            builder.add(`<td class='ladderGameTimeTD nowrap'> &nbsp; ${match.time}</td>`);
          }

          function buildLadderResultTimeCell(match, builder) {
            builder.add(`<td class='ladderGameTimeTD nowrap'> &nbsp; ${match.time}</td>`);
          }

          function buildLadderResultPlayerCell(player, builder) {
            builder.add('<td>');
            builder.add(PlayersList.getPlayerLink(player));
            builder.add('</td>');
          }

          function buildLadderResultOutcomeCellHTML(match, builder) {
            let cellHtml = `<td class='nowrap'>`;
            if (match.result == 'win') {
              cellHtml += '<span class=\'greenfont\'>win</span>';
            } else if (match.result == 'loss') {
              cellHtml += '<span class=\'redfont\'>loss</span>';
            } else {
              cellHtml += '<span style=\'color: yellow;\'>-</span>';
            }
            cellHtml += '</td>';
            builder.add(cellHtml);
          }

          PlayerInfo_.prototype.__showFriends = function (properties) {
            const { userId, username, friends } = properties;
            const builder = new HTMLBuilder();

            builder.add(`<h2>Friends (${(friends.length)} / 100)</h2>`);
            for (let i = 0; i < friends.length; i++) {
              builder.add(' ');
              builder.add(PlayersList.getPlayerLink(friends[i].username));
              builder.add('<br />');
            }

            this.__generatePlayerWindow(userId, username, builder);
          };

          PlayerInfo_.prototype.__showMaps = function (properties) {
            const { userId, username, maps } = properties;
            const builder = new HTMLBuilder();

            builder.add(`<p>Maps made by ${username}:</p><br />`);
            if (maps.length > 0) {
              maps.forEach((map) => {
                builder.add(` &nbsp; ${map.name}<br />`);
              });
            } else {
              builder.add(` &nbsp; ${username} has not made any maps`);
            }

            this.__generatePlayerWindow(userId, username, builder);
          };

          PlayerInfo_.prototype.__showAchievements = function (userId, playerName, achievements, emotes) {
            const builder = new HTMLBuilder();

            builder.add('<div>');
            achievements.forEach((a) => {
              builder.add(`<div class='achivement_div2' title='${a.text}'>`);
              builder.add(`<img class='pixelated' style='height: 81px;' src='imgs/achivements/${a.img}' /><p>${a.name}</p></div>`);
            });
            builder.add('</div>');

            builder.add('<div style=\'clear: both;\'></div><br /><br /><div>');
            emotes.forEach((em) => {
              builder.add(`<img title='${em.name}' class='buytableImgs' src='imgs/emotes/${em.img}' /> `);
            });
            builder.add('</div>');

            this.__generatePlayerWindow(userId, playerName, builder);
          };

          return new PlayerInfo_();
        })();

        const LeagueList = (() => {
          function LeagueList_() {
            Initialization.onDocumentReady(() => this.init());
          }

          LeagueList_.prototype.init = function () {
            this.__initNetworkListeners();
          };

          LeagueList_.prototype.__initNetworkListeners = function () {
            network.registerJSONListener(null, 'players-in-league', (properties) => {
              const {
                leagueId, leagueName, users,
              } = properties;

              const builder = new HTMLBuilder();

              builder.add('<div style=\'margin: 0 auto; text-align: center;\'>');
              builder.add(getLeagueLink(leagueId, false, 4, false));
              builder.add('</div><br /><table style=\'margin: 0 auto;\'>');
              builder.add('<tr><td class=\'tabletop\'>Rank</td><td class=\'tabletop\'>Player</td><td class=\'tabletop\'>Points</td><td class=\'tabletop\'>Record</td></tr>');

              users.forEach((user, index) => {
                const { id, username, mmr, wins, losses, mmrDeviation, mmrVolatility } = user;
                const class_ = username == networkPlayerName ? ' class=\'highlighted\' ' : '';
                builder.add(`<tr><td ${class_}>${index + 1}</td><td ${class_}>`);
                builder.add(PlayersList.getPlayerLink(username));
                builder.add(`</td><td ${class_}>${mmr}</td>`);
                builder.add(`<td ${class_}><font class='greenfont'>${wins}</font> / `);
                builder.add(`<font class='redfont'>${losses}</font></td></tr>`);
              });

              builder.add('</table><button id=\'showAllLeaguesButton\'>All divisions</button>');
              builder.addHook(() => $('#showAllLeaguesButton').click(addClickSound(() => showAllDivisions())));

              builder.insertInto('#addScrollableSubDivTextArea');

              uimanager.playerInfoWindow.setTitleText(leagueNames[leagueId]);
              uimanager.playerInfoWindow.setRider(new HTMLBuilder());
              uimanager.playerInfoWindow.setHeadRider(new HTMLBuilder());
              fadeIn($('#playerInfoWindow'));
            });
          };

          return new LeagueList_();
        })();

        const LadderWindow = (() => {
          function LadderWindow_() {
            Initialization.onDocumentReady(() => this.init());
          }

          LadderWindow_.prototype.init = function () {
            this.__initNetworkListeners();
          };

          LadderWindow_.prototype.__initNetworkListeners = function () {
            network.registerJSONListener(null, 'laddermaps-list', (properties) => {
              const { maps } = properties;

              network.send('cancel-ladder');
              fadeIn($('#ladderWindow'));

              // Ranked ladder description
              var str = 'Here you can play ranked 1v1 matches. If you click the \'Start searching\' button, an opponent (preferably of same skill) will be searched (this may take a while, depending on how many other player searching for ranked matches). The winner gets ranking points while the loser loses ranking points. ';
              str += 'The first 5 ranked matches you play will be used to determine your skill level. After your 5th game you will be placed into a division. ';
              str += 'From there on you can get promoted or demoted depending on your results. Ranked matches are played on one of the following maps (randomly picked):<br /><br /><font style=\'color: #13C700;\'>';

              // Laddermaps list
              str += maps.join(', ');
              str += '</font><br /><br />';

              $('#ladderWindow').html(str);

              $('#ladderWindow').append(uimanager.createButton('ladderButton2', 'Start searching', function () {
                if (AccountInfo.authedAndLogged) {
                  network.send('init-ladder<<$' + GAME_VERSION);
                  fadeIn($('#ladderWindow'));
                  $('#ladderWindow').html('<br /><p style=\'font-size: 30px; margin: 20px auto;\'>searching for opponent ...</p><br /><br /><br />');
                  $('#ladderWindow').append(uimanager.createButton('cancelLadderButton', 'cancel', function () {
                    network.send('cancel-ladder');
                    fadeOut($('#ladderWindow'));
                    soundManager.playSound(SOUND.CLICK);
                  }));
                } else {
                  displayInfoMsg('Only registered users can play ranked matches.');
                  fadeOut($('#ladderWindow'));
                }

                soundManager.playSound(SOUND.CLICK);
              }));

              $('#ladderWindow').append(uimanager.createButton('ladderCancelButton2', 'Cancel', function () {
                fadeOut($('#ladderWindow'));
                soundManager.playSound(SOUND.CLICK);
              }));
            });
          };

          return new LadderWindow_();
        })();

        const MapSelection = (() => {
          function MapSelection_() {
            this.SelectionAction = Object.freeze({
              MULTIPLAYER: 0,
              SINGLEPLAYER: 1,
              EDITOR: 2,
              TUTORIAL: 3,
              CHANGE_MAP: 4,
            });

            this.__titles = Object.freeze({
              [this.SelectionAction.MULTIPLAYER]: '» Create Multiplayer Game',
              [this.SelectionAction.SINGLEPLAYER]: '» Create Singleplayer Game',
              [this.SelectionAction.EDITOR]: '» Load Map',
              [this.SelectionAction.TUTORIAL]: '» Tutorials',
              [this.SelectionAction.CHANGE_MAP]: '» Change Map',
            });

            // Keeps track of the reason the selection window was opened
            this.__selectionAction = null;

            Initialization.onDocumentReady(() => this.init());
          }

          MapSelection_.prototype.init = function () {
            this.mapSelectionWindow = new UIWindow('pickMapWindow', null, true, 'Select Map', true);
            this.mapSelectionWindow.addSubDiv('pickMapWindowContents');
            $('#pickMapWindow').hide();

            // Close the menu whenever the game state changes
            onGameStateChange(() => this.closeWindow());

            this.__initNetworkListeners();
          };

          MapSelection_.prototype.__initNetworkListeners = function () {
            network.registerListener(null, 'maps-list', (splitMsg) => {
              const page = parseInt(splitMsg[1]) + 1;
              const totalPages = parseInt(splitMsg[2]);
              const maps = [];

              for (let i = 3; i < splitMsg.length; i += 6) {
                maps.push({
                  name: escapeHtml(splitMsg[i]),
                  description: escapeHtml(splitMsg[i + 1]),
                  img: escapeHtml(splitMsg[i + 2]),
                  countPlayers: escapeHtml(splitMsg[i + 3]),
                  mode: escapeHtml(splitMsg[i + 4]),
                  popularity: escapeHtml(splitMsg[i + 5]),
                });
              }

              // The window must already be open if this callback was triggered
              this.__populateSelectionWindow(page, totalPages, maps);
            });

            // Only start loading screen if lobby name is allowed
            network.registerListener(null, 'custom-game-accepted', (splitMsg) => {
              this.__showLoading();
            });

            const closeWindowOn = (msg) => network.registerListener(null, msg, () => this.closeWindow());
            closeWindowOn('game-created');
            closeWindowOn('singleplayer-game-created');
            closeWindowOn('change-map-file');
            closeWindowOn('custom-map-editor-file');
          };

          MapSelection_.prototype.__requestCustomMapsPage = function (page) {
            const search = $('#mapSearchInput').val();
            const mapFilter = $('#mapSearchSelect').val();
            const popularityFilter = $('#mapPopularitySelect').val();


            const msgType = (this.__selectionAction == this.SelectionAction.EDITOR) ? 'get-custom-maps-editor' : 'get-custom-maps';
            const tutorialEnabled = (this.__selectionAction == this.SelectionAction.TUTORIAL) ? 1 : 0;

            network.send(`${msgType}<<$${page}<<$${search}<<$${mapFilter}<<$${tutorialEnabled}<<$${popularityFilter}`);

            this.__showLoading();
            soundManager.playSound(SOUND.CLICK);
          };

          MapSelection_.prototype.openWindow = function (selectionAction) {
            this.__selectionAction = selectionAction;
            this.mapSelectionWindow.setTitleText(this.__titles[this.__selectionAction]);

            const builder = new HTMLBuilder();
            builder
              .add('<div id=\'selectMapArea\'></div>')
              .add('<div id=\'selectMapPages\'></div>')
              .add('<label id=\'searchLabel\' for=\'mapSearchInput\'>Search Map</label>')
              .add('<input type=\'text\' id=\'mapSearchInput\'>')
              .addHook(() => $('#mapSearchInput').keydown((e) => {
                if (keyManager.getKeyCode(e) == KEY.ENTER) {
                  this.__requestCustomMapsPage(0);
                }
              }));

            builder.add('<select id=\'mapSearchSelect\'>');
            builder.add('<option value=\'*\'>All maps</option>');
            for (let i = 2; i <= MAX_PLAYERS; i++) {
              builder.add(`<option value='${i} player maps'>${i} player maps</option>`);
            }
            builder
              .add('<option title=\'Modded maps can differ quite a lot from the normal game. They can use modified or completely new units, buildings and abilities\' value=\'Custom mods\'>Custom mods</option>')
              .add('</select>')
              .addHook(() => $('#mapSearchSelect').change((e) => this.__requestCustomMapsPage(0)));

            builder.add('<select id=\'mapPopularitySelect\'>');
            builder.add('<option value=\'popularity\'>Last 5 days</option>');
            builder.add('<option value=\'monthPopularity\'>Last month</option>');
            builder.add('<option value=\'yearPopularity\'>Last year</option>');
            // builder.add("<option value='allTime'>All time</option>"); // Add allTime once a year has passed I guess
            builder.add('<option value=\'id\'>New</option>');
            builder.add('</select>');
            builder.addHook(() => $('#mapPopularitySelect').change((e) => this.__requestCustomMapsPage(0)));
            if (this.__selectionAction == this.SelectionAction.MULTIPLAYER) {
              builder
                .add('<label id=\'gameNameLabel\' for=\'gameNameInput\'>Game Name</label>')
                .add('<input type=\'text\' id=\'gameNameInput\' title=\'Enter a custom name for your game\'>')
                .add('<label id=\'gamePWLabel\' for=\'gamePWInput\'>Password</label>')
                .add('<input type=\'text\' id=\'gamePWInput\' title=\'Enter a password for your game, or leave empty for no password\'>');
            }

            if (this.__selectionAction == this.SelectionAction.EDITOR) {
              builder.add(generateButton('loadExternalButton', null, 'Load a map from your computer', () => {
                const fileInput = document.createElement('input');
                fileInput.type = 'file';

                fileInput.onchange = () => {
                  const file = fileInput.files[0];
                  if (!file) {
                    return;
                  }

                  const reader = new FileReader();
                  reader.readAsBinaryString(file);
                  reader.onload = (e) => {
                    // TODO: move this to be with map editor code
                    const map = JSON.parse(e.target.result);
                    map.img = getImageFromMap(map);
                    uimanager.showLoadingScreen(map);

                    setTimeout(() => {
                      map.description = map.description ?? '';

                      game = new Game();
                      game.loadMap(map, null, null, null, true);

                      worker.postMessage({ what: 'start-game', editorLoad: true, map: map, players: null, network_game: network_game, game_state: game_state, networkPlayerName: networkPlayerName });
                      this.closeWindow();
                    }, 50);
                  };
                };

                fileInput.click();
                soundManager.playSound(SOUND.CLICK);
              }, 'Load external'));
            }

            builder.insertInto('#pickMapWindowContents');

            this.__requestCustomMapsPage(0);
            $('#mapSearchInput')[0].focus();
            fadeIn($('#pickMapWindow'));
          };

          MapSelection_.prototype.closeWindow = function () {
            fadeOut($('#pickMapWindow'));
          };

          MapSelection_.prototype.__showLoading = function () {
            $('#selectMapArea').html('<br /><br /><br /><br /><br /><br /><span id=\'loading\'>loading...</span>');
          };

          MapSelection_.prototype.__createGame = function (mapName, mapImg) {
            const customName = $('#gameNameInput')[0] ? $('#gameNameInput').val().trim() : '';
            const customPW = $('#gamePWInput')[0] ? $('#gamePWInput').val() : '';

            if (customName.length >= 21 || customName.match(/[A-Za-z0-9\-\_\?\!\(\)\[\]\+\#\.\:\,\;\* ]*/) != customName) {
              displayInfoMsg('Invalid game name!');
              return;
            }

            if (customPW.length >= 21 && customPW.match(/[A-Za-z0-9\-\_\?\!\(\)\[\]\+\#\.\:\,\;\* ]*/) != customPW) {
              displayInfoMsg('Invalid password!');
              return;
            }

            // Tell the server the type of "game" that is being created
            let gameType = {
              [this.SelectionAction.SINGLEPLAYER]: '0',
              [this.SelectionAction.MULTIPLAYER]: '1',
              [this.SelectionAction.EDITOR]: '2',
              [this.SelectionAction.TUTORIAL]: '0',
            }[this.__selectionAction];

            network.send(`create-game-custom<<$${mapName}<<$${GAME_VERSION}<<$${AIManager.getAICommit()}<<$${gameType}<<$${customName}<<$${customPW}`);
          };

          MapSelection_.prototype.__changeMap = function (mapName, mapImg) {
            if (game_state == GAME.SKIRMISH) {
              // Simply create a new singleplayer lobby
              network.send(`create-game-custom<<$${mapName}<<$${GAME_VERSION}<<$${AIManager.getAICommit()}<<$0<<$<<$`);
            } else {
              // The server must handle changing the map for a multiplayer lobby
              network.send(`change-map<<$${mapName}`);
            }
            this.__showLoading();
          };

          // Populates the selection window with the provided maps, setting "page" as the current page and creating
          // buttons to navigate to all the other pages
          MapSelection_.prototype.__populateSelectionWindow = function (page, totalPages, maps) {
            // Draw the pagination tabs on the bottom
            $('#selectMapPages').html('');
            if (totalPages > 1) {
              const paginationBuilder = new HTMLBuilder();
              const firstPage = page - (16 - Math.min(totalPages - page, 8));
              const lastPage = page + (16 - Math.min(page, 8));

              // Generates a button which will take us to a page of maps
              const generatePageButton = (pageNumber) => {
                const ID = uniqueID('pageButton');
                return new HTMLBuilder()
                  .add(`<button id='${ID}'>${pageNumber}</button> `)
                  .addHook(() => $(`#${ID}`).click(() => this.__requestCustomMapsPage(pageNumber - 1)));
              };

              // Insert a button for page 1 if it isn't already included, and a ... if we skip a page to reach firstPage
              if (firstPage > 1) {
                paginationBuilder.add(generatePageButton(1));
                if (firstPage - 1 > 1) {
                  paginationBuilder.add('...');
                }
              }

              // Insert the pages in the region around the current page
              for (let i = Math.max(firstPage, 1); i <= Math.min(lastPage, totalPages); i++) {
                paginationBuilder.add(i == page ? `<span>${i}</span> ` : generatePageButton(i));
              }

              // Insert a button for the last page if not already included, and a ... if there is a skip from lastPage
              if (lastPage < totalPages) {
                if (totalPages - lastPage > 1) {
                  paginationBuilder.add('...');
                }
                paginationBuilder.add(generatePageButton(totalPages));
              }

              paginationBuilder.insertInto('#selectMapPages');
            }

            // Display the maps
            $('#selectMapArea').html('');
            maps.forEach((map) => {
              let buttonClass = 'mapButton';
              let buttonTitle = (map.description.length > 300) ? (map.description.substring(0, 300) + '... ') : map.description;

              if (map.mode == 'Custom mods') {
                buttonClass = 'mapButtonMod';
                buttonTitle += '\n\n[This map contains modding elements. It can contain custom or modified units, buildings and abilities different from the normal game]';
              }

              if (map.popularity) {
                const popularityTimePeriod = $('#mapPopularitySelect').val();

                switch (popularityTimePeriod) {
                  case 'popularity':
                    buttonTitle += `\n\n${map.popularity} times played in the last 5 days`;
                    break;
                  case 'monthPopularity':
                    buttonTitle += `\n\n${map.popularity} times played in the month`;
                    break;
                  case 'yearPopularity':
                    buttonTitle += `\n\n${map.popularity} times played in the last year`;
                    break;
                }
              }

              let clickHandler = addClickSound(() => {
                if (this.__selectionAction == this.SelectionAction.CHANGE_MAP) {
                  this.__changeMap(map.name, map.img);
                } else {
                  this.__createGame(map.name, map.img);
                }
              });

              const ID = uniqueID('mapButton');
              new HTMLBuilder()
                .add(`<button id='${ID}' class='${buttonClass}'>`)
                .add(`${map.name} [${map.countPlayers}]<br />`)
                .add(`<img class='mapPreviewImg2' src='${map.img}' />`)
                .add(map.mode == 'Custom mods' ? '<div class=\'modLabel\'>[mod]</div>' : '')
                .add('</button>')
                .addHook(() => $(`#${ID}`).click(clickHandler))
                .addHook(() => $(`#${ID}`).attr('title', buttonTitle))
                .appendInto('#selectMapArea');
            });
          };

          return new MapSelection_();
        })();

        function getXPRequiredForLvl(lvl) {
          return lvl <= 1 ? 0 : Math.floor(Math.pow(lvl - 1, 1.8) * 150 + 150);
        };

        function getLvlFromXp(xp) {
          var lvl = 1;

          while (getXPRequiredForLvl(lvl + 1) <= xp) {
            lvl++;
          }

          return lvl;
        };

        const LADDER_RESULT_TYPE_PLACEMENT = 'placement';
        const LADDER_RESULT_TYPE_GAME = 'ladder-game';
        const LADDER_RESULT_INIT_PLACE = 'init-place';
        const LADDER_RESULT_PROMOTION = 'promotion';
        const LADDER_RESULT_DEMOTION = 'demotion';

        const StatsWindow = (() => {
          function StatsWindow_() {
            Initialization.onDocumentReady(() => this.init());
          }

          StatsWindow_.prototype.init = function () {
            this.statisticsWindow = new UIWindow('statisticsWindow', null, true, 'Statistics', true);
            this.statisticsWindow.addScrollableSubDiv('statisticsTextArea');
            $('#statisticsWindow').hide();

            // TODO: don't use the global variable game if we can help it
            const saveReplay = addClickSound(() => {
              const blob = new Blob([game.getReplayFile()], { type: 'text/plain;charset=utf-8' });
              saveAs(blob, game.getReplayName() + '.json');
            });

            new HTMLBuilder()
              .add('<div id=\'showLadderPointsDiv\' title=\'Ladder points determine your rank in your division. ' +
                'You win ladder points for victories in ranked games and lose ladder points for losses in ranked games.\'></div>')
              .add('<div id=\'xpBarDiv\'></div>')
              .add(generateButton('saveReplayButton', null, null, saveReplay, 'Save Replay'))
              .appendInto('#statisticsWindow');

            this.__initNetworkListeners();
          };

          StatsWindow_.prototype.clear = function () {
            $('#showLadderPointsDiv').html('');
            $('#xpBarDiv').html('');
          };

          StatsWindow_.prototype.__initNetworkListeners = function () {
            network.registerJSONListener(null, 'gained-xp', (properties) => this.__gainedXPListener(properties));
            network.registerJSONListener(null, 'ladder-result', (properties) => this.__ladderResultListener(properties));
          };

          StatsWindow_.prototype.__gainedXPListener = function (properties) {
            const { xp } = properties;
            AccountInfo.xp += parseInt(xp);

            const lvl = getLvlFromXp(AccountInfo.xp);
            const xp1 = getXPRequiredForLvl(lvl);
            const xp2 = getXPRequiredForLvl(parseInt(lvl) + 1);

            const builder = new HTMLBuilder();

            builder.add('<div class=\'xpBarContainer\'>');
            builder.add(`<div class='xpBar' style='width: ${(((AccountInfo.xp - xp1) / (xp2 - xp1)) * 200)}px;'>`);
            builder.add(`<span class='xpGainText' title='You gain experience from multiplayer games. \
         Experience allows you to level up and unlock new features!'>Level ${lvl} / +${xp} XP</span></div></div>`);

            const xpRequiredID = uniqueID('xpRequired');
            builder.add(`<div id=${xpRequiredID} class='xpRequiredDiv'>${xp2} XP required for Level ${lvl + 1}</div>`);

            builder.insertInto('#xpBarDiv');
          };

          StatsWindow_.prototype.__ladderResultListener = function (properties) {
            const { type, mmrChange, league } = properties;

            AccountInfo.ladderGameCount += 1;

            if (LADDER_RESULT_TYPE_GAME === type) {
              if (mmrChange > 0) {
                $('#showLadderPointsDiv').html(`<span class='gainedLadderPoints'>+${Math.round(mmrChange)} MMR</span>`);
              } else {
                $('#showLadderPointsDiv').html(`<span class='lostLadderPoints'>${Math.round(mmrChange)} MMR</span>`);
              }
            } else if (LADDER_RESULT_PROMOTION === type) {
              AccountInfo.league = league;
              const builder = new HTMLBuilder();

              builder.add('<div id=\'promotionTextDiv\' style=\'font-size: 30px;\'><font class=\'greenfont\'>Congratulations!</font> ');
              builder.add('You were promoted to a new league</div>');
              builder.add(getLeagueLink(AccountInfo.league, false, 6));

              storedAchievements.push({
                text: '',
                builder: builder,
                sound: SOUND.ARCHIVEMENT2,
              });

              showAchievement();
            } else if (LADDER_RESULT_DEMOTION === type) {
              AccountInfo.league = league;
              const builder = new HTMLBuilder();

              builder.add('<div id=\'promotionTextDiv\' style=\'font-size: 30px;\'>You were demoted to a new league</div>');
              builder.add(getLeagueLink(AccountInfo.league, false, 6));

              storedAchievements.push({
                text: '',
                builder: builder,
              });

              showAchievement();
            } else if (LADDER_RESULT_TYPE_PLACEMENT === type) {
              $('#showLadderPointsDiv').html(
                `<span id='placementMessage'>${5 - AccountInfo.ladderGameCount} matches left until you get placed</span>`);
            } else if (LADDER_RESULT_INIT_PLACE === type) {
              AccountInfo.league = league;
              const builder = new HTMLBuilder();

              builder.add('<div id=\'promotionTextDiv\' style=\'font-size: 30px;\'><font class=\'greenfont\'>Congratulations!</font> ');
              builder.add('You\'ve been placed in a league</div>');
              builder.add(getLeagueLink(AccountInfo.league, false, 6));

              storedAchievements.push({
                text: '',
                builder: builder,
                sound: SOUND.ARCHIVEMENT2,
              });

              showAchievement();
            }
          };

          StatsWindow_.prototype.__calculateFromThresholds = function (value, thresholdC, thresholdB, thresholdA) {
            if (value <= thresholdC) {
              return 'C';
            } else if (value <= thresholdB) {
              return 'B';
            } else if (value <= thresholdA) {
              return 'A';
            } else {
              return 'S';
            }
          };

          StatsWindow_.prototype.__createLetterRankDiv = function (category, name, hovertext) {
            return new HTMLBuilder()
              .add(`<div class='${category}-rank'>`)
              .add(`<img src='/play/imgs/ui/LetterIcons.png' class='${category}-rank-img pixelated'></img>`)
              .add(`<div class='rank-label'>${name}</div>`)
              .add('</div>');
          };

          StatsWindow_.prototype.showGameStatistics = function (curGame) {
            // Build statistics table
            const statsBuilder = new HTMLBuilder();
            statsBuilder.add('<table style=\'margin: 40px auto 30px;\'>');
            statsBuilder.add('<tr><td></td><td>Units Killed</td><td>Units Lost</td><td>Buildings Destroyed</td><td>Buildings Lost</td><td>Actions Per Minute</td><td>Mined Gold</td></tr>');

            // Write out statistics for each player
            for (let i = 1; i < curGame.players.length; i++) {
              if (curGame.players[i] && curGame.players[i].controller != CONTROLLER.SPECTATOR) {
                const player = curGame.players[i];
                const apm = Math.floor(player.apm / (ticksCounter / 1200));
                const backgroundColorStyle = (PLAYING_PLAYER == player ? ' background-color: rgba(255, 255, 255, 0.2);' : '');

                statsBuilder.add(`<tr style='color: ${player.getColor()}; ${backgroundColorStyle};'>`);
                statsBuilder.add('<td style=\'font-size: 18px;\'>');
                statsBuilder.add(player.name);
                statsBuilder.add(`</td><td class='size24px'>${player.unitKills}</td>`);
                statsBuilder.add(`<td class='size24px'>${player.unitDeaths}</td><td class='size24px'>${player.buildingKills}</td>`);
                statsBuilder.add(`<td class='size24px'>${player.buildingDeaths}</td><td class='size24px'>${apm}</td>`);
                statsBuilder.add(`<td class='size24px'>${player.minedGold}</td></tr>`);
              }
            }
            statsBuilder.add('</table>');

            if (!curGame.replay_mode && Login.loginState == Login.LoginStates.GUEST) {
              statsBuilder.add('<div id=\'guestAccountPrompt\'>Log in to gain exp and level up rewards!<br /><br /></div>');
            }

            if (!curGame.replay_mode && PLAYING_PLAYER.controller != CONTROLLER.SPECTATOR) {
              const apmRank = this.__calculateFromThresholds(PLAYING_PLAYER.apm / (ticksCounter / 1200), 30, 60, 120);
              const goldRank = this.__calculateFromThresholds(PLAYING_PLAYER.minedGold / (ticksCounter / 1200), 300, 600, 1000);
              // Inverted as less is better
              const buildingsLostRank = this.__calculateFromThresholds(-PLAYING_PLAYER.buildingDeaths, -20, -10, -5);

              statsBuilder
                .add('<div id=\'rankContainer\'>')
                .add(this.__createLetterRankDiv(apmRank, 'APM'))
                .add(this.__createLetterRankDiv(goldRank, 'GOLD PER MIN'))
                .add(this.__createLetterRankDiv(buildingsLostRank, 'BUILDINGS LOST'))
                .add('</div>');
            }

            statsBuilder.insertInto('#statisticsTextArea');

            if (curGame.replay_mode) {
              $('#saveReplayButton').css('display', 'none');
              this.statisticsWindow.setTitleText('Replay complete');
              this.statisticsWindow.setTitleStyle('windowTitle');
            } else {
              $('#saveReplayButton').css('display', 'inline-block');
              this.statisticsWindow.setTitleText(curGame.playingPlayerWon ? 'Victory' : 'Defeat');
              this.statisticsWindow.setTitleStyle(curGame.playingPlayerWon ? 'victoryTitle' : 'defeatTitle');
            }

            fadeIn($('#statisticsWindow'));
          };

          return new StatsWindow_();
        })();

      }).call(this)
    }).call(this, require("buffer").Buffer)
  }, { "./Assert.js": 1, "./HTMLBuilder.js": 2, "./LocalConfig.js": 3, "./SoundManager.js": 4, "./UIWindow.js": 5, "./data/Sound.js": 6, "@sentry/browser": 14, "@sentry/tracing": 73, "buffer": 126, "dedent": 129, "minizlib": 150 }], 8: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var core_1 = require("@sentry/core");
    var types_1 = require("@sentry/types");
    var utils_1 = require("@sentry/utils");
    var eventbuilder_1 = require("./eventbuilder");
    var transports_1 = require("./transports");
    /**
     * The Sentry Browser SDK Backend.
     * @hidden
     */
    var BrowserBackend = /** @class */ (function (_super) {
      tslib_1.__extends(BrowserBackend, _super);
      function BrowserBackend() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * @inheritDoc
       */
      BrowserBackend.prototype.eventFromException = function (exception, hint) {
        return eventbuilder_1.eventFromException(exception, hint, this._options.attachStacktrace);
      };
      /**
       * @inheritDoc
       */
      BrowserBackend.prototype.eventFromMessage = function (message, level, hint) {
        if (level === void 0) { level = types_1.Severity.Info; }
        return eventbuilder_1.eventFromMessage(message, level, hint, this._options.attachStacktrace);
      };
      /**
       * @inheritDoc
       */
      BrowserBackend.prototype._setupTransport = function () {
        if (!this._options.dsn) {
          // We return the noop transport here in case there is no Dsn.
          return _super.prototype._setupTransport.call(this);
        }
        var transportOptions = tslib_1.__assign(tslib_1.__assign({}, this._options.transportOptions), { dsn: this._options.dsn, tunnel: this._options.tunnel, sendClientReports: this._options.sendClientReports, _metadata: this._options._metadata });
        var api = core_1.initAPIDetails(transportOptions.dsn, transportOptions._metadata, transportOptions.tunnel);
        var url = core_1.getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel);
        if (this._options.transport) {
          return new this._options.transport(transportOptions);
        }
        if (utils_1.supportsFetch()) {
          var requestOptions = tslib_1.__assign({}, transportOptions.fetchParameters);
          this._newTransport = transports_1.makeNewFetchTransport({ requestOptions: requestOptions, url: url });
          return new transports_1.FetchTransport(transportOptions);
        }
        this._newTransport = transports_1.makeNewXHRTransport({
          url: url,
          headers: transportOptions.headers,
        });
        return new transports_1.XHRTransport(transportOptions);
      };
      return BrowserBackend;
    }(core_1.BaseBackend));
    exports.BrowserBackend = BrowserBackend;

  }, { "./eventbuilder": 10, "./transports": 26, "@sentry/core": 36, "@sentry/types": 83, "@sentry/utils": 95, "tslib": 181 }], 9: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var core_1 = require("@sentry/core");
    var utils_1 = require("@sentry/utils");
    var backend_1 = require("./backend");
    var flags_1 = require("./flags");
    var helpers_1 = require("./helpers");
    var integrations_1 = require("./integrations");
    /**
     * The Sentry Browser SDK Client.
     *
     * @see BrowserOptions for documentation on configuration options.
     * @see SentryClient for usage documentation.
     */
    var BrowserClient = /** @class */ (function (_super) {
      tslib_1.__extends(BrowserClient, _super);
      /**
       * Creates a new Browser SDK instance.
       *
       * @param options Configuration options for this SDK.
       */
      function BrowserClient(options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        options._metadata = options._metadata || {};
        options._metadata.sdk = options._metadata.sdk || {
          name: 'sentry.javascript.browser',
          packages: [
            {
              name: 'npm:@sentry/browser',
              version: core_1.SDK_VERSION,
            },
          ],
          version: core_1.SDK_VERSION,
        };
        _this = _super.call(this, backend_1.BrowserBackend, options) || this;
        return _this;
      }
      /**
       * Show a report dialog to the user to send feedback to a specific event.
       *
       * @param options Set individual options for the dialog
       */
      BrowserClient.prototype.showReportDialog = function (options) {
        if (options === void 0) { options = {}; }
        // doesn't work without a document (React Native)
        var document = utils_1.getGlobalObject().document;
        if (!document) {
          return;
        }
        if (!this._isEnabled()) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.error('Trying to call showReportDialog with Sentry Client disabled');
          return;
        }
        helpers_1.injectReportDialog(tslib_1.__assign(tslib_1.__assign({}, options), { dsn: options.dsn || this.getDsn() }));
      };
      /**
       * @inheritDoc
       */
      BrowserClient.prototype._prepareEvent = function (event, scope, hint) {
        event.platform = event.platform || 'javascript';
        return _super.prototype._prepareEvent.call(this, event, scope, hint);
      };
      /**
       * @inheritDoc
       */
      BrowserClient.prototype._sendEvent = function (event) {
        var integration = this.getIntegration(integrations_1.Breadcrumbs);
        if (integration) {
          integration.addSentryBreadcrumb(event);
        }
        _super.prototype._sendEvent.call(this, event);
      };
      return BrowserClient;
    }(core_1.BaseClient));
    exports.BrowserClient = BrowserClient;

  }, { "./backend": 8, "./flags": 12, "./helpers": 13, "./integrations": 18, "@sentry/core": 36, "@sentry/utils": 95, "tslib": 181 }], 10: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var types_1 = require("@sentry/types");
    var utils_1 = require("@sentry/utils");
    var stack_parsers_1 = require("./stack-parsers");
    /**
     * This function creates an exception from an TraceKitStackTrace
     * @param stacktrace TraceKitStackTrace that will be converted to an exception
     * @hidden
     */
    function exceptionFromError(ex) {
      // Get the frames first since Opera can lose the stack if we touch anything else first
      var frames = parseStackFrames(ex);
      var exception = {
        type: ex && ex.name,
        value: extractMessage(ex),
      };
      if (frames.length) {
        exception.stacktrace = { frames: frames };
      }
      if (exception.type === undefined && exception.value === '') {
        exception.value = 'Unrecoverable error caught';
      }
      return exception;
    }
    exports.exceptionFromError = exceptionFromError;
    /**
     * @hidden
     */
    function eventFromPlainObject(exception, syntheticException, isUnhandledRejection) {
      var event = {
        exception: {
          values: [
            {
              type: utils_1.isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? 'UnhandledRejection' : 'Error',
              value: "Non-Error " + (isUnhandledRejection ? 'promise rejection' : 'exception') + " captured with keys: " + utils_1.extractExceptionKeysForMessage(exception),
            },
          ],
        },
        extra: {
          __serialized__: utils_1.normalizeToSize(exception),
        },
      };
      if (syntheticException) {
        var frames_1 = parseStackFrames(syntheticException);
        if (frames_1.length) {
          event.stacktrace = { frames: frames_1 };
        }
      }
      return event;
    }
    exports.eventFromPlainObject = eventFromPlainObject;
    /**
     * @hidden
     */
    function eventFromError(ex) {
      return {
        exception: {
          values: [exceptionFromError(ex)],
        },
      };
    }
    exports.eventFromError = eventFromError;
    /** Parses stack frames from an error */
    function parseStackFrames(ex) {
      // Access and store the stacktrace property before doing ANYTHING
      // else to it because Opera is not very good at providing it
      // reliably in other circumstances.
      var stacktrace = ex.stacktrace || ex.stack || '';
      var popSize = getPopSize(ex);
      try {
        return utils_1.createStackParser(stack_parsers_1.opera10StackParser, stack_parsers_1.opera11StackParser, stack_parsers_1.chromeStackParser, stack_parsers_1.winjsStackParser, stack_parsers_1.geckoStackParser)(stacktrace, popSize);
      }
      catch (e) {
        // no-empty
      }
      return [];
    }
    exports.parseStackFrames = parseStackFrames;
    // Based on our own mapping pattern - https://github.com/getsentry/sentry/blob/9f08305e09866c8bd6d0c24f5b0aabdd7dd6c59c/src/sentry/lang/javascript/errormapping.py#L83-L108
    var reactMinifiedRegexp = /Minified React error #\d+;/i;
    function getPopSize(ex) {
      if (ex) {
        if (typeof ex.framesToPop === 'number') {
          return ex.framesToPop;
        }
        if (reactMinifiedRegexp.test(ex.message)) {
          return 1;
        }
      }
      return 0;
    }
    /**
     * There are cases where stacktrace.message is an Event object
     * https://github.com/getsentry/sentry-javascript/issues/1949
     * In this specific case we try to extract stacktrace.message.error.message
     */
    function extractMessage(ex) {
      var message = ex && ex.message;
      if (!message) {
        return 'No error message';
      }
      if (message.error && typeof message.error.message === 'string') {
        return message.error.message;
      }
      return message;
    }
    /**
     * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.
     * @hidden
     */
    function eventFromException(exception, hint, attachStacktrace) {
      var syntheticException = (hint && hint.syntheticException) || undefined;
      var event = eventFromUnknownInput(exception, syntheticException, attachStacktrace);
      utils_1.addExceptionMechanism(event); // defaults to { type: 'generic', handled: true }
      event.level = types_1.Severity.Error;
      if (hint && hint.event_id) {
        event.event_id = hint.event_id;
      }
      return utils_1.resolvedSyncPromise(event);
    }
    exports.eventFromException = eventFromException;
    /**
     * Builds and Event from a Message
     * @hidden
     */
    function eventFromMessage(message, level, hint, attachStacktrace) {
      if (level === void 0) { level = types_1.Severity.Info; }
      var syntheticException = (hint && hint.syntheticException) || undefined;
      var event = eventFromString(message, syntheticException, attachStacktrace);
      event.level = level;
      if (hint && hint.event_id) {
        event.event_id = hint.event_id;
      }
      return utils_1.resolvedSyncPromise(event);
    }
    exports.eventFromMessage = eventFromMessage;
    /**
     * @hidden
     */
    function eventFromUnknownInput(exception, syntheticException, attachStacktrace, isUnhandledRejection) {
      var event;
      if (utils_1.isErrorEvent(exception) && exception.error) {
        // If it is an ErrorEvent with `error` property, extract it to get actual Error
        var errorEvent = exception;
        return eventFromError(errorEvent.error);
      }
      // If it is a `DOMError` (which is a legacy API, but still supported in some browsers) then we just extract the name
      // and message, as it doesn't provide anything else. According to the spec, all `DOMExceptions` should also be
      // `Error`s, but that's not the case in IE11, so in that case we treat it the same as we do a `DOMError`.
      //
      // https://developer.mozilla.org/en-US/docs/Web/API/DOMError
      // https://developer.mozilla.org/en-US/docs/Web/API/DOMException
      // https://webidl.spec.whatwg.org/#es-DOMException-specialness
      if (utils_1.isDOMError(exception) || utils_1.isDOMException(exception)) {
        var domException = exception;
        if ('stack' in exception) {
          event = eventFromError(exception);
        }
        else {
          var name_1 = domException.name || (utils_1.isDOMError(domException) ? 'DOMError' : 'DOMException');
          var message = domException.message ? name_1 + ": " + domException.message : name_1;
          event = eventFromString(message, syntheticException, attachStacktrace);
          utils_1.addExceptionTypeValue(event, message);
        }
        if ('code' in domException) {
          event.tags = tslib_1.__assign(tslib_1.__assign({}, event.tags), { 'DOMException.code': "" + domException.code });
        }
        return event;
      }
      if (utils_1.isError(exception)) {
        // we have a real Error object, do nothing
        return eventFromError(exception);
      }
      if (utils_1.isPlainObject(exception) || utils_1.isEvent(exception)) {
        // If it's a plain object or an instance of `Event` (the built-in JS kind, not this SDK's `Event` type), serialize
        // it manually. This will allow us to group events based on top-level keys which is much better than creating a new
        // group on any key/value change.
        var objectException = exception;
        event = eventFromPlainObject(objectException, syntheticException, isUnhandledRejection);
        utils_1.addExceptionMechanism(event, {
          synthetic: true,
        });
        return event;
      }
      // If none of previous checks were valid, then it means that it's not:
      // - an instance of DOMError
      // - an instance of DOMException
      // - an instance of Event
      // - an instance of Error
      // - a valid ErrorEvent (one with an error property)
      // - a plain Object
      //
      // So bail out and capture it as a simple message:
      event = eventFromString(exception, syntheticException, attachStacktrace);
      utils_1.addExceptionTypeValue(event, "" + exception, undefined);
      utils_1.addExceptionMechanism(event, {
        synthetic: true,
      });
      return event;
    }
    exports.eventFromUnknownInput = eventFromUnknownInput;
    /**
     * @hidden
     */
    function eventFromString(input, syntheticException, attachStacktrace) {
      var event = {
        message: input,
      };
      if (attachStacktrace && syntheticException) {
        var frames_2 = parseStackFrames(syntheticException);
        if (frames_2.length) {
          event.stacktrace = { frames: frames_2 };
        }
      }
      return event;
    }
    exports.eventFromString = eventFromString;

  }, { "./stack-parsers": 23, "@sentry/types": 83, "@sentry/utils": 95, "tslib": 181 }], 11: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require("@sentry/types");
    exports.Severity = types_1.Severity;
    var core_1 = require("@sentry/core");
    exports.addGlobalEventProcessor = core_1.addGlobalEventProcessor;
    exports.addBreadcrumb = core_1.addBreadcrumb;
    exports.captureException = core_1.captureException;
    exports.captureEvent = core_1.captureEvent;
    exports.captureMessage = core_1.captureMessage;
    exports.configureScope = core_1.configureScope;
    exports.getHubFromCarrier = core_1.getHubFromCarrier;
    exports.getCurrentHub = core_1.getCurrentHub;
    exports.Hub = core_1.Hub;
    exports.makeMain = core_1.makeMain;
    exports.Scope = core_1.Scope;
    exports.Session = core_1.Session;
    exports.startTransaction = core_1.startTransaction;
    exports.SDK_VERSION = core_1.SDK_VERSION;
    exports.setContext = core_1.setContext;
    exports.setExtra = core_1.setExtra;
    exports.setExtras = core_1.setExtras;
    exports.setTag = core_1.setTag;
    exports.setTags = core_1.setTags;
    exports.setUser = core_1.setUser;
    exports.withScope = core_1.withScope;
    var client_1 = require("./client");
    exports.BrowserClient = client_1.BrowserClient;
    var helpers_1 = require("./helpers");
    exports.injectReportDialog = helpers_1.injectReportDialog;
    var eventbuilder_1 = require("./eventbuilder");
    exports.eventFromException = eventbuilder_1.eventFromException;
    exports.eventFromMessage = eventbuilder_1.eventFromMessage;
    var sdk_1 = require("./sdk");
    exports.defaultIntegrations = sdk_1.defaultIntegrations;
    exports.forceLoad = sdk_1.forceLoad;
    exports.init = sdk_1.init;
    exports.lastEventId = sdk_1.lastEventId;
    exports.onLoad = sdk_1.onLoad;
    exports.showReportDialog = sdk_1.showReportDialog;
    exports.flush = sdk_1.flush;
    exports.close = sdk_1.close;
    exports.wrap = sdk_1.wrap;
    var version_1 = require("./version");
    exports.SDK_NAME = version_1.SDK_NAME;

  }, { "./client": 9, "./eventbuilder": 10, "./helpers": 13, "./sdk": 22, "./version": 31, "@sentry/core": 36, "@sentry/types": 83 }], 12: [function (require, module, exports) {
    /*
     * This file defines flags and constants that can be modified during compile time in order to facilitate tree shaking
     * for users.
     *
     * Debug flags need to be declared in each package individually and must not be imported across package boundaries,
     * because some build tools have trouble tree-shaking imported guards.
     *
     * As a convention, we define debug flags in a `flags.ts` file in the root of a package's `src` folder.
     *
     * Debug flag files will contain "magic strings" like `__SENTRY_DEBUG__` that may get replaced with actual values during
     * our, or the user's build process. Take care when introducing new flags - they must not throw if they are not
     * replaced.
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    /** Flag that is true for debug builds, false otherwise. */
    exports.IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === 'undefined' ? true : __SENTRY_DEBUG__;

  }, {}], 13: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var core_1 = require("@sentry/core");
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("./flags");
    var global = utils_1.getGlobalObject();
    var ignoreOnError = 0;
    /**
     * @hidden
     */
    function shouldIgnoreOnError() {
      return ignoreOnError > 0;
    }
    exports.shouldIgnoreOnError = shouldIgnoreOnError;
    /**
     * @hidden
     */
    function ignoreNextOnError() {
      // onerror should trigger before setTimeout
      ignoreOnError += 1;
      setTimeout(function () {
        ignoreOnError -= 1;
      });
    }
    exports.ignoreNextOnError = ignoreNextOnError;
    /**
     * Instruments the given function and sends an event to Sentry every time the
     * function throws an exception.
     *
     * @param fn A function to wrap.
     * @returns The wrapped function.
     * @hidden
     */
    function wrap(fn, options, before) {
      // for future readers what this does is wrap a function and then create
      // a bi-directional wrapping between them.
      //
      // example: wrapped = wrap(original);
      //  original.__sentry_wrapped__ -> wrapped
      //  wrapped.__sentry_original__ -> original
      if (options === void 0) { options = {}; }
      if (typeof fn !== 'function') {
        return fn;
      }
      try {
        // if we're dealing with a function that was previously wrapped, return
        // the original wrapper.
        var wrapper = fn.__sentry_wrapped__;
        if (wrapper) {
          return wrapper;
        }
        // We don't wanna wrap it twice
        if (utils_1.getOriginalFunction(fn)) {
          return fn;
        }
      }
      catch (e) {
        // Just accessing custom props in some Selenium environments
        // can cause a "Permission denied" exception (see raven-js#495).
        // Bail on wrapping and return the function as-is (defers to window.onerror).
        return fn;
      }
      /* eslint-disable prefer-rest-params */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var sentryWrapped = function () {
        var args = Array.prototype.slice.call(arguments);
        try {
          if (before && typeof before === 'function') {
            before.apply(this, arguments);
          }
          // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access
          var wrappedArguments = args.map(function (arg) { return wrap(arg, options); });
          // Attempt to invoke user-land function
          // NOTE: If you are a Sentry user, and you are seeing this stack frame, it
          //       means the sentry.javascript SDK caught an error invoking your application code. This
          //       is expected behavior and NOT indicative of a bug with sentry.javascript.
          return fn.apply(this, wrappedArguments);
        }
        catch (ex) {
          ignoreNextOnError();
          core_1.withScope(function (scope) {
            scope.addEventProcessor(function (event) {
              if (options.mechanism) {
                utils_1.addExceptionTypeValue(event, undefined, undefined);
                utils_1.addExceptionMechanism(event, options.mechanism);
              }
              event.extra = tslib_1.__assign(tslib_1.__assign({}, event.extra), { arguments: args });
              return event;
            });
            core_1.captureException(ex);
          });
          throw ex;
        }
      };
      /* eslint-enable prefer-rest-params */
      // Accessing some objects may throw
      // ref: https://github.com/getsentry/sentry-javascript/issues/1168
      try {
        for (var property in fn) {
          if (Object.prototype.hasOwnProperty.call(fn, property)) {
            sentryWrapped[property] = fn[property];
          }
        }
      }
      catch (_oO) { } // eslint-disable-line no-empty
      // Signal that this function has been wrapped/filled already
      // for both debugging and to prevent it to being wrapped/filled twice
      utils_1.markFunctionWrapped(sentryWrapped, fn);
      utils_1.addNonEnumerableProperty(fn, '__sentry_wrapped__', sentryWrapped);
      // Restore original function name (not all browsers allow that)
      try {
        var descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, 'name');
        if (descriptor.configurable) {
          Object.defineProperty(sentryWrapped, 'name', {
            get: function () {
              return fn.name;
            },
          });
        }
        // eslint-disable-next-line no-empty
      }
      catch (_oO) { }
      return sentryWrapped;
    }
    exports.wrap = wrap;
    /**
     * Injects the Report Dialog script
     * @hidden
     */
    function injectReportDialog(options) {
      if (options === void 0) { options = {}; }
      if (!global.document) {
        return;
      }
      if (!options.eventId) {
        flags_1.IS_DEBUG_BUILD && utils_1.logger.error('Missing eventId option in showReportDialog call');
        return;
      }
      if (!options.dsn) {
        flags_1.IS_DEBUG_BUILD && utils_1.logger.error('Missing dsn option in showReportDialog call');
        return;
      }
      var script = global.document.createElement('script');
      script.async = true;
      script.src = core_1.getReportDialogEndpoint(options.dsn, options);
      if (options.onLoad) {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        script.onload = options.onLoad;
      }
      var injectionPoint = global.document.head || global.document.body;
      if (injectionPoint) {
        injectionPoint.appendChild(script);
      }
    }
    exports.injectReportDialog = injectReportDialog;

  }, { "./flags": 12, "@sentry/core": 36, "@sentry/utils": 95, "tslib": 181 }], 14: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    tslib_1.__exportStar(require("./exports"), exports);
    var core_1 = require("@sentry/core");
    var utils_1 = require("@sentry/utils");
    var BrowserIntegrations = require("./integrations");
    var Transports = require("./transports");
    exports.Transports = Transports;
    var windowIntegrations = {};
    // This block is needed to add compatibility with the integrations packages when used with a CDN
    var _window = utils_1.getGlobalObject();
    if (_window.Sentry && _window.Sentry.Integrations) {
      windowIntegrations = _window.Sentry.Integrations;
    }
    var INTEGRATIONS = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, windowIntegrations), core_1.Integrations), BrowserIntegrations);
    exports.Integrations = INTEGRATIONS;

  }, { "./exports": 11, "./integrations": 18, "./transports": 26, "@sentry/core": 36, "@sentry/utils": 95, "tslib": 181 }], 15: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    /* eslint-disable max-lines */
    var core_1 = require("@sentry/core");
    var types_1 = require("@sentry/types");
    var utils_1 = require("@sentry/utils");
    /**
     * Default Breadcrumbs instrumentations
     * TODO: Deprecated - with v6, this will be renamed to `Instrument`
     */
    var Breadcrumbs = /** @class */ (function () {
      /**
       * @inheritDoc
       */
      function Breadcrumbs(options) {
        /**
         * @inheritDoc
         */
        this.name = Breadcrumbs.id;
        this._options = tslib_1.__assign({ console: true, dom: true, fetch: true, history: true, sentry: true, xhr: true }, options);
      }
      /**
       * Create a breadcrumb of `sentry` from the events themselves
       */
      Breadcrumbs.prototype.addSentryBreadcrumb = function (event) {
        if (!this._options.sentry) {
          return;
        }
        core_1.getCurrentHub().addBreadcrumb({
          category: "sentry." + (event.type === 'transaction' ? 'transaction' : 'event'),
          event_id: event.event_id,
          level: event.level,
          message: utils_1.getEventDescription(event),
        }, {
          event: event,
        });
      };
      /**
       * Instrument browser built-ins w/ breadcrumb capturing
       *  - Console API
       *  - DOM API (click/typing)
       *  - XMLHttpRequest API
       *  - Fetch API
       *  - History API
       */
      Breadcrumbs.prototype.setupOnce = function () {
        if (this._options.console) {
          utils_1.addInstrumentationHandler('console', _consoleBreadcrumb);
        }
        if (this._options.dom) {
          utils_1.addInstrumentationHandler('dom', _domBreadcrumb(this._options.dom));
        }
        if (this._options.xhr) {
          utils_1.addInstrumentationHandler('xhr', _xhrBreadcrumb);
        }
        if (this._options.fetch) {
          utils_1.addInstrumentationHandler('fetch', _fetchBreadcrumb);
        }
        if (this._options.history) {
          utils_1.addInstrumentationHandler('history', _historyBreadcrumb);
        }
      };
      /**
       * @inheritDoc
       */
      Breadcrumbs.id = 'Breadcrumbs';
      return Breadcrumbs;
    }());
    exports.Breadcrumbs = Breadcrumbs;
    /**
     * A HOC that creaes a function that creates breadcrumbs from DOM API calls.
     * This is a HOC so that we get access to dom options in the closure.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function _domBreadcrumb(dom) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      function _innerDomBreadcrumb(handlerData) {
        var target;
        var keyAttrs = typeof dom === 'object' ? dom.serializeAttribute : undefined;
        if (typeof keyAttrs === 'string') {
          keyAttrs = [keyAttrs];
        }
        // Accessing event.target can throw (see getsentry/raven-js#838, #768)
        try {
          target = handlerData.event.target
            ? utils_1.htmlTreeAsString(handlerData.event.target, keyAttrs)
            : utils_1.htmlTreeAsString(handlerData.event, keyAttrs);
        }
        catch (e) {
          target = '<unknown>';
        }
        if (target.length === 0) {
          return;
        }
        core_1.getCurrentHub().addBreadcrumb({
          category: "ui." + handlerData.name,
          message: target,
        }, {
          event: handlerData.event,
          name: handlerData.name,
          global: handlerData.global,
        });
      }
      return _innerDomBreadcrumb;
    }
    /**
     * Creates breadcrumbs from console API calls
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function _consoleBreadcrumb(handlerData) {
      var breadcrumb = {
        category: 'console',
        data: {
          arguments: handlerData.args,
          logger: 'console',
        },
        level: utils_1.severityFromString(handlerData.level),
        message: utils_1.safeJoin(handlerData.args, ' '),
      };
      if (handlerData.level === 'assert') {
        if (handlerData.args[0] === false) {
          breadcrumb.message = "Assertion failed: " + (utils_1.safeJoin(handlerData.args.slice(1), ' ') || 'console.assert');
          breadcrumb.data.arguments = handlerData.args.slice(1);
        }
        else {
          // Don't capture a breadcrumb for passed assertions
          return;
        }
      }
      core_1.getCurrentHub().addBreadcrumb(breadcrumb, {
        input: handlerData.args,
        level: handlerData.level,
      });
    }
    /**
     * Creates breadcrumbs from XHR API calls
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function _xhrBreadcrumb(handlerData) {
      if (handlerData.endTimestamp) {
        // We only capture complete, non-sentry requests
        if (handlerData.xhr.__sentry_own_request__) {
          return;
        }
        var _a = handlerData.xhr.__sentry_xhr__ || {}, method = _a.method, url = _a.url, status_code = _a.status_code, body = _a.body;
        core_1.getCurrentHub().addBreadcrumb({
          category: 'xhr',
          data: {
            method: method,
            url: url,
            status_code: status_code,
          },
          type: 'http',
        }, {
          xhr: handlerData.xhr,
          input: body,
        });
        return;
      }
    }
    /**
     * Creates breadcrumbs from fetch API calls
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function _fetchBreadcrumb(handlerData) {
      // We only capture complete fetch requests
      if (!handlerData.endTimestamp) {
        return;
      }
      if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === 'POST') {
        // We will not create breadcrumbs for fetch requests that contain `sentry_key` (internal sentry requests)
        return;
      }
      if (handlerData.error) {
        core_1.getCurrentHub().addBreadcrumb({
          category: 'fetch',
          data: handlerData.fetchData,
          level: types_1.Severity.Error,
          type: 'http',
        }, {
          data: handlerData.error,
          input: handlerData.args,
        });
      }
      else {
        core_1.getCurrentHub().addBreadcrumb({
          category: 'fetch',
          data: tslib_1.__assign(tslib_1.__assign({}, handlerData.fetchData), { status_code: handlerData.response.status }),
          type: 'http',
        }, {
          input: handlerData.args,
          response: handlerData.response,
        });
      }
    }
    /**
     * Creates breadcrumbs from history API calls
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function _historyBreadcrumb(handlerData) {
      var global = utils_1.getGlobalObject();
      var from = handlerData.from;
      var to = handlerData.to;
      var parsedLoc = utils_1.parseUrl(global.location.href);
      var parsedFrom = utils_1.parseUrl(from);
      var parsedTo = utils_1.parseUrl(to);
      // Initial pushState doesn't provide `from` information
      if (!parsedFrom.path) {
        parsedFrom = parsedLoc;
      }
      // Use only the path component of the URL if the URL matches the current
      // document (almost all the time when using pushState)
      if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
        to = parsedTo.relative;
      }
      if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
        from = parsedFrom.relative;
      }
      core_1.getCurrentHub().addBreadcrumb({
        category: 'navigation',
        data: {
          from: from,
          to: to,
        },
      });
    }

  }, { "@sentry/core": 36, "@sentry/types": 83, "@sentry/utils": 95, "tslib": 181 }], 16: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("../flags");
    /** Deduplication filter */
    var Dedupe = /** @class */ (function () {
      function Dedupe() {
        /**
         * @inheritDoc
         */
        this.name = Dedupe.id;
      }
      /**
       * @inheritDoc
       */
      Dedupe.prototype.setupOnce = function (addGlobalEventProcessor, getCurrentHub) {
        addGlobalEventProcessor(function (currentEvent) {
          var self = getCurrentHub().getIntegration(Dedupe);
          if (self) {
            // Juuust in case something goes wrong
            try {
              if (_shouldDropEvent(currentEvent, self._previousEvent)) {
                flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('Event dropped due to being a duplicate of previously captured event.');
                return null;
              }
            }
            catch (_oO) {
              return (self._previousEvent = currentEvent);
            }
            return (self._previousEvent = currentEvent);
          }
          return currentEvent;
        });
      };
      /**
       * @inheritDoc
       */
      Dedupe.id = 'Dedupe';
      return Dedupe;
    }());
    exports.Dedupe = Dedupe;
    /** JSDoc */
    function _shouldDropEvent(currentEvent, previousEvent) {
      if (!previousEvent) {
        return false;
      }
      if (_isSameMessageEvent(currentEvent, previousEvent)) {
        return true;
      }
      if (_isSameExceptionEvent(currentEvent, previousEvent)) {
        return true;
      }
      return false;
    }
    /** JSDoc */
    function _isSameMessageEvent(currentEvent, previousEvent) {
      var currentMessage = currentEvent.message;
      var previousMessage = previousEvent.message;
      // If neither event has a message property, they were both exceptions, so bail out
      if (!currentMessage && !previousMessage) {
        return false;
      }
      // If only one event has a stacktrace, but not the other one, they are not the same
      if ((currentMessage && !previousMessage) || (!currentMessage && previousMessage)) {
        return false;
      }
      if (currentMessage !== previousMessage) {
        return false;
      }
      if (!_isSameFingerprint(currentEvent, previousEvent)) {
        return false;
      }
      if (!_isSameStacktrace(currentEvent, previousEvent)) {
        return false;
      }
      return true;
    }
    /** JSDoc */
    function _isSameExceptionEvent(currentEvent, previousEvent) {
      var previousException = _getExceptionFromEvent(previousEvent);
      var currentException = _getExceptionFromEvent(currentEvent);
      if (!previousException || !currentException) {
        return false;
      }
      if (previousException.type !== currentException.type || previousException.value !== currentException.value) {
        return false;
      }
      if (!_isSameFingerprint(currentEvent, previousEvent)) {
        return false;
      }
      if (!_isSameStacktrace(currentEvent, previousEvent)) {
        return false;
      }
      return true;
    }
    /** JSDoc */
    function _isSameStacktrace(currentEvent, previousEvent) {
      var currentFrames = _getFramesFromEvent(currentEvent);
      var previousFrames = _getFramesFromEvent(previousEvent);
      // If neither event has a stacktrace, they are assumed to be the same
      if (!currentFrames && !previousFrames) {
        return true;
      }
      // If only one event has a stacktrace, but not the other one, they are not the same
      if ((currentFrames && !previousFrames) || (!currentFrames && previousFrames)) {
        return false;
      }
      currentFrames = currentFrames;
      previousFrames = previousFrames;
      // If number of frames differ, they are not the same
      if (previousFrames.length !== currentFrames.length) {
        return false;
      }
      // Otherwise, compare the two
      for (var i = 0; i < previousFrames.length; i++) {
        var frameA = previousFrames[i];
        var frameB = currentFrames[i];
        if (frameA.filename !== frameB.filename ||
          frameA.lineno !== frameB.lineno ||
          frameA.colno !== frameB.colno ||
          frameA.function !== frameB.function) {
          return false;
        }
      }
      return true;
    }
    /** JSDoc */
    function _isSameFingerprint(currentEvent, previousEvent) {
      var currentFingerprint = currentEvent.fingerprint;
      var previousFingerprint = previousEvent.fingerprint;
      // If neither event has a fingerprint, they are assumed to be the same
      if (!currentFingerprint && !previousFingerprint) {
        return true;
      }
      // If only one event has a fingerprint, but not the other one, they are not the same
      if ((currentFingerprint && !previousFingerprint) || (!currentFingerprint && previousFingerprint)) {
        return false;
      }
      currentFingerprint = currentFingerprint;
      previousFingerprint = previousFingerprint;
      // Otherwise, compare the two
      try {
        return !!(currentFingerprint.join('') === previousFingerprint.join(''));
      }
      catch (_oO) {
        return false;
      }
    }
    /** JSDoc */
    function _getExceptionFromEvent(event) {
      return event.exception && event.exception.values && event.exception.values[0];
    }
    /** JSDoc */
    function _getFramesFromEvent(event) {
      var exception = event.exception;
      if (exception) {
        try {
          // @ts-ignore Object could be undefined
          return exception.values[0].stacktrace.frames;
        }
        catch (_oO) {
          return undefined;
        }
      }
      else if (event.stacktrace) {
        return event.stacktrace.frames;
      }
      return undefined;
    }

  }, { "../flags": 12, "@sentry/utils": 95 }], 17: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    var core_1 = require("@sentry/core");
    var types_1 = require("@sentry/types");
    var utils_1 = require("@sentry/utils");
    var eventbuilder_1 = require("../eventbuilder");
    var flags_1 = require("../flags");
    var helpers_1 = require("../helpers");
    /** Global handlers */
    var GlobalHandlers = /** @class */ (function () {
      /** JSDoc */
      function GlobalHandlers(options) {
        /**
         * @inheritDoc
         */
        this.name = GlobalHandlers.id;
        /**
         * Stores references functions to installing handlers. Will set to undefined
         * after they have been run so that they are not used twice.
         */
        this._installFunc = {
          onerror: _installGlobalOnErrorHandler,
          onunhandledrejection: _installGlobalOnUnhandledRejectionHandler,
        };
        this._options = tslib_1.__assign({ onerror: true, onunhandledrejection: true }, options);
      }
      /**
       * @inheritDoc
       */
      GlobalHandlers.prototype.setupOnce = function () {
        Error.stackTraceLimit = 50;
        var options = this._options;
        // We can disable guard-for-in as we construct the options object above + do checks against
        // `this._installFunc` for the property.
        // eslint-disable-next-line guard-for-in
        for (var key in options) {
          var installFunc = this._installFunc[key];
          if (installFunc && options[key]) {
            globalHandlerLog(key);
            installFunc();
            this._installFunc[key] = undefined;
          }
        }
      };
      /**
       * @inheritDoc
       */
      GlobalHandlers.id = 'GlobalHandlers';
      return GlobalHandlers;
    }());
    exports.GlobalHandlers = GlobalHandlers;
    /** JSDoc */
    function _installGlobalOnErrorHandler() {
      utils_1.addInstrumentationHandler('error',
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        function (data) {
          var _a = tslib_1.__read(getHubAndAttachStacktrace(), 2), hub = _a[0], attachStacktrace = _a[1];
          if (!hub.getIntegration(GlobalHandlers)) {
            return;
          }
          var msg = data.msg, url = data.url, line = data.line, column = data.column, error = data.error;
          if (helpers_1.shouldIgnoreOnError() || (error && error.__sentry_own_request__)) {
            return;
          }
          var event = error === undefined && utils_1.isString(msg)
            ? _eventFromIncompleteOnError(msg, url, line, column)
            : _enhanceEventWithInitialFrame(eventbuilder_1.eventFromUnknownInput(error || msg, undefined, attachStacktrace, false), url, line, column);
          event.level = types_1.Severity.Error;
          addMechanismAndCapture(hub, error, event, 'onerror');
        });
    }
    /** JSDoc */
    function _installGlobalOnUnhandledRejectionHandler() {
      utils_1.addInstrumentationHandler('unhandledrejection',
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        function (e) {
          var _a = tslib_1.__read(getHubAndAttachStacktrace(), 2), hub = _a[0], attachStacktrace = _a[1];
          if (!hub.getIntegration(GlobalHandlers)) {
            return;
          }
          var error = e;
          // dig the object of the rejection out of known event types
          try {
            // PromiseRejectionEvents store the object of the rejection under 'reason'
            // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent
            if ('reason' in e) {
              error = e.reason;
            }
            // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents
            // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into
            // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec
            // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and
            // https://github.com/getsentry/sentry-javascript/issues/2380
            else if ('detail' in e && 'reason' in e.detail) {
              error = e.detail.reason;
            }
          }
          catch (_oO) {
            // no-empty
          }
          if (helpers_1.shouldIgnoreOnError() || (error && error.__sentry_own_request__)) {
            return true;
          }
          var event = utils_1.isPrimitive(error)
            ? _eventFromRejectionWithPrimitive(error)
            : eventbuilder_1.eventFromUnknownInput(error, undefined, attachStacktrace, true);
          event.level = types_1.Severity.Error;
          addMechanismAndCapture(hub, error, event, 'onunhandledrejection');
          return;
        });
    }
    /**
     * Create an event from a promise rejection where the `reason` is a primitive.
     *
     * @param reason: The `reason` property of the promise rejection
     * @returns An Event object with an appropriate `exception` value
     */
    function _eventFromRejectionWithPrimitive(reason) {
      return {
        exception: {
          values: [
            {
              type: 'UnhandledRejection',
              // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
              value: "Non-Error promise rejection captured with value: " + String(reason),
            },
          ],
        },
      };
    }
    /**
     * This function creates a stack from an old, error-less onerror handler.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function _eventFromIncompleteOnError(msg, url, line, column) {
      var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
      // If 'message' is ErrorEvent, get real message from inside
      var message = utils_1.isErrorEvent(msg) ? msg.message : msg;
      var name = 'Error';
      var groups = message.match(ERROR_TYPES_RE);
      if (groups) {
        name = groups[1];
        message = groups[2];
      }
      var event = {
        exception: {
          values: [
            {
              type: name,
              value: message,
            },
          ],
        },
      };
      return _enhanceEventWithInitialFrame(event, url, line, column);
    }
    /** JSDoc */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function _enhanceEventWithInitialFrame(event, url, line, column) {
      // event.exception
      var e = (event.exception = event.exception || {});
      // event.exception.values
      var ev = (e.values = e.values || []);
      // event.exception.values[0]
      var ev0 = (ev[0] = ev[0] || {});
      // event.exception.values[0].stacktrace
      var ev0s = (ev0.stacktrace = ev0.stacktrace || {});
      // event.exception.values[0].stacktrace.frames
      var ev0sf = (ev0s.frames = ev0s.frames || []);
      var colno = isNaN(parseInt(column, 10)) ? undefined : column;
      var lineno = isNaN(parseInt(line, 10)) ? undefined : line;
      var filename = utils_1.isString(url) && url.length > 0 ? url : utils_1.getLocationHref();
      // event.exception.values[0].stacktrace.frames
      if (ev0sf.length === 0) {
        ev0sf.push({
          colno: colno,
          filename: filename,
          function: '?',
          in_app: true,
          lineno: lineno,
        });
      }
      return event;
    }
    function globalHandlerLog(type) {
      flags_1.IS_DEBUG_BUILD && utils_1.logger.log("Global Handler attached: " + type);
    }
    function addMechanismAndCapture(hub, error, event, type) {
      utils_1.addExceptionMechanism(event, {
        handled: false,
        type: type,
      });
      hub.captureEvent(event, {
        originalException: error,
      });
    }
    function getHubAndAttachStacktrace() {
      var hub = core_1.getCurrentHub();
      var client = hub.getClient();
      var attachStacktrace = client && client.getOptions().attachStacktrace;
      return [hub, attachStacktrace];
    }

  }, { "../eventbuilder": 10, "../flags": 12, "../helpers": 13, "@sentry/core": 36, "@sentry/types": 83, "@sentry/utils": 95, "tslib": 181 }], 18: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var globalhandlers_1 = require("./globalhandlers");
    exports.GlobalHandlers = globalhandlers_1.GlobalHandlers;
    var trycatch_1 = require("./trycatch");
    exports.TryCatch = trycatch_1.TryCatch;
    var breadcrumbs_1 = require("./breadcrumbs");
    exports.Breadcrumbs = breadcrumbs_1.Breadcrumbs;
    var linkederrors_1 = require("./linkederrors");
    exports.LinkedErrors = linkederrors_1.LinkedErrors;
    var useragent_1 = require("./useragent");
    exports.UserAgent = useragent_1.UserAgent;
    var dedupe_1 = require("./dedupe");
    exports.Dedupe = dedupe_1.Dedupe;

  }, { "./breadcrumbs": 15, "./dedupe": 16, "./globalhandlers": 17, "./linkederrors": 19, "./trycatch": 20, "./useragent": 21 }], 19: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var core_1 = require("@sentry/core");
    var utils_1 = require("@sentry/utils");
    var eventbuilder_1 = require("../eventbuilder");
    var DEFAULT_KEY = 'cause';
    var DEFAULT_LIMIT = 5;
    /** Adds SDK info to an event. */
    var LinkedErrors = /** @class */ (function () {
      /**
       * @inheritDoc
       */
      function LinkedErrors(options) {
        if (options === void 0) { options = {}; }
        /**
         * @inheritDoc
         */
        this.name = LinkedErrors.id;
        this._key = options.key || DEFAULT_KEY;
        this._limit = options.limit || DEFAULT_LIMIT;
      }
      /**
       * @inheritDoc
       */
      LinkedErrors.prototype.setupOnce = function () {
        core_1.addGlobalEventProcessor(function (event, hint) {
          var self = core_1.getCurrentHub().getIntegration(LinkedErrors);
          return self ? _handler(self._key, self._limit, event, hint) : event;
        });
      };
      /**
       * @inheritDoc
       */
      LinkedErrors.id = 'LinkedErrors';
      return LinkedErrors;
    }());
    exports.LinkedErrors = LinkedErrors;
    /**
     * @inheritDoc
     */
    function _handler(key, limit, event, hint) {
      if (!event.exception || !event.exception.values || !hint || !utils_1.isInstanceOf(hint.originalException, Error)) {
        return event;
      }
      var linkedErrors = _walkErrorTree(limit, hint.originalException, key);
      event.exception.values = tslib_1.__spread(linkedErrors, event.exception.values);
      return event;
    }
    exports._handler = _handler;
    /**
     * JSDOC
     */
    function _walkErrorTree(limit, error, key, stack) {
      if (stack === void 0) { stack = []; }
      if (!utils_1.isInstanceOf(error[key], Error) || stack.length + 1 >= limit) {
        return stack;
      }
      var exception = eventbuilder_1.exceptionFromError(error[key]);
      return _walkErrorTree(limit, error[key], key, tslib_1.__spread([exception], stack));
    }
    exports._walkErrorTree = _walkErrorTree;

  }, { "../eventbuilder": 10, "@sentry/core": 36, "@sentry/utils": 95, "tslib": 181 }], 20: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var utils_1 = require("@sentry/utils");
    var helpers_1 = require("../helpers");
    var DEFAULT_EVENT_TARGET = [
      'EventTarget',
      'Window',
      'Node',
      'ApplicationCache',
      'AudioTrackList',
      'ChannelMergerNode',
      'CryptoOperation',
      'EventSource',
      'FileReader',
      'HTMLUnknownElement',
      'IDBDatabase',
      'IDBRequest',
      'IDBTransaction',
      'KeyOperation',
      'MediaController',
      'MessagePort',
      'ModalWindow',
      'Notification',
      'SVGElementInstance',
      'Screen',
      'TextTrack',
      'TextTrackCue',
      'TextTrackList',
      'WebSocket',
      'WebSocketWorker',
      'Worker',
      'XMLHttpRequest',
      'XMLHttpRequestEventTarget',
      'XMLHttpRequestUpload',
    ];
    /** Wrap timer functions and event targets to catch errors and provide better meta data */
    var TryCatch = /** @class */ (function () {
      /**
       * @inheritDoc
       */
      function TryCatch(options) {
        /**
         * @inheritDoc
         */
        this.name = TryCatch.id;
        this._options = tslib_1.__assign({ XMLHttpRequest: true, eventTarget: true, requestAnimationFrame: true, setInterval: true, setTimeout: true }, options);
      }
      /**
       * Wrap timer functions and event targets to catch errors
       * and provide better metadata.
       */
      TryCatch.prototype.setupOnce = function () {
        var global = utils_1.getGlobalObject();
        if (this._options.setTimeout) {
          utils_1.fill(global, 'setTimeout', _wrapTimeFunction);
        }
        if (this._options.setInterval) {
          utils_1.fill(global, 'setInterval', _wrapTimeFunction);
        }
        if (this._options.requestAnimationFrame) {
          utils_1.fill(global, 'requestAnimationFrame', _wrapRAF);
        }
        if (this._options.XMLHttpRequest && 'XMLHttpRequest' in global) {
          utils_1.fill(XMLHttpRequest.prototype, 'send', _wrapXHR);
        }
        var eventTargetOption = this._options.eventTarget;
        if (eventTargetOption) {
          var eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;
          eventTarget.forEach(_wrapEventTarget);
        }
      };
      /**
       * @inheritDoc
       */
      TryCatch.id = 'TryCatch';
      return TryCatch;
    }());
    exports.TryCatch = TryCatch;
    /** JSDoc */
    function _wrapTimeFunction(original) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var originalCallback = args[0];
        args[0] = helpers_1.wrap(originalCallback, {
          mechanism: {
            data: { function: utils_1.getFunctionName(original) },
            handled: true,
            type: 'instrument',
          },
        });
        return original.apply(this, args);
      };
    }
    /** JSDoc */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function _wrapRAF(original) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return function (callback) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        return original.apply(this, [
          helpers_1.wrap(callback, {
            mechanism: {
              data: {
                function: 'requestAnimationFrame',
                handler: utils_1.getFunctionName(original),
              },
              handled: true,
              type: 'instrument',
            },
          }),
        ]);
      };
    }
    /** JSDoc */
    function _wrapXHR(originalSend) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        var xhr = this;
        var xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];
        xmlHttpRequestProps.forEach(function (prop) {
          if (prop in xhr && typeof xhr[prop] === 'function') {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            utils_1.fill(xhr, prop, function (original) {
              var wrapOptions = {
                mechanism: {
                  data: {
                    function: prop,
                    handler: utils_1.getFunctionName(original),
                  },
                  handled: true,
                  type: 'instrument',
                },
              };
              // If Instrument integration has been called before TryCatch, get the name of original function
              var originalFunction = utils_1.getOriginalFunction(original);
              if (originalFunction) {
                wrapOptions.mechanism.data.handler = utils_1.getFunctionName(originalFunction);
              }
              // Otherwise wrap directly
              return helpers_1.wrap(original, wrapOptions);
            });
          }
        });
        return originalSend.apply(this, args);
      };
    }
    /** JSDoc */
    function _wrapEventTarget(target) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var global = utils_1.getGlobalObject();
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      var proto = global[target] && global[target].prototype;
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins
      if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {
        return;
      }
      utils_1.fill(proto, 'addEventListener', function (original) {
        return function (eventName, fn, options) {
          try {
            if (typeof fn.handleEvent === 'function') {
              fn.handleEvent = helpers_1.wrap(fn.handleEvent.bind(fn), {
                mechanism: {
                  data: {
                    function: 'handleEvent',
                    handler: utils_1.getFunctionName(fn),
                    target: target,
                  },
                  handled: true,
                  type: 'instrument',
                },
              });
            }
          }
          catch (err) {
            // can sometimes get 'Permission denied to access property "handle Event'
          }
          return original.apply(this, [
            eventName,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            helpers_1.wrap(fn, {
              mechanism: {
                data: {
                  function: 'addEventListener',
                  handler: utils_1.getFunctionName(fn),
                  target: target,
                },
                handled: true,
                type: 'instrument',
              },
            }),
            options,
          ]);
        };
      });
      utils_1.fill(proto, 'removeEventListener', function (originalRemoveEventListener) {
        return function (eventName, fn, options) {
          /**
           * There are 2 possible scenarios here:
           *
           * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified
           * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function
           * as a pass-through, and call original `removeEventListener` with it.
           *
           * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using
           * our wrapped version of `addEventListener`, which internally calls `wrap` helper.
           * This helper "wraps" whole callback inside a try/catch statement, and attached appropriate metadata to it,
           * in order for us to make a distinction between wrapped/non-wrapped functions possible.
           * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.
           *
           * When someone adds a handler prior to initialization, and then do it again, but after,
           * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible
           * to get rid of the initial handler and it'd stick there forever.
           */
          var wrappedEventHandler = fn;
          try {
            var originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;
            if (originalEventHandler) {
              originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
            }
          }
          catch (e) {
            // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments
          }
          return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);
        };
      });
    }

  }, { "../helpers": 13, "@sentry/utils": 95, "tslib": 181 }], 21: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var core_1 = require("@sentry/core");
    var utils_1 = require("@sentry/utils");
    var global = utils_1.getGlobalObject();
    /** UserAgent */
    var UserAgent = /** @class */ (function () {
      function UserAgent() {
        /**
         * @inheritDoc
         */
        this.name = UserAgent.id;
      }
      /**
       * @inheritDoc
       */
      UserAgent.prototype.setupOnce = function () {
        core_1.addGlobalEventProcessor(function (event) {
          if (core_1.getCurrentHub().getIntegration(UserAgent)) {
            // if none of the information we want exists, don't bother
            if (!global.navigator && !global.location && !global.document) {
              return event;
            }
            // grab as much info as exists and add it to the event
            var url = (event.request && event.request.url) || (global.location && global.location.href);
            var referrer = (global.document || {}).referrer;
            var userAgent = (global.navigator || {}).userAgent;
            var headers = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, (event.request && event.request.headers)), (referrer && { Referer: referrer })), (userAgent && { 'User-Agent': userAgent }));
            var request = tslib_1.__assign(tslib_1.__assign({}, (url && { url: url })), { headers: headers });
            return tslib_1.__assign(tslib_1.__assign({}, event), { request: request });
          }
          return event;
        });
      };
      /**
       * @inheritDoc
       */
      UserAgent.id = 'UserAgent';
      return UserAgent;
    }());
    exports.UserAgent = UserAgent;

  }, { "@sentry/core": 36, "@sentry/utils": 95, "tslib": 181 }], 22: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var core_1 = require("@sentry/core");
    var utils_1 = require("@sentry/utils");
    var client_1 = require("./client");
    var flags_1 = require("./flags");
    var helpers_1 = require("./helpers");
    var integrations_1 = require("./integrations");
    exports.defaultIntegrations = [
      new core_1.Integrations.InboundFilters(),
      new core_1.Integrations.FunctionToString(),
      new integrations_1.TryCatch(),
      new integrations_1.Breadcrumbs(),
      new integrations_1.GlobalHandlers(),
      new integrations_1.LinkedErrors(),
      new integrations_1.Dedupe(),
      new integrations_1.UserAgent(),
    ];
    /**
     * The Sentry Browser SDK Client.
     *
     * To use this SDK, call the {@link init} function as early as possible when
     * loading the web page. To set context information or send manual events, use
     * the provided methods.
     *
     * @example
     *
     * ```
     *
     * import { init } from '@sentry/browser';
     *
     * init({
     *   dsn: '__DSN__',
     *   // ...
     * });
     * ```
     *
     * @example
     * ```
     *
     * import { configureScope } from '@sentry/browser';
     * configureScope((scope: Scope) => {
     *   scope.setExtra({ battery: 0.7 });
     *   scope.setTag({ user_mode: 'admin' });
     *   scope.setUser({ id: '4711' });
     * });
     * ```
     *
     * @example
     * ```
     *
     * import { addBreadcrumb } from '@sentry/browser';
     * addBreadcrumb({
     *   message: 'My Breadcrumb',
     *   // ...
     * });
     * ```
     *
     * @example
     *
     * ```
     *
     * import * as Sentry from '@sentry/browser';
     * Sentry.captureMessage('Hello, world!');
     * Sentry.captureException(new Error('Good bye'));
     * Sentry.captureEvent({
     *   message: 'Manual',
     *   stacktrace: [
     *     // ...
     *   ],
     * });
     * ```
     *
     * @see {@link BrowserOptions} for documentation on configuration options.
     */
    function init(options) {
      if (options === void 0) { options = {}; }
      if (options.defaultIntegrations === undefined) {
        options.defaultIntegrations = exports.defaultIntegrations;
      }
      if (options.release === undefined) {
        var window_1 = utils_1.getGlobalObject();
        // This supports the variable that sentry-webpack-plugin injects
        if (window_1.SENTRY_RELEASE && window_1.SENTRY_RELEASE.id) {
          options.release = window_1.SENTRY_RELEASE.id;
        }
      }
      if (options.autoSessionTracking === undefined) {
        options.autoSessionTracking = true;
      }
      if (options.sendClientReports === undefined) {
        options.sendClientReports = true;
      }
      core_1.initAndBind(client_1.BrowserClient, options);
      if (options.autoSessionTracking) {
        startSessionTracking();
      }
    }
    exports.init = init;
    /**
     * Present the user with a report dialog.
     *
     * @param options Everything is optional, we try to fetch all info need from the global scope.
     */
    function showReportDialog(options) {
      if (options === void 0) { options = {}; }
      var hub = core_1.getCurrentHub();
      var scope = hub.getScope();
      if (scope) {
        options.user = tslib_1.__assign(tslib_1.__assign({}, scope.getUser()), options.user);
      }
      if (!options.eventId) {
        options.eventId = hub.lastEventId();
      }
      var client = hub.getClient();
      if (client) {
        client.showReportDialog(options);
      }
    }
    exports.showReportDialog = showReportDialog;
    /**
     * This is the getter for lastEventId.
     *
     * @returns The last event id of a captured event.
     */
    function lastEventId() {
      return core_1.getCurrentHub().lastEventId();
    }
    exports.lastEventId = lastEventId;
    /**
     * This function is here to be API compatible with the loader.
     * @hidden
     */
    function forceLoad() {
      // Noop
    }
    exports.forceLoad = forceLoad;
    /**
     * This function is here to be API compatible with the loader.
     * @hidden
     */
    function onLoad(callback) {
      callback();
    }
    exports.onLoad = onLoad;
    /**
     * Call `flush()` on the current client, if there is one. See {@link Client.flush}.
     *
     * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause
     * the client to wait until all events are sent before resolving the promise.
     * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it
     * doesn't (or if there's no client defined).
     */
    function flush(timeout) {
      var client = core_1.getCurrentHub().getClient();
      if (client) {
        return client.flush(timeout);
      }
      flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('Cannot flush events. No client defined.');
      return utils_1.resolvedSyncPromise(false);
    }
    exports.flush = flush;
    /**
     * Call `close()` on the current client, if there is one. See {@link Client.close}.
     *
     * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this
     * parameter will cause the client to wait until all events are sent before disabling itself.
     * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it
     * doesn't (or if there's no client defined).
     */
    function close(timeout) {
      var client = core_1.getCurrentHub().getClient();
      if (client) {
        return client.close(timeout);
      }
      flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('Cannot flush events and disable SDK. No client defined.');
      return utils_1.resolvedSyncPromise(false);
    }
    exports.close = close;
    /**
     * Wrap code within a try/catch block so the SDK is able to capture errors.
     *
     * @param fn A function to wrap.
     *
     * @returns The result of wrapped function call.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function wrap(fn) {
      return helpers_1.wrap(fn)();
    }
    exports.wrap = wrap;
    function startSessionOnHub(hub) {
      hub.startSession({ ignoreDuration: true });
      hub.captureSession();
    }
    /**
     * Enable automatic Session Tracking for the initial page load.
     */
    function startSessionTracking() {
      var window = utils_1.getGlobalObject();
      var document = window.document;
      if (typeof document === 'undefined') {
        flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('Session tracking in non-browser environment with @sentry/browser is not supported.');
        return;
      }
      var hub = core_1.getCurrentHub();
      // The only way for this to be false is for there to be a version mismatch between @sentry/browser (>= 6.0.0) and
      // @sentry/hub (< 5.27.0). In the simple case, there won't ever be such a mismatch, because the two packages are
      // pinned at the same version in package.json, but there are edge cases where it's possible. See
      // https://github.com/getsentry/sentry-javascript/issues/3207 and
      // https://github.com/getsentry/sentry-javascript/issues/3234 and
      // https://github.com/getsentry/sentry-javascript/issues/3278.
      if (!hub.captureSession) {
        return;
      }
      // The session duration for browser sessions does not track a meaningful
      // concept that can be used as a metric.
      // Automatically captured sessions are akin to page views, and thus we
      // discard their duration.
      startSessionOnHub(hub);
      // We want to create a session for every navigation as well
      utils_1.addInstrumentationHandler('history', function (_a) {
        var from = _a.from, to = _a.to;
        // Don't create an additional session for the initial route or if the location did not change
        if (!(from === undefined || from === to)) {
          startSessionOnHub(core_1.getCurrentHub());
        }
      });
    }

  }, { "./client": 9, "./flags": 12, "./helpers": 13, "./integrations": 18, "@sentry/core": 36, "@sentry/utils": 95, "tslib": 181 }], 23: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    // global reference to slice
    var UNKNOWN_FUNCTION = '?';
    var OPERA10_PRIORITY = 10;
    var OPERA11_PRIORITY = 20;
    var CHROME_PRIORITY = 30;
    var WINJS_PRIORITY = 40;
    var GECKO_PRIORITY = 50;
    function createFrame(filename, func, lineno, colno) {
      var frame = {
        filename: filename,
        function: func,
        // All browser frames are considered in_app
        in_app: true,
      };
      if (lineno !== undefined) {
        frame.lineno = lineno;
      }
      if (colno !== undefined) {
        frame.colno = colno;
      }
      return frame;
    }
    // Chromium based browsers: Chrome, Brave, new Opera, new Edge
    var chromeRegex = /^\s*at (?:(.*?) ?\((?:address at )?)?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    var chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    var chrome = function (line) {
      var parts = chromeRegex.exec(line);
      if (parts) {
        var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line
        if (isEval) {
          var subMatch = chromeEvalRegex.exec(parts[2]);
          if (subMatch) {
            // throw out eval line/column and use top-most line/column number
            parts[2] = subMatch[1]; // url
            parts[3] = subMatch[2]; // line
            parts[4] = subMatch[3]; // column
          }
        }
        // Kamil: One more hack won't hurt us right? Understanding and adding more rules on top of these regexps right now
        // would be way too time consuming. (TODO: Rewrite whole RegExp to be more readable)
        var _a = tslib_1.__read(extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]), 2), func = _a[0], filename = _a[1];
        return createFrame(filename, func, parts[3] ? +parts[3] : undefined, parts[4] ? +parts[4] : undefined);
      }
      return;
    };
    exports.chromeStackParser = [CHROME_PRIORITY, chrome];
    // gecko regex: `(?:bundle|\d+\.js)`: `bundle` is for react native, `\d+\.js` also but specifically for ram bundles because it
    // generates filenames without a prefix like `file://` the filenames in the stacktrace are just 42.js
    // We need this specific case for now because we want no other regex to match.
    var geckoREgex = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|capacitor).*?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
    var geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    var gecko = function (line) {
      var _a;
      var parts = geckoREgex.exec(line);
      if (parts) {
        var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
        if (isEval) {
          var subMatch = geckoEvalRegex.exec(parts[3]);
          if (subMatch) {
            // throw out eval line/column and use top-most line number
            parts[1] = parts[1] || 'eval';
            parts[3] = subMatch[1];
            parts[4] = subMatch[2];
            parts[5] = ''; // no column when eval
          }
        }
        var filename = parts[3];
        var func = parts[1] || UNKNOWN_FUNCTION;
        _a = tslib_1.__read(extractSafariExtensionDetails(func, filename), 2), func = _a[0], filename = _a[1];
        return createFrame(filename, func, parts[4] ? +parts[4] : undefined, parts[5] ? +parts[5] : undefined);
      }
      return;
    };
    exports.geckoStackParser = [GECKO_PRIORITY, gecko];
    var winjsRegex = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    var winjs = function (line) {
      var parts = winjsRegex.exec(line);
      return parts
        ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : undefined)
        : undefined;
    };
    exports.winjsStackParser = [WINJS_PRIORITY, winjs];
    var opera10Regex = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i;
    var opera10 = function (line) {
      var parts = opera10Regex.exec(line);
      return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : undefined;
    };
    exports.opera10StackParser = [OPERA10_PRIORITY, opera10];
    var opera11Regex = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\(.*\))? in (.*):\s*$/i;
    var opera11 = function (line) {
      var parts = opera11Regex.exec(line);
      return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : undefined;
    };
    exports.opera11StackParser = [OPERA11_PRIORITY, opera11];
    /**
     * Safari web extensions, starting version unknown, can produce "frames-only" stacktraces.
     * What it means, is that instead of format like:
     *
     * Error: wat
     *   at function@url:row:col
     *   at function@url:row:col
     *   at function@url:row:col
     *
     * it produces something like:
     *
     *   function@url:row:col
     *   function@url:row:col
     *   function@url:row:col
     *
     * Because of that, it won't be captured by `chrome` RegExp and will fall into `Gecko` branch.
     * This function is extracted so that we can use it in both places without duplicating the logic.
     * Unfortunately "just" changing RegExp is too complicated now and making it pass all tests
     * and fix this case seems like an impossible, or at least way too time-consuming task.
     */
    var extractSafariExtensionDetails = function (func, filename) {
      var isSafariExtension = func.indexOf('safari-extension') !== -1;
      var isSafariWebExtension = func.indexOf('safari-web-extension') !== -1;
      return isSafariExtension || isSafariWebExtension
        ? [
          func.indexOf('@') !== -1 ? func.split('@')[0] : UNKNOWN_FUNCTION,
          isSafariExtension ? "safari-extension:" + filename : "safari-web-extension:" + filename,
        ]
        : [func, filename];
    };

  }, { "tslib": 181 }], 24: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var core_1 = require("@sentry/core");
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("../flags");
    var utils_2 = require("./utils");
    function requestTypeToCategory(ty) {
      var tyStr = ty;
      return tyStr === 'event' ? 'error' : tyStr;
    }
    var global = utils_1.getGlobalObject();
    /** Base Transport class implementation */
    var BaseTransport = /** @class */ (function () {
      function BaseTransport(options) {
        var _this = this;
        this.options = options;
        /** A simple buffer holding all requests. */
        this._buffer = utils_1.makePromiseBuffer(30);
        /** Locks transport after receiving rate limits in a response */
        this._rateLimits = {};
        this._outcomes = {};
        this._api = core_1.initAPIDetails(options.dsn, options._metadata, options.tunnel);
        // eslint-disable-next-line deprecation/deprecation
        this.url = core_1.getStoreEndpointWithUrlEncodedAuth(this._api.dsn);
        if (this.options.sendClientReports && global.document) {
          global.document.addEventListener('visibilitychange', function () {
            if (global.document.visibilityState === 'hidden') {
              _this._flushOutcomes();
            }
          });
        }
      }
      /**
       * @inheritDoc
       */
      BaseTransport.prototype.sendEvent = function (event) {
        return this._sendRequest(core_1.eventToSentryRequest(event, this._api), event);
      };
      /**
       * @inheritDoc
       */
      BaseTransport.prototype.sendSession = function (session) {
        return this._sendRequest(core_1.sessionToSentryRequest(session, this._api), session);
      };
      /**
       * @inheritDoc
       */
      BaseTransport.prototype.close = function (timeout) {
        return this._buffer.drain(timeout);
      };
      /**
       * @inheritDoc
       */
      BaseTransport.prototype.recordLostEvent = function (reason, category) {
        var _a;
        if (!this.options.sendClientReports) {
          return;
        }
        // We want to track each category (event, transaction, session) separately
        // but still keep the distinction between different type of outcomes.
        // We could use nested maps, but it's much easier to read and type this way.
        // A correct type for map-based implementation if we want to go that route
        // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`
        var key = requestTypeToCategory(category) + ":" + reason;
        flags_1.IS_DEBUG_BUILD && utils_1.logger.log("Adding outcome: " + key);
        this._outcomes[key] = (_a = this._outcomes[key], (_a !== null && _a !== void 0 ? _a : 0)) + 1;
      };
      /**
       * Send outcomes as an envelope
       */
      BaseTransport.prototype._flushOutcomes = function () {
        if (!this.options.sendClientReports) {
          return;
        }
        var outcomes = this._outcomes;
        this._outcomes = {};
        // Nothing to send
        if (!Object.keys(outcomes).length) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.log('No outcomes to flush');
          return;
        }
        flags_1.IS_DEBUG_BUILD && utils_1.logger.log("Flushing outcomes:\n" + JSON.stringify(outcomes, null, 2));
        var url = core_1.getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn, this._api.tunnel);
        var discardedEvents = Object.keys(outcomes).map(function (key) {
          var _a = tslib_1.__read(key.split(':'), 2), category = _a[0], reason = _a[1];
          return {
            reason: reason,
            category: category,
            quantity: outcomes[key],
          };
          // TODO: Improve types on discarded_events to get rid of cast
        });
        var envelope = utils_1.createClientReportEnvelope(discardedEvents, this._api.tunnel && utils_1.dsnToString(this._api.dsn));
        try {
          utils_2.sendReport(url, utils_1.serializeEnvelope(envelope));
        }
        catch (e) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.error(e);
        }
      };
      /**
       * Handle Sentry repsonse for promise-based transports.
       */
      BaseTransport.prototype._handleResponse = function (_a) {
        var requestType = _a.requestType, response = _a.response, headers = _a.headers, resolve = _a.resolve, reject = _a.reject;
        var status = utils_1.eventStatusFromHttpCode(response.status);
        this._rateLimits = utils_1.updateRateLimits(this._rateLimits, headers);
        // eslint-disable-next-line deprecation/deprecation
        if (this._isRateLimited(requestType)) {
          flags_1.IS_DEBUG_BUILD &&
            // eslint-disable-next-line deprecation/deprecation
            utils_1.logger.warn("Too many " + requestType + " requests, backing off until: " + this._disabledUntil(requestType));
        }
        if (status === 'success') {
          resolve({ status: status });
          return;
        }
        reject(response);
      };
      /**
       * Gets the time that given category is disabled until for rate limiting
       *
       * @deprecated Please use `disabledUntil` from @sentry/utils
       */
      BaseTransport.prototype._disabledUntil = function (requestType) {
        var category = requestTypeToCategory(requestType);
        return new Date(utils_1.disabledUntil(this._rateLimits, category));
      };
      /**
       * Checks if a category is rate limited
       *
       * @deprecated Please use `isRateLimited` from @sentry/utils
       */
      BaseTransport.prototype._isRateLimited = function (requestType) {
        var category = requestTypeToCategory(requestType);
        return utils_1.isRateLimited(this._rateLimits, category);
      };
      return BaseTransport;
    }());
    exports.BaseTransport = BaseTransport;

  }, { "../flags": 12, "./utils": 29, "@sentry/core": 36, "@sentry/utils": 95, "tslib": 181 }], 25: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var utils_1 = require("@sentry/utils");
    var base_1 = require("./base");
    var utils_2 = require("./utils");
    /** `fetch` based transport */
    var FetchTransport = /** @class */ (function (_super) {
      tslib_1.__extends(FetchTransport, _super);
      function FetchTransport(options, fetchImpl) {
        if (fetchImpl === void 0) { fetchImpl = utils_2.getNativeFetchImplementation(); }
        var _this = _super.call(this, options) || this;
        _this._fetch = fetchImpl;
        return _this;
      }
      /**
       * @param sentryRequest Prepared SentryRequest to be delivered
       * @param originalPayload Original payload used to create SentryRequest
       */
      FetchTransport.prototype._sendRequest = function (sentryRequest, originalPayload) {
        var _this = this;
        // eslint-disable-next-line deprecation/deprecation
        if (this._isRateLimited(sentryRequest.type)) {
          this.recordLostEvent('ratelimit_backoff', sentryRequest.type);
          return Promise.reject({
            event: originalPayload,
            type: sentryRequest.type,
            // eslint-disable-next-line deprecation/deprecation
            reason: "Transport for " + sentryRequest.type + " requests locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
            status: 429,
          });
        }
        var options = {
          body: sentryRequest.body,
          method: 'POST',
          // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default'
          // (see https://caniuse.com/#feat=referrer-policy),
          // it doesn't. And it throws an exception instead of ignoring this parameter...
          // REF: https://github.com/getsentry/raven-js/issues/1233
          referrerPolicy: (utils_1.supportsReferrerPolicy() ? 'origin' : ''),
        };
        if (this.options.fetchParameters !== undefined) {
          Object.assign(options, this.options.fetchParameters);
        }
        if (this.options.headers !== undefined) {
          options.headers = this.options.headers;
        }
        return this._buffer
          .add(function () {
            return new utils_1.SyncPromise(function (resolve, reject) {
              void _this._fetch(sentryRequest.url, options)
                .then(function (response) {
                  var headers = {
                    'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),
                    'retry-after': response.headers.get('Retry-After'),
                  };
                  _this._handleResponse({
                    requestType: sentryRequest.type,
                    response: response,
                    headers: headers,
                    resolve: resolve,
                    reject: reject,
                  });
                })
                .catch(reject);
            });
          })
          .then(undefined, function (reason) {
            // It's either buffer rejection or any other xhr/fetch error, which are treated as NetworkError.
            if (reason instanceof utils_1.SentryError) {
              _this.recordLostEvent('queue_overflow', sentryRequest.type);
            }
            else {
              _this.recordLostEvent('network_error', sentryRequest.type);
            }
            throw reason;
          });
      };
      return FetchTransport;
    }(base_1.BaseTransport));
    exports.FetchTransport = FetchTransport;

  }, { "./base": 24, "./utils": 29, "@sentry/utils": 95, "tslib": 181 }], 26: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_1 = require("./base");
    exports.BaseTransport = base_1.BaseTransport;
    var fetch_1 = require("./fetch");
    exports.FetchTransport = fetch_1.FetchTransport;
    var xhr_1 = require("./xhr");
    exports.XHRTransport = xhr_1.XHRTransport;
    var new_fetch_1 = require("./new-fetch");
    exports.makeNewFetchTransport = new_fetch_1.makeNewFetchTransport;
    var new_xhr_1 = require("./new-xhr");
    exports.makeNewXHRTransport = new_xhr_1.makeNewXHRTransport;

  }, { "./base": 24, "./fetch": 25, "./new-fetch": 27, "./new-xhr": 28, "./xhr": 30 }], 27: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var core_1 = require("@sentry/core");
    var utils_1 = require("./utils");
    /**
     * Creates a Transport that uses the Fetch API to send events to Sentry.
     */
    function makeNewFetchTransport(options, nativeFetch) {
      if (nativeFetch === void 0) { nativeFetch = utils_1.getNativeFetchImplementation(); }
      function makeRequest(request) {
        var requestOptions = tslib_1.__assign({ body: request.body, method: 'POST', referrerPolicy: 'origin' }, options.requestOptions);
        return nativeFetch(options.url, requestOptions).then(function (response) {
          return response.text().then(function (body) {
            return ({
              body: body,
              headers: {
                'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),
                'retry-after': response.headers.get('Retry-After'),
              },
              reason: response.statusText,
              statusCode: response.status,
            });
          });
        });
      }
      return core_1.createTransport({ bufferSize: options.bufferSize }, makeRequest);
    }
    exports.makeNewFetchTransport = makeNewFetchTransport;

  }, { "./utils": 29, "@sentry/core": 36, "tslib": 181 }], 28: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require("@sentry/core");
    var utils_1 = require("@sentry/utils");
    /**
     * The DONE ready state for XmlHttpRequest
     *
     * Defining it here as a constant b/c XMLHttpRequest.DONE is not always defined
     * (e.g. during testing, it is `undefined`)
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState}
     */
    var XHR_READYSTATE_DONE = 4;
    /**
     * Creates a Transport that uses the XMLHttpRequest API to send events to Sentry.
     */
    function makeNewXHRTransport(options) {
      function makeRequest(request) {
        return new utils_1.SyncPromise(function (resolve, _reject) {
          var xhr = new XMLHttpRequest();
          xhr.onreadystatechange = function () {
            if (xhr.readyState === XHR_READYSTATE_DONE) {
              var response = {
                body: xhr.response,
                headers: {
                  'x-sentry-rate-limits': xhr.getResponseHeader('X-Sentry-Rate-Limits'),
                  'retry-after': xhr.getResponseHeader('Retry-After'),
                },
                reason: xhr.statusText,
                statusCode: xhr.status,
              };
              resolve(response);
            }
          };
          xhr.open('POST', options.url);
          for (var header in options.headers) {
            if (Object.prototype.hasOwnProperty.call(options.headers, header)) {
              xhr.setRequestHeader(header, options.headers[header]);
            }
          }
          xhr.send(request.body);
        });
      }
      return core_1.createTransport({ bufferSize: options.bufferSize }, makeRequest);
    }
    exports.makeNewXHRTransport = makeNewXHRTransport;

  }, { "@sentry/core": 36, "@sentry/utils": 95 }], 29: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("../flags");
    var global = utils_1.getGlobalObject();
    var cachedFetchImpl;
    /**
     * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.
     * Whenever someone wraps the Fetch API and returns the wrong promise chain,
     * this chain becomes orphaned and there is no possible way to capture it's rejections
     * other than allowing it bubble up to this very handler. eg.
     *
     * const f = window.fetch;
     * window.fetch = function () {
     *   const p = f.apply(this, arguments);
     *
     *   p.then(function() {
     *     console.log('hi.');
     *   });
     *
     *   return p;
     * }
     *
     * `p.then(function () { ... })` is producing a completely separate promise chain,
     * however, what's returned is `p` - the result of original `fetch` call.
     *
     * This mean, that whenever we use the Fetch API to send our own requests, _and_
     * some ad-blocker blocks it, this orphaned chain will _always_ reject,
     * effectively causing another event to be captured.
     * This makes a whole process become an infinite loop, which we need to somehow
     * deal with, and break it in one way or another.
     *
     * To deal with this issue, we are making sure that we _always_ use the real
     * browser Fetch API, instead of relying on what `window.fetch` exposes.
     * The only downside to this would be missing our own requests as breadcrumbs,
     * but because we are already not doing this, it should be just fine.
     *
     * Possible failed fetch error messages per-browser:
     *
     * Chrome:  Failed to fetch
     * Edge:    Failed to Fetch
     * Firefox: NetworkError when attempting to fetch resource
     * Safari:  resource blocked by content blocker
     */
    function getNativeFetchImplementation() {
      if (cachedFetchImpl) {
        return cachedFetchImpl;
      }
      /* eslint-disable @typescript-eslint/unbound-method */
      // Fast path to avoid DOM I/O
      if (utils_1.isNativeFetch(global.fetch)) {
        return (cachedFetchImpl = global.fetch.bind(global));
      }
      var document = global.document;
      var fetchImpl = global.fetch;
      // eslint-disable-next-line deprecation/deprecation
      if (document && typeof document.createElement === 'function') {
        try {
          var sandbox = document.createElement('iframe');
          sandbox.hidden = true;
          document.head.appendChild(sandbox);
          var contentWindow = sandbox.contentWindow;
          if (contentWindow && contentWindow.fetch) {
            fetchImpl = contentWindow.fetch;
          }
          document.head.removeChild(sandbox);
        }
        catch (e) {
          flags_1.IS_DEBUG_BUILD &&
            utils_1.logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e);
        }
      }
      return (cachedFetchImpl = fetchImpl.bind(global));
      /* eslint-enable @typescript-eslint/unbound-method */
    }
    exports.getNativeFetchImplementation = getNativeFetchImplementation;
    /**
     * Sends sdk client report using sendBeacon or fetch as a fallback if available
     *
     * @param url report endpoint
     * @param body report payload
     */
    function sendReport(url, body) {
      var isRealNavigator = Object.prototype.toString.call(global && global.navigator) === '[object Navigator]';
      var hasSendBeacon = isRealNavigator && typeof global.navigator.sendBeacon === 'function';
      if (hasSendBeacon) {
        // Prevent illegal invocations - https://xgwang.me/posts/you-may-not-know-beacon/#it-may-throw-error%2C-be-sure-to-catch
        var sendBeacon = global.navigator.sendBeacon.bind(global.navigator);
        return sendBeacon(url, body);
      }
      if (utils_1.supportsFetch()) {
        var fetch_1 = getNativeFetchImplementation();
        return utils_1.forget(fetch_1(url, {
          body: body,
          method: 'POST',
          credentials: 'omit',
          keepalive: true,
        }));
      }
    }
    exports.sendReport = sendReport;

  }, { "../flags": 12, "@sentry/utils": 95 }], 30: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var utils_1 = require("@sentry/utils");
    var base_1 = require("./base");
    /** `XHR` based transport */
    var XHRTransport = /** @class */ (function (_super) {
      tslib_1.__extends(XHRTransport, _super);
      function XHRTransport() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * @param sentryRequest Prepared SentryRequest to be delivered
       * @param originalPayload Original payload used to create SentryRequest
       */
      XHRTransport.prototype._sendRequest = function (sentryRequest, originalPayload) {
        var _this = this;
        // eslint-disable-next-line deprecation/deprecation
        if (this._isRateLimited(sentryRequest.type)) {
          this.recordLostEvent('ratelimit_backoff', sentryRequest.type);
          return Promise.reject({
            event: originalPayload,
            type: sentryRequest.type,
            // eslint-disable-next-line deprecation/deprecation
            reason: "Transport for " + sentryRequest.type + " requests locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
            status: 429,
          });
        }
        return this._buffer
          .add(function () {
            return new utils_1.SyncPromise(function (resolve, reject) {
              var request = new XMLHttpRequest();
              request.onreadystatechange = function () {
                if (request.readyState === 4) {
                  var headers = {
                    'x-sentry-rate-limits': request.getResponseHeader('X-Sentry-Rate-Limits'),
                    'retry-after': request.getResponseHeader('Retry-After'),
                  };
                  _this._handleResponse({ requestType: sentryRequest.type, response: request, headers: headers, resolve: resolve, reject: reject });
                }
              };
              request.open('POST', sentryRequest.url);
              for (var header in _this.options.headers) {
                if (Object.prototype.hasOwnProperty.call(_this.options.headers, header)) {
                  request.setRequestHeader(header, _this.options.headers[header]);
                }
              }
              request.send(sentryRequest.body);
            });
          })
          .then(undefined, function (reason) {
            // It's either buffer rejection or any other xhr/fetch error, which are treated as NetworkError.
            if (reason instanceof utils_1.SentryError) {
              _this.recordLostEvent('queue_overflow', sentryRequest.type);
            }
            else {
              _this.recordLostEvent('network_error', sentryRequest.type);
            }
            throw reason;
          });
      };
      return XHRTransport;
    }(base_1.BaseTransport));
    exports.XHRTransport = XHRTransport;

  }, { "./base": 24, "@sentry/utils": 95, "tslib": 181 }], 31: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    // TODO: Remove in the next major release and rely only on @sentry/core SDK_VERSION and SdkInfo metadata
    exports.SDK_NAME = 'sentry.javascript.browser';

  }, {}], 32: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require("@sentry/utils");
    var SENTRY_API_VERSION = '7';
    /**
     * Helper class to provide urls, headers and metadata that can be used to form
     * different types of requests to Sentry endpoints.
     * Supports both envelopes and regular event requests.
     *
     * @deprecated Please use APIDetails
     **/
    var API = /** @class */ (function () {
      /** Create a new instance of API */
      function API(dsn, metadata, tunnel) {
        if (metadata === void 0) { metadata = {}; }
        this.dsn = dsn;
        this._dsnObject = utils_1.makeDsn(dsn);
        this.metadata = metadata;
        this._tunnel = tunnel;
      }
      /** Returns the Dsn object. */
      API.prototype.getDsn = function () {
        return this._dsnObject;
      };
      /** Does this transport force envelopes? */
      API.prototype.forceEnvelope = function () {
        return !!this._tunnel;
      };
      /** Returns the prefix to construct Sentry ingestion API endpoints. */
      API.prototype.getBaseApiEndpoint = function () {
        return getBaseApiEndpoint(this._dsnObject);
      };
      /** Returns the store endpoint URL. */
      API.prototype.getStoreEndpoint = function () {
        return getStoreEndpoint(this._dsnObject);
      };
      /**
       * Returns the store endpoint URL with auth in the query string.
       *
       * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
       */
      API.prototype.getStoreEndpointWithUrlEncodedAuth = function () {
        return getStoreEndpointWithUrlEncodedAuth(this._dsnObject);
      };
      /**
       * Returns the envelope endpoint URL with auth in the query string.
       *
       * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
       */
      API.prototype.getEnvelopeEndpointWithUrlEncodedAuth = function () {
        return getEnvelopeEndpointWithUrlEncodedAuth(this._dsnObject, this._tunnel);
      };
      return API;
    }());
    exports.API = API;
    /** Initializes API Details */
    function initAPIDetails(dsn, metadata, tunnel) {
      return {
        initDsn: dsn,
        metadata: metadata || {},
        dsn: utils_1.makeDsn(dsn),
        tunnel: tunnel,
      };
    }
    exports.initAPIDetails = initAPIDetails;
    /** Returns the prefix to construct Sentry ingestion API endpoints. */
    function getBaseApiEndpoint(dsn) {
      var protocol = dsn.protocol ? dsn.protocol + ":" : '';
      var port = dsn.port ? ":" + dsn.port : '';
      return protocol + "//" + dsn.host + port + (dsn.path ? "/" + dsn.path : '') + "/api/";
    }
    /** Returns the ingest API endpoint for target. */
    function _getIngestEndpoint(dsn, target) {
      return "" + getBaseApiEndpoint(dsn) + dsn.projectId + "/" + target + "/";
    }
    /** Returns a URL-encoded string with auth config suitable for a query string. */
    function _encodedAuth(dsn) {
      return utils_1.urlEncode({
        // We send only the minimum set of required information. See
        // https://github.com/getsentry/sentry-javascript/issues/2572.
        sentry_key: dsn.publicKey,
        sentry_version: SENTRY_API_VERSION,
      });
    }
    /** Returns the store endpoint URL. */
    function getStoreEndpoint(dsn) {
      return _getIngestEndpoint(dsn, 'store');
    }
    /**
     * Returns the store endpoint URL with auth in the query string.
     *
     * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
     */
    function getStoreEndpointWithUrlEncodedAuth(dsn) {
      return getStoreEndpoint(dsn) + "?" + _encodedAuth(dsn);
    }
    exports.getStoreEndpointWithUrlEncodedAuth = getStoreEndpointWithUrlEncodedAuth;
    /** Returns the envelope endpoint URL. */
    function _getEnvelopeEndpoint(dsn) {
      return _getIngestEndpoint(dsn, 'envelope');
    }
    /**
     * Returns the envelope endpoint URL with auth in the query string.
     *
     * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
     */
    function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnel) {
      return tunnel ? tunnel : _getEnvelopeEndpoint(dsn) + "?" + _encodedAuth(dsn);
    }
    exports.getEnvelopeEndpointWithUrlEncodedAuth = getEnvelopeEndpointWithUrlEncodedAuth;
    /**
     * Returns an object that can be used in request headers.
     * This is needed for node and the old /store endpoint in sentry
     */
    function getRequestHeaders(dsn, clientName, clientVersion) {
      // CHANGE THIS to use metadata but keep clientName and clientVersion compatible
      var header = ["Sentry sentry_version=" + SENTRY_API_VERSION];
      header.push("sentry_client=" + clientName + "/" + clientVersion);
      header.push("sentry_key=" + dsn.publicKey);
      if (dsn.pass) {
        header.push("sentry_secret=" + dsn.pass);
      }
      return {
        'Content-Type': 'application/json',
        'X-Sentry-Auth': header.join(', '),
      };
    }
    exports.getRequestHeaders = getRequestHeaders;
    /** Returns the url to the report dialog endpoint. */
    function getReportDialogEndpoint(dsnLike, dialogOptions) {
      var dsn = utils_1.makeDsn(dsnLike);
      var endpoint = getBaseApiEndpoint(dsn) + "embed/error-page/";
      var encodedOptions = "dsn=" + utils_1.dsnToString(dsn);
      for (var key in dialogOptions) {
        if (key === 'dsn') {
          continue;
        }
        if (key === 'user') {
          if (!dialogOptions.user) {
            continue;
          }
          if (dialogOptions.user.name) {
            encodedOptions += "&name=" + encodeURIComponent(dialogOptions.user.name);
          }
          if (dialogOptions.user.email) {
            encodedOptions += "&email=" + encodeURIComponent(dialogOptions.user.email);
          }
        }
        else {
          encodedOptions += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(dialogOptions[key]);
        }
      }
      return endpoint + "?" + encodedOptions;
    }
    exports.getReportDialogEndpoint = getReportDialogEndpoint;

  }, { "@sentry/utils": 95 }], 33: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var utils_1 = require("@sentry/utils");
    var api_1 = require("./api");
    var flags_1 = require("./flags");
    var request_1 = require("./request");
    var noop_1 = require("./transports/noop");
    /**
     * This is the base implemention of a Backend.
     * @hidden
     */
    var BaseBackend = /** @class */ (function () {
      /** Creates a new backend instance. */
      function BaseBackend(options) {
        this._options = options;
        if (!this._options.dsn) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('No DSN provided, backend will not do anything.');
        }
        this._transport = this._setupTransport();
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
      BaseBackend.prototype.eventFromException = function (_exception, _hint) {
        throw new utils_1.SentryError('Backend has to implement `eventFromException` method');
      };
      /**
       * @inheritDoc
       */
      BaseBackend.prototype.eventFromMessage = function (_message, _level, _hint) {
        throw new utils_1.SentryError('Backend has to implement `eventFromMessage` method');
      };
      /**
       * @inheritDoc
       */
      BaseBackend.prototype.sendEvent = function (event) {
        // TODO(v7): Remove the if-else
        if (this._newTransport &&
          this._options.dsn &&
          this._options._experiments &&
          this._options._experiments.newTransport) {
          var api = api_1.initAPIDetails(this._options.dsn, this._options._metadata, this._options.tunnel);
          var env = request_1.createEventEnvelope(event, api);
          void this._newTransport.send(env).then(null, function (reason) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.error('Error while sending event:', reason);
          });
        }
        else {
          void this._transport.sendEvent(event).then(null, function (reason) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.error('Error while sending event:', reason);
          });
        }
      };
      /**
       * @inheritDoc
       */
      BaseBackend.prototype.sendSession = function (session) {
        if (!this._transport.sendSession) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.warn("Dropping session because custom transport doesn't implement sendSession");
          return;
        }
        // TODO(v7): Remove the if-else
        if (this._newTransport &&
          this._options.dsn &&
          this._options._experiments &&
          this._options._experiments.newTransport) {
          var api = api_1.initAPIDetails(this._options.dsn, this._options._metadata, this._options.tunnel);
          var _a = tslib_1.__read(request_1.createSessionEnvelope(session, api), 1), env = _a[0];
          void this._newTransport.send(env).then(null, function (reason) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.error('Error while sending session:', reason);
          });
        }
        else {
          void this._transport.sendSession(session).then(null, function (reason) {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.error('Error while sending session:', reason);
          });
        }
      };
      /**
       * @inheritDoc
       */
      BaseBackend.prototype.getTransport = function () {
        return this._transport;
      };
      /**
       * Sets up the transport so it can be used later to send requests.
       */
      BaseBackend.prototype._setupTransport = function () {
        return new noop_1.NoopTransport();
      };
      return BaseBackend;
    }());
    exports.BaseBackend = BaseBackend;

  }, { "./api": 32, "./flags": 35, "./request": 41, "./transports/noop": 44, "@sentry/utils": 95, "tslib": 181 }], 34: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    /* eslint-disable max-lines */
    var hub_1 = require("@sentry/hub");
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("./flags");
    var integration_1 = require("./integration");
    var ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
    /**
     * Base implementation for all JavaScript SDK clients.
     *
     * Call the constructor with the corresponding backend constructor and options
     * specific to the client subclass. To access these options later, use
     * {@link Client.getOptions}. Also, the Backend instance is available via
     * {@link Client.getBackend}.
     *
     * If a Dsn is specified in the options, it will be parsed and stored. Use
     * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is
     * invalid, the constructor will throw a {@link SentryException}. Note that
     * without a valid Dsn, the SDK will not send any events to Sentry.
     *
     * Before sending an event via the backend, it is passed through
     * {@link BaseClient._prepareEvent} to add SDK information and scope data
     * (breadcrumbs and context). To add more custom information, override this
     * method and extend the resulting prepared event.
     *
     * To issue automatically created events (e.g. via instrumentation), use
     * {@link Client.captureEvent}. It will prepare the event and pass it through
     * the callback lifecycle. To issue auto-breadcrumbs, use
     * {@link Client.addBreadcrumb}.
     *
     * @example
     * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {
     *   public constructor(options: NodeOptions) {
     *     super(NodeBackend, options);
     *   }
     *
     *   // ...
     * }
     */
    var BaseClient = /** @class */ (function () {
      /**
       * Initializes this client instance.
       *
       * @param backendClass A constructor function to create the backend.
       * @param options Options for the client.
       */
      function BaseClient(backendClass, options) {
        /** Array of used integrations. */
        this._integrations = {};
        /** Number of calls being processed */
        this._numProcessing = 0;
        this._backend = new backendClass(options);
        this._options = options;
        if (options.dsn) {
          this._dsn = utils_1.makeDsn(options.dsn);
        }
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
      BaseClient.prototype.captureException = function (exception, hint, scope) {
        var _this = this;
        // ensure we haven't captured this very object before
        if (utils_1.checkOrSetAlreadyCaught(exception)) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.log(ALREADY_SEEN_ERROR);
          return;
        }
        var eventId = hint && hint.event_id;
        this._process(this._getBackend()
          .eventFromException(exception, hint)
          .then(function (event) { return _this._captureEvent(event, hint, scope); })
          .then(function (result) {
            eventId = result;
          }));
        return eventId;
      };
      /**
       * @inheritDoc
       */
      BaseClient.prototype.captureMessage = function (message, level, hint, scope) {
        var _this = this;
        var eventId = hint && hint.event_id;
        var promisedEvent = utils_1.isPrimitive(message)
          ? this._getBackend().eventFromMessage(String(message), level, hint)
          : this._getBackend().eventFromException(message, hint);
        this._process(promisedEvent
          .then(function (event) { return _this._captureEvent(event, hint, scope); })
          .then(function (result) {
            eventId = result;
          }));
        return eventId;
      };
      /**
       * @inheritDoc
       */
      BaseClient.prototype.captureEvent = function (event, hint, scope) {
        // ensure we haven't captured this very object before
        if (hint && hint.originalException && utils_1.checkOrSetAlreadyCaught(hint.originalException)) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.log(ALREADY_SEEN_ERROR);
          return;
        }
        var eventId = hint && hint.event_id;
        this._process(this._captureEvent(event, hint, scope).then(function (result) {
          eventId = result;
        }));
        return eventId;
      };
      /**
       * @inheritDoc
       */
      BaseClient.prototype.captureSession = function (session) {
        if (!this._isEnabled()) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('SDK not enabled, will not capture session.');
          return;
        }
        if (!(typeof session.release === 'string')) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('Discarded session because of missing or non-string release');
        }
        else {
          this._sendSession(session);
          // After sending, we set init false to indicate it's not the first occurrence
          session.update({ init: false });
        }
      };
      /**
       * @inheritDoc
       */
      BaseClient.prototype.getDsn = function () {
        return this._dsn;
      };
      /**
       * @inheritDoc
       */
      BaseClient.prototype.getOptions = function () {
        return this._options;
      };
      /**
       * @inheritDoc
       */
      BaseClient.prototype.getTransport = function () {
        return this._getBackend().getTransport();
      };
      /**
       * @inheritDoc
       */
      BaseClient.prototype.flush = function (timeout) {
        var _this = this;
        return this._isClientDoneProcessing(timeout).then(function (clientFinished) {
          return _this.getTransport()
            .close(timeout)
            .then(function (transportFlushed) { return clientFinished && transportFlushed; });
        });
      };
      /**
       * @inheritDoc
       */
      BaseClient.prototype.close = function (timeout) {
        var _this = this;
        return this.flush(timeout).then(function (result) {
          _this.getOptions().enabled = false;
          return result;
        });
      };
      /**
       * Sets up the integrations
       */
      BaseClient.prototype.setupIntegrations = function () {
        if (this._isEnabled() && !this._integrations.initialized) {
          this._integrations = integration_1.setupIntegrations(this._options);
        }
      };
      /**
       * @inheritDoc
       */
      BaseClient.prototype.getIntegration = function (integration) {
        try {
          return this._integrations[integration.id] || null;
        }
        catch (_oO) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.warn("Cannot retrieve integration " + integration.id + " from the current Client");
          return null;
        }
      };
      /** Updates existing session based on the provided event */
      BaseClient.prototype._updateSessionFromEvent = function (session, event) {
        var e_1, _a;
        var crashed = false;
        var errored = false;
        var exceptions = event.exception && event.exception.values;
        if (exceptions) {
          errored = true;
          try {
            for (var exceptions_1 = tslib_1.__values(exceptions), exceptions_1_1 = exceptions_1.next(); !exceptions_1_1.done; exceptions_1_1 = exceptions_1.next()) {
              var ex = exceptions_1_1.value;
              var mechanism = ex.mechanism;
              if (mechanism && mechanism.handled === false) {
                crashed = true;
                break;
              }
            }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
            try {
              if (exceptions_1_1 && !exceptions_1_1.done && (_a = exceptions_1.return)) _a.call(exceptions_1);
            }
            finally { if (e_1) throw e_1.error; }
          }
        }
        // A session is updated and that session update is sent in only one of the two following scenarios:
        // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update
        // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update
        var sessionNonTerminal = session.status === 'ok';
        var shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);
        if (shouldUpdateAndSend) {
          session.update(tslib_1.__assign(tslib_1.__assign({}, (crashed && { status: 'crashed' })), { errors: session.errors || Number(errored || crashed) }));
          this.captureSession(session);
        }
      };
      /** Deliver captured session to Sentry */
      BaseClient.prototype._sendSession = function (session) {
        this._getBackend().sendSession(session);
      };
      /**
       * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
       * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
       *
       * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
       * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
       * `true`.
       * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
       * `false` otherwise
       */
      BaseClient.prototype._isClientDoneProcessing = function (timeout) {
        var _this = this;
        return new utils_1.SyncPromise(function (resolve) {
          var ticked = 0;
          var tick = 1;
          var interval = setInterval(function () {
            if (_this._numProcessing == 0) {
              clearInterval(interval);
              resolve(true);
            }
            else {
              ticked += tick;
              if (timeout && ticked >= timeout) {
                clearInterval(interval);
                resolve(false);
              }
            }
          }, tick);
        });
      };
      /** Returns the current backend. */
      BaseClient.prototype._getBackend = function () {
        return this._backend;
      };
      /** Determines whether this SDK is enabled and a valid Dsn is present. */
      BaseClient.prototype._isEnabled = function () {
        return this.getOptions().enabled !== false && this._dsn !== undefined;
      };
      /**
       * Adds common information to events.
       *
       * The information includes release and environment from `options`,
       * breadcrumbs and context (extra, tags and user) from the scope.
       *
       * Information that is already present in the event is never overwritten. For
       * nested objects, such as the context, keys are merged.
       *
       * @param event The original event.
       * @param hint May contain additional information about the original exception.
       * @param scope A scope containing event metadata.
       * @returns A new event with more information.
       */
      BaseClient.prototype._prepareEvent = function (event, scope, hint) {
        var _this = this;
        var _a = this.getOptions(), _b = _a.normalizeDepth, normalizeDepth = _b === void 0 ? 3 : _b, _c = _a.normalizeMaxBreadth, normalizeMaxBreadth = _c === void 0 ? 1000 : _c;
        var prepared = tslib_1.__assign(tslib_1.__assign({}, event), { event_id: event.event_id || (hint && hint.event_id ? hint.event_id : utils_1.uuid4()), timestamp: event.timestamp || utils_1.dateTimestampInSeconds() });
        this._applyClientOptions(prepared);
        this._applyIntegrationsMetadata(prepared);
        // If we have scope given to us, use it as the base for further modifications.
        // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.
        var finalScope = scope;
        if (hint && hint.captureContext) {
          finalScope = hub_1.Scope.clone(finalScope).update(hint.captureContext);
        }
        // We prepare the result here with a resolved Event.
        var result = utils_1.resolvedSyncPromise(prepared);
        // This should be the last thing called, since we want that
        // {@link Hub.addEventProcessor} gets the finished prepared event.
        if (finalScope) {
          // In case we have a hub we reassign it.
          result = finalScope.applyToEvent(prepared, hint);
        }
        return result.then(function (evt) {
          if (evt) {
            // TODO this is more of the hack trying to solve https://github.com/getsentry/sentry-javascript/issues/2809
            // it is only attached as extra data to the event if the event somehow skips being normalized
            evt.sdkProcessingMetadata = tslib_1.__assign(tslib_1.__assign({}, evt.sdkProcessingMetadata), { normalizeDepth: utils_1.normalize(normalizeDepth) + " (" + typeof normalizeDepth + ")" });
          }
          if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {
            return _this._normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
          }
          return evt;
        });
      };
      /**
       * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.
       * Normalized keys:
       * - `breadcrumbs.data`
       * - `user`
       * - `contexts`
       * - `extra`
       * @param event Event
       * @returns Normalized event
       */
      BaseClient.prototype._normalizeEvent = function (event, depth, maxBreadth) {
        if (!event) {
          return null;
        }
        var normalized = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, event), (event.breadcrumbs && {
          breadcrumbs: event.breadcrumbs.map(function (b) {
            return (tslib_1.__assign(tslib_1.__assign({}, b), (b.data && {
              data: utils_1.normalize(b.data, depth, maxBreadth),
            })));
          }),
        })), (event.user && {
          user: utils_1.normalize(event.user, depth, maxBreadth),
        })), (event.contexts && {
          contexts: utils_1.normalize(event.contexts, depth, maxBreadth),
        })), (event.extra && {
          extra: utils_1.normalize(event.extra, depth, maxBreadth),
        }));
        // event.contexts.trace stores information about a Transaction. Similarly,
        // event.spans[] stores information about child Spans. Given that a
        // Transaction is conceptually a Span, normalization should apply to both
        // Transactions and Spans consistently.
        // For now the decision is to skip normalization of Transactions and Spans,
        // so this block overwrites the normalized event to add back the original
        // Transaction information prior to normalization.
        if (event.contexts && event.contexts.trace) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          normalized.contexts.trace = event.contexts.trace;
        }
        normalized.sdkProcessingMetadata = tslib_1.__assign(tslib_1.__assign({}, normalized.sdkProcessingMetadata), { baseClientNormalized: true });
        return normalized;
      };
      /**
       *  Enhances event using the client configuration.
       *  It takes care of all "static" values like environment, release and `dist`,
       *  as well as truncating overly long values.
       * @param event event instance to be enhanced
       */
      BaseClient.prototype._applyClientOptions = function (event) {
        var options = this.getOptions();
        var environment = options.environment, release = options.release, dist = options.dist, _a = options.maxValueLength, maxValueLength = _a === void 0 ? 250 : _a;
        if (!('environment' in event)) {
          event.environment = 'environment' in options ? environment : 'production';
        }
        if (event.release === undefined && release !== undefined) {
          event.release = release;
        }
        if (event.dist === undefined && dist !== undefined) {
          event.dist = dist;
        }
        if (event.message) {
          event.message = utils_1.truncate(event.message, maxValueLength);
        }
        var exception = event.exception && event.exception.values && event.exception.values[0];
        if (exception && exception.value) {
          exception.value = utils_1.truncate(exception.value, maxValueLength);
        }
        var request = event.request;
        if (request && request.url) {
          request.url = utils_1.truncate(request.url, maxValueLength);
        }
      };
      /**
       * This function adds all used integrations to the SDK info in the event.
       * @param event The event that will be filled with all integrations.
       */
      BaseClient.prototype._applyIntegrationsMetadata = function (event) {
        var integrationsArray = Object.keys(this._integrations);
        if (integrationsArray.length > 0) {
          event.sdk = event.sdk || {};
          event.sdk.integrations = tslib_1.__spread((event.sdk.integrations || []), integrationsArray);
        }
      };
      /**
       * Tells the backend to send this event
       * @param event The Sentry event to send
       */
      BaseClient.prototype._sendEvent = function (event) {
        this._getBackend().sendEvent(event);
      };
      /**
       * Processes the event and logs an error in case of rejection
       * @param event
       * @param hint
       * @param scope
       */
      BaseClient.prototype._captureEvent = function (event, hint, scope) {
        return this._processEvent(event, hint, scope).then(function (finalEvent) {
          return finalEvent.event_id;
        }, function (reason) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.error(reason);
          return undefined;
        });
      };
      /**
       * Processes an event (either error or message) and sends it to Sentry.
       *
       * This also adds breadcrumbs and context information to the event. However,
       * platform specific meta data (such as the User's IP address) must be added
       * by the SDK implementor.
       *
       *
       * @param event The event to send to Sentry.
       * @param hint May contain additional information about the original exception.
       * @param scope A scope containing event metadata.
       * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
       */
      BaseClient.prototype._processEvent = function (event, hint, scope) {
        var _this = this;
        // eslint-disable-next-line @typescript-eslint/unbound-method
        var _a = this.getOptions(), beforeSend = _a.beforeSend, sampleRate = _a.sampleRate;
        var transport = this.getTransport();
        function recordLostEvent(outcome, category) {
          if (transport.recordLostEvent) {
            transport.recordLostEvent(outcome, category);
          }
        }
        if (!this._isEnabled()) {
          return utils_1.rejectedSyncPromise(new utils_1.SentryError('SDK not enabled, will not capture event.'));
        }
        var isTransaction = event.type === 'transaction';
        // 1.0 === 100% events are sent
        // 0.0 === 0% events are sent
        // Sampling for transaction happens somewhere else
        if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {
          recordLostEvent('sample_rate', 'event');
          return utils_1.rejectedSyncPromise(new utils_1.SentryError("Discarding event because it's not included in the random sample (sampling rate = " + sampleRate + ")"));
        }
        return this._prepareEvent(event, scope, hint)
          .then(function (prepared) {
            if (prepared === null) {
              recordLostEvent('event_processor', event.type || 'event');
              throw new utils_1.SentryError('An event processor returned null, will not send event.');
            }
            var isInternalException = hint && hint.data && hint.data.__sentry__ === true;
            if (isInternalException || isTransaction || !beforeSend) {
              return prepared;
            }
            var beforeSendResult = beforeSend(prepared, hint);
            return _ensureBeforeSendRv(beforeSendResult);
          })
          .then(function (processedEvent) {
            if (processedEvent === null) {
              recordLostEvent('before_send', event.type || 'event');
              throw new utils_1.SentryError('`beforeSend` returned `null`, will not send event.');
            }
            var session = scope && scope.getSession && scope.getSession();
            if (!isTransaction && session) {
              _this._updateSessionFromEvent(session, processedEvent);
            }
            _this._sendEvent(processedEvent);
            return processedEvent;
          })
          .then(null, function (reason) {
            if (reason instanceof utils_1.SentryError) {
              throw reason;
            }
            _this.captureException(reason, {
              data: {
                __sentry__: true,
              },
              originalException: reason,
            });
            throw new utils_1.SentryError("Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: " + reason);
          });
      };
      /**
       * Occupies the client with processing and event
       */
      BaseClient.prototype._process = function (promise) {
        var _this = this;
        this._numProcessing += 1;
        void promise.then(function (value) {
          _this._numProcessing -= 1;
          return value;
        }, function (reason) {
          _this._numProcessing -= 1;
          return reason;
        });
      };
      return BaseClient;
    }());
    exports.BaseClient = BaseClient;
    /**
     * Verifies that return value of configured `beforeSend` is of expected type.
     */
    function _ensureBeforeSendRv(rv) {
      var nullErr = '`beforeSend` method has to return `null` or a valid event.';
      if (utils_1.isThenable(rv)) {
        return rv.then(function (event) {
          if (!(utils_1.isPlainObject(event) || event === null)) {
            throw new utils_1.SentryError(nullErr);
          }
          return event;
        }, function (e) {
          throw new utils_1.SentryError("beforeSend rejected with " + e);
        });
      }
      else if (!(utils_1.isPlainObject(rv) || rv === null)) {
        throw new utils_1.SentryError(nullErr);
      }
      return rv;
    }

  }, { "./flags": 35, "./integration": 37, "@sentry/hub": 48, "@sentry/utils": 95, "tslib": 181 }], 35: [function (require, module, exports) {
    arguments[4][12][0].apply(exports, arguments)
  }, { "dup": 12 }], 36: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var minimal_1 = require("@sentry/minimal");
    exports.addBreadcrumb = minimal_1.addBreadcrumb;
    exports.captureException = minimal_1.captureException;
    exports.captureEvent = minimal_1.captureEvent;
    exports.captureMessage = minimal_1.captureMessage;
    exports.configureScope = minimal_1.configureScope;
    exports.startTransaction = minimal_1.startTransaction;
    exports.setContext = minimal_1.setContext;
    exports.setExtra = minimal_1.setExtra;
    exports.setExtras = minimal_1.setExtras;
    exports.setTag = minimal_1.setTag;
    exports.setTags = minimal_1.setTags;
    exports.setUser = minimal_1.setUser;
    exports.withScope = minimal_1.withScope;
    var hub_1 = require("@sentry/hub");
    exports.addGlobalEventProcessor = hub_1.addGlobalEventProcessor;
    exports.getCurrentHub = hub_1.getCurrentHub;
    exports.getHubFromCarrier = hub_1.getHubFromCarrier;
    exports.Hub = hub_1.Hub;
    exports.makeMain = hub_1.makeMain;
    exports.Scope = hub_1.Scope;
    exports.Session = hub_1.Session;
    var api_1 = require("./api");
    // eslint-disable-next-line deprecation/deprecation
    exports.API = api_1.API;
    exports.getEnvelopeEndpointWithUrlEncodedAuth = api_1.getEnvelopeEndpointWithUrlEncodedAuth;
    exports.getStoreEndpointWithUrlEncodedAuth = api_1.getStoreEndpointWithUrlEncodedAuth;
    exports.getRequestHeaders = api_1.getRequestHeaders;
    exports.initAPIDetails = api_1.initAPIDetails;
    exports.getReportDialogEndpoint = api_1.getReportDialogEndpoint;
    var baseclient_1 = require("./baseclient");
    exports.BaseClient = baseclient_1.BaseClient;
    var basebackend_1 = require("./basebackend");
    exports.BaseBackend = basebackend_1.BaseBackend;
    var request_1 = require("./request");
    exports.eventToSentryRequest = request_1.eventToSentryRequest;
    exports.sessionToSentryRequest = request_1.sessionToSentryRequest;
    var sdk_1 = require("./sdk");
    exports.initAndBind = sdk_1.initAndBind;
    var noop_1 = require("./transports/noop");
    exports.NoopTransport = noop_1.NoopTransport;
    var base_1 = require("./transports/base");
    exports.createTransport = base_1.createTransport;
    var version_1 = require("./version");
    exports.SDK_VERSION = version_1.SDK_VERSION;
    var Integrations = require("./integrations");
    exports.Integrations = Integrations;

  }, { "./api": 32, "./basebackend": 33, "./baseclient": 34, "./integrations": 40, "./request": 41, "./sdk": 42, "./transports/base": 43, "./transports/noop": 44, "./version": 45, "@sentry/hub": 48, "@sentry/minimal": 52 }], 37: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var hub_1 = require("@sentry/hub");
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("./flags");
    exports.installedIntegrations = [];
    /**
     * @private
     */
    function filterDuplicates(integrations) {
      return integrations.reduce(function (acc, integrations) {
        if (acc.every(function (accIntegration) { return integrations.name !== accIntegration.name; })) {
          acc.push(integrations);
        }
        return acc;
      }, []);
    }
    /** Gets integration to install */
    function getIntegrationsToSetup(options) {
      var defaultIntegrations = (options.defaultIntegrations && tslib_1.__spread(options.defaultIntegrations)) || [];
      var userIntegrations = options.integrations;
      var integrations = tslib_1.__spread(filterDuplicates(defaultIntegrations));
      if (Array.isArray(userIntegrations)) {
        // Filter out integrations that are also included in user options
        integrations = tslib_1.__spread(integrations.filter(function (integrations) {
          return userIntegrations.every(function (userIntegration) { return userIntegration.name !== integrations.name; });
        }), filterDuplicates(userIntegrations));
      }
      else if (typeof userIntegrations === 'function') {
        integrations = userIntegrations(integrations);
        integrations = Array.isArray(integrations) ? integrations : [integrations];
      }
      // Make sure that if present, `Debug` integration will always run last
      var integrationsNames = integrations.map(function (i) { return i.name; });
      var alwaysLastToRun = 'Debug';
      if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {
        integrations.push.apply(integrations, tslib_1.__spread(integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1)));
      }
      return integrations;
    }
    exports.getIntegrationsToSetup = getIntegrationsToSetup;
    /** Setup given integration */
    function setupIntegration(integration) {
      if (exports.installedIntegrations.indexOf(integration.name) !== -1) {
        return;
      }
      integration.setupOnce(hub_1.addGlobalEventProcessor, hub_1.getCurrentHub);
      exports.installedIntegrations.push(integration.name);
      flags_1.IS_DEBUG_BUILD && utils_1.logger.log("Integration installed: " + integration.name);
    }
    exports.setupIntegration = setupIntegration;
    /**
     * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default
     * integrations are added unless they were already provided before.
     * @param integrations array of integration instances
     * @param withDefault should enable default integrations
     */
    function setupIntegrations(options) {
      var integrations = {};
      getIntegrationsToSetup(options).forEach(function (integration) {
        integrations[integration.name] = integration;
        setupIntegration(integration);
      });
      // set the `initialized` flag so we don't run through the process again unecessarily; use `Object.defineProperty`
      // because by default it creates a property which is nonenumerable, which we want since `initialized` shouldn't be
      // considered a member of the index the way the actual integrations are
      utils_1.addNonEnumerableProperty(integrations, 'initialized', true);
      return integrations;
    }
    exports.setupIntegrations = setupIntegrations;

  }, { "./flags": 35, "@sentry/hub": 48, "@sentry/utils": 95, "tslib": 181 }], 38: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require("@sentry/utils");
    var originalFunctionToString;
    /** Patch toString calls to return proper name for wrapped functions */
    var FunctionToString = /** @class */ (function () {
      function FunctionToString() {
        /**
         * @inheritDoc
         */
        this.name = FunctionToString.id;
      }
      /**
       * @inheritDoc
       */
      FunctionToString.prototype.setupOnce = function () {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        originalFunctionToString = Function.prototype.toString;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Function.prototype.toString = function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var context = utils_1.getOriginalFunction(this) || this;
          return originalFunctionToString.apply(context, args);
        };
      };
      /**
       * @inheritDoc
       */
      FunctionToString.id = 'FunctionToString';
      return FunctionToString;
    }());
    exports.FunctionToString = FunctionToString;

  }, { "@sentry/utils": 95 }], 39: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("../flags");
    // "Script error." is hard coded into browsers for errors that it can't read.
    // this is the result of a script being pulled in from an external domain and CORS.
    var DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
    /** Inbound filters configurable by the user */
    var InboundFilters = /** @class */ (function () {
      function InboundFilters(_options) {
        if (_options === void 0) { _options = {}; }
        this._options = _options;
        /**
         * @inheritDoc
         */
        this.name = InboundFilters.id;
      }
      /**
       * @inheritDoc
       */
      InboundFilters.prototype.setupOnce = function (addGlobalEventProcessor, getCurrentHub) {
        addGlobalEventProcessor(function (event) {
          var hub = getCurrentHub();
          if (hub) {
            var self_1 = hub.getIntegration(InboundFilters);
            if (self_1) {
              var client = hub.getClient();
              var clientOptions = client ? client.getOptions() : {};
              var options = _mergeOptions(self_1._options, clientOptions);
              return _shouldDropEvent(event, options) ? null : event;
            }
          }
          return event;
        });
      };
      /**
       * @inheritDoc
       */
      InboundFilters.id = 'InboundFilters';
      return InboundFilters;
    }());
    exports.InboundFilters = InboundFilters;
    /** JSDoc */
    function _mergeOptions(internalOptions, clientOptions) {
      if (internalOptions === void 0) { internalOptions = {}; }
      if (clientOptions === void 0) { clientOptions = {}; }
      return {
        allowUrls: tslib_1.__spread((internalOptions.whitelistUrls || []), (internalOptions.allowUrls || []), (clientOptions.whitelistUrls || []), (clientOptions.allowUrls || [])),
        denyUrls: tslib_1.__spread((internalOptions.blacklistUrls || []), (internalOptions.denyUrls || []), (clientOptions.blacklistUrls || []), (clientOptions.denyUrls || [])),
        ignoreErrors: tslib_1.__spread((internalOptions.ignoreErrors || []), (clientOptions.ignoreErrors || []), DEFAULT_IGNORE_ERRORS),
        ignoreInternal: internalOptions.ignoreInternal !== undefined ? internalOptions.ignoreInternal : true,
      };
    }
    exports._mergeOptions = _mergeOptions;
    /** JSDoc */
    function _shouldDropEvent(event, options) {
      if (options.ignoreInternal && _isSentryError(event)) {
        flags_1.IS_DEBUG_BUILD &&
          utils_1.logger.warn("Event dropped due to being internal Sentry Error.\nEvent: " + utils_1.getEventDescription(event));
        return true;
      }
      if (_isIgnoredError(event, options.ignoreErrors)) {
        flags_1.IS_DEBUG_BUILD &&
          utils_1.logger.warn("Event dropped due to being matched by `ignoreErrors` option.\nEvent: " + utils_1.getEventDescription(event));
        return true;
      }
      if (_isDeniedUrl(event, options.denyUrls)) {
        flags_1.IS_DEBUG_BUILD &&
          utils_1.logger.warn("Event dropped due to being matched by `denyUrls` option.\nEvent: " + utils_1.getEventDescription(event) + ".\nUrl: " + _getEventFilterUrl(event));
        return true;
      }
      if (!_isAllowedUrl(event, options.allowUrls)) {
        flags_1.IS_DEBUG_BUILD &&
          utils_1.logger.warn("Event dropped due to not being matched by `allowUrls` option.\nEvent: " + utils_1.getEventDescription(event) + ".\nUrl: " + _getEventFilterUrl(event));
        return true;
      }
      return false;
    }
    exports._shouldDropEvent = _shouldDropEvent;
    function _isIgnoredError(event, ignoreErrors) {
      if (!ignoreErrors || !ignoreErrors.length) {
        return false;
      }
      return _getPossibleEventMessages(event).some(function (message) {
        return ignoreErrors.some(function (pattern) { return utils_1.isMatchingPattern(message, pattern); });
      });
    }
    function _isDeniedUrl(event, denyUrls) {
      // TODO: Use Glob instead?
      if (!denyUrls || !denyUrls.length) {
        return false;
      }
      var url = _getEventFilterUrl(event);
      return !url ? false : denyUrls.some(function (pattern) { return utils_1.isMatchingPattern(url, pattern); });
    }
    function _isAllowedUrl(event, allowUrls) {
      // TODO: Use Glob instead?
      if (!allowUrls || !allowUrls.length) {
        return true;
      }
      var url = _getEventFilterUrl(event);
      return !url ? true : allowUrls.some(function (pattern) { return utils_1.isMatchingPattern(url, pattern); });
    }
    function _getPossibleEventMessages(event) {
      if (event.message) {
        return [event.message];
      }
      if (event.exception) {
        try {
          var _a = (event.exception.values && event.exception.values[0]) || {}, _b = _a.type, type = _b === void 0 ? '' : _b, _c = _a.value, value = _c === void 0 ? '' : _c;
          return ["" + value, type + ": " + value];
        }
        catch (oO) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.error("Cannot extract message for event " + utils_1.getEventDescription(event));
          return [];
        }
      }
      return [];
    }
    function _isSentryError(event) {
      try {
        // @ts-ignore can't be a sentry error if undefined
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        return event.exception.values[0].type === 'SentryError';
      }
      catch (e) {
        // ignore
      }
      return false;
    }
    function _getLastValidUrl(frames) {
      if (frames === void 0) { frames = []; }
      for (var i = frames.length - 1; i >= 0; i--) {
        var frame = frames[i];
        if (frame && frame.filename !== '<anonymous>' && frame.filename !== '[native code]') {
          return frame.filename || null;
        }
      }
      return null;
    }
    function _getEventFilterUrl(event) {
      try {
        if (event.stacktrace) {
          return _getLastValidUrl(event.stacktrace.frames);
        }
        var frames_1;
        try {
          // @ts-ignore we only care about frames if the whole thing here is defined
          frames_1 = event.exception.values[0].stacktrace.frames;
        }
        catch (e) {
          // ignore
        }
        return frames_1 ? _getLastValidUrl(frames_1) : null;
      }
      catch (oO) {
        flags_1.IS_DEBUG_BUILD && utils_1.logger.error("Cannot extract url for event " + utils_1.getEventDescription(event));
        return null;
      }
    }

  }, { "../flags": 35, "@sentry/utils": 95, "tslib": 181 }], 40: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var functiontostring_1 = require("./functiontostring");
    exports.FunctionToString = functiontostring_1.FunctionToString;
    var inboundfilters_1 = require("./inboundfilters");
    exports.InboundFilters = inboundfilters_1.InboundFilters;

  }, { "./functiontostring": 38, "./inboundfilters": 39 }], 41: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var utils_1 = require("@sentry/utils");
    var api_1 = require("./api");
    /** Extract sdk info from from the API metadata */
    function getSdkMetadataForEnvelopeHeader(api) {
      if (!api.metadata || !api.metadata.sdk) {
        return;
      }
      var _a = api.metadata.sdk, name = _a.name, version = _a.version;
      return { name: name, version: version };
    }
    /**
     * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.
     * Merge with existing data if any.
     **/
    function enhanceEventWithSdkInfo(event, sdkInfo) {
      if (!sdkInfo) {
        return event;
      }
      event.sdk = event.sdk || {};
      event.sdk.name = event.sdk.name || sdkInfo.name;
      event.sdk.version = event.sdk.version || sdkInfo.version;
      event.sdk.integrations = tslib_1.__spread((event.sdk.integrations || []), (sdkInfo.integrations || []));
      event.sdk.packages = tslib_1.__spread((event.sdk.packages || []), (sdkInfo.packages || []));
      return event;
    }
    /** Creates an envelope from a Session */
    function createSessionEnvelope(session, api) {
      var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
      var envelopeHeaders = tslib_1.__assign(tslib_1.__assign({ sent_at: new Date().toISOString() }, (sdkInfo && { sdk: sdkInfo })), (!!api.tunnel && { dsn: utils_1.dsnToString(api.dsn) }));
      // I know this is hacky but we don't want to add `sessions` to request type since it's never rate limited
      var type = 'aggregates' in session ? 'sessions' : 'session';
      // TODO (v7) Have to cast type because envelope items do not accept a `SentryRequestType`
      var envelopeItem = [{ type: type }, session];
      var envelope = utils_1.createEnvelope(envelopeHeaders, [envelopeItem]);
      return [envelope, type];
    }
    exports.createSessionEnvelope = createSessionEnvelope;
    /** Creates a SentryRequest from a Session. */
    function sessionToSentryRequest(session, api) {
      var _a = tslib_1.__read(createSessionEnvelope(session, api), 2), envelope = _a[0], type = _a[1];
      return {
        body: utils_1.serializeEnvelope(envelope),
        type: type,
        url: api_1.getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel),
      };
    }
    exports.sessionToSentryRequest = sessionToSentryRequest;
    /**
     * Create an Envelope from an event. Note that this is duplicated from below,
     * but on purpose as this will be refactored in v7.
     */
    function createEventEnvelope(event, api) {
      var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
      var eventType = event.type || 'event';
      var transactionSampling = (event.sdkProcessingMetadata || {}).transactionSampling;
      var _a = transactionSampling || {}, samplingMethod = _a.method, sampleRate = _a.rate;
      // TODO: Below is a temporary hack in order to debug a serialization error - see
      // https://github.com/getsentry/sentry-javascript/issues/2809,
      // https://github.com/getsentry/sentry-javascript/pull/4425, and
      // https://github.com/getsentry/sentry-javascript/pull/4574.
      //
      // TL; DR: even though we normalize all events (which should prevent this), something is causing `JSON.stringify` to
      // throw a circular reference error.
      //
      // When it's time to remove it:
      // 1. Delete everything between here and where the request object `req` is created, EXCEPT the line deleting
      //    `sdkProcessingMetadata`
      // 2. Restore the original version of the request body, which is commented out
      // 3. Search for either of the PR URLs above and pull out the companion hacks in the browser playwright tests and the
      //    baseClient tests in this package
      enhanceEventWithSdkInfo(event, api.metadata.sdk);
      event.tags = event.tags || {};
      event.extra = event.extra || {};
      // In theory, all events should be marked as having gone through normalization and so
      // we should never set this tag/extra data
      if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {
        event.tags.skippedNormalization = true;
        event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : 'unset';
      }
      // prevent this data from being sent to sentry
      // TODO: This is NOT part of the hack - DO NOT DELETE
      delete event.sdkProcessingMetadata;
      var envelopeHeaders = tslib_1.__assign(tslib_1.__assign({ event_id: event.event_id, sent_at: new Date().toISOString() }, (sdkInfo && { sdk: sdkInfo })), (!!api.tunnel && { dsn: utils_1.dsnToString(api.dsn) }));
      var eventItem = [
        {
          type: eventType,
          sample_rates: [{ id: samplingMethod, rate: sampleRate }],
        },
        event,
      ];
      return utils_1.createEnvelope(envelopeHeaders, [eventItem]);
    }
    exports.createEventEnvelope = createEventEnvelope;
    /** Creates a SentryRequest from an event. */
    function eventToSentryRequest(event, api) {
      var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
      var eventType = event.type || 'event';
      var useEnvelope = eventType === 'transaction' || !!api.tunnel;
      var transactionSampling = (event.sdkProcessingMetadata || {}).transactionSampling;
      var _a = transactionSampling || {}, samplingMethod = _a.method, sampleRate = _a.rate;
      // TODO: Below is a temporary hack in order to debug a serialization error - see
      // https://github.com/getsentry/sentry-javascript/issues/2809,
      // https://github.com/getsentry/sentry-javascript/pull/4425, and
      // https://github.com/getsentry/sentry-javascript/pull/4574.
      //
      // TL; DR: even though we normalize all events (which should prevent this), something is causing `JSON.stringify` to
      // throw a circular reference error.
      //
      // When it's time to remove it:
      // 1. Delete everything between here and where the request object `req` is created, EXCEPT the line deleting
      //    `sdkProcessingMetadata`
      // 2. Restore the original version of the request body, which is commented out
      // 3. Search for either of the PR URLs above and pull out the companion hacks in the browser playwright tests and the
      //    baseClient tests in this package
      enhanceEventWithSdkInfo(event, api.metadata.sdk);
      event.tags = event.tags || {};
      event.extra = event.extra || {};
      // In theory, all events should be marked as having gone through normalization and so
      // we should never set this tag/extra data
      if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {
        event.tags.skippedNormalization = true;
        event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : 'unset';
      }
      // prevent this data from being sent to sentry
      // TODO: This is NOT part of the hack - DO NOT DELETE
      delete event.sdkProcessingMetadata;
      var body;
      try {
        // 99.9% of events should get through just fine - no change in behavior for them
        body = JSON.stringify(event);
      }
      catch (err) {
        // Record data about the error without replacing original event data, then force renormalization
        event.tags.JSONStringifyError = true;
        event.extra.JSONStringifyError = err;
        try {
          body = JSON.stringify(utils_1.normalize(event));
        }
        catch (newErr) {
          // At this point even renormalization hasn't worked, meaning something about the event data has gone very wrong.
          // Time to cut our losses and record only the new error. With luck, even in the problematic cases we're trying to
          // debug with this hack, we won't ever land here.
          var innerErr = newErr;
          body = JSON.stringify({
            message: 'JSON.stringify error after renormalization',
            // setting `extra: { innerErr }` here for some reason results in an empty object, so unpack manually
            extra: { message: innerErr.message, stack: innerErr.stack },
          });
        }
      }
      var req = {
        // this is the relevant line of code before the hack was added, to make it easy to undo said hack once we've solved
        // the mystery
        // body: JSON.stringify(sdkInfo ? enhanceEventWithSdkInfo(event, api.metadata.sdk) : event),
        body: body,
        type: eventType,
        url: useEnvelope
          ? api_1.getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel)
          : api_1.getStoreEndpointWithUrlEncodedAuth(api.dsn),
      };
      // https://develop.sentry.dev/sdk/envelopes/
      // Since we don't need to manipulate envelopes nor store them, there is no
      // exported concept of an Envelope with operations including serialization and
      // deserialization. Instead, we only implement a minimal subset of the spec to
      // serialize events inline here.
      if (useEnvelope) {
        var envelopeHeaders = tslib_1.__assign(tslib_1.__assign({ event_id: event.event_id, sent_at: new Date().toISOString() }, (sdkInfo && { sdk: sdkInfo })), (!!api.tunnel && { dsn: utils_1.dsnToString(api.dsn) }));
        var eventItem = [
          {
            type: eventType,
            sample_rates: [{ id: samplingMethod, rate: sampleRate }],
          },
          req.body,
        ];
        var envelope = utils_1.createEnvelope(envelopeHeaders, [eventItem]);
        req.body = utils_1.serializeEnvelope(envelope);
      }
      return req;
    }
    exports.eventToSentryRequest = eventToSentryRequest;

  }, { "./api": 32, "@sentry/utils": 95, "tslib": 181 }], 42: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var hub_1 = require("@sentry/hub");
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("./flags");
    /**
     * Internal function to create a new SDK client instance. The client is
     * installed and then bound to the current scope.
     *
     * @param clientClass The client class to instantiate.
     * @param options Options to pass to the client.
     */
    function initAndBind(clientClass, options) {
      if (options.debug === true) {
        if (flags_1.IS_DEBUG_BUILD) {
          utils_1.logger.enable();
        }
        else {
          // use `console.warn` rather than `logger.warn` since by non-debug bundles have all `logger.x` statements stripped
          // eslint-disable-next-line no-console
          console.warn('[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.');
        }
      }
      var hub = hub_1.getCurrentHub();
      var scope = hub.getScope();
      if (scope) {
        scope.update(options.initialScope);
      }
      var client = new clientClass(options);
      hub.bindClient(client);
    }
    exports.initAndBind = initAndBind;

  }, { "./flags": 35, "@sentry/hub": 48, "@sentry/utils": 95 }], 43: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require("@sentry/utils");
    exports.ERROR_TRANSPORT_CATEGORY = 'error';
    exports.TRANSACTION_TRANSPORT_CATEGORY = 'transaction';
    exports.ATTACHMENT_TRANSPORT_CATEGORY = 'attachment';
    exports.SESSION_TRANSPORT_CATEGORY = 'session';
    exports.DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
    /**
     * Creates a `NewTransport`
     *
     * @param options
     * @param makeRequest
     */
    function createTransport(options, makeRequest, buffer) {
      if (buffer === void 0) { buffer = utils_1.makePromiseBuffer(options.bufferSize || exports.DEFAULT_TRANSPORT_BUFFER_SIZE); }
      var rateLimits = {};
      var flush = function (timeout) { return buffer.drain(timeout); };
      function send(envelope) {
        var envCategory = utils_1.getEnvelopeType(envelope);
        var category = envCategory === 'event' ? 'error' : envCategory;
        var request = {
          category: category,
          body: utils_1.serializeEnvelope(envelope),
        };
        // Don't add to buffer if transport is already rate-limited
        if (utils_1.isRateLimited(rateLimits, category)) {
          return utils_1.rejectedSyncPromise({
            status: 'rate_limit',
            reason: getRateLimitReason(rateLimits, category),
          });
        }
        var requestTask = function () {
          return makeRequest(request).then(function (_a) {
            var body = _a.body, headers = _a.headers, reason = _a.reason, statusCode = _a.statusCode;
            var status = utils_1.eventStatusFromHttpCode(statusCode);
            if (headers) {
              rateLimits = utils_1.updateRateLimits(rateLimits, headers);
            }
            if (status === 'success') {
              return utils_1.resolvedSyncPromise({ status: status, reason: reason });
            }
            return utils_1.rejectedSyncPromise({
              status: status,
              reason: reason ||
                body ||
                (status === 'rate_limit' ? getRateLimitReason(rateLimits, category) : 'Unknown transport error'),
            });
          });
        };
        return buffer.add(requestTask);
      }
      return {
        send: send,
        flush: flush,
      };
    }
    exports.createTransport = createTransport;
    function getRateLimitReason(rateLimits, category) {
      return "Too many " + category + " requests, backing off until: " + new Date(utils_1.disabledUntil(rateLimits, category)).toISOString();
    }

  }, { "@sentry/utils": 95 }], 44: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require("@sentry/utils");
    /** Noop transport */
    var NoopTransport = /** @class */ (function () {
      function NoopTransport() {
      }
      /**
       * @inheritDoc
       */
      NoopTransport.prototype.sendEvent = function (_) {
        return utils_1.resolvedSyncPromise({
          reason: 'NoopTransport: Event has been skipped because no Dsn is configured.',
          status: 'skipped',
        });
      };
      /**
       * @inheritDoc
       */
      NoopTransport.prototype.close = function (_) {
        return utils_1.resolvedSyncPromise(true);
      };
      return NoopTransport;
    }());
    exports.NoopTransport = NoopTransport;

  }, { "@sentry/utils": 95 }], 45: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDK_VERSION = '6.19.7';

  }, {}], 46: [function (require, module, exports) {
    arguments[4][12][0].apply(exports, arguments)
  }, { "dup": 12 }], 47: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("./flags");
    var scope_1 = require("./scope");
    var session_1 = require("./session");
    /**
     * API compatibility version of this hub.
     *
     * WARNING: This number should only be increased when the global interface
     * changes and new methods are introduced.
     *
     * @hidden
     */
    exports.API_VERSION = 4;
    /**
     * Default maximum number of breadcrumbs added to an event. Can be overwritten
     * with {@link Options.maxBreadcrumbs}.
     */
    var DEFAULT_BREADCRUMBS = 100;
    /**
     * @inheritDoc
     */
    var Hub = /** @class */ (function () {
      /**
       * Creates a new instance of the hub, will push one {@link Layer} into the
       * internal stack on creation.
       *
       * @param client bound to the hub.
       * @param scope bound to the hub.
       * @param version number, higher number means higher priority.
       */
      function Hub(client, scope, _version) {
        if (scope === void 0) { scope = new scope_1.Scope(); }
        if (_version === void 0) { _version = exports.API_VERSION; }
        this._version = _version;
        /** Is a {@link Layer}[] containing the client and scope */
        this._stack = [{}];
        this.getStackTop().scope = scope;
        if (client) {
          this.bindClient(client);
        }
      }
      /**
       * @inheritDoc
       */
      Hub.prototype.isOlderThan = function (version) {
        return this._version < version;
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.bindClient = function (client) {
        var top = this.getStackTop();
        top.client = client;
        if (client && client.setupIntegrations) {
          client.setupIntegrations();
        }
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.pushScope = function () {
        // We want to clone the content of prev scope
        var scope = scope_1.Scope.clone(this.getScope());
        this.getStack().push({
          client: this.getClient(),
          scope: scope,
        });
        return scope;
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.popScope = function () {
        if (this.getStack().length <= 1)
          return false;
        return !!this.getStack().pop();
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.withScope = function (callback) {
        var scope = this.pushScope();
        try {
          callback(scope);
        }
        finally {
          this.popScope();
        }
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.getClient = function () {
        return this.getStackTop().client;
      };
      /** Returns the scope of the top stack. */
      Hub.prototype.getScope = function () {
        return this.getStackTop().scope;
      };
      /** Returns the scope stack for domains or the process. */
      Hub.prototype.getStack = function () {
        return this._stack;
      };
      /** Returns the topmost scope layer in the order domain > local > process. */
      Hub.prototype.getStackTop = function () {
        return this._stack[this._stack.length - 1];
      };
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
      Hub.prototype.captureException = function (exception, hint) {
        var eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : utils_1.uuid4());
        var finalHint = hint;
        // If there's no explicit hint provided, mimic the same thing that would happen
        // in the minimal itself to create a consistent behavior.
        // We don't do this in the client, as it's the lowest level API, and doing this,
        // would prevent user from having full control over direct calls.
        if (!hint) {
          var syntheticException = void 0;
          try {
            throw new Error('Sentry syntheticException');
          }
          catch (exception) {
            syntheticException = exception;
          }
          finalHint = {
            originalException: exception,
            syntheticException: syntheticException,
          };
        }
        this._invokeClient('captureException', exception, tslib_1.__assign(tslib_1.__assign({}, finalHint), { event_id: eventId }));
        return eventId;
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.captureMessage = function (message, level, hint) {
        var eventId = (this._lastEventId = hint && hint.event_id ? hint.event_id : utils_1.uuid4());
        var finalHint = hint;
        // If there's no explicit hint provided, mimic the same thing that would happen
        // in the minimal itself to create a consistent behavior.
        // We don't do this in the client, as it's the lowest level API, and doing this,
        // would prevent user from having full control over direct calls.
        if (!hint) {
          var syntheticException = void 0;
          try {
            throw new Error(message);
          }
          catch (exception) {
            syntheticException = exception;
          }
          finalHint = {
            originalException: message,
            syntheticException: syntheticException,
          };
        }
        this._invokeClient('captureMessage', message, level, tslib_1.__assign(tslib_1.__assign({}, finalHint), { event_id: eventId }));
        return eventId;
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.captureEvent = function (event, hint) {
        var eventId = hint && hint.event_id ? hint.event_id : utils_1.uuid4();
        if (event.type !== 'transaction') {
          this._lastEventId = eventId;
        }
        this._invokeClient('captureEvent', event, tslib_1.__assign(tslib_1.__assign({}, hint), { event_id: eventId }));
        return eventId;
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.lastEventId = function () {
        return this._lastEventId;
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.addBreadcrumb = function (breadcrumb, hint) {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        if (!scope || !client)
          return;
        // eslint-disable-next-line @typescript-eslint/unbound-method
        var _b = (client.getOptions && client.getOptions()) || {}, _c = _b.beforeBreadcrumb, beforeBreadcrumb = _c === void 0 ? null : _c, _d = _b.maxBreadcrumbs, maxBreadcrumbs = _d === void 0 ? DEFAULT_BREADCRUMBS : _d;
        if (maxBreadcrumbs <= 0)
          return;
        var timestamp = utils_1.dateTimestampInSeconds();
        var mergedBreadcrumb = tslib_1.__assign({ timestamp: timestamp }, breadcrumb);
        var finalBreadcrumb = beforeBreadcrumb
          ? utils_1.consoleSandbox(function () { return beforeBreadcrumb(mergedBreadcrumb, hint); })
          : mergedBreadcrumb;
        if (finalBreadcrumb === null)
          return;
        scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.setUser = function (user) {
        var scope = this.getScope();
        if (scope)
          scope.setUser(user);
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.setTags = function (tags) {
        var scope = this.getScope();
        if (scope)
          scope.setTags(tags);
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.setExtras = function (extras) {
        var scope = this.getScope();
        if (scope)
          scope.setExtras(extras);
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.setTag = function (key, value) {
        var scope = this.getScope();
        if (scope)
          scope.setTag(key, value);
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.setExtra = function (key, extra) {
        var scope = this.getScope();
        if (scope)
          scope.setExtra(key, extra);
      };
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Hub.prototype.setContext = function (name, context) {
        var scope = this.getScope();
        if (scope)
          scope.setContext(name, context);
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.configureScope = function (callback) {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        if (scope && client) {
          callback(scope);
        }
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.run = function (callback) {
        var oldHub = makeMain(this);
        try {
          callback(this);
        }
        finally {
          makeMain(oldHub);
        }
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.getIntegration = function (integration) {
        var client = this.getClient();
        if (!client)
          return null;
        try {
          return client.getIntegration(integration);
        }
        catch (_oO) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.warn("Cannot retrieve integration " + integration.id + " from the current Hub");
          return null;
        }
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.startSpan = function (context) {
        return this._callExtensionMethod('startSpan', context);
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.startTransaction = function (context, customSamplingContext) {
        return this._callExtensionMethod('startTransaction', context, customSamplingContext);
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.traceHeaders = function () {
        return this._callExtensionMethod('traceHeaders');
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.captureSession = function (endSession) {
        if (endSession === void 0) { endSession = false; }
        // both send the update and pull the session from the scope
        if (endSession) {
          return this.endSession();
        }
        // only send the update
        this._sendSessionUpdate();
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.endSession = function () {
        var layer = this.getStackTop();
        var scope = layer && layer.scope;
        var session = scope && scope.getSession();
        if (session) {
          session.close();
        }
        this._sendSessionUpdate();
        // the session is over; take it off of the scope
        if (scope) {
          scope.setSession();
        }
      };
      /**
       * @inheritDoc
       */
      Hub.prototype.startSession = function (context) {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        var _b = (client && client.getOptions()) || {}, release = _b.release, environment = _b.environment;
        // Will fetch userAgent if called from browser sdk
        var global = utils_1.getGlobalObject();
        var userAgent = (global.navigator || {}).userAgent;
        var session = new session_1.Session(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({
          release: release,
          environment: environment
        }, (scope && { user: scope.getUser() })), (userAgent && { userAgent: userAgent })), context));
        if (scope) {
          // End existing session if there's one
          var currentSession = scope.getSession && scope.getSession();
          if (currentSession && currentSession.status === 'ok') {
            currentSession.update({ status: 'exited' });
          }
          this.endSession();
          // Afterwards we set the new session on the scope
          scope.setSession(session);
        }
        return session;
      };
      /**
       * Sends the current Session on the scope
       */
      Hub.prototype._sendSessionUpdate = function () {
        var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
        if (!scope)
          return;
        var session = scope.getSession && scope.getSession();
        if (session) {
          if (client && client.captureSession) {
            client.captureSession(session);
          }
        }
      };
      /**
       * Internal helper function to call a method on the top client if it exists.
       *
       * @param method The method to call on the client.
       * @param args Arguments to pass to the client function.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Hub.prototype._invokeClient = function (method) {
        var _a;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var _b = this.getStackTop(), scope = _b.scope, client = _b.client;
        if (client && client[method]) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
          (_a = client)[method].apply(_a, tslib_1.__spread(args, [scope]));
        }
      };
      /**
       * Calls global extension method and binding current instance to the function call
       */
      // @ts-ignore Function lacks ending return statement and return type does not include 'undefined'. ts(2366)
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      Hub.prototype._callExtensionMethod = function (method) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var carrier = getMainCarrier();
        var sentry = carrier.__SENTRY__;
        if (sentry && sentry.extensions && typeof sentry.extensions[method] === 'function') {
          return sentry.extensions[method].apply(this, args);
        }
        flags_1.IS_DEBUG_BUILD && utils_1.logger.warn("Extension method " + method + " couldn't be found, doing nothing.");
      };
      return Hub;
    }());
    exports.Hub = Hub;
    /**
     * Returns the global shim registry.
     *
     * FIXME: This function is problematic, because despite always returning a valid Carrier,
     * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check
     * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.
     **/
    function getMainCarrier() {
      var carrier = utils_1.getGlobalObject();
      carrier.__SENTRY__ = carrier.__SENTRY__ || {
        extensions: {},
        hub: undefined,
      };
      return carrier;
    }
    exports.getMainCarrier = getMainCarrier;
    /**
     * Replaces the current main hub with the passed one on the global object
     *
     * @returns The old replaced hub
     */
    function makeMain(hub) {
      var registry = getMainCarrier();
      var oldHub = getHubFromCarrier(registry);
      setHubOnCarrier(registry, hub);
      return oldHub;
    }
    exports.makeMain = makeMain;
    /**
     * Returns the default hub instance.
     *
     * If a hub is already registered in the global carrier but this module
     * contains a more recent version, it replaces the registered version.
     * Otherwise, the currently registered hub will be returned.
     */
    function getCurrentHub() {
      // Get main carrier (global for every environment)
      var registry = getMainCarrier();
      // If there's no hub, or its an old API, assign a new one
      if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(exports.API_VERSION)) {
        setHubOnCarrier(registry, new Hub());
      }
      // Prefer domains over global if they are there (applicable only to Node environment)
      if (utils_1.isNodeEnv()) {
        return getHubFromActiveDomain(registry);
      }
      // Return hub that lives on a global object
      return getHubFromCarrier(registry);
    }
    exports.getCurrentHub = getCurrentHub;
    /**
     * Returns the active domain, if one exists
     * @deprecated No longer used; remove in v7
     * @returns The domain, or undefined if there is no active domain
     */
    // eslint-disable-next-line deprecation/deprecation
    function getActiveDomain() {
      flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('Function `getActiveDomain` is deprecated and will be removed in a future version.');
      var sentry = getMainCarrier().__SENTRY__;
      return sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
    }
    exports.getActiveDomain = getActiveDomain;
    /**
     * Try to read the hub from an active domain, and fallback to the registry if one doesn't exist
     * @returns discovered hub
     */
    function getHubFromActiveDomain(registry) {
      try {
        var sentry = getMainCarrier().__SENTRY__;
        var activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
        // If there's no active domain, just return global hub
        if (!activeDomain) {
          return getHubFromCarrier(registry);
        }
        // If there's no hub on current domain, or it's an old API, assign a new one
        if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(exports.API_VERSION)) {
          var registryHubTopStack = getHubFromCarrier(registry).getStackTop();
          setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, scope_1.Scope.clone(registryHubTopStack.scope)));
        }
        // Return hub that lives on a domain
        return getHubFromCarrier(activeDomain);
      }
      catch (_Oo) {
        // Return hub that lives on a global object
        return getHubFromCarrier(registry);
      }
    }
    /**
     * This will tell whether a carrier has a hub on it or not
     * @param carrier object
     */
    function hasHubOnCarrier(carrier) {
      return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
    }
    /**
     * This will create a new {@link Hub} and add to the passed object on
     * __SENTRY__.hub.
     * @param carrier object
     * @hidden
     */
    function getHubFromCarrier(carrier) {
      return utils_1.getGlobalSingleton('hub', function () { return new Hub(); }, carrier);
    }
    exports.getHubFromCarrier = getHubFromCarrier;
    /**
     * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute
     * @param carrier object
     * @param hub Hub
     * @returns A boolean indicating success or failure
     */
    function setHubOnCarrier(carrier, hub) {
      if (!carrier)
        return false;
      var __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});
      __SENTRY__.hub = hub;
      return true;
    }
    exports.setHubOnCarrier = setHubOnCarrier;

  }, { "./flags": 46, "./scope": 49, "./session": 50, "@sentry/utils": 95, "tslib": 181 }], 48: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var scope_1 = require("./scope");
    exports.addGlobalEventProcessor = scope_1.addGlobalEventProcessor;
    exports.Scope = scope_1.Scope;
    var session_1 = require("./session");
    exports.Session = session_1.Session;
    var sessionflusher_1 = require("./sessionflusher");
    exports.SessionFlusher = sessionflusher_1.SessionFlusher;
    var hub_1 = require("./hub");
    // eslint-disable-next-line deprecation/deprecation
    exports.getActiveDomain = hub_1.getActiveDomain;
    exports.getCurrentHub = hub_1.getCurrentHub;
    exports.getHubFromCarrier = hub_1.getHubFromCarrier;
    exports.getMainCarrier = hub_1.getMainCarrier;
    exports.Hub = hub_1.Hub;
    exports.makeMain = hub_1.makeMain;
    exports.setHubOnCarrier = hub_1.setHubOnCarrier;

  }, { "./hub": 47, "./scope": 49, "./session": 50, "./sessionflusher": 51 }], 49: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var utils_1 = require("@sentry/utils");
    /**
     * Absolute maximum number of breadcrumbs added to an event.
     * The `maxBreadcrumbs` option cannot be higher than this value.
     */
    var MAX_BREADCRUMBS = 100;
    /**
     * Holds additional event information. {@link Scope.applyToEvent} will be
     * called by the client before an event will be sent.
     */
    var Scope = /** @class */ (function () {
      function Scope() {
        /** Flag if notifying is happening. */
        this._notifyingListeners = false;
        /** Callback for client to receive scope changes. */
        this._scopeListeners = [];
        /** Callback list that will be called after {@link applyToEvent}. */
        this._eventProcessors = [];
        /** Array of breadcrumbs. */
        this._breadcrumbs = [];
        /** User */
        this._user = {};
        /** Tags */
        this._tags = {};
        /** Extra */
        this._extra = {};
        /** Contexts */
        this._contexts = {};
        /**
         * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
         * sent to Sentry
         */
        this._sdkProcessingMetadata = {};
      }
      /**
       * Inherit values from the parent scope.
       * @param scope to clone.
       */
      Scope.clone = function (scope) {
        var newScope = new Scope();
        if (scope) {
          newScope._breadcrumbs = tslib_1.__spread(scope._breadcrumbs);
          newScope._tags = tslib_1.__assign({}, scope._tags);
          newScope._extra = tslib_1.__assign({}, scope._extra);
          newScope._contexts = tslib_1.__assign({}, scope._contexts);
          newScope._user = scope._user;
          newScope._level = scope._level;
          newScope._span = scope._span;
          newScope._session = scope._session;
          newScope._transactionName = scope._transactionName;
          newScope._fingerprint = scope._fingerprint;
          newScope._eventProcessors = tslib_1.__spread(scope._eventProcessors);
          newScope._requestSession = scope._requestSession;
        }
        return newScope;
      };
      /**
       * Add internal on change listener. Used for sub SDKs that need to store the scope.
       * @hidden
       */
      Scope.prototype.addScopeListener = function (callback) {
        this._scopeListeners.push(callback);
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.addEventProcessor = function (callback) {
        this._eventProcessors.push(callback);
        return this;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.setUser = function (user) {
        this._user = user || {};
        if (this._session) {
          this._session.update({ user: user });
        }
        this._notifyScopeListeners();
        return this;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.getUser = function () {
        return this._user;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.getRequestSession = function () {
        return this._requestSession;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.setRequestSession = function (requestSession) {
        this._requestSession = requestSession;
        return this;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.setTags = function (tags) {
        this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), tags);
        this._notifyScopeListeners();
        return this;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.setTag = function (key, value) {
        var _a;
        this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), (_a = {}, _a[key] = value, _a));
        this._notifyScopeListeners();
        return this;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.setExtras = function (extras) {
        this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), extras);
        this._notifyScopeListeners();
        return this;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.setExtra = function (key, extra) {
        var _a;
        this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), (_a = {}, _a[key] = extra, _a));
        this._notifyScopeListeners();
        return this;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.setFingerprint = function (fingerprint) {
        this._fingerprint = fingerprint;
        this._notifyScopeListeners();
        return this;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.setLevel = function (level) {
        this._level = level;
        this._notifyScopeListeners();
        return this;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.setTransactionName = function (name) {
        this._transactionName = name;
        this._notifyScopeListeners();
        return this;
      };
      /**
       * Can be removed in major version.
       * @deprecated in favor of {@link this.setTransactionName}
       */
      Scope.prototype.setTransaction = function (name) {
        return this.setTransactionName(name);
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.setContext = function (key, context) {
        var _a;
        if (context === null) {
          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
          delete this._contexts[key];
        }
        else {
          this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), (_a = {}, _a[key] = context, _a));
        }
        this._notifyScopeListeners();
        return this;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.setSpan = function (span) {
        this._span = span;
        this._notifyScopeListeners();
        return this;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.getSpan = function () {
        return this._span;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.getTransaction = function () {
        // Often, this span (if it exists at all) will be a transaction, but it's not guaranteed to be. Regardless, it will
        // have a pointer to the currently-active transaction.
        var span = this.getSpan();
        return span && span.transaction;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.setSession = function (session) {
        if (!session) {
          delete this._session;
        }
        else {
          this._session = session;
        }
        this._notifyScopeListeners();
        return this;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.getSession = function () {
        return this._session;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.update = function (captureContext) {
        if (!captureContext) {
          return this;
        }
        if (typeof captureContext === 'function') {
          var updatedScope = captureContext(this);
          return updatedScope instanceof Scope ? updatedScope : this;
        }
        if (captureContext instanceof Scope) {
          this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), captureContext._tags);
          this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), captureContext._extra);
          this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), captureContext._contexts);
          if (captureContext._user && Object.keys(captureContext._user).length) {
            this._user = captureContext._user;
          }
          if (captureContext._level) {
            this._level = captureContext._level;
          }
          if (captureContext._fingerprint) {
            this._fingerprint = captureContext._fingerprint;
          }
          if (captureContext._requestSession) {
            this._requestSession = captureContext._requestSession;
          }
        }
        else if (utils_1.isPlainObject(captureContext)) {
          // eslint-disable-next-line no-param-reassign
          captureContext = captureContext;
          this._tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), captureContext.tags);
          this._extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), captureContext.extra);
          this._contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), captureContext.contexts);
          if (captureContext.user) {
            this._user = captureContext.user;
          }
          if (captureContext.level) {
            this._level = captureContext.level;
          }
          if (captureContext.fingerprint) {
            this._fingerprint = captureContext.fingerprint;
          }
          if (captureContext.requestSession) {
            this._requestSession = captureContext.requestSession;
          }
        }
        return this;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.clear = function () {
        this._breadcrumbs = [];
        this._tags = {};
        this._extra = {};
        this._user = {};
        this._contexts = {};
        this._level = undefined;
        this._transactionName = undefined;
        this._fingerprint = undefined;
        this._requestSession = undefined;
        this._span = undefined;
        this._session = undefined;
        this._notifyScopeListeners();
        return this;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.addBreadcrumb = function (breadcrumb, maxBreadcrumbs) {
        var maxCrumbs = typeof maxBreadcrumbs === 'number' ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;
        // No data has been changed, so don't notify scope listeners
        if (maxCrumbs <= 0) {
          return this;
        }
        var mergedBreadcrumb = tslib_1.__assign({ timestamp: utils_1.dateTimestampInSeconds() }, breadcrumb);
        this._breadcrumbs = tslib_1.__spread(this._breadcrumbs, [mergedBreadcrumb]).slice(-maxCrumbs);
        this._notifyScopeListeners();
        return this;
      };
      /**
       * @inheritDoc
       */
      Scope.prototype.clearBreadcrumbs = function () {
        this._breadcrumbs = [];
        this._notifyScopeListeners();
        return this;
      };
      /**
       * Applies the current context and fingerprint to the event.
       * Note that breadcrumbs will be added by the client.
       * Also if the event has already breadcrumbs on it, we do not merge them.
       * @param event Event
       * @param hint May contain additional information about the original exception.
       * @hidden
       */
      Scope.prototype.applyToEvent = function (event, hint) {
        if (this._extra && Object.keys(this._extra).length) {
          event.extra = tslib_1.__assign(tslib_1.__assign({}, this._extra), event.extra);
        }
        if (this._tags && Object.keys(this._tags).length) {
          event.tags = tslib_1.__assign(tslib_1.__assign({}, this._tags), event.tags);
        }
        if (this._user && Object.keys(this._user).length) {
          event.user = tslib_1.__assign(tslib_1.__assign({}, this._user), event.user);
        }
        if (this._contexts && Object.keys(this._contexts).length) {
          event.contexts = tslib_1.__assign(tslib_1.__assign({}, this._contexts), event.contexts);
        }
        if (this._level) {
          event.level = this._level;
        }
        if (this._transactionName) {
          event.transaction = this._transactionName;
        }
        // We want to set the trace context for normal events only if there isn't already
        // a trace context on the event. There is a product feature in place where we link
        // errors with transaction and it relies on that.
        if (this._span) {
          event.contexts = tslib_1.__assign({ trace: this._span.getTraceContext() }, event.contexts);
          var transactionName = this._span.transaction && this._span.transaction.name;
          if (transactionName) {
            event.tags = tslib_1.__assign({ transaction: transactionName }, event.tags);
          }
        }
        this._applyFingerprint(event);
        event.breadcrumbs = tslib_1.__spread((event.breadcrumbs || []), this._breadcrumbs);
        event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : undefined;
        event.sdkProcessingMetadata = this._sdkProcessingMetadata;
        return this._notifyEventProcessors(tslib_1.__spread(getGlobalEventProcessors(), this._eventProcessors), event, hint);
      };
      /**
       * Add data which will be accessible during event processing but won't get sent to Sentry
       */
      Scope.prototype.setSDKProcessingMetadata = function (newData) {
        this._sdkProcessingMetadata = tslib_1.__assign(tslib_1.__assign({}, this._sdkProcessingMetadata), newData);
        return this;
      };
      /**
       * This will be called after {@link applyToEvent} is finished.
       */
      Scope.prototype._notifyEventProcessors = function (processors, event, hint, index) {
        var _this = this;
        if (index === void 0) { index = 0; }
        return new utils_1.SyncPromise(function (resolve, reject) {
          var processor = processors[index];
          if (event === null || typeof processor !== 'function') {
            resolve(event);
          }
          else {
            var result = processor(tslib_1.__assign({}, event), hint);
            if (utils_1.isThenable(result)) {
              void result
                .then(function (final) { return _this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve); })
                .then(null, reject);
            }
            else {
              void _this._notifyEventProcessors(processors, result, hint, index + 1)
                .then(resolve)
                .then(null, reject);
            }
          }
        });
      };
      /**
       * This will be called on every set call.
       */
      Scope.prototype._notifyScopeListeners = function () {
        var _this = this;
        // We need this check for this._notifyingListeners to be able to work on scope during updates
        // If this check is not here we'll produce endless recursion when something is done with the scope
        // during the callback.
        if (!this._notifyingListeners) {
          this._notifyingListeners = true;
          this._scopeListeners.forEach(function (callback) {
            callback(_this);
          });
          this._notifyingListeners = false;
        }
      };
      /**
       * Applies fingerprint from the scope to the event if there's one,
       * uses message if there's one instead or get rid of empty fingerprint
       */
      Scope.prototype._applyFingerprint = function (event) {
        // Make sure it's an array first and we actually have something in place
        event.fingerprint = event.fingerprint
          ? Array.isArray(event.fingerprint)
            ? event.fingerprint
            : [event.fingerprint]
          : [];
        // If we have something on the scope, then merge it with event
        if (this._fingerprint) {
          event.fingerprint = event.fingerprint.concat(this._fingerprint);
        }
        // If we have no data at all, remove empty array default
        if (event.fingerprint && !event.fingerprint.length) {
          delete event.fingerprint;
        }
      };
      return Scope;
    }());
    exports.Scope = Scope;
    /**
     * Returns the global event processors.
     */
    function getGlobalEventProcessors() {
      return utils_1.getGlobalSingleton('globalEventProcessors', function () { return []; });
    }
    /**
     * Add a EventProcessor to be kept globally.
     * @param callback EventProcessor to add
     */
    function addGlobalEventProcessor(callback) {
      getGlobalEventProcessors().push(callback);
    }
    exports.addGlobalEventProcessor = addGlobalEventProcessor;

  }, { "@sentry/utils": 95, "tslib": 181 }], 50: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require("@sentry/utils");
    /**
     * @inheritdoc
     */
    var Session = /** @class */ (function () {
      function Session(context) {
        this.errors = 0;
        this.sid = utils_1.uuid4();
        this.duration = 0;
        this.status = 'ok';
        this.init = true;
        this.ignoreDuration = false;
        // Both timestamp and started are in seconds since the UNIX epoch.
        var startingTime = utils_1.timestampInSeconds();
        this.timestamp = startingTime;
        this.started = startingTime;
        if (context) {
          this.update(context);
        }
      }
      /** JSDoc */
      // eslint-disable-next-line complexity
      Session.prototype.update = function (context) {
        if (context === void 0) { context = {}; }
        if (context.user) {
          if (!this.ipAddress && context.user.ip_address) {
            this.ipAddress = context.user.ip_address;
          }
          if (!this.did && !context.did) {
            this.did = context.user.id || context.user.email || context.user.username;
          }
        }
        this.timestamp = context.timestamp || utils_1.timestampInSeconds();
        if (context.ignoreDuration) {
          this.ignoreDuration = context.ignoreDuration;
        }
        if (context.sid) {
          // Good enough uuid validation. — Kamil
          this.sid = context.sid.length === 32 ? context.sid : utils_1.uuid4();
        }
        if (context.init !== undefined) {
          this.init = context.init;
        }
        if (!this.did && context.did) {
          this.did = "" + context.did;
        }
        if (typeof context.started === 'number') {
          this.started = context.started;
        }
        if (this.ignoreDuration) {
          this.duration = undefined;
        }
        else if (typeof context.duration === 'number') {
          this.duration = context.duration;
        }
        else {
          var duration = this.timestamp - this.started;
          this.duration = duration >= 0 ? duration : 0;
        }
        if (context.release) {
          this.release = context.release;
        }
        if (context.environment) {
          this.environment = context.environment;
        }
        if (!this.ipAddress && context.ipAddress) {
          this.ipAddress = context.ipAddress;
        }
        if (!this.userAgent && context.userAgent) {
          this.userAgent = context.userAgent;
        }
        if (typeof context.errors === 'number') {
          this.errors = context.errors;
        }
        if (context.status) {
          this.status = context.status;
        }
      };
      /** JSDoc */
      Session.prototype.close = function (status) {
        if (status) {
          this.update({ status: status });
        }
        else if (this.status === 'ok') {
          this.update({ status: 'exited' });
        }
        else {
          this.update();
        }
      };
      /** JSDoc */
      Session.prototype.toJSON = function () {
        return utils_1.dropUndefinedKeys({
          sid: "" + this.sid,
          init: this.init,
          // Make sure that sec is converted to ms for date constructor
          started: new Date(this.started * 1000).toISOString(),
          timestamp: new Date(this.timestamp * 1000).toISOString(),
          status: this.status,
          errors: this.errors,
          did: typeof this.did === 'number' || typeof this.did === 'string' ? "" + this.did : undefined,
          duration: this.duration,
          attrs: {
            release: this.release,
            environment: this.environment,
            ip_address: this.ipAddress,
            user_agent: this.userAgent,
          },
        });
      };
      return Session;
    }());
    exports.Session = Session;

  }, { "@sentry/utils": 95 }], 51: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("./flags");
    var hub_1 = require("./hub");
    /**
     * @inheritdoc
     */
    var SessionFlusher = /** @class */ (function () {
      function SessionFlusher(transport, attrs) {
        var _this = this;
        this.flushTimeout = 60;
        this._pendingAggregates = {};
        this._isEnabled = true;
        this._transport = transport;
        // Call to setInterval, so that flush is called every 60 seconds
        this._intervalId = setInterval(function () { return _this.flush(); }, this.flushTimeout * 1000);
        this._sessionAttrs = attrs;
      }
      /** Sends session aggregates to Transport */
      SessionFlusher.prototype.sendSessionAggregates = function (sessionAggregates) {
        if (!this._transport.sendSession) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.warn("Dropping session because custom transport doesn't implement sendSession");
          return;
        }
        void this._transport.sendSession(sessionAggregates).then(null, function (reason) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.error('Error while sending session:', reason);
        });
      };
      /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSessions` */
      SessionFlusher.prototype.flush = function () {
        var sessionAggregates = this.getSessionAggregates();
        if (sessionAggregates.aggregates.length === 0) {
          return;
        }
        this._pendingAggregates = {};
        this.sendSessionAggregates(sessionAggregates);
      };
      /** Massages the entries in `pendingAggregates` and returns aggregated sessions */
      SessionFlusher.prototype.getSessionAggregates = function () {
        var _this = this;
        var aggregates = Object.keys(this._pendingAggregates).map(function (key) {
          return _this._pendingAggregates[parseInt(key)];
        });
        var sessionAggregates = {
          attrs: this._sessionAttrs,
          aggregates: aggregates,
        };
        return utils_1.dropUndefinedKeys(sessionAggregates);
      };
      /** JSDoc */
      SessionFlusher.prototype.close = function () {
        clearInterval(this._intervalId);
        this._isEnabled = false;
        this.flush();
      };
      /**
       * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then
       * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to
       * `_incrementSessionStatusCount` along with the start date
       */
      SessionFlusher.prototype.incrementSessionStatusCount = function () {
        if (!this._isEnabled) {
          return;
        }
        var scope = hub_1.getCurrentHub().getScope();
        var requestSession = scope && scope.getRequestSession();
        if (requestSession && requestSession.status) {
          this._incrementSessionStatusCount(requestSession.status, new Date());
          // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in
          // case captureRequestSession is called more than once to prevent double count
          if (scope) {
            scope.setRequestSession(undefined);
          }
          /* eslint-enable @typescript-eslint/no-unsafe-member-access */
        }
      };
      /**
       * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of
       * the session received
       */
      SessionFlusher.prototype._incrementSessionStatusCount = function (status, date) {
        // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys
        var sessionStartedTrunc = new Date(date).setSeconds(0, 0);
        this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};
        // corresponds to aggregated sessions in one specific minute bucket
        // for example, {"started":"2021-03-16T08:00:00.000Z","exited":4, "errored": 1}
        var aggregationCounts = this._pendingAggregates[sessionStartedTrunc];
        if (!aggregationCounts.started) {
          aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();
        }
        switch (status) {
          case 'errored':
            aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;
            return aggregationCounts.errored;
          case 'ok':
            aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;
            return aggregationCounts.exited;
          default:
            aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;
            return aggregationCounts.crashed;
        }
      };
      return SessionFlusher;
    }());
    exports.SessionFlusher = SessionFlusher;

  }, { "./flags": 46, "./hub": 47, "@sentry/utils": 95 }], 52: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var hub_1 = require("@sentry/hub");
    /**
     * This calls a function on the current hub.
     * @param method function to call on hub.
     * @param args to pass to function.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function callOnHub(method) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var hub = hub_1.getCurrentHub();
      if (hub && hub[method]) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return hub[method].apply(hub, tslib_1.__spread(args));
      }
      throw new Error("No hub defined or " + method + " was not found on the hub, please open a bug report.");
    }
    /**
     * Captures an exception event and sends it to Sentry.
     *
     * @param exception An exception-like object.
     * @returns The generated eventId.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    function captureException(exception, captureContext) {
      var syntheticException = new Error('Sentry syntheticException');
      return callOnHub('captureException', exception, {
        captureContext: captureContext,
        originalException: exception,
        syntheticException: syntheticException,
      });
    }
    exports.captureException = captureException;
    /**
     * Captures a message event and sends it to Sentry.
     *
     * @param message The message to send to Sentry.
     * @param Severity Define the level of the message.
     * @returns The generated eventId.
     */
    function captureMessage(message, captureContext) {
      var syntheticException = new Error(message);
      // This is necessary to provide explicit scopes upgrade, without changing the original
      // arity of the `captureMessage(message, level)` method.
      var level = typeof captureContext === 'string' ? captureContext : undefined;
      var context = typeof captureContext !== 'string' ? { captureContext: captureContext } : undefined;
      return callOnHub('captureMessage', message, level, tslib_1.__assign({ originalException: message, syntheticException: syntheticException }, context));
    }
    exports.captureMessage = captureMessage;
    /**
     * Captures a manually created event and sends it to Sentry.
     *
     * @param event The event to send to Sentry.
     * @returns The generated eventId.
     */
    function captureEvent(event) {
      return callOnHub('captureEvent', event);
    }
    exports.captureEvent = captureEvent;
    /**
     * Callback to set context information onto the scope.
     * @param callback Callback function that receives Scope.
     */
    function configureScope(callback) {
      callOnHub('configureScope', callback);
    }
    exports.configureScope = configureScope;
    /**
     * Records a new breadcrumb which will be attached to future events.
     *
     * Breadcrumbs will be added to subsequent events to provide more context on
     * user's actions prior to an error or crash.
     *
     * @param breadcrumb The breadcrumb to record.
     */
    function addBreadcrumb(breadcrumb) {
      callOnHub('addBreadcrumb', breadcrumb);
    }
    exports.addBreadcrumb = addBreadcrumb;
    /**
     * Sets context data with the given name.
     * @param name of the context
     * @param context Any kind of data. This data will be normalized.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function setContext(name, context) {
      callOnHub('setContext', name, context);
    }
    exports.setContext = setContext;
    /**
     * Set an object that will be merged sent as extra data with the event.
     * @param extras Extras object to merge into current context.
     */
    function setExtras(extras) {
      callOnHub('setExtras', extras);
    }
    exports.setExtras = setExtras;
    /**
     * Set an object that will be merged sent as tags data with the event.
     * @param tags Tags context object to merge into current context.
     */
    function setTags(tags) {
      callOnHub('setTags', tags);
    }
    exports.setTags = setTags;
    /**
     * Set key:value that will be sent as extra data with the event.
     * @param key String of extra
     * @param extra Any kind of data. This data will be normalized.
     */
    function setExtra(key, extra) {
      callOnHub('setExtra', key, extra);
    }
    exports.setExtra = setExtra;
    /**
     * Set key:value that will be sent as tags data with the event.
     *
     * Can also be used to unset a tag, by passing `undefined`.
     *
     * @param key String key of tag
     * @param value Value of tag
     */
    function setTag(key, value) {
      callOnHub('setTag', key, value);
    }
    exports.setTag = setTag;
    /**
     * Updates user context information for future events.
     *
     * @param user User context object to be set in the current context. Pass `null` to unset the user.
     */
    function setUser(user) {
      callOnHub('setUser', user);
    }
    exports.setUser = setUser;
    /**
     * Creates a new scope with and executes the given operation within.
     * The scope is automatically removed once the operation
     * finishes or throws.
     *
     * This is essentially a convenience function for:
     *
     *     pushScope();
     *     callback();
     *     popScope();
     *
     * @param callback that will be enclosed into push/popScope.
     */
    function withScope(callback) {
      callOnHub('withScope', callback);
    }
    exports.withScope = withScope;
    /**
     * Calls a function on the latest client. Use this with caution, it's meant as
     * in "internal" helper so we don't need to expose every possible function in
     * the shim. It is not guaranteed that the client actually implements the
     * function.
     *
     * @param method The method to call on the client/client.
     * @param args Arguments to pass to the client/fontend.
     * @hidden
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function _callOnClient(method) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      callOnHub.apply(void 0, tslib_1.__spread(['_invokeClient', method], args));
    }
    exports._callOnClient = _callOnClient;
    /**
     * Starts a new `Transaction` and returns it. This is the entry point to manual tracing instrumentation.
     *
     * A tree structure can be built by adding child spans to the transaction, and child spans to other spans. To start a
     * new child span within the transaction or any span, call the respective `.startChild()` method.
     *
     * Every child span must be finished before the transaction is finished, otherwise the unfinished spans are discarded.
     *
     * The transaction must be finished with a call to its `.finish()` method, at which point the transaction with all its
     * finished child spans will be sent to Sentry.
     *
     * @param context Properties of the new `Transaction`.
     * @param customSamplingContext Information given to the transaction sampling function (along with context-dependent
     * default values). See {@link Options.tracesSampler}.
     *
     * @returns The transaction which was just started
     */
    function startTransaction(context, customSamplingContext) {
      return callOnHub('startTransaction', tslib_1.__assign({}, context), customSamplingContext);
    }
    exports.startTransaction = startTransaction;

  }, { "@sentry/hub": 48, "tslib": 181 }], 53: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require("@sentry/utils");
    var constants_1 = require("../constants");
    var flags_1 = require("../flags");
    var utils_2 = require("../utils");
    var global = utils_1.getGlobalObject();
    /**
     * Add a listener that cancels and finishes a transaction when the global
     * document is hidden.
     */
    function registerBackgroundTabDetection() {
      if (global && global.document) {
        global.document.addEventListener('visibilitychange', function () {
          var activeTransaction = utils_2.getActiveTransaction();
          if (global.document.hidden && activeTransaction) {
            var statusType = 'cancelled';
            flags_1.IS_DEBUG_BUILD &&
              utils_1.logger.log("[Tracing] Transaction: " + statusType + " -> since tab moved to the background, op: " + activeTransaction.op);
            // We should not set status if it is already set, this prevent important statuses like
            // error or data loss from being overwritten on transaction.
            if (!activeTransaction.status) {
              activeTransaction.setStatus(statusType);
            }
            activeTransaction.setTag('visibilitychange', 'document.hidden');
            activeTransaction.setTag(constants_1.FINISH_REASON_TAG, constants_1.IDLE_TRANSACTION_FINISH_REASONS[2]);
            activeTransaction.finish();
          }
        });
      }
      else {
        flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('[Tracing] Could not set up background tab detection due to lack of global document');
      }
    }
    exports.registerBackgroundTabDetection = registerBackgroundTabDetection;

  }, { "../constants": 68, "../flags": 70, "../utils": 82, "@sentry/utils": 95 }], 54: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("../flags");
    var hubextensions_1 = require("../hubextensions");
    var idletransaction_1 = require("../idletransaction");
    var utils_2 = require("../utils");
    var backgroundtab_1 = require("./backgroundtab");
    var metrics_1 = require("./metrics");
    var request_1 = require("./request");
    var router_1 = require("./router");
    exports.DEFAULT_MAX_TRANSACTION_DURATION_SECONDS = 600;
    var DEFAULT_BROWSER_TRACING_OPTIONS = tslib_1.__assign({ idleTimeout: idletransaction_1.DEFAULT_IDLE_TIMEOUT, markBackgroundTransactions: true, maxTransactionDuration: exports.DEFAULT_MAX_TRANSACTION_DURATION_SECONDS, routingInstrumentation: router_1.instrumentRoutingWithDefaults, startTransactionOnLocationChange: true, startTransactionOnPageLoad: true }, request_1.defaultRequestInstrumentationOptions);
    /**
     * The Browser Tracing integration automatically instruments browser pageload/navigation
     * actions as transactions, and captures requests, metrics and errors as spans.
     *
     * The integration can be configured with a variety of options, and can be extended to use
     * any routing library. This integration uses {@see IdleTransaction} to create transactions.
     */
    var BrowserTracing = /** @class */ (function () {
      function BrowserTracing(_options) {
        /**
         * @inheritDoc
         */
        this.name = BrowserTracing.id;
        /** Store configured idle timeout so that it can be added as a tag to transactions */
        this._configuredIdleTimeout = undefined;
        var tracingOrigins = request_1.defaultRequestInstrumentationOptions.tracingOrigins;
        // NOTE: Logger doesn't work in constructors, as it's initialized after integrations instances
        if (_options) {
          this._configuredIdleTimeout = _options.idleTimeout;
          if (_options.tracingOrigins && Array.isArray(_options.tracingOrigins) && _options.tracingOrigins.length !== 0) {
            tracingOrigins = _options.tracingOrigins;
          }
          else {
            flags_1.IS_DEBUG_BUILD && (this._emitOptionsWarning = true);
          }
        }
        this.options = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, DEFAULT_BROWSER_TRACING_OPTIONS), _options), { tracingOrigins: tracingOrigins });
        var _metricOptions = this.options._metricOptions;
        this._metrics = new metrics_1.MetricsInstrumentation(_metricOptions && _metricOptions._reportAllChanges);
      }
      /**
       * @inheritDoc
       */
      BrowserTracing.prototype.setupOnce = function (_, getCurrentHub) {
        var _this = this;
        this._getCurrentHub = getCurrentHub;
        if (this._emitOptionsWarning) {
          flags_1.IS_DEBUG_BUILD &&
            utils_1.logger.warn('[Tracing] You need to define `tracingOrigins` in the options. Set an array of urls or patterns to trace.');
          flags_1.IS_DEBUG_BUILD &&
            utils_1.logger.warn("[Tracing] We added a reasonable default for you: " + request_1.defaultRequestInstrumentationOptions.tracingOrigins);
        }
        // eslint-disable-next-line @typescript-eslint/unbound-method
        var _a = this.options, instrumentRouting = _a.routingInstrumentation, startTransactionOnLocationChange = _a.startTransactionOnLocationChange, startTransactionOnPageLoad = _a.startTransactionOnPageLoad, markBackgroundTransactions = _a.markBackgroundTransactions, traceFetch = _a.traceFetch, traceXHR = _a.traceXHR, tracingOrigins = _a.tracingOrigins, shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;
        instrumentRouting(function (context) { return _this._createRouteTransaction(context); }, startTransactionOnPageLoad, startTransactionOnLocationChange);
        if (markBackgroundTransactions) {
          backgroundtab_1.registerBackgroundTabDetection();
        }
        request_1.instrumentOutgoingRequests({ traceFetch: traceFetch, traceXHR: traceXHR, tracingOrigins: tracingOrigins, shouldCreateSpanForRequest: shouldCreateSpanForRequest });
      };
      /** Create routing idle transaction. */
      BrowserTracing.prototype._createRouteTransaction = function (context) {
        var _this = this;
        if (!this._getCurrentHub) {
          flags_1.IS_DEBUG_BUILD &&
            utils_1.logger.warn("[Tracing] Did not create " + context.op + " transaction because _getCurrentHub is invalid.");
          return undefined;
        }
        // eslint-disable-next-line @typescript-eslint/unbound-method
        var _a = this.options, beforeNavigate = _a.beforeNavigate, idleTimeout = _a.idleTimeout, maxTransactionDuration = _a.maxTransactionDuration;
        var parentContextFromHeader = context.op === 'pageload' ? getHeaderContext() : undefined;
        var expandedContext = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, context), parentContextFromHeader), { trimEnd: true });
        var modifiedContext = typeof beforeNavigate === 'function' ? beforeNavigate(expandedContext) : expandedContext;
        // For backwards compatibility reasons, beforeNavigate can return undefined to "drop" the transaction (prevent it
        // from being sent to Sentry).
        var finalContext = modifiedContext === undefined ? tslib_1.__assign(tslib_1.__assign({}, expandedContext), { sampled: false }) : modifiedContext;
        if (finalContext.sampled === false) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.log("[Tracing] Will not send " + finalContext.op + " transaction because of beforeNavigate.");
        }
        flags_1.IS_DEBUG_BUILD && utils_1.logger.log("[Tracing] Starting " + finalContext.op + " transaction on scope");
        var hub = this._getCurrentHub();
        var location = utils_1.getGlobalObject().location;
        var idleTransaction = hubextensions_1.startIdleTransaction(hub, finalContext, idleTimeout, true, { location: location });
        idleTransaction.registerBeforeFinishCallback(function (transaction, endTimestamp) {
          _this._metrics.addPerformanceEntries(transaction);
          adjustTransactionDuration(utils_2.secToMs(maxTransactionDuration), transaction, endTimestamp);
        });
        idleTransaction.setTag('idleTimeout', this._configuredIdleTimeout);
        return idleTransaction;
      };
      /**
       * @inheritDoc
       */
      BrowserTracing.id = 'BrowserTracing';
      return BrowserTracing;
    }());
    exports.BrowserTracing = BrowserTracing;
    /**
     * Gets transaction context from a sentry-trace meta.
     *
     * @returns Transaction context data from the header or undefined if there's no header or the header is malformed
     */
    function getHeaderContext() {
      var header = getMetaContent('sentry-trace');
      if (header) {
        return utils_2.extractTraceparentData(header);
      }
      return undefined;
    }
    exports.getHeaderContext = getHeaderContext;
    /** Returns the value of a meta tag */
    function getMetaContent(metaName) {
      var el = utils_1.getGlobalObject().document.querySelector("meta[name=" + metaName + "]");
      return el ? el.getAttribute('content') : null;
    }
    exports.getMetaContent = getMetaContent;
    /** Adjusts transaction value based on max transaction duration */
    function adjustTransactionDuration(maxDuration, transaction, endTimestamp) {
      var diff = endTimestamp - transaction.startTimestamp;
      var isOutdatedTransaction = endTimestamp && (diff > maxDuration || diff < 0);
      if (isOutdatedTransaction) {
        transaction.setStatus('deadline_exceeded');
        transaction.setTag('maxTransactionDurationExceeded', 'true');
      }
    }

  }, { "../flags": 70, "../hubextensions": 71, "../idletransaction": 72, "../utils": 82, "./backgroundtab": 53, "./metrics": 56, "./request": 57, "./router": 58, "@sentry/utils": 95, "tslib": 181 }], 55: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var browsertracing_1 = require("./browsertracing");
    exports.BrowserTracing = browsertracing_1.BrowserTracing;
    var request_1 = require("./request");
    exports.instrumentOutgoingRequests = request_1.instrumentOutgoingRequests;
    exports.defaultRequestInstrumentationOptions = request_1.defaultRequestInstrumentationOptions;

  }, { "./browsertracing": 54, "./request": 57 }], 56: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("../flags");
    var utils_2 = require("../utils");
    var getCLS_1 = require("./web-vitals/getCLS");
    var getFID_1 = require("./web-vitals/getFID");
    var getLCP_1 = require("./web-vitals/getLCP");
    var getVisibilityWatcher_1 = require("./web-vitals/lib/getVisibilityWatcher");
    var global = utils_1.getGlobalObject();
    /** Class tracking metrics  */
    var MetricsInstrumentation = /** @class */ (function () {
      function MetricsInstrumentation(_reportAllChanges) {
        if (_reportAllChanges === void 0) { _reportAllChanges = false; }
        this._reportAllChanges = _reportAllChanges;
        this._measurements = {};
        this._performanceCursor = 0;
        if (!utils_1.isNodeEnv() && global && global.performance && global.document) {
          if (global.performance.mark) {
            global.performance.mark('sentry-tracing-init');
          }
          this._trackCLS();
          this._trackLCP();
          this._trackFID();
        }
      }
      /** Add performance related spans to a transaction */
      MetricsInstrumentation.prototype.addPerformanceEntries = function (transaction) {
        var _this = this;
        if (!global || !global.performance || !global.performance.getEntries || !utils_1.browserPerformanceTimeOrigin) {
          // Gatekeeper if performance API not available
          return;
        }
        flags_1.IS_DEBUG_BUILD && utils_1.logger.log('[Tracing] Adding & adjusting spans using Performance API');
        var timeOrigin = utils_2.msToSec(utils_1.browserPerformanceTimeOrigin);
        var responseStartTimestamp;
        var requestStartTimestamp;
        global.performance
          .getEntries()
          .slice(this._performanceCursor)
          .forEach(function (entry) {
            var startTime = utils_2.msToSec(entry.startTime);
            var duration = utils_2.msToSec(entry.duration);
            if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {
              return;
            }
            switch (entry.entryType) {
              case 'navigation': {
                addNavigationSpans(transaction, entry, timeOrigin);
                responseStartTimestamp = timeOrigin + utils_2.msToSec(entry.responseStart);
                requestStartTimestamp = timeOrigin + utils_2.msToSec(entry.requestStart);
                break;
              }
              case 'mark':
              case 'paint':
              case 'measure': {
                var startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);
                // capture web vitals
                var firstHidden = getVisibilityWatcher_1.getVisibilityWatcher();
                // Only report if the page wasn't hidden prior to the web vital.
                var shouldRecord = entry.startTime < firstHidden.firstHiddenTime;
                if (entry.name === 'first-paint' && shouldRecord) {
                  flags_1.IS_DEBUG_BUILD && utils_1.logger.log('[Measurements] Adding FP');
                  _this._measurements['fp'] = { value: entry.startTime };
                  _this._measurements['mark.fp'] = { value: startTimestamp };
                }
                if (entry.name === 'first-contentful-paint' && shouldRecord) {
                  flags_1.IS_DEBUG_BUILD && utils_1.logger.log('[Measurements] Adding FCP');
                  _this._measurements['fcp'] = { value: entry.startTime };
                  _this._measurements['mark.fcp'] = { value: startTimestamp };
                }
                break;
              }
              case 'resource': {
                var resourceName = entry.name.replace(global.location.origin, '');
                addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);
                break;
              }
              default:
              // Ignore other entry types.
            }
          });
        this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);
        this._trackNavigator(transaction);
        // Measurements are only available for pageload transactions
        if (transaction.op === 'pageload') {
          // normalize applicable web vital values to be relative to transaction.startTimestamp
          var timeOrigin_1 = utils_2.msToSec(utils_1.browserPerformanceTimeOrigin);
          // Generate TTFB (Time to First Byte), which measured as the time between the beginning of the transaction and the
          // start of the response in milliseconds
          if (typeof responseStartTimestamp === 'number') {
            flags_1.IS_DEBUG_BUILD && utils_1.logger.log('[Measurements] Adding TTFB');
            this._measurements['ttfb'] = { value: (responseStartTimestamp - transaction.startTimestamp) * 1000 };
            if (typeof requestStartTimestamp === 'number' && requestStartTimestamp <= responseStartTimestamp) {
              // Capture the time spent making the request and receiving the first byte of the response.
              // This is the time between the start of the request and the start of the response in milliseconds.
              this._measurements['ttfb.requestTime'] = { value: (responseStartTimestamp - requestStartTimestamp) * 1000 };
            }
          }
          ['fcp', 'fp', 'lcp'].forEach(function (name) {
            if (!_this._measurements[name] || timeOrigin_1 >= transaction.startTimestamp) {
              return;
            }
            // The web vitals, fcp, fp, lcp, and ttfb, all measure relative to timeOrigin.
            // Unfortunately, timeOrigin is not captured within the transaction span data, so these web vitals will need
            // to be adjusted to be relative to transaction.startTimestamp.
            var oldValue = _this._measurements[name].value;
            var measurementTimestamp = timeOrigin_1 + utils_2.msToSec(oldValue);
            // normalizedValue should be in milliseconds
            var normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1000);
            var delta = normalizedValue - oldValue;
            flags_1.IS_DEBUG_BUILD &&
              utils_1.logger.log("[Measurements] Normalized " + name + " from " + oldValue + " to " + normalizedValue + " (" + delta + ")");
            _this._measurements[name].value = normalizedValue;
          });
          if (this._measurements['mark.fid'] && this._measurements['fid']) {
            // create span for FID
            _startChild(transaction, {
              description: 'first input delay',
              endTimestamp: this._measurements['mark.fid'].value + utils_2.msToSec(this._measurements['fid'].value),
              op: 'web.vitals',
              startTimestamp: this._measurements['mark.fid'].value,
            });
          }
          // If FCP is not recorded we should not record the cls value
          // according to the new definition of CLS.
          if (!('fcp' in this._measurements)) {
            delete this._measurements.cls;
          }
          transaction.setMeasurements(this._measurements);
          tagMetricInfo(transaction, this._lcpEntry, this._clsEntry);
          transaction.setTag('sentry_reportAllChanges', this._reportAllChanges);
        }
      };
      /**
       * Capture the information of the user agent.
       */
      MetricsInstrumentation.prototype._trackNavigator = function (transaction) {
        var navigator = global.navigator;
        if (!navigator) {
          return;
        }
        // track network connectivity
        var connection = navigator.connection;
        if (connection) {
          if (connection.effectiveType) {
            transaction.setTag('effectiveConnectionType', connection.effectiveType);
          }
          if (connection.type) {
            transaction.setTag('connectionType', connection.type);
          }
          if (isMeasurementValue(connection.rtt)) {
            this._measurements['connection.rtt'] = { value: connection.rtt };
          }
          if (isMeasurementValue(connection.downlink)) {
            this._measurements['connection.downlink'] = { value: connection.downlink };
          }
        }
        if (isMeasurementValue(navigator.deviceMemory)) {
          transaction.setTag('deviceMemory', String(navigator.deviceMemory));
        }
        if (isMeasurementValue(navigator.hardwareConcurrency)) {
          transaction.setTag('hardwareConcurrency', String(navigator.hardwareConcurrency));
        }
      };
      /** Starts tracking the Cumulative Layout Shift on the current page. */
      MetricsInstrumentation.prototype._trackCLS = function () {
        var _this = this;
        // See:
        // https://web.dev/evolving-cls/
        // https://web.dev/cls-web-tooling/
        getCLS_1.getCLS(function (metric) {
          var entry = metric.entries.pop();
          if (!entry) {
            return;
          }
          flags_1.IS_DEBUG_BUILD && utils_1.logger.log('[Measurements] Adding CLS');
          _this._measurements['cls'] = { value: metric.value };
          _this._clsEntry = entry;
        });
      };
      /** Starts tracking the Largest Contentful Paint on the current page. */
      MetricsInstrumentation.prototype._trackLCP = function () {
        var _this = this;
        getLCP_1.getLCP(function (metric) {
          var entry = metric.entries.pop();
          if (!entry) {
            return;
          }
          var timeOrigin = utils_2.msToSec(utils_1.browserPerformanceTimeOrigin);
          var startTime = utils_2.msToSec(entry.startTime);
          flags_1.IS_DEBUG_BUILD && utils_1.logger.log('[Measurements] Adding LCP');
          _this._measurements['lcp'] = { value: metric.value };
          _this._measurements['mark.lcp'] = { value: timeOrigin + startTime };
          _this._lcpEntry = entry;
        }, this._reportAllChanges);
      };
      /** Starts tracking the First Input Delay on the current page. */
      MetricsInstrumentation.prototype._trackFID = function () {
        var _this = this;
        getFID_1.getFID(function (metric) {
          var entry = metric.entries.pop();
          if (!entry) {
            return;
          }
          var timeOrigin = utils_2.msToSec(utils_1.browserPerformanceTimeOrigin);
          var startTime = utils_2.msToSec(entry.startTime);
          flags_1.IS_DEBUG_BUILD && utils_1.logger.log('[Measurements] Adding FID');
          _this._measurements['fid'] = { value: metric.value };
          _this._measurements['mark.fid'] = { value: timeOrigin + startTime };
        });
      };
      return MetricsInstrumentation;
    }());
    exports.MetricsInstrumentation = MetricsInstrumentation;
    /** Instrument navigation entries */
    function addNavigationSpans(transaction, entry, timeOrigin) {
      ['unloadEvent', 'redirect', 'domContentLoadedEvent', 'loadEvent', 'connect'].forEach(function (event) {
        addPerformanceNavigationTiming(transaction, entry, event, timeOrigin);
      });
      addPerformanceNavigationTiming(transaction, entry, 'secureConnection', timeOrigin, 'TLS/SSL', 'connectEnd');
      addPerformanceNavigationTiming(transaction, entry, 'fetch', timeOrigin, 'cache', 'domainLookupStart');
      addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin, 'DNS');
      addRequest(transaction, entry, timeOrigin);
    }
    /** Create measure related spans */
    function addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {
      var measureStartTimestamp = timeOrigin + startTime;
      var measureEndTimestamp = measureStartTimestamp + duration;
      _startChild(transaction, {
        description: entry.name,
        endTimestamp: measureEndTimestamp,
        op: entry.entryType,
        startTimestamp: measureStartTimestamp,
      });
      return measureStartTimestamp;
    }
    /** Create resource-related spans */
    function addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin) {
      // we already instrument based on fetch and xhr, so we don't need to
      // duplicate spans here.
      if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {
        return;
      }
      var data = {};
      if ('transferSize' in entry) {
        data['Transfer Size'] = entry.transferSize;
      }
      if ('encodedBodySize' in entry) {
        data['Encoded Body Size'] = entry.encodedBodySize;
      }
      if ('decodedBodySize' in entry) {
        data['Decoded Body Size'] = entry.decodedBodySize;
      }
      var startTimestamp = timeOrigin + startTime;
      var endTimestamp = startTimestamp + duration;
      _startChild(transaction, {
        description: resourceName,
        endTimestamp: endTimestamp,
        op: entry.initiatorType ? "resource." + entry.initiatorType : 'resource',
        startTimestamp: startTimestamp,
        data: data,
      });
    }
    exports.addResourceSpans = addResourceSpans;
    /** Create performance navigation related spans */
    function addPerformanceNavigationTiming(transaction, entry, event, timeOrigin, description, eventEnd) {
      var end = eventEnd ? entry[eventEnd] : entry[event + "End"];
      var start = entry[event + "Start"];
      if (!start || !end) {
        return;
      }
      _startChild(transaction, {
        op: 'browser',
        description: (description !== null && description !== void 0 ? description : event),
        startTimestamp: timeOrigin + utils_2.msToSec(start),
        endTimestamp: timeOrigin + utils_2.msToSec(end),
      });
    }
    /** Create request and response related spans */
    function addRequest(transaction, entry, timeOrigin) {
      _startChild(transaction, {
        op: 'browser',
        description: 'request',
        startTimestamp: timeOrigin + utils_2.msToSec(entry.requestStart),
        endTimestamp: timeOrigin + utils_2.msToSec(entry.responseEnd),
      });
      _startChild(transaction, {
        op: 'browser',
        description: 'response',
        startTimestamp: timeOrigin + utils_2.msToSec(entry.responseStart),
        endTimestamp: timeOrigin + utils_2.msToSec(entry.responseEnd),
      });
    }
    /**
     * Helper function to start child on transactions. This function will make sure that the transaction will
     * use the start timestamp of the created child span if it is earlier than the transactions actual
     * start timestamp.
     */
    function _startChild(transaction, _a) {
      var startTimestamp = _a.startTimestamp, ctx = tslib_1.__rest(_a, ["startTimestamp"]);
      if (startTimestamp && transaction.startTimestamp > startTimestamp) {
        transaction.startTimestamp = startTimestamp;
      }
      return transaction.startChild(tslib_1.__assign({ startTimestamp: startTimestamp }, ctx));
    }
    exports._startChild = _startChild;
    /**
     * Checks if a given value is a valid measurement value.
     */
    function isMeasurementValue(value) {
      return typeof value === 'number' && isFinite(value);
    }
    /** Add LCP / CLS data to transaction to allow debugging */
    function tagMetricInfo(transaction, lcpEntry, clsEntry) {
      if (lcpEntry) {
        flags_1.IS_DEBUG_BUILD && utils_1.logger.log('[Measurements] Adding LCP Data');
        // Capture Properties of the LCP element that contributes to the LCP.
        if (lcpEntry.element) {
          transaction.setTag('lcp.element', utils_1.htmlTreeAsString(lcpEntry.element));
        }
        if (lcpEntry.id) {
          transaction.setTag('lcp.id', lcpEntry.id);
        }
        if (lcpEntry.url) {
          // Trim URL to the first 200 characters.
          transaction.setTag('lcp.url', lcpEntry.url.trim().slice(0, 200));
        }
        transaction.setTag('lcp.size', lcpEntry.size);
      }
      // See: https://developer.mozilla.org/en-US/docs/Web/API/LayoutShift
      if (clsEntry && clsEntry.sources) {
        flags_1.IS_DEBUG_BUILD && utils_1.logger.log('[Measurements] Adding CLS Data');
        clsEntry.sources.forEach(function (source, index) {
          return transaction.setTag("cls.source." + (index + 1), utils_1.htmlTreeAsString(source.node));
        });
      }
    }

  }, { "../flags": 70, "../utils": 82, "./web-vitals/getCLS": 59, "./web-vitals/getFID": 60, "./web-vitals/getLCP": 61, "./web-vitals/lib/getVisibilityWatcher": 64, "@sentry/utils": 95, "tslib": 181 }], 57: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var utils_1 = require("@sentry/utils");
    var utils_2 = require("../utils");
    exports.DEFAULT_TRACING_ORIGINS = ['localhost', /^\//];
    exports.defaultRequestInstrumentationOptions = {
      traceFetch: true,
      traceXHR: true,
      tracingOrigins: exports.DEFAULT_TRACING_ORIGINS,
    };
    /** Registers span creators for xhr and fetch requests  */
    function instrumentOutgoingRequests(_options) {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      var _a = tslib_1.__assign(tslib_1.__assign({}, exports.defaultRequestInstrumentationOptions), _options), traceFetch = _a.traceFetch, traceXHR = _a.traceXHR, tracingOrigins = _a.tracingOrigins, shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;
      // We should cache url -> decision so that we don't have to compute
      // regexp everytime we create a request.
      var urlMap = {};
      var defaultShouldCreateSpan = function (url) {
        if (urlMap[url]) {
          return urlMap[url];
        }
        var origins = tracingOrigins;
        urlMap[url] =
          origins.some(function (origin) { return utils_1.isMatchingPattern(url, origin); }) &&
          !utils_1.isMatchingPattern(url, 'sentry_key');
        return urlMap[url];
      };
      // We want that our users don't have to re-implement shouldCreateSpanForRequest themselves
      // That's why we filter out already unwanted Spans from tracingOrigins
      var shouldCreateSpan = defaultShouldCreateSpan;
      if (typeof shouldCreateSpanForRequest === 'function') {
        shouldCreateSpan = function (url) {
          return defaultShouldCreateSpan(url) && shouldCreateSpanForRequest(url);
        };
      }
      var spans = {};
      if (traceFetch) {
        utils_1.addInstrumentationHandler('fetch', function (handlerData) {
          fetchCallback(handlerData, shouldCreateSpan, spans);
        });
      }
      if (traceXHR) {
        utils_1.addInstrumentationHandler('xhr', function (handlerData) {
          xhrCallback(handlerData, shouldCreateSpan, spans);
        });
      }
    }
    exports.instrumentOutgoingRequests = instrumentOutgoingRequests;
    /**
     * Create and track fetch request spans
     */
    function fetchCallback(handlerData, shouldCreateSpan, spans) {
      if (!utils_2.hasTracingEnabled() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {
        return;
      }
      if (handlerData.endTimestamp) {
        var spanId = handlerData.fetchData.__span;
        if (!spanId)
          return;
        var span = spans[spanId];
        if (span) {
          if (handlerData.response) {
            // TODO (kmclb) remove this once types PR goes through
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            span.setHttpStatus(handlerData.response.status);
          }
          else if (handlerData.error) {
            span.setStatus('internal_error');
          }
          span.finish();
          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
          delete spans[spanId];
        }
        return;
      }
      var activeTransaction = utils_2.getActiveTransaction();
      if (activeTransaction) {
        var span = activeTransaction.startChild({
          data: tslib_1.__assign(tslib_1.__assign({}, handlerData.fetchData), { type: 'fetch' }),
          description: handlerData.fetchData.method + " " + handlerData.fetchData.url,
          op: 'http.client',
        });
        handlerData.fetchData.__span = span.spanId;
        spans[span.spanId] = span;
        var request = (handlerData.args[0] = handlerData.args[0]);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var options = (handlerData.args[1] = handlerData.args[1] || {});
        var headers = options.headers;
        if (utils_1.isInstanceOf(request, Request)) {
          headers = request.headers;
        }
        if (headers) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          if (typeof headers.append === 'function') {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            headers.append('sentry-trace', span.toTraceparent());
          }
          else if (Array.isArray(headers)) {
            headers = tslib_1.__spread(headers, [['sentry-trace', span.toTraceparent()]]);
          }
          else {
            headers = tslib_1.__assign(tslib_1.__assign({}, headers), { 'sentry-trace': span.toTraceparent() });
          }
        }
        else {
          headers = { 'sentry-trace': span.toTraceparent() };
        }
        options.headers = headers;
      }
    }
    exports.fetchCallback = fetchCallback;
    /**
     * Create and track xhr request spans
     */
    function xhrCallback(handlerData, shouldCreateSpan, spans) {
      if (!utils_2.hasTracingEnabled() ||
        (handlerData.xhr && handlerData.xhr.__sentry_own_request__) ||
        !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url))) {
        return;
      }
      var xhr = handlerData.xhr.__sentry_xhr__;
      // check first if the request has finished and is tracked by an existing span which should now end
      if (handlerData.endTimestamp) {
        var spanId = handlerData.xhr.__sentry_xhr_span_id__;
        if (!spanId)
          return;
        var span = spans[spanId];
        if (span) {
          span.setHttpStatus(xhr.status_code);
          span.finish();
          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
          delete spans[spanId];
        }
        return;
      }
      // if not, create a new span to track it
      var activeTransaction = utils_2.getActiveTransaction();
      if (activeTransaction) {
        var span = activeTransaction.startChild({
          data: tslib_1.__assign(tslib_1.__assign({}, xhr.data), { type: 'xhr', method: xhr.method, url: xhr.url }),
          description: xhr.method + " " + xhr.url,
          op: 'http.client',
        });
        handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;
        spans[handlerData.xhr.__sentry_xhr_span_id__] = span;
        if (handlerData.xhr.setRequestHeader) {
          try {
            handlerData.xhr.setRequestHeader('sentry-trace', span.toTraceparent());
          }
          catch (_) {
            // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.
          }
        }
      }
    }
    exports.xhrCallback = xhrCallback;

  }, { "../utils": 82, "@sentry/utils": 95, "tslib": 181 }], 58: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("../flags");
    var global = utils_1.getGlobalObject();
    /**
     * Default function implementing pageload and navigation transactions
     */
    function instrumentRoutingWithDefaults(customStartTransaction, startTransactionOnPageLoad, startTransactionOnLocationChange) {
      if (startTransactionOnPageLoad === void 0) { startTransactionOnPageLoad = true; }
      if (startTransactionOnLocationChange === void 0) { startTransactionOnLocationChange = true; }
      if (!global || !global.location) {
        flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('Could not initialize routing instrumentation due to invalid location');
        return;
      }
      var startingUrl = global.location.href;
      var activeTransaction;
      if (startTransactionOnPageLoad) {
        activeTransaction = customStartTransaction({ name: global.location.pathname, op: 'pageload' });
      }
      if (startTransactionOnLocationChange) {
        utils_1.addInstrumentationHandler('history', function (_a) {
          var to = _a.to, from = _a.from;
          /**
           * This early return is there to account for some cases where a navigation transaction starts right after
           * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't
           * create an uneccessary navigation transaction.
           *
           * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also
           * only be caused in certain development environments where the usage of a hot module reloader is causing
           * errors.
           */
          if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {
            startingUrl = undefined;
            return;
          }
          if (from !== to) {
            startingUrl = undefined;
            if (activeTransaction) {
              flags_1.IS_DEBUG_BUILD && utils_1.logger.log("[Tracing] Finishing current transaction with op: " + activeTransaction.op);
              // If there's an open transaction on the scope, we need to finish it before creating an new one.
              activeTransaction.finish();
            }
            activeTransaction = customStartTransaction({ name: global.location.pathname, op: 'navigation' });
          }
        });
      }
    }
    exports.instrumentRoutingWithDefaults = instrumentRoutingWithDefaults;

  }, { "../flags": 70, "@sentry/utils": 95 }], 59: [function (require, module, exports) {
    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    var bindReporter_1 = require("./lib/bindReporter");
    var initMetric_1 = require("./lib/initMetric");
    var observe_1 = require("./lib/observe");
    var onHidden_1 = require("./lib/onHidden");
    exports.getCLS = function (onReport, reportAllChanges) {
      var metric = initMetric_1.initMetric('CLS', 0);
      var report;
      var sessionValue = 0;
      var sessionEntries = [];
      var entryHandler = function (entry) {
        // Only count layout shifts without recent user input.
        // TODO: Figure out why entry can be undefined
        if (entry && !entry.hadRecentInput) {
          var firstSessionEntry = sessionEntries[0];
          var lastSessionEntry = sessionEntries[sessionEntries.length - 1];
          // If the entry occurred less than 1 second after the previous entry and
          // less than 5 seconds after the first entry in the session, include the
          // entry in the current session. Otherwise, start a new session.
          if (sessionValue &&
            sessionEntries.length !== 0 &&
            entry.startTime - lastSessionEntry.startTime < 1000 &&
            entry.startTime - firstSessionEntry.startTime < 5000) {
            sessionValue += entry.value;
            sessionEntries.push(entry);
          }
          else {
            sessionValue = entry.value;
            sessionEntries = [entry];
          }
          // If the current session value is larger than the current CLS value,
          // update CLS and the entries contributing to it.
          if (sessionValue > metric.value) {
            metric.value = sessionValue;
            metric.entries = sessionEntries;
            if (report) {
              report();
            }
          }
        }
      };
      var po = observe_1.observe('layout-shift', entryHandler);
      if (po) {
        report = bindReporter_1.bindReporter(onReport, metric, reportAllChanges);
        onHidden_1.onHidden(function () {
          po.takeRecords().map(entryHandler);
          report(true);
        });
      }
    };

  }, { "./lib/bindReporter": 62, "./lib/initMetric": 65, "./lib/observe": 66, "./lib/onHidden": 67 }], 60: [function (require, module, exports) {
    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    var bindReporter_1 = require("./lib/bindReporter");
    var getVisibilityWatcher_1 = require("./lib/getVisibilityWatcher");
    var initMetric_1 = require("./lib/initMetric");
    var observe_1 = require("./lib/observe");
    var onHidden_1 = require("./lib/onHidden");
    exports.getFID = function (onReport, reportAllChanges) {
      var visibilityWatcher = getVisibilityWatcher_1.getVisibilityWatcher();
      var metric = initMetric_1.initMetric('FID');
      var report;
      var entryHandler = function (entry) {
        // Only report if the page wasn't hidden prior to the first input.
        if (report && entry.startTime < visibilityWatcher.firstHiddenTime) {
          metric.value = entry.processingStart - entry.startTime;
          metric.entries.push(entry);
          report(true);
        }
      };
      var po = observe_1.observe('first-input', entryHandler);
      if (po) {
        report = bindReporter_1.bindReporter(onReport, metric, reportAllChanges);
        onHidden_1.onHidden(function () {
          po.takeRecords().map(entryHandler);
          po.disconnect();
        }, true);
      }
    };

  }, { "./lib/bindReporter": 62, "./lib/getVisibilityWatcher": 64, "./lib/initMetric": 65, "./lib/observe": 66, "./lib/onHidden": 67 }], 61: [function (require, module, exports) {
    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    var bindReporter_1 = require("./lib/bindReporter");
    var getVisibilityWatcher_1 = require("./lib/getVisibilityWatcher");
    var initMetric_1 = require("./lib/initMetric");
    var observe_1 = require("./lib/observe");
    var onHidden_1 = require("./lib/onHidden");
    var reportedMetricIDs = {};
    exports.getLCP = function (onReport, reportAllChanges) {
      var visibilityWatcher = getVisibilityWatcher_1.getVisibilityWatcher();
      var metric = initMetric_1.initMetric('LCP');
      var report;
      var entryHandler = function (entry) {
        // The startTime attribute returns the value of the renderTime if it is not 0,
        // and the value of the loadTime otherwise.
        var value = entry.startTime;
        // If the page was hidden prior to paint time of the entry,
        // ignore it and mark the metric as final, otherwise add the entry.
        if (value < visibilityWatcher.firstHiddenTime) {
          metric.value = value;
          metric.entries.push(entry);
        }
        if (report) {
          report();
        }
      };
      var po = observe_1.observe('largest-contentful-paint', entryHandler);
      if (po) {
        report = bindReporter_1.bindReporter(onReport, metric, reportAllChanges);
        var stopListening_1 = function () {
          if (!reportedMetricIDs[metric.id]) {
            po.takeRecords().map(entryHandler);
            po.disconnect();
            reportedMetricIDs[metric.id] = true;
            report(true);
          }
        };
        // Stop listening after input. Note: while scrolling is an input that
        // stop LCP observation, it's unreliable since it can be programmatically
        // generated. See: https://github.com/GoogleChrome/web-vitals/issues/75
        ['keydown', 'click'].forEach(function (type) {
          addEventListener(type, stopListening_1, { once: true, capture: true });
        });
        onHidden_1.onHidden(stopListening_1, true);
      }
    };

  }, { "./lib/bindReporter": 62, "./lib/getVisibilityWatcher": 64, "./lib/initMetric": 65, "./lib/observe": 66, "./lib/onHidden": 67 }], 62: [function (require, module, exports) {
    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bindReporter = function (callback, metric, reportAllChanges) {
      var prevValue;
      return function (forceReport) {
        if (metric.value >= 0) {
          if (forceReport || reportAllChanges) {
            metric.delta = metric.value - (prevValue || 0);
            // Report the metric if there's a non-zero delta or if no previous
            // value exists (which can happen in the case of the document becoming
            // hidden when the metric value is 0).
            // See: https://github.com/GoogleChrome/web-vitals/issues/14
            if (metric.delta || prevValue === undefined) {
              prevValue = metric.value;
              callback(metric);
            }
          }
        }
      };
    };

  }, {}], 63: [function (require, module, exports) {
    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Performantly generate a unique, 30-char string by combining a version
     * number, the current timestamp with a 13-digit number integer.
     * @return {string}
     */
    exports.generateUniqueID = function () {
      return "v2-" + Date.now() + "-" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);
    };

  }, {}], 64: [function (require, module, exports) {
    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require("@sentry/utils");
    var onHidden_1 = require("./onHidden");
    var firstHiddenTime = -1;
    var initHiddenTime = function () {
      return utils_1.getGlobalObject().document.visibilityState === 'hidden' ? 0 : Infinity;
    };
    var trackChanges = function () {
      // Update the time if/when the document becomes hidden.
      onHidden_1.onHidden(function (_a) {
        var timeStamp = _a.timeStamp;
        firstHiddenTime = timeStamp;
      }, true);
    };
    exports.getVisibilityWatcher = function () {
      if (firstHiddenTime < 0) {
        // If the document is hidden when this code runs, assume it was hidden
        // since navigation start. This isn't a perfect heuristic, but it's the
        // best we can do until an API is available to support querying past
        // visibilityState.
        firstHiddenTime = initHiddenTime();
        trackChanges();
      }
      return {
        get firstHiddenTime() {
          return firstHiddenTime;
        },
      };
    };

  }, { "./onHidden": 67, "@sentry/utils": 95 }], 65: [function (require, module, exports) {
    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    var generateUniqueID_1 = require("./generateUniqueID");
    exports.initMetric = function (name, value) {
      return {
        name: name,
        value: (value !== null && value !== void 0 ? value : -1),
        delta: 0,
        entries: [],
        id: generateUniqueID_1.generateUniqueID(),
      };
    };

  }, { "./generateUniqueID": 63 }], 66: [function (require, module, exports) {
    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Takes a performance entry type and a callback function, and creates a
     * `PerformanceObserver` instance that will observe the specified entry type
     * with buffering enabled and call the callback _for each entry_.
     *
     * This function also feature-detects entry support and wraps the logic in a
     * try/catch to avoid errors in unsupporting browsers.
     */
    exports.observe = function (type, callback) {
      try {
        if (PerformanceObserver.supportedEntryTypes.includes(type)) {
          // More extensive feature detect needed for Firefox due to:
          // https://github.com/GoogleChrome/web-vitals/issues/142
          if (type === 'first-input' && !('PerformanceEventTiming' in self)) {
            return;
          }
          var po = new PerformanceObserver(function (l) { return l.getEntries().map(callback); });
          po.observe({ type: type, buffered: true });
          return po;
        }
      }
      catch (e) {
        // Do nothing.
      }
      return;
    };

  }, {}], 67: [function (require, module, exports) {
    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require("@sentry/utils");
    exports.onHidden = function (cb, once) {
      var onHiddenOrPageHide = function (event) {
        if (event.type === 'pagehide' || utils_1.getGlobalObject().document.visibilityState === 'hidden') {
          cb(event);
          if (once) {
            removeEventListener('visibilitychange', onHiddenOrPageHide, true);
            removeEventListener('pagehide', onHiddenOrPageHide, true);
          }
        }
      };
      addEventListener('visibilitychange', onHiddenOrPageHide, true);
      // Some browsers have buggy implementations of visibilitychange,
      // so we use pagehide in addition, just to be safe.
      addEventListener('pagehide', onHiddenOrPageHide, true);
    };

  }, { "@sentry/utils": 95 }], 68: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    // Store finish reasons in tuple to save on bundle size
    // Readonly type should enforce that this is not mutated.
    exports.FINISH_REASON_TAG = 'finishReason';
    exports.IDLE_TRANSACTION_FINISH_REASONS = ['heartbeatFailed', 'idleTimeout', 'documentHidden'];

  }, {}], 69: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("./flags");
    var utils_2 = require("./utils");
    /**
     * Configures global error listeners
     */
    function registerErrorInstrumentation() {
      utils_1.addInstrumentationHandler('error', errorCallback);
      utils_1.addInstrumentationHandler('unhandledrejection', errorCallback);
    }
    exports.registerErrorInstrumentation = registerErrorInstrumentation;
    /**
     * If an error or unhandled promise occurs, we mark the active transaction as failed
     */
    function errorCallback() {
      var activeTransaction = utils_2.getActiveTransaction();
      if (activeTransaction) {
        var status_1 = 'internal_error';
        flags_1.IS_DEBUG_BUILD && utils_1.logger.log("[Tracing] Transaction: " + status_1 + " -> Global error occured");
        activeTransaction.setStatus(status_1);
      }
    }

  }, { "./flags": 70, "./utils": 82, "@sentry/utils": 95 }], 70: [function (require, module, exports) {
    arguments[4][12][0].apply(exports, arguments)
  }, { "dup": 12 }], 71: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var hub_1 = require("@sentry/hub");
    var utils_1 = require("@sentry/utils");
    var errors_1 = require("./errors");
    var flags_1 = require("./flags");
    var idletransaction_1 = require("./idletransaction");
    var transaction_1 = require("./transaction");
    var utils_2 = require("./utils");
    /** Returns all trace headers that are currently on the top scope. */
    function traceHeaders() {
      var scope = this.getScope();
      if (scope) {
        var span = scope.getSpan();
        if (span) {
          return {
            'sentry-trace': span.toTraceparent(),
          };
        }
      }
      return {};
    }
    /**
     * Makes a sampling decision for the given transaction and stores it on the transaction.
     *
     * Called every time a transaction is created. Only transactions which emerge with a `sampled` value of `true` will be
     * sent to Sentry.
     *
     * @param transaction: The transaction needing a sampling decision
     * @param options: The current client's options, so we can access `tracesSampleRate` and/or `tracesSampler`
     * @param samplingContext: Default and user-provided data which may be used to help make the decision
     *
     * @returns The given transaction with its `sampled` value set
     */
    function sample(transaction, options, samplingContext) {
      // nothing to do if tracing is not enabled
      if (!utils_2.hasTracingEnabled(options)) {
        transaction.sampled = false;
        return transaction;
      }
      // if the user has forced a sampling decision by passing a `sampled` value in their transaction context, go with that
      if (transaction.sampled !== undefined) {
        transaction.setMetadata({
          transactionSampling: { method: 'explicitly_set' },
        });
        return transaction;
      }
      // we would have bailed already if neither `tracesSampler` nor `tracesSampleRate` were defined, so one of these should
      // work; prefer the hook if so
      var sampleRate;
      if (typeof options.tracesSampler === 'function') {
        sampleRate = options.tracesSampler(samplingContext);
        transaction.setMetadata({
          transactionSampling: {
            method: 'client_sampler',
            // cast to number in case it's a boolean
            rate: Number(sampleRate),
          },
        });
      }
      else if (samplingContext.parentSampled !== undefined) {
        sampleRate = samplingContext.parentSampled;
        transaction.setMetadata({
          transactionSampling: { method: 'inheritance' },
        });
      }
      else {
        sampleRate = options.tracesSampleRate;
        transaction.setMetadata({
          transactionSampling: {
            method: 'client_rate',
            // cast to number in case it's a boolean
            rate: Number(sampleRate),
          },
        });
      }
      // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The
      // only valid values are booleans or numbers between 0 and 1.)
      if (!isValidSampleRate(sampleRate)) {
        flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('[Tracing] Discarding transaction because of invalid sample rate.');
        transaction.sampled = false;
        return transaction;
      }
      // if the function returned 0 (or false), or if `tracesSampleRate` is 0, it's a sign the transaction should be dropped
      if (!sampleRate) {
        flags_1.IS_DEBUG_BUILD &&
          utils_1.logger.log("[Tracing] Discarding transaction because " + (typeof options.tracesSampler === 'function'
            ? 'tracesSampler returned 0 or false'
            : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'));
        transaction.sampled = false;
        return transaction;
      }
      // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is
      // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.
      transaction.sampled = Math.random() < sampleRate;
      // if we're not going to keep it, we're done
      if (!transaction.sampled) {
        flags_1.IS_DEBUG_BUILD &&
          utils_1.logger.log("[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = " + Number(sampleRate) + ")");
        return transaction;
      }
      flags_1.IS_DEBUG_BUILD && utils_1.logger.log("[Tracing] starting " + transaction.op + " transaction - " + transaction.name);
      return transaction;
    }
    /**
     * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).
     */
    function isValidSampleRate(rate) {
      // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      if (utils_1.isNaN(rate) || !(typeof rate === 'number' || typeof rate === 'boolean')) {
        flags_1.IS_DEBUG_BUILD &&
          utils_1.logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got " + JSON.stringify(rate) + " of type " + JSON.stringify(typeof rate) + ".");
        return false;
      }
      // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false
      if (rate < 0 || rate > 1) {
        flags_1.IS_DEBUG_BUILD &&
          utils_1.logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got " + rate + ".");
        return false;
      }
      return true;
    }
    /**
     * Creates a new transaction and adds a sampling decision if it doesn't yet have one.
     *
     * The Hub.startTransaction method delegates to this method to do its work, passing the Hub instance in as `this`, as if
     * it had been called on the hub directly. Exists as a separate function so that it can be injected into the class as an
     * "extension method."
     *
     * @param this: The Hub starting the transaction
     * @param transactionContext: Data used to configure the transaction
     * @param CustomSamplingContext: Optional data to be provided to the `tracesSampler` function (if any)
     *
     * @returns The new transaction
     *
     * @see {@link Hub.startTransaction}
     */
    function _startTransaction(transactionContext, customSamplingContext) {
      var client = this.getClient();
      var options = (client && client.getOptions()) || {};
      var transaction = new transaction_1.Transaction(transactionContext, this);
      transaction = sample(transaction, options, tslib_1.__assign({ parentSampled: transactionContext.parentSampled, transactionContext: transactionContext }, customSamplingContext));
      if (transaction.sampled) {
        transaction.initSpanRecorder(options._experiments && options._experiments.maxSpans);
      }
      return transaction;
    }
    /**
     * Create new idle transaction.
     */
    function startIdleTransaction(hub, transactionContext, idleTimeout, onScope, customSamplingContext) {
      var client = hub.getClient();
      var options = (client && client.getOptions()) || {};
      var transaction = new idletransaction_1.IdleTransaction(transactionContext, hub, idleTimeout, onScope);
      transaction = sample(transaction, options, tslib_1.__assign({ parentSampled: transactionContext.parentSampled, transactionContext: transactionContext }, customSamplingContext));
      if (transaction.sampled) {
        transaction.initSpanRecorder(options._experiments && options._experiments.maxSpans);
      }
      return transaction;
    }
    exports.startIdleTransaction = startIdleTransaction;
    /**
     * @private
     */
    function _addTracingExtensions() {
      var carrier = hub_1.getMainCarrier();
      if (!carrier.__SENTRY__) {
        return;
      }
      carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
      if (!carrier.__SENTRY__.extensions.startTransaction) {
        carrier.__SENTRY__.extensions.startTransaction = _startTransaction;
      }
      if (!carrier.__SENTRY__.extensions.traceHeaders) {
        carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;
      }
    }
    exports._addTracingExtensions = _addTracingExtensions;
    /**
     * @private
     */
    function _autoloadDatabaseIntegrations() {
      var carrier = hub_1.getMainCarrier();
      if (!carrier.__SENTRY__) {
        return;
      }
      var packageToIntegrationMapping = {
        mongodb: function () {
          var integration = utils_1.dynamicRequire(module, './integrations/node/mongo');
          return new integration.Mongo();
        },
        mongoose: function () {
          var integration = utils_1.dynamicRequire(module, './integrations/node/mongo');
          return new integration.Mongo({ mongoose: true });
        },
        mysql: function () {
          var integration = utils_1.dynamicRequire(module, './integrations/node/mysql');
          return new integration.Mysql();
        },
        pg: function () {
          var integration = utils_1.dynamicRequire(module, './integrations/node/postgres');
          return new integration.Postgres();
        },
      };
      var mappedPackages = Object.keys(packageToIntegrationMapping)
        .filter(function (moduleName) { return !!utils_1.loadModule(moduleName); })
        .map(function (pkg) {
          try {
            return packageToIntegrationMapping[pkg]();
          }
          catch (e) {
            return undefined;
          }
        })
        .filter(function (p) { return p; });
      if (mappedPackages.length > 0) {
        carrier.__SENTRY__.integrations = tslib_1.__spread((carrier.__SENTRY__.integrations || []), mappedPackages);
      }
    }
    /**
     * This patches the global object and injects the Tracing extensions methods
     */
    function addExtensionMethods() {
      _addTracingExtensions();
      // Detect and automatically load specified integrations.
      if (utils_1.isNodeEnv()) {
        _autoloadDatabaseIntegrations();
      }
      // If an error happens globally, we should make sure transaction status is set to error.
      errors_1.registerErrorInstrumentation();
    }
    exports.addExtensionMethods = addExtensionMethods;

  }, { "./errors": 69, "./flags": 70, "./idletransaction": 72, "./transaction": 81, "./utils": 82, "@sentry/hub": 48, "@sentry/utils": 95, "tslib": 181 }], 72: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var utils_1 = require("@sentry/utils");
    var constants_1 = require("./constants");
    var flags_1 = require("./flags");
    var span_1 = require("./span");
    var transaction_1 = require("./transaction");
    exports.DEFAULT_IDLE_TIMEOUT = 1000;
    exports.HEARTBEAT_INTERVAL = 5000;
    /**
     * @inheritDoc
     */
    var IdleTransactionSpanRecorder = /** @class */ (function (_super) {
      tslib_1.__extends(IdleTransactionSpanRecorder, _super);
      function IdleTransactionSpanRecorder(_pushActivity, _popActivity, transactionSpanId, maxlen) {
        if (transactionSpanId === void 0) { transactionSpanId = ''; }
        var _this = _super.call(this, maxlen) || this;
        _this._pushActivity = _pushActivity;
        _this._popActivity = _popActivity;
        _this.transactionSpanId = transactionSpanId;
        return _this;
      }
      /**
       * @inheritDoc
       */
      IdleTransactionSpanRecorder.prototype.add = function (span) {
        var _this = this;
        // We should make sure we do not push and pop activities for
        // the transaction that this span recorder belongs to.
        if (span.spanId !== this.transactionSpanId) {
          // We patch span.finish() to pop an activity after setting an endTimestamp.
          span.finish = function (endTimestamp) {
            span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : utils_1.timestampWithMs();
            _this._popActivity(span.spanId);
          };
          // We should only push new activities if the span does not have an end timestamp.
          if (span.endTimestamp === undefined) {
            this._pushActivity(span.spanId);
          }
        }
        _super.prototype.add.call(this, span);
      };
      return IdleTransactionSpanRecorder;
    }(span_1.SpanRecorder));
    exports.IdleTransactionSpanRecorder = IdleTransactionSpanRecorder;
    /**
     * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.
     * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will
     * put itself on the scope on creation.
     */
    var IdleTransaction = /** @class */ (function (_super) {
      tslib_1.__extends(IdleTransaction, _super);
      function IdleTransaction(transactionContext, _idleHub,
        /**
         * The time to wait in ms until the idle transaction will be finished.
         * @default 1000
         */
        _idleTimeout,
        // Whether or not the transaction should put itself on the scope when it starts and pop itself off when it ends
        _onScope) {
        if (_idleTimeout === void 0) { _idleTimeout = exports.DEFAULT_IDLE_TIMEOUT; }
        if (_onScope === void 0) { _onScope = false; }
        var _this = _super.call(this, transactionContext, _idleHub) || this;
        _this._idleHub = _idleHub;
        _this._idleTimeout = _idleTimeout;
        _this._onScope = _onScope;
        // Activities store a list of active spans
        _this.activities = {};
        // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.
        _this._heartbeatCounter = 0;
        // We should not use heartbeat if we finished a transaction
        _this._finished = false;
        _this._beforeFinishCallbacks = [];
        if (_idleHub && _onScope) {
          // There should only be one active transaction on the scope
          clearActiveTransaction(_idleHub);
          // We set the transaction here on the scope so error events pick up the trace
          // context and attach it to the error.
          flags_1.IS_DEBUG_BUILD && utils_1.logger.log("Setting idle transaction on scope. Span ID: " + _this.spanId);
          _idleHub.configureScope(function (scope) { return scope.setSpan(_this); });
        }
        _this._initTimeout = setTimeout(function () {
          if (!_this._finished) {
            _this.finish();
          }
        }, _this._idleTimeout);
        return _this;
      }
      /** {@inheritDoc} */
      IdleTransaction.prototype.finish = function (endTimestamp) {
        var e_1, _a;
        var _this = this;
        if (endTimestamp === void 0) { endTimestamp = utils_1.timestampWithMs(); }
        this._finished = true;
        this.activities = {};
        if (this.spanRecorder) {
          flags_1.IS_DEBUG_BUILD &&
            utils_1.logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);
          try {
            for (var _b = tslib_1.__values(this._beforeFinishCallbacks), _c = _b.next(); !_c.done; _c = _b.next()) {
              var callback = _c.value;
              callback(this, endTimestamp);
            }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
          }
          this.spanRecorder.spans = this.spanRecorder.spans.filter(function (span) {
            // If we are dealing with the transaction itself, we just return it
            if (span.spanId === _this.spanId) {
              return true;
            }
            // We cancel all pending spans with status "cancelled" to indicate the idle transaction was finished early
            if (!span.endTimestamp) {
              span.endTimestamp = endTimestamp;
              span.setStatus('cancelled');
              flags_1.IS_DEBUG_BUILD &&
                utils_1.logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));
            }
            var keepSpan = span.startTimestamp < endTimestamp;
            if (!keepSpan) {
              flags_1.IS_DEBUG_BUILD &&
                utils_1.logger.log('[Tracing] discarding Span since it happened after Transaction was finished', JSON.stringify(span, undefined, 2));
            }
            return keepSpan;
          });
          flags_1.IS_DEBUG_BUILD && utils_1.logger.log('[Tracing] flushing IdleTransaction');
        }
        else {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.log('[Tracing] No active IdleTransaction');
        }
        // if `this._onScope` is `true`, the transaction put itself on the scope when it started
        if (this._onScope) {
          clearActiveTransaction(this._idleHub);
        }
        return _super.prototype.finish.call(this, endTimestamp);
      };
      /**
       * Register a callback function that gets excecuted before the transaction finishes.
       * Useful for cleanup or if you want to add any additional spans based on current context.
       *
       * This is exposed because users have no other way of running something before an idle transaction
       * finishes.
       */
      IdleTransaction.prototype.registerBeforeFinishCallback = function (callback) {
        this._beforeFinishCallbacks.push(callback);
      };
      /**
       * @inheritDoc
       */
      IdleTransaction.prototype.initSpanRecorder = function (maxlen) {
        var _this = this;
        if (!this.spanRecorder) {
          var pushActivity = function (id) {
            if (_this._finished) {
              return;
            }
            _this._pushActivity(id);
          };
          var popActivity = function (id) {
            if (_this._finished) {
              return;
            }
            _this._popActivity(id);
          };
          this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);
          // Start heartbeat so that transactions do not run forever.
          flags_1.IS_DEBUG_BUILD && utils_1.logger.log('Starting heartbeat');
          this._pingHeartbeat();
        }
        this.spanRecorder.add(this);
      };
      /**
       * Start tracking a specific activity.
       * @param spanId The span id that represents the activity
       */
      IdleTransaction.prototype._pushActivity = function (spanId) {
        if (this._initTimeout) {
          clearTimeout(this._initTimeout);
          this._initTimeout = undefined;
        }
        flags_1.IS_DEBUG_BUILD && utils_1.logger.log("[Tracing] pushActivity: " + spanId);
        this.activities[spanId] = true;
        flags_1.IS_DEBUG_BUILD && utils_1.logger.log('[Tracing] new activities count', Object.keys(this.activities).length);
      };
      /**
       * Remove an activity from usage
       * @param spanId The span id that represents the activity
       */
      IdleTransaction.prototype._popActivity = function (spanId) {
        var _this = this;
        if (this.activities[spanId]) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.log("[Tracing] popActivity " + spanId);
          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
          delete this.activities[spanId];
          flags_1.IS_DEBUG_BUILD && utils_1.logger.log('[Tracing] new activities count', Object.keys(this.activities).length);
        }
        if (Object.keys(this.activities).length === 0) {
          var timeout = this._idleTimeout;
          // We need to add the timeout here to have the real endtimestamp of the transaction
          // Remember timestampWithMs is in seconds, timeout is in ms
          var end_1 = utils_1.timestampWithMs() + timeout / 1000;
          setTimeout(function () {
            if (!_this._finished) {
              _this.setTag(constants_1.FINISH_REASON_TAG, constants_1.IDLE_TRANSACTION_FINISH_REASONS[1]);
              _this.finish(end_1);
            }
          }, timeout);
        }
      };
      /**
       * Checks when entries of this.activities are not changing for 3 beats.
       * If this occurs we finish the transaction.
       */
      IdleTransaction.prototype._beat = function () {
        // We should not be running heartbeat if the idle transaction is finished.
        if (this._finished) {
          return;
        }
        var heartbeatString = Object.keys(this.activities).join('');
        if (heartbeatString === this._prevHeartbeatString) {
          this._heartbeatCounter += 1;
        }
        else {
          this._heartbeatCounter = 1;
        }
        this._prevHeartbeatString = heartbeatString;
        if (this._heartbeatCounter >= 3) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');
          this.setStatus('deadline_exceeded');
          this.setTag(constants_1.FINISH_REASON_TAG, constants_1.IDLE_TRANSACTION_FINISH_REASONS[0]);
          this.finish();
        }
        else {
          this._pingHeartbeat();
        }
      };
      /**
       * Pings the heartbeat
       */
      IdleTransaction.prototype._pingHeartbeat = function () {
        var _this = this;
        flags_1.IS_DEBUG_BUILD && utils_1.logger.log("pinging Heartbeat -> current counter: " + this._heartbeatCounter);
        setTimeout(function () {
          _this._beat();
        }, exports.HEARTBEAT_INTERVAL);
      };
      return IdleTransaction;
    }(transaction_1.Transaction));
    exports.IdleTransaction = IdleTransaction;
    /**
     * Reset transaction on scope to `undefined`
     */
    function clearActiveTransaction(hub) {
      if (hub) {
        var scope = hub.getScope();
        if (scope) {
          var transaction = scope.getTransaction();
          if (transaction) {
            scope.setSpan(undefined);
          }
        }
      }
    }

  }, { "./constants": 68, "./flags": 70, "./span": 79, "./transaction": 81, "@sentry/utils": 95, "tslib": 181 }], 73: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var hubextensions_1 = require("./hubextensions");
    exports.addExtensionMethods = hubextensions_1.addExtensionMethods;
    var Integrations = require("./integrations");
    exports.Integrations = Integrations;
    // This is already exported as part of `Integrations` above (and for the moment will remain so for
    // backwards compatibility), but that interferes with treeshaking, so we also export it separately
    // here.
    //
    // Previously we expected users to import tracing integrations like
    //
    // import { Integrations } from '@sentry/tracing';
    // const instance = new Integrations.BrowserTracing();
    //
    // This makes the integrations unable to be treeshaken though. To address this, we now have
    // this individual export. We now expect users to consume BrowserTracing like so:
    //
    // import { BrowserTracing } from '@sentry/tracing';
    // const instance = new BrowserTracing();
    //
    // For an example of of the new usage of BrowserTracing, see @sentry/nextjs index.client.ts
    var browser_1 = require("./browser");
    exports.BrowserTracing = browser_1.BrowserTracing;
    var span_1 = require("./span");
    exports.Span = span_1.Span;
    exports.spanStatusfromHttpCode = span_1.spanStatusfromHttpCode;
    // eslint-disable-next-line deprecation/deprecation
    var spanstatus_1 = require("./spanstatus");
    exports.SpanStatus = spanstatus_1.SpanStatus;
    var transaction_1 = require("./transaction");
    exports.Transaction = transaction_1.Transaction;
    var browser_2 = require("./browser");
    // TODO deprecate old name in v7
    exports.registerRequestInstrumentation = browser_2.instrumentOutgoingRequests;
    exports.defaultRequestInstrumentationOptions = browser_2.defaultRequestInstrumentationOptions;
    var idletransaction_1 = require("./idletransaction");
    exports.IdleTransaction = idletransaction_1.IdleTransaction;
    var hubextensions_2 = require("./hubextensions");
    exports.startIdleTransaction = hubextensions_2.startIdleTransaction;
    // We are patching the global object with our hub extension methods
    hubextensions_1.addExtensionMethods();
    var utils_1 = require("./utils");
    exports.extractTraceparentData = utils_1.extractTraceparentData;
    exports.getActiveTransaction = utils_1.getActiveTransaction;
    exports.hasTracingEnabled = utils_1.hasTracingEnabled;
    exports.stripUrlQueryAndFragment = utils_1.stripUrlQueryAndFragment;
    exports.TRACEPARENT_REGEXP = utils_1.TRACEPARENT_REGEXP;

  }, { "./browser": 55, "./hubextensions": 71, "./idletransaction": 72, "./integrations": 74, "./span": 79, "./spanstatus": 80, "./transaction": 81, "./utils": 82 }], 74: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var express_1 = require("./node/express");
    exports.Express = express_1.Express;
    var postgres_1 = require("./node/postgres");
    exports.Postgres = postgres_1.Postgres;
    var mysql_1 = require("./node/mysql");
    exports.Mysql = mysql_1.Mysql;
    var mongo_1 = require("./node/mongo");
    exports.Mongo = mongo_1.Mongo;
    // TODO(v7): Remove this export
    // Please see `src/index.ts` for more details.
    var browser_1 = require("../browser");
    exports.BrowserTracing = browser_1.BrowserTracing;

  }, { "../browser": 55, "./node/express": 75, "./node/mongo": 76, "./node/mysql": 77, "./node/postgres": 78 }], 75: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("../../flags");
    /**
     * Express integration
     *
     * Provides an request and error handler for Express framework as well as tracing capabilities
     */
    var Express = /** @class */ (function () {
      /**
       * @inheritDoc
       */
      function Express(options) {
        if (options === void 0) { options = {}; }
        /**
         * @inheritDoc
         */
        this.name = Express.id;
        this._router = options.router || options.app;
        this._methods = (Array.isArray(options.methods) ? options.methods : []).concat('use');
      }
      /**
       * @inheritDoc
       */
      Express.prototype.setupOnce = function () {
        if (!this._router) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.error('ExpressIntegration is missing an Express instance');
          return;
        }
        instrumentMiddlewares(this._router, this._methods);
      };
      /**
       * @inheritDoc
       */
      Express.id = 'Express';
      return Express;
    }());
    exports.Express = Express;
    /**
     * Wraps original middleware function in a tracing call, which stores the info about the call as a span,
     * and finishes it once the middleware is done invoking.
     *
     * Express middlewares have 3 various forms, thus we have to take care of all of them:
     * // sync
     * app.use(function (req, res) { ... })
     * // async
     * app.use(function (req, res, next) { ... })
     * // error handler
     * app.use(function (err, req, res, next) { ... })
     *
     * They all internally delegate to the `router[method]` of the given application instance.
     */
    // eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any
    function wrap(fn, method) {
      var arity = fn.length;
      switch (arity) {
        case 2: {
          return function (req, res) {
            var transaction = res.__sentry_transaction;
            if (transaction) {
              var span_1 = transaction.startChild({
                description: fn.name,
                op: "express.middleware." + method,
              });
              res.once('finish', function () {
                span_1.finish();
              });
            }
            return fn.call(this, req, res);
          };
        }
        case 3: {
          return function (req, res, next) {
            var _a;
            var transaction = res.__sentry_transaction;
            var span = (_a = transaction) === null || _a === void 0 ? void 0 : _a.startChild({
              description: fn.name,
              op: "express.middleware." + method,
            });
            fn.call(this, req, res, function () {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var _a;
              (_a = span) === null || _a === void 0 ? void 0 : _a.finish();
              next.call.apply(next, tslib_1.__spread([this], args));
            });
          };
        }
        case 4: {
          return function (err, req, res, next) {
            var _a;
            var transaction = res.__sentry_transaction;
            var span = (_a = transaction) === null || _a === void 0 ? void 0 : _a.startChild({
              description: fn.name,
              op: "express.middleware." + method,
            });
            fn.call(this, err, req, res, function () {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var _a;
              (_a = span) === null || _a === void 0 ? void 0 : _a.finish();
              next.call.apply(next, tslib_1.__spread([this], args));
            });
          };
        }
        default: {
          throw new Error("Express middleware takes 2-4 arguments. Got: " + arity);
        }
      }
    }
    /**
     * Takes all the function arguments passed to the original `app` or `router` method, eg. `app.use` or `router.use`
     * and wraps every function, as well as array of functions with a call to our `wrap` method.
     * We have to take care of the arrays as well as iterate over all of the arguments,
     * as `app.use` can accept middlewares in few various forms.
     *
     * app.use([<path>], <fn>)
     * app.use([<path>], <fn>, ...<fn>)
     * app.use([<path>], ...<fn>[])
     */
    function wrapMiddlewareArgs(args, method) {
      return args.map(function (arg) {
        if (typeof arg === 'function') {
          return wrap(arg, method);
        }
        if (Array.isArray(arg)) {
          return arg.map(function (a) {
            if (typeof a === 'function') {
              return wrap(a, method);
            }
            return a;
          });
        }
        return arg;
      });
    }
    /**
     * Patches original router to utilize our tracing functionality
     */
    function patchMiddleware(router, method) {
      var originalCallback = router[method];
      router[method] = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return originalCallback.call.apply(originalCallback, tslib_1.__spread([this], wrapMiddlewareArgs(args, method)));
      };
      return router;
    }
    /**
     * Patches original router methods
     */
    function instrumentMiddlewares(router, methods) {
      if (methods === void 0) { methods = []; }
      methods.forEach(function (method) { return patchMiddleware(router, method); });
    }

  }, { "../../flags": 70, "@sentry/utils": 95, "tslib": 181 }], 76: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("../../flags");
    var OPERATIONS = [
      'aggregate',
      'bulkWrite',
      'countDocuments',
      'createIndex',
      'createIndexes',
      'deleteMany',
      'deleteOne',
      'distinct',
      'drop',
      'dropIndex',
      'dropIndexes',
      'estimatedDocumentCount',
      'find',
      'findOne',
      'findOneAndDelete',
      'findOneAndReplace',
      'findOneAndUpdate',
      'indexes',
      'indexExists',
      'indexInformation',
      'initializeOrderedBulkOp',
      'insertMany',
      'insertOne',
      'isCapped',
      'mapReduce',
      'options',
      'parallelCollectionScan',
      'rename',
      'replaceOne',
      'stats',
      'updateMany',
      'updateOne',
    ];
    // All of the operations above take `options` and `callback` as their final parameters, but some of them
    // take additional parameters as well. For those operations, this is a map of
    // { <operation name>:  [<names of additional parameters>] }, as a way to know what to call the operation's
    // positional arguments when we add them to the span's `data` object later
    var OPERATION_SIGNATURES = {
      // aggregate intentionally not included because `pipeline` arguments are too complex to serialize well
      // see https://github.com/getsentry/sentry-javascript/pull/3102
      bulkWrite: ['operations'],
      countDocuments: ['query'],
      createIndex: ['fieldOrSpec'],
      createIndexes: ['indexSpecs'],
      deleteMany: ['filter'],
      deleteOne: ['filter'],
      distinct: ['key', 'query'],
      dropIndex: ['indexName'],
      find: ['query'],
      findOne: ['query'],
      findOneAndDelete: ['filter'],
      findOneAndReplace: ['filter', 'replacement'],
      findOneAndUpdate: ['filter', 'update'],
      indexExists: ['indexes'],
      insertMany: ['docs'],
      insertOne: ['doc'],
      mapReduce: ['map', 'reduce'],
      rename: ['newName'],
      replaceOne: ['filter', 'doc'],
      updateMany: ['filter', 'update'],
      updateOne: ['filter', 'update'],
    };
    /** Tracing integration for mongo package */
    var Mongo = /** @class */ (function () {
      /**
       * @inheritDoc
       */
      function Mongo(options) {
        if (options === void 0) { options = {}; }
        /**
         * @inheritDoc
         */
        this.name = Mongo.id;
        this._operations = Array.isArray(options.operations) ? options.operations : OPERATIONS;
        this._describeOperations = 'describeOperations' in options ? options.describeOperations : true;
        this._useMongoose = !!options.useMongoose;
      }
      /**
       * @inheritDoc
       */
      Mongo.prototype.setupOnce = function (_, getCurrentHub) {
        var moduleName = this._useMongoose ? 'mongoose' : 'mongodb';
        var pkg = utils_1.loadModule(moduleName);
        if (!pkg) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.error("Mongo Integration was unable to require `" + moduleName + "` package.");
          return;
        }
        this._instrumentOperations(pkg.Collection, this._operations, getCurrentHub);
      };
      /**
       * Patches original collection methods
       */
      Mongo.prototype._instrumentOperations = function (collection, operations, getCurrentHub) {
        var _this = this;
        operations.forEach(function (operation) { return _this._patchOperation(collection, operation, getCurrentHub); });
      };
      /**
       * Patches original collection to utilize our tracing functionality
       */
      Mongo.prototype._patchOperation = function (collection, operation, getCurrentHub) {
        if (!(operation in collection.prototype))
          return;
        var getSpanContext = this._getSpanContextFromOperationArguments.bind(this);
        utils_1.fill(collection.prototype, operation, function (orig) {
          return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var _a, _b, _c, _d;
            var lastArg = args[args.length - 1];
            var scope = getCurrentHub().getScope();
            var parentSpan = (_a = scope) === null || _a === void 0 ? void 0 : _a.getSpan();
            // Check if the operation was passed a callback. (mapReduce requires a different check, as
            // its (non-callback) arguments can also be functions.)
            if (typeof lastArg !== 'function' || (operation === 'mapReduce' && args.length === 2)) {
              var span_1 = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild(getSpanContext(this, operation, args));
              var maybePromise = orig.call.apply(orig, tslib_1.__spread([this], args));
              if (utils_1.isThenable(maybePromise)) {
                return maybePromise.then(function (res) {
                  var _a;
                  (_a = span_1) === null || _a === void 0 ? void 0 : _a.finish();
                  return res;
                });
              }
              else {
                (_c = span_1) === null || _c === void 0 ? void 0 : _c.finish();
                return maybePromise;
              }
            }
            var span = (_d = parentSpan) === null || _d === void 0 ? void 0 : _d.startChild(getSpanContext(this, operation, args.slice(0, -1)));
            return orig.call.apply(orig, tslib_1.__spread([this], args.slice(0, -1), [function (err, result) {
              var _a;
              (_a = span) === null || _a === void 0 ? void 0 : _a.finish();
              lastArg(err, result);
            }]));
          };
        });
      };
      /**
       * Form a SpanContext based on the user input to a given operation.
       */
      Mongo.prototype._getSpanContextFromOperationArguments = function (collection, operation, args) {
        var data = {
          collectionName: collection.collectionName,
          dbName: collection.dbName,
          namespace: collection.namespace,
        };
        var spanContext = {
          op: 'db',
          description: operation,
          data: data,
        };
        // If the operation takes no arguments besides `options` and `callback`, or if argument
        // collection is disabled for this operation, just return early.
        var signature = OPERATION_SIGNATURES[operation];
        var shouldDescribe = Array.isArray(this._describeOperations)
          ? this._describeOperations.includes(operation)
          : this._describeOperations;
        if (!signature || !shouldDescribe) {
          return spanContext;
        }
        try {
          // Special case for `mapReduce`, as the only one accepting functions as arguments.
          if (operation === 'mapReduce') {
            var _a = tslib_1.__read(args, 2), map = _a[0], reduce = _a[1];
            data[signature[0]] = typeof map === 'string' ? map : map.name || '<anonymous>';
            data[signature[1]] = typeof reduce === 'string' ? reduce : reduce.name || '<anonymous>';
          }
          else {
            for (var i = 0; i < signature.length; i++) {
              data[signature[i]] = JSON.stringify(args[i]);
            }
          }
        }
        catch (_oO) {
          // no-empty
        }
        return spanContext;
      };
      /**
       * @inheritDoc
       */
      Mongo.id = 'Mongo';
      return Mongo;
    }());
    exports.Mongo = Mongo;

  }, { "../../flags": 70, "@sentry/utils": 95, "tslib": 181 }], 77: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("../../flags");
    /** Tracing integration for node-mysql package */
    var Mysql = /** @class */ (function () {
      function Mysql() {
        /**
         * @inheritDoc
         */
        this.name = Mysql.id;
      }
      /**
       * @inheritDoc
       */
      Mysql.prototype.setupOnce = function (_, getCurrentHub) {
        var pkg = utils_1.loadModule('mysql/lib/Connection.js');
        if (!pkg) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.error('Mysql Integration was unable to require `mysql` package.');
          return;
        }
        // The original function will have one of these signatures:
        //    function (callback) => void
        //    function (options, callback) => void
        //    function (options, values, callback) => void
        utils_1.fill(pkg, 'createQuery', function (orig) {
          return function (options, values, callback) {
            var _a, _b;
            var scope = getCurrentHub().getScope();
            var parentSpan = (_a = scope) === null || _a === void 0 ? void 0 : _a.getSpan();
            var span = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild({
              description: typeof options === 'string' ? options : options.sql,
              op: 'db',
            });
            if (typeof callback === 'function') {
              return orig.call(this, options, values, function (err, result, fields) {
                var _a;
                (_a = span) === null || _a === void 0 ? void 0 : _a.finish();
                callback(err, result, fields);
              });
            }
            if (typeof values === 'function') {
              return orig.call(this, options, function (err, result, fields) {
                var _a;
                (_a = span) === null || _a === void 0 ? void 0 : _a.finish();
                values(err, result, fields);
              });
            }
            return orig.call(this, options, values, callback);
          };
        });
      };
      /**
       * @inheritDoc
       */
      Mysql.id = 'Mysql';
      return Mysql;
    }());
    exports.Mysql = Mysql;

  }, { "../../flags": 70, "@sentry/utils": 95 }], 78: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("../../flags");
    /** Tracing integration for node-postgres package */
    var Postgres = /** @class */ (function () {
      function Postgres(options) {
        if (options === void 0) { options = {}; }
        /**
         * @inheritDoc
         */
        this.name = Postgres.id;
        this._usePgNative = !!options.usePgNative;
      }
      /**
       * @inheritDoc
       */
      Postgres.prototype.setupOnce = function (_, getCurrentHub) {
        var _a;
        var pkg = utils_1.loadModule('pg');
        if (!pkg) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.error('Postgres Integration was unable to require `pg` package.');
          return;
        }
        if (this._usePgNative && !((_a = pkg.native) === null || _a === void 0 ? void 0 : _a.Client)) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.error("Postgres Integration was unable to access 'pg-native' bindings.");
          return;
        }
        var Client = (this._usePgNative ? pkg.native : pkg).Client;
        /**
         * function (query, callback) => void
         * function (query, params, callback) => void
         * function (query) => Promise
         * function (query, params) => Promise
         * function (pg.Cursor) => pg.Cursor
         */
        utils_1.fill(Client.prototype, 'query', function (orig) {
          return function (config, values, callback) {
            var _a, _b, _c;
            var scope = getCurrentHub().getScope();
            var parentSpan = (_a = scope) === null || _a === void 0 ? void 0 : _a.getSpan();
            var span = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild({
              description: typeof config === 'string' ? config : config.text,
              op: 'db',
            });
            if (typeof callback === 'function') {
              return orig.call(this, config, values, function (err, result) {
                var _a;
                (_a = span) === null || _a === void 0 ? void 0 : _a.finish();
                callback(err, result);
              });
            }
            if (typeof values === 'function') {
              return orig.call(this, config, function (err, result) {
                var _a;
                (_a = span) === null || _a === void 0 ? void 0 : _a.finish();
                values(err, result);
              });
            }
            var rv = typeof values !== 'undefined' ? orig.call(this, config, values) : orig.call(this, config);
            if (utils_1.isThenable(rv)) {
              return rv.then(function (res) {
                var _a;
                (_a = span) === null || _a === void 0 ? void 0 : _a.finish();
                return res;
              });
            }
            (_c = span) === null || _c === void 0 ? void 0 : _c.finish();
            return rv;
          };
        });
      };
      /**
       * @inheritDoc
       */
      Postgres.id = 'Postgres';
      return Postgres;
    }());
    exports.Postgres = Postgres;

  }, { "../../flags": 70, "@sentry/utils": 95 }], 79: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var utils_1 = require("@sentry/utils");
    /**
     * Keeps track of finished spans for a given transaction
     * @internal
     * @hideconstructor
     * @hidden
     */
    var SpanRecorder = /** @class */ (function () {
      function SpanRecorder(maxlen) {
        if (maxlen === void 0) { maxlen = 1000; }
        this.spans = [];
        this._maxlen = maxlen;
      }
      /**
       * This is just so that we don't run out of memory while recording a lot
       * of spans. At some point we just stop and flush out the start of the
       * trace tree (i.e.the first n spans with the smallest
       * start_timestamp).
       */
      SpanRecorder.prototype.add = function (span) {
        if (this.spans.length > this._maxlen) {
          span.spanRecorder = undefined;
        }
        else {
          this.spans.push(span);
        }
      };
      return SpanRecorder;
    }());
    exports.SpanRecorder = SpanRecorder;
    /**
     * Span contains all data about a span
     */
    var Span = /** @class */ (function () {
      /**
       * You should never call the constructor manually, always use `Sentry.startTransaction()`
       * or call `startChild()` on an existing span.
       * @internal
       * @hideconstructor
       * @hidden
       */
      function Span(spanContext) {
        /**
         * @inheritDoc
         */
        this.traceId = utils_1.uuid4();
        /**
         * @inheritDoc
         */
        this.spanId = utils_1.uuid4().substring(16);
        /**
         * Timestamp in seconds when the span was created.
         */
        this.startTimestamp = utils_1.timestampWithMs();
        /**
         * @inheritDoc
         */
        this.tags = {};
        /**
         * @inheritDoc
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.data = {};
        if (!spanContext) {
          return this;
        }
        if (spanContext.traceId) {
          this.traceId = spanContext.traceId;
        }
        if (spanContext.spanId) {
          this.spanId = spanContext.spanId;
        }
        if (spanContext.parentSpanId) {
          this.parentSpanId = spanContext.parentSpanId;
        }
        // We want to include booleans as well here
        if ('sampled' in spanContext) {
          this.sampled = spanContext.sampled;
        }
        if (spanContext.op) {
          this.op = spanContext.op;
        }
        if (spanContext.description) {
          this.description = spanContext.description;
        }
        if (spanContext.data) {
          this.data = spanContext.data;
        }
        if (spanContext.tags) {
          this.tags = spanContext.tags;
        }
        if (spanContext.status) {
          this.status = spanContext.status;
        }
        if (spanContext.startTimestamp) {
          this.startTimestamp = spanContext.startTimestamp;
        }
        if (spanContext.endTimestamp) {
          this.endTimestamp = spanContext.endTimestamp;
        }
      }
      /**
       * @inheritDoc
       * @deprecated
       */
      Span.prototype.child = function (spanContext) {
        return this.startChild(spanContext);
      };
      /**
       * @inheritDoc
       */
      Span.prototype.startChild = function (spanContext) {
        var childSpan = new Span(tslib_1.__assign(tslib_1.__assign({}, spanContext), { parentSpanId: this.spanId, sampled: this.sampled, traceId: this.traceId }));
        childSpan.spanRecorder = this.spanRecorder;
        if (childSpan.spanRecorder) {
          childSpan.spanRecorder.add(childSpan);
        }
        childSpan.transaction = this.transaction;
        return childSpan;
      };
      /**
       * @inheritDoc
       */
      Span.prototype.setTag = function (key, value) {
        var _a;
        this.tags = tslib_1.__assign(tslib_1.__assign({}, this.tags), (_a = {}, _a[key] = value, _a));
        return this;
      };
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
      Span.prototype.setData = function (key, value) {
        var _a;
        this.data = tslib_1.__assign(tslib_1.__assign({}, this.data), (_a = {}, _a[key] = value, _a));
        return this;
      };
      /**
       * @inheritDoc
       */
      Span.prototype.setStatus = function (value) {
        this.status = value;
        return this;
      };
      /**
       * @inheritDoc
       */
      Span.prototype.setHttpStatus = function (httpStatus) {
        this.setTag('http.status_code', String(httpStatus));
        var spanStatus = spanStatusfromHttpCode(httpStatus);
        if (spanStatus !== 'unknown_error') {
          this.setStatus(spanStatus);
        }
        return this;
      };
      /**
       * @inheritDoc
       */
      Span.prototype.isSuccess = function () {
        return this.status === 'ok';
      };
      /**
       * @inheritDoc
       */
      Span.prototype.finish = function (endTimestamp) {
        this.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : utils_1.timestampWithMs();
      };
      /**
       * @inheritDoc
       */
      Span.prototype.toTraceparent = function () {
        var sampledString = '';
        if (this.sampled !== undefined) {
          sampledString = this.sampled ? '-1' : '-0';
        }
        return this.traceId + "-" + this.spanId + sampledString;
      };
      /**
       * @inheritDoc
       */
      Span.prototype.toContext = function () {
        return utils_1.dropUndefinedKeys({
          data: this.data,
          description: this.description,
          endTimestamp: this.endTimestamp,
          op: this.op,
          parentSpanId: this.parentSpanId,
          sampled: this.sampled,
          spanId: this.spanId,
          startTimestamp: this.startTimestamp,
          status: this.status,
          tags: this.tags,
          traceId: this.traceId,
        });
      };
      /**
       * @inheritDoc
       */
      Span.prototype.updateWithContext = function (spanContext) {
        var _a, _b, _c, _d, _e;
        this.data = (_a = spanContext.data, (_a !== null && _a !== void 0 ? _a : {}));
        this.description = spanContext.description;
        this.endTimestamp = spanContext.endTimestamp;
        this.op = spanContext.op;
        this.parentSpanId = spanContext.parentSpanId;
        this.sampled = spanContext.sampled;
        this.spanId = (_b = spanContext.spanId, (_b !== null && _b !== void 0 ? _b : this.spanId));
        this.startTimestamp = (_c = spanContext.startTimestamp, (_c !== null && _c !== void 0 ? _c : this.startTimestamp));
        this.status = spanContext.status;
        this.tags = (_d = spanContext.tags, (_d !== null && _d !== void 0 ? _d : {}));
        this.traceId = (_e = spanContext.traceId, (_e !== null && _e !== void 0 ? _e : this.traceId));
        return this;
      };
      /**
       * @inheritDoc
       */
      Span.prototype.getTraceContext = function () {
        return utils_1.dropUndefinedKeys({
          data: Object.keys(this.data).length > 0 ? this.data : undefined,
          description: this.description,
          op: this.op,
          parent_span_id: this.parentSpanId,
          span_id: this.spanId,
          status: this.status,
          tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,
          trace_id: this.traceId,
        });
      };
      /**
       * @inheritDoc
       */
      Span.prototype.toJSON = function () {
        return utils_1.dropUndefinedKeys({
          data: Object.keys(this.data).length > 0 ? this.data : undefined,
          description: this.description,
          op: this.op,
          parent_span_id: this.parentSpanId,
          span_id: this.spanId,
          start_timestamp: this.startTimestamp,
          status: this.status,
          tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,
          timestamp: this.endTimestamp,
          trace_id: this.traceId,
        });
      };
      return Span;
    }());
    exports.Span = Span;
    /**
     * Converts a HTTP status code into a {@link SpanStatusType}.
     *
     * @param httpStatus The HTTP response status code.
     * @returns The span status or unknown_error.
     */
    function spanStatusfromHttpCode(httpStatus) {
      if (httpStatus < 400 && httpStatus >= 100) {
        return 'ok';
      }
      if (httpStatus >= 400 && httpStatus < 500) {
        switch (httpStatus) {
          case 401:
            return 'unauthenticated';
          case 403:
            return 'permission_denied';
          case 404:
            return 'not_found';
          case 409:
            return 'already_exists';
          case 413:
            return 'failed_precondition';
          case 429:
            return 'resource_exhausted';
          default:
            return 'invalid_argument';
        }
      }
      if (httpStatus >= 500 && httpStatus < 600) {
        switch (httpStatus) {
          case 501:
            return 'unimplemented';
          case 503:
            return 'unavailable';
          case 504:
            return 'deadline_exceeded';
          default:
            return 'internal_error';
        }
      }
      return 'unknown_error';
    }
    exports.spanStatusfromHttpCode = spanStatusfromHttpCode;

  }, { "@sentry/utils": 95, "tslib": 181 }], 80: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    /** The status of an Span.
     *
     * @deprecated Use string literals - if you require type casting, cast to SpanStatusType type
     */
    // eslint-disable-next-line import/export
    var SpanStatus;
    (function (SpanStatus) {
      /** The operation completed successfully. */
      SpanStatus["Ok"] = "ok";
      /** Deadline expired before operation could complete. */
      SpanStatus["DeadlineExceeded"] = "deadline_exceeded";
      /** 401 Unauthorized (actually does mean unauthenticated according to RFC 7235) */
      SpanStatus["Unauthenticated"] = "unauthenticated";
      /** 403 Forbidden */
      SpanStatus["PermissionDenied"] = "permission_denied";
      /** 404 Not Found. Some requested entity (file or directory) was not found. */
      SpanStatus["NotFound"] = "not_found";
      /** 429 Too Many Requests */
      SpanStatus["ResourceExhausted"] = "resource_exhausted";
      /** Client specified an invalid argument. 4xx. */
      SpanStatus["InvalidArgument"] = "invalid_argument";
      /** 501 Not Implemented */
      SpanStatus["Unimplemented"] = "unimplemented";
      /** 503 Service Unavailable */
      SpanStatus["Unavailable"] = "unavailable";
      /** Other/generic 5xx. */
      SpanStatus["InternalError"] = "internal_error";
      /** Unknown. Any non-standard HTTP status code. */
      SpanStatus["UnknownError"] = "unknown_error";
      /** The operation was cancelled (typically by the user). */
      SpanStatus["Cancelled"] = "cancelled";
      /** Already exists (409) */
      SpanStatus["AlreadyExists"] = "already_exists";
      /** Operation was rejected because the system is not in a state required for the operation's */
      SpanStatus["FailedPrecondition"] = "failed_precondition";
      /** The operation was aborted, typically due to a concurrency issue. */
      SpanStatus["Aborted"] = "aborted";
      /** Operation was attempted past the valid range. */
      SpanStatus["OutOfRange"] = "out_of_range";
      /** Unrecoverable data loss or corruption */
      SpanStatus["DataLoss"] = "data_loss";
    })(SpanStatus = exports.SpanStatus || (exports.SpanStatus = {}));

  }, {}], 81: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var hub_1 = require("@sentry/hub");
    var utils_1 = require("@sentry/utils");
    var flags_1 = require("./flags");
    var span_1 = require("./span");
    /** JSDoc */
    var Transaction = /** @class */ (function (_super) {
      tslib_1.__extends(Transaction, _super);
      /**
       * This constructor should never be called manually. Those instrumenting tracing should use
       * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.
       * @internal
       * @hideconstructor
       * @hidden
       */
      function Transaction(transactionContext, hub) {
        var _this = _super.call(this, transactionContext) || this;
        _this._measurements = {};
        /**
         * The reference to the current hub.
         */
        _this._hub = hub_1.getCurrentHub();
        if (utils_1.isInstanceOf(hub, hub_1.Hub)) {
          _this._hub = hub;
        }
        _this.name = transactionContext.name || '';
        _this.metadata = transactionContext.metadata || {};
        _this._trimEnd = transactionContext.trimEnd;
        // this is because transactions are also spans, and spans have a transaction pointer
        _this.transaction = _this;
        return _this;
      }
      /**
       * JSDoc
       */
      Transaction.prototype.setName = function (name) {
        this.name = name;
      };
      /**
       * Attaches SpanRecorder to the span itself
       * @param maxlen maximum number of spans that can be recorded
       */
      Transaction.prototype.initSpanRecorder = function (maxlen) {
        if (maxlen === void 0) { maxlen = 1000; }
        if (!this.spanRecorder) {
          this.spanRecorder = new span_1.SpanRecorder(maxlen);
        }
        this.spanRecorder.add(this);
      };
      /**
       * Set observed measurements for this transaction.
       * @hidden
       */
      Transaction.prototype.setMeasurements = function (measurements) {
        this._measurements = tslib_1.__assign({}, measurements);
      };
      /**
       * Set metadata for this transaction.
       * @hidden
       */
      Transaction.prototype.setMetadata = function (newMetadata) {
        this.metadata = tslib_1.__assign(tslib_1.__assign({}, this.metadata), newMetadata);
      };
      /**
       * @inheritDoc
       */
      Transaction.prototype.finish = function (endTimestamp) {
        var _this = this;
        // This transaction is already finished, so we should not flush it again.
        if (this.endTimestamp !== undefined) {
          return undefined;
        }
        if (!this.name) {
          flags_1.IS_DEBUG_BUILD && utils_1.logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');
          this.name = '<unlabeled transaction>';
        }
        // just sets the end timestamp
        _super.prototype.finish.call(this, endTimestamp);
        if (this.sampled !== true) {
          // At this point if `sampled !== true` we want to discard the transaction.
          flags_1.IS_DEBUG_BUILD && utils_1.logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');
          var client = this._hub.getClient();
          var transport = client && client.getTransport && client.getTransport();
          if (transport && transport.recordLostEvent) {
            transport.recordLostEvent('sample_rate', 'transaction');
          }
          return undefined;
        }
        var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(function (s) { return s !== _this && s.endTimestamp; }) : [];
        if (this._trimEnd && finishedSpans.length > 0) {
          this.endTimestamp = finishedSpans.reduce(function (prev, current) {
            if (prev.endTimestamp && current.endTimestamp) {
              return prev.endTimestamp > current.endTimestamp ? prev : current;
            }
            return prev;
          }).endTimestamp;
        }
        var transaction = {
          contexts: {
            trace: this.getTraceContext(),
          },
          spans: finishedSpans,
          start_timestamp: this.startTimestamp,
          tags: this.tags,
          timestamp: this.endTimestamp,
          transaction: this.name,
          type: 'transaction',
          sdkProcessingMetadata: this.metadata,
        };
        var hasMeasurements = Object.keys(this._measurements).length > 0;
        if (hasMeasurements) {
          flags_1.IS_DEBUG_BUILD &&
            utils_1.logger.log('[Measurements] Adding measurements to transaction', JSON.stringify(this._measurements, undefined, 2));
          transaction.measurements = this._measurements;
        }
        flags_1.IS_DEBUG_BUILD && utils_1.logger.log("[Tracing] Finishing " + this.op + " transaction: " + this.name + ".");
        return this._hub.captureEvent(transaction);
      };
      /**
       * @inheritDoc
       */
      Transaction.prototype.toContext = function () {
        var spanContext = _super.prototype.toContext.call(this);
        return utils_1.dropUndefinedKeys(tslib_1.__assign(tslib_1.__assign({}, spanContext), { name: this.name, trimEnd: this._trimEnd }));
      };
      /**
       * @inheritDoc
       */
      Transaction.prototype.updateWithContext = function (transactionContext) {
        var _a;
        _super.prototype.updateWithContext.call(this, transactionContext);
        this.name = (_a = transactionContext.name, (_a !== null && _a !== void 0 ? _a : ''));
        this._trimEnd = transactionContext.trimEnd;
        return this;
      };
      return Transaction;
    }(span_1.Span));
    exports.Transaction = Transaction;

  }, { "./flags": 70, "./span": 79, "@sentry/hub": 48, "@sentry/utils": 95, "tslib": 181 }], 82: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var hub_1 = require("@sentry/hub");
    /**
     * The `extractTraceparentData` function and `TRACEPARENT_REGEXP` constant used
     * to be declared in this file. It was later moved into `@sentry/utils` as part of a
     * move to remove `@sentry/tracing` dependencies from `@sentry/node` (`extractTraceparentData`
     * is the only tracing function used by `@sentry/node`).
     *
     * These exports are kept here for backwards compatability's sake.
     *
     * TODO(v7): Reorganize these exports
     *
     * See https://github.com/getsentry/sentry-javascript/issues/4642 for more details.
     */
    var utils_1 = require("@sentry/utils");
    exports.TRACEPARENT_REGEXP = utils_1.TRACEPARENT_REGEXP;
    exports.extractTraceparentData = utils_1.extractTraceparentData;
    /**
     * Determines if tracing is currently enabled.
     *
     * Tracing is enabled when at least one of `tracesSampleRate` and `tracesSampler` is defined in the SDK config.
     */
    function hasTracingEnabled(maybeOptions) {
      var client = hub_1.getCurrentHub().getClient();
      var options = maybeOptions || (client && client.getOptions());
      return !!options && ('tracesSampleRate' in options || 'tracesSampler' in options);
    }
    exports.hasTracingEnabled = hasTracingEnabled;
    /** Grabs active transaction off scope, if any */
    function getActiveTransaction(maybeHub) {
      var hub = maybeHub || hub_1.getCurrentHub();
      var scope = hub.getScope();
      return scope && scope.getTransaction();
    }
    exports.getActiveTransaction = getActiveTransaction;
    /**
     * Converts from milliseconds to seconds
     * @param time time in ms
     */
    function msToSec(time) {
      return time / 1000;
    }
    exports.msToSec = msToSec;
    /**
     * Converts from seconds to milliseconds
     * @param time time in seconds
     */
    function secToMs(time) {
      return time * 1000;
    }
    exports.secToMs = secToMs;
    // so it can be used in manual instrumentation without necessitating a hard dependency on @sentry/utils
    var utils_2 = require("@sentry/utils");
    exports.stripUrlQueryAndFragment = utils_2.stripUrlQueryAndFragment;

  }, { "@sentry/hub": 48, "@sentry/utils": 95 }], 83: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var severity_1 = require("./severity");
    exports.Severity = severity_1.Severity;
    var severity_2 = require("./severity");
    exports.SeverityLevels = severity_2.SeverityLevels;

  }, { "./severity": 84 }], 84: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * TODO(v7): Remove this enum and replace with SeverityLevel
     */
    var Severity;
    (function (Severity) {
      /** JSDoc */
      Severity["Fatal"] = "fatal";
      /** JSDoc */
      Severity["Error"] = "error";
      /** JSDoc */
      Severity["Warning"] = "warning";
      /** JSDoc */
      Severity["Log"] = "log";
      /** JSDoc */
      Severity["Info"] = "info";
      /** JSDoc */
      Severity["Debug"] = "debug";
      /** JSDoc */
      Severity["Critical"] = "critical";
    })(Severity = exports.Severity || (exports.Severity = {}));
    // TODO: in v7, these can disappear, because they now also exist in `@sentry/utils`. (Having them there rather than here
    // is nice because then it enforces the idea that only types are exported from `@sentry/types`.)
    exports.SeverityLevels = ['fatal', 'error', 'warning', 'log', 'info', 'debug', 'critical'];

  }, {}], 85: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Consumes the promise and logs the error when it rejects.
     * @param promise A promise to forget.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function forget(promise) {
      void promise.then(null, function (e) {
        // TODO: Use a better logging mechanism
        // eslint-disable-next-line no-console
        console.error(e);
      });
    }
    exports.forget = forget;

  }, {}], 86: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var global_1 = require("./global");
    var is_1 = require("./is");
    /**
     * Given a child DOM element, returns a query-selector statement describing that
     * and its ancestors
     * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
     * @returns generated DOM path
     */
    function htmlTreeAsString(elem, keyAttrs) {
      // try/catch both:
      // - accessing event.target (see getsentry/raven-js#838, #768)
      // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
      // - can throw an exception in some circumstances.
      try {
        var currentElem = elem;
        var MAX_TRAVERSE_HEIGHT = 5;
        var MAX_OUTPUT_LEN = 80;
        var out = [];
        var height = 0;
        var len = 0;
        var separator = ' > ';
        var sepLength = separator.length;
        var nextStr = void 0;
        // eslint-disable-next-line no-plusplus
        while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
          nextStr = _htmlElementAsString(currentElem, keyAttrs);
          // bail out if
          // - nextStr is the 'html' element
          // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
          //   (ignore this limit if we are on the first iteration)
          if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {
            break;
          }
          out.push(nextStr);
          len += nextStr.length;
          currentElem = currentElem.parentNode;
        }
        return out.reverse().join(separator);
      }
      catch (_oO) {
        return '<unknown>';
      }
    }
    exports.htmlTreeAsString = htmlTreeAsString;
    /**
     * Returns a simple, query-selector representation of a DOM element
     * e.g. [HTMLElement] => input#foo.btn[name=baz]
     * @returns generated DOM path
     */
    function _htmlElementAsString(el, keyAttrs) {
      var elem = el;
      var out = [];
      var className;
      var classes;
      var key;
      var attr;
      var i;
      if (!elem || !elem.tagName) {
        return '';
      }
      out.push(elem.tagName.toLowerCase());
      // Pairs of attribute keys defined in `serializeAttribute` and their values on element.
      var keyAttrPairs = keyAttrs && keyAttrs.length
        ? keyAttrs.filter(function (keyAttr) { return elem.getAttribute(keyAttr); }).map(function (keyAttr) { return [keyAttr, elem.getAttribute(keyAttr)]; })
        : null;
      if (keyAttrPairs && keyAttrPairs.length) {
        keyAttrPairs.forEach(function (keyAttrPair) {
          out.push("[" + keyAttrPair[0] + "=\"" + keyAttrPair[1] + "\"]");
        });
      }
      else {
        if (elem.id) {
          out.push("#" + elem.id);
        }
        // eslint-disable-next-line prefer-const
        className = elem.className;
        if (className && is_1.isString(className)) {
          classes = className.split(/\s+/);
          for (i = 0; i < classes.length; i++) {
            out.push("." + classes[i]);
          }
        }
      }
      var allowedAttrs = ['type', 'name', 'title', 'alt'];
      for (i = 0; i < allowedAttrs.length; i++) {
        key = allowedAttrs[i];
        attr = elem.getAttribute(key);
        if (attr) {
          out.push("[" + key + "=\"" + attr + "\"]");
        }
      }
      return out.join('');
    }
    /**
     * A safe form of location.href
     */
    function getLocationHref() {
      var global = global_1.getGlobalObject();
      try {
        return global.document.location.href;
      }
      catch (oO) {
        return '';
      }
    }
    exports.getLocationHref = getLocationHref;

  }, { "./global": 94, "./is": 97 }], 87: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var envelope_1 = require("./envelope");
    var time_1 = require("./time");
    /**
     * Creates client report envelope
     * @param discarded_events An array of discard events
     * @param dsn A DSN that can be set on the header. Optional.
     */
    function createClientReportEnvelope(discarded_events, dsn, timestamp) {
      var clientReportItem = [
        { type: 'client_report' },
        {
          timestamp: timestamp || time_1.dateTimestampInSeconds(),
          discarded_events: discarded_events,
        },
      ];
      return envelope_1.createEnvelope(dsn ? { dsn: dsn } : {}, [clientReportItem]);
    }
    exports.createClientReportEnvelope = createClientReportEnvelope;

  }, { "./envelope": 91, "./time": 114 }], 88: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var error_1 = require("./error");
    var flags_1 = require("./flags");
    /** Regular expression used to parse a Dsn. */
    var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+))?@)([\w.-]+)(?::(\d+))?\/(.+)/;
    function isValidProtocol(protocol) {
      return protocol === 'http' || protocol === 'https';
    }
    /**
     * Renders the string representation of this Dsn.
     *
     * By default, this will render the public representation without the password
     * component. To get the deprecated private representation, set `withPassword`
     * to true.
     *
     * @param withPassword When set to true, the password will be included.
     */
    function dsnToString(dsn, withPassword) {
      if (withPassword === void 0) { withPassword = false; }
      var host = dsn.host, path = dsn.path, pass = dsn.pass, port = dsn.port, projectId = dsn.projectId, protocol = dsn.protocol, publicKey = dsn.publicKey;
      return (protocol + "://" + publicKey + (withPassword && pass ? ":" + pass : '') +
        ("@" + host + (port ? ":" + port : '') + "/" + (path ? path + "/" : path) + projectId));
    }
    exports.dsnToString = dsnToString;
    function dsnFromString(str) {
      var match = DSN_REGEX.exec(str);
      if (!match) {
        throw new error_1.SentryError("Invalid Sentry Dsn: " + str);
      }
      var _a = tslib_1.__read(match.slice(1), 6), protocol = _a[0], publicKey = _a[1], _b = _a[2], pass = _b === void 0 ? '' : _b, host = _a[3], _c = _a[4], port = _c === void 0 ? '' : _c, lastPath = _a[5];
      var path = '';
      var projectId = lastPath;
      var split = projectId.split('/');
      if (split.length > 1) {
        path = split.slice(0, -1).join('/');
        projectId = split.pop();
      }
      if (projectId) {
        var projectMatch = projectId.match(/^\d+/);
        if (projectMatch) {
          projectId = projectMatch[0];
        }
      }
      return dsnFromComponents({ host: host, pass: pass, path: path, projectId: projectId, port: port, protocol: protocol, publicKey: publicKey });
    }
    function dsnFromComponents(components) {
      // TODO this is for backwards compatibility, and can be removed in a future version
      if ('user' in components && !('publicKey' in components)) {
        components.publicKey = components.user;
      }
      return {
        user: components.publicKey || '',
        protocol: components.protocol,
        publicKey: components.publicKey || '',
        pass: components.pass || '',
        host: components.host,
        port: components.port || '',
        path: components.path || '',
        projectId: components.projectId,
      };
    }
    function validateDsn(dsn) {
      if (!flags_1.IS_DEBUG_BUILD) {
        return;
      }
      var port = dsn.port, projectId = dsn.projectId, protocol = dsn.protocol;
      var requiredComponents = ['protocol', 'publicKey', 'host', 'projectId'];
      requiredComponents.forEach(function (component) {
        if (!dsn[component]) {
          throw new error_1.SentryError("Invalid Sentry Dsn: " + component + " missing");
        }
      });
      if (!projectId.match(/^\d+$/)) {
        throw new error_1.SentryError("Invalid Sentry Dsn: Invalid projectId " + projectId);
      }
      if (!isValidProtocol(protocol)) {
        throw new error_1.SentryError("Invalid Sentry Dsn: Invalid protocol " + protocol);
      }
      if (port && isNaN(parseInt(port, 10))) {
        throw new error_1.SentryError("Invalid Sentry Dsn: Invalid port " + port);
      }
      return true;
    }
    /** The Sentry Dsn, identifying a Sentry instance and project. */
    function makeDsn(from) {
      var components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);
      validateDsn(components);
      return components;
    }
    exports.makeDsn = makeDsn;

  }, { "./error": 92, "./flags": 93, "tslib": 181 }], 89: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SeverityLevels = ['fatal', 'error', 'warning', 'log', 'info', 'debug', 'critical'];

  }, {}], 90: [function (require, module, exports) {
    /*
     * This module exists for optimizations in the build process through rollup and terser.  We define some global
     * constants, which can be overridden during build. By guarding certain pieces of code with functions that return these
     * constants, we can control whether or not they appear in the final bundle. (Any code guarded by a false condition will
     * never run, and will hence be dropped during treeshaking.) The two primary uses for this are stripping out calls to
     * `logger` and preventing node-related code from appearing in browser bundles.
     *
     * Attention:
     * This file should not be used to define constants/flags that are intended to be used for tree-shaking conducted by
     * users. These fags should live in their respective packages, as we identified user tooling (specifically webpack)
     * having issues tree-shaking these constants across package boundaries.
     * An example for this is the __SENTRY_DEBUG__ constant. It is declared in each package individually because we want
     * users to be able to shake away expressions that it guards.
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Figures out if we're building a browser bundle.
     *
     * @returns true if this is a browser bundle build.
     */
    function isBrowserBundle() {
      return typeof __SENTRY_BROWSER_BUNDLE__ !== 'undefined' && !!__SENTRY_BROWSER_BUNDLE__;
    }
    exports.isBrowserBundle = isBrowserBundle;

  }, {}], 91: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var is_1 = require("./is");
    /**
     * Creates an envelope.
     * Make sure to always explicitly provide the generic to this function
     * so that the envelope types resolve correctly.
     */
    function createEnvelope(headers, items) {
      if (items === void 0) { items = []; }
      return [headers, items];
    }
    exports.createEnvelope = createEnvelope;
    /**
     * Add an item to an envelope.
     * Make sure to always explicitly provide the generic to this function
     * so that the envelope types resolve correctly.
     */
    function addItemToEnvelope(envelope, newItem) {
      var _a = tslib_1.__read(envelope, 2), headers = _a[0], items = _a[1];
      return [headers, tslib_1.__spread(items, [newItem])];
    }
    exports.addItemToEnvelope = addItemToEnvelope;
    /**
     * Get the type of the envelope. Grabs the type from the first envelope item.
     */
    function getEnvelopeType(envelope) {
      var _a = tslib_1.__read(envelope, 2), _b = tslib_1.__read(_a[1], 1), _c = tslib_1.__read(_b[0], 1), firstItemHeader = _c[0];
      return firstItemHeader.type;
    }
    exports.getEnvelopeType = getEnvelopeType;
    /**
     * Serializes an envelope into a string.
     */
    function serializeEnvelope(envelope) {
      var _a = tslib_1.__read(envelope, 2), headers = _a[0], items = _a[1];
      var serializedHeaders = JSON.stringify(headers);
      // Have to cast items to any here since Envelope is a union type
      // Fixed in Typescript 4.2
      // TODO: Remove any[] cast when we upgrade to TS 4.2
      // https://github.com/microsoft/TypeScript/issues/36390
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return items.reduce(function (acc, item) {
        var _a = tslib_1.__read(item, 2), itemHeaders = _a[0], payload = _a[1];
        // We do not serialize payloads that are primitives
        var serializedPayload = is_1.isPrimitive(payload) ? String(payload) : JSON.stringify(payload);
        return acc + "\n" + JSON.stringify(itemHeaders) + "\n" + serializedPayload;
      }, serializedHeaders);
    }
    exports.serializeEnvelope = serializeEnvelope;

  }, { "./is": 97, "tslib": 181 }], 92: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var polyfill_1 = require("./polyfill");
    /** An error emitted by Sentry SDKs and related utilities. */
    var SentryError = /** @class */ (function (_super) {
      tslib_1.__extends(SentryError, _super);
      function SentryError(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = _newTarget.prototype.constructor.name;
        polyfill_1.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
      }
      return SentryError;
    }(Error));
    exports.SentryError = SentryError;

  }, { "./polyfill": 105, "tslib": 181 }], 93: [function (require, module, exports) {
    arguments[4][12][0].apply(exports, arguments)
  }, { "dup": 12 }], 94: [function (require, module, exports) {
    (function (global) {
      (function () {
        /**
         * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
         * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
         */
        Object.defineProperty(exports, "__esModule", { value: true });
        var node_1 = require("./node");
        var fallbackGlobalObject = {};
        /**
         * Safely get global scope object
         *
         * @returns Global scope object
         */
        function getGlobalObject() {
          return (node_1.isNodeEnv()
            ? global
            : typeof window !== 'undefined' // eslint-disable-line no-restricted-globals
              ? window // eslint-disable-line no-restricted-globals
              : typeof self !== 'undefined'
                ? self
                : fallbackGlobalObject);
        }
        exports.getGlobalObject = getGlobalObject;
        /**
         * Returns a global singleton contained in the global `__SENTRY__` object.
         *
         * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory
         * function and added to the `__SENTRY__` object.
         *
         * @param name name of the global singleton on __SENTRY__
         * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`
         * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `getGlobalObject`'s return value
         * @returns the singleton
         */
        function getGlobalSingleton(name, creator, obj) {
          var global = (obj || getGlobalObject());
          var __SENTRY__ = (global.__SENTRY__ = global.__SENTRY__ || {});
          var singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
          return singleton;
        }
        exports.getGlobalSingleton = getGlobalSingleton;

      }).call(this)
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  }, { "./node": 101 }], 95: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    tslib_1.__exportStar(require("./async"), exports);
    tslib_1.__exportStar(require("./browser"), exports);
    tslib_1.__exportStar(require("./dsn"), exports);
    tslib_1.__exportStar(require("./enums"), exports);
    tslib_1.__exportStar(require("./error"), exports);
    tslib_1.__exportStar(require("./global"), exports);
    tslib_1.__exportStar(require("./instrument"), exports);
    tslib_1.__exportStar(require("./is"), exports);
    tslib_1.__exportStar(require("./logger"), exports);
    tslib_1.__exportStar(require("./memo"), exports);
    tslib_1.__exportStar(require("./misc"), exports);
    tslib_1.__exportStar(require("./node"), exports);
    tslib_1.__exportStar(require("./normalize"), exports);
    tslib_1.__exportStar(require("./object"), exports);
    tslib_1.__exportStar(require("./path"), exports);
    tslib_1.__exportStar(require("./promisebuffer"), exports);
    tslib_1.__exportStar(require("./severity"), exports);
    tslib_1.__exportStar(require("./stacktrace"), exports);
    tslib_1.__exportStar(require("./status"), exports);
    tslib_1.__exportStar(require("./string"), exports);
    tslib_1.__exportStar(require("./supports"), exports);
    tslib_1.__exportStar(require("./syncpromise"), exports);
    tslib_1.__exportStar(require("./time"), exports);
    tslib_1.__exportStar(require("./tracing"), exports);
    tslib_1.__exportStar(require("./env"), exports);
    tslib_1.__exportStar(require("./envelope"), exports);
    tslib_1.__exportStar(require("./clientreport"), exports);
    tslib_1.__exportStar(require("./ratelimit"), exports);

  }, { "./async": 85, "./browser": 86, "./clientreport": 87, "./dsn": 88, "./enums": 89, "./env": 90, "./envelope": 91, "./error": 92, "./global": 94, "./instrument": 96, "./is": 97, "./logger": 98, "./memo": 99, "./misc": 100, "./node": 101, "./normalize": 102, "./object": 103, "./path": 104, "./promisebuffer": 106, "./ratelimit": 107, "./severity": 108, "./stacktrace": 109, "./status": 110, "./string": 111, "./supports": 112, "./syncpromise": 113, "./time": 114, "./tracing": 115, "tslib": 181 }], 96: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var flags_1 = require("./flags");
    var global_1 = require("./global");
    var is_1 = require("./is");
    var logger_1 = require("./logger");
    var object_1 = require("./object");
    var stacktrace_1 = require("./stacktrace");
    var supports_1 = require("./supports");
    var global = global_1.getGlobalObject();
    /**
     * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.
     *  - Console API
     *  - Fetch API
     *  - XHR API
     *  - History API
     *  - DOM API (click/typing)
     *  - Error API
     *  - UnhandledRejection API
     */
    var handlers = {};
    var instrumented = {};
    /** Instruments given API */
    function instrument(type) {
      if (instrumented[type]) {
        return;
      }
      instrumented[type] = true;
      switch (type) {
        case 'console':
          instrumentConsole();
          break;
        case 'dom':
          instrumentDOM();
          break;
        case 'xhr':
          instrumentXHR();
          break;
        case 'fetch':
          instrumentFetch();
          break;
        case 'history':
          instrumentHistory();
          break;
        case 'error':
          instrumentError();
          break;
        case 'unhandledrejection':
          instrumentUnhandledRejection();
          break;
        default:
          flags_1.IS_DEBUG_BUILD && logger_1.logger.warn('unknown instrumentation type:', type);
          return;
      }
    }
    /**
     * Add handler that will be called when given type of instrumentation triggers.
     * Use at your own risk, this might break without changelog notice, only used internally.
     * @hidden
     */
    function addInstrumentationHandler(type, callback) {
      handlers[type] = handlers[type] || [];
      handlers[type].push(callback);
      instrument(type);
    }
    exports.addInstrumentationHandler = addInstrumentationHandler;
    /** JSDoc */
    function triggerHandlers(type, data) {
      var e_1, _a;
      if (!type || !handlers[type]) {
        return;
      }
      try {
        for (var _b = tslib_1.__values(handlers[type] || []), _c = _b.next(); !_c.done; _c = _b.next()) {
          var handler = _c.value;
          try {
            handler(data);
          }
          catch (e) {
            flags_1.IS_DEBUG_BUILD &&
              logger_1.logger.error("Error while triggering instrumentation handler.\nType: " + type + "\nName: " + stacktrace_1.getFunctionName(handler) + "\nError:", e);
          }
        }
      }
      catch (e_1_1) { e_1 = { error: e_1_1 }; }
      finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
      }
    }
    /** JSDoc */
    function instrumentConsole() {
      if (!('console' in global)) {
        return;
      }
      logger_1.CONSOLE_LEVELS.forEach(function (level) {
        if (!(level in global.console)) {
          return;
        }
        object_1.fill(global.console, level, function (originalConsoleMethod) {
          return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            triggerHandlers('console', { args: args, level: level });
            // this fails for some browsers. :(
            if (originalConsoleMethod) {
              originalConsoleMethod.apply(global.console, args);
            }
          };
        });
      });
    }
    /** JSDoc */
    function instrumentFetch() {
      if (!supports_1.supportsNativeFetch()) {
        return;
      }
      object_1.fill(global, 'fetch', function (originalFetch) {
        return function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var handlerData = {
            args: args,
            fetchData: {
              method: getFetchMethod(args),
              url: getFetchUrl(args),
            },
            startTimestamp: Date.now(),
          };
          triggerHandlers('fetch', tslib_1.__assign({}, handlerData));
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          return originalFetch.apply(global, args).then(function (response) {
            triggerHandlers('fetch', tslib_1.__assign(tslib_1.__assign({}, handlerData), { endTimestamp: Date.now(), response: response }));
            return response;
          }, function (error) {
            triggerHandlers('fetch', tslib_1.__assign(tslib_1.__assign({}, handlerData), { endTimestamp: Date.now(), error: error }));
            // NOTE: If you are a Sentry user, and you are seeing this stack frame,
            //       it means the sentry.javascript SDK caught an error invoking your application code.
            //       This is expected behavior and NOT indicative of a bug with sentry.javascript.
            throw error;
          });
        };
      });
    }
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    /** Extract `method` from fetch call arguments */
    function getFetchMethod(fetchArgs) {
      if (fetchArgs === void 0) { fetchArgs = []; }
      if ('Request' in global && is_1.isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {
        return String(fetchArgs[0].method).toUpperCase();
      }
      if (fetchArgs[1] && fetchArgs[1].method) {
        return String(fetchArgs[1].method).toUpperCase();
      }
      return 'GET';
    }
    /** Extract `url` from fetch call arguments */
    function getFetchUrl(fetchArgs) {
      if (fetchArgs === void 0) { fetchArgs = []; }
      if (typeof fetchArgs[0] === 'string') {
        return fetchArgs[0];
      }
      if ('Request' in global && is_1.isInstanceOf(fetchArgs[0], Request)) {
        return fetchArgs[0].url;
      }
      return String(fetchArgs[0]);
    }
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
    /** JSDoc */
    function instrumentXHR() {
      if (!('XMLHttpRequest' in global)) {
        return;
      }
      var xhrproto = XMLHttpRequest.prototype;
      object_1.fill(xhrproto, 'open', function (originalOpen) {
        return function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          // eslint-disable-next-line @typescript-eslint/no-this-alias
          var xhr = this;
          var url = args[1];
          var xhrInfo = (xhr.__sentry_xhr__ = {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            method: is_1.isString(args[0]) ? args[0].toUpperCase() : args[0],
            url: args[1],
          });
          // if Sentry key appears in URL, don't capture it as a request
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          if (is_1.isString(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {
            xhr.__sentry_own_request__ = true;
          }
          var onreadystatechangeHandler = function () {
            if (xhr.readyState === 4) {
              try {
                // touching statusCode in some platforms throws
                // an exception
                xhrInfo.status_code = xhr.status;
              }
              catch (e) {
                /* do nothing */
              }
              triggerHandlers('xhr', {
                args: args,
                endTimestamp: Date.now(),
                startTimestamp: Date.now(),
                xhr: xhr,
              });
            }
          };
          if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {
            object_1.fill(xhr, 'onreadystatechange', function (original) {
              return function () {
                var readyStateArgs = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  readyStateArgs[_i] = arguments[_i];
                }
                onreadystatechangeHandler();
                return original.apply(xhr, readyStateArgs);
              };
            });
          }
          else {
            xhr.addEventListener('readystatechange', onreadystatechangeHandler);
          }
          return originalOpen.apply(xhr, args);
        };
      });
      object_1.fill(xhrproto, 'send', function (originalSend) {
        return function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (this.__sentry_xhr__ && args[0] !== undefined) {
            this.__sentry_xhr__.body = args[0];
          }
          triggerHandlers('xhr', {
            args: args,
            startTimestamp: Date.now(),
            xhr: this,
          });
          return originalSend.apply(this, args);
        };
      });
    }
    var lastHref;
    /** JSDoc */
    function instrumentHistory() {
      if (!supports_1.supportsHistory()) {
        return;
      }
      var oldOnPopState = global.onpopstate;
      global.onpopstate = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var to = global.location.href;
        // keep track of the current URL state, as we always receive only the updated state
        var from = lastHref;
        lastHref = to;
        triggerHandlers('history', {
          from: from,
          to: to,
        });
        if (oldOnPopState) {
          // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.
          // https://github.com/getsentry/sentry-javascript/issues/3344
          // https://github.com/bugsnag/bugsnag-js/issues/469
          try {
            return oldOnPopState.apply(this, args);
          }
          catch (_oO) {
            // no-empty
          }
        }
      };
      /** @hidden */
      function historyReplacementFunction(originalHistoryFunction) {
        return function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var url = args.length > 2 ? args[2] : undefined;
          if (url) {
            // coerce to string (this is what pushState does)
            var from = lastHref;
            var to = String(url);
            // keep track of the current URL state, as we always receive only the updated state
            lastHref = to;
            triggerHandlers('history', {
              from: from,
              to: to,
            });
          }
          return originalHistoryFunction.apply(this, args);
        };
      }
      object_1.fill(global.history, 'pushState', historyReplacementFunction);
      object_1.fill(global.history, 'replaceState', historyReplacementFunction);
    }
    var debounceDuration = 1000;
    var debounceTimerID;
    var lastCapturedEvent;
    /**
     * Decide whether the current event should finish the debounce of previously captured one.
     * @param previous previously captured event
     * @param current event to be captured
     */
    function shouldShortcircuitPreviousDebounce(previous, current) {
      // If there was no previous event, it should always be swapped for the new one.
      if (!previous) {
        return true;
      }
      // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.
      if (previous.type !== current.type) {
        return true;
      }
      try {
        // If both events have the same type, it's still possible that actions were performed on different targets.
        // e.g. 2 clicks on different buttons.
        if (previous.target !== current.target) {
          return true;
        }
      }
      catch (e) {
        // just accessing `target` property can throw an exception in some rare circumstances
        // see: https://github.com/getsentry/sentry-javascript/issues/838
      }
      // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_
      // to which an event listener was attached), we treat them as the same action, as we want to capture
      // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.
      return false;
    }
    /**
     * Decide whether an event should be captured.
     * @param event event to be captured
     */
    function shouldSkipDOMEvent(event) {
      // We are only interested in filtering `keypress` events for now.
      if (event.type !== 'keypress') {
        return false;
      }
      try {
        var target = event.target;
        if (!target || !target.tagName) {
          return true;
        }
        // Only consider keypress events on actual input elements. This will disregard keypresses targeting body
        // e.g.tabbing through elements, hotkeys, etc.
        if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
          return false;
        }
      }
      catch (e) {
        // just accessing `target` property can throw an exception in some rare circumstances
        // see: https://github.com/getsentry/sentry-javascript/issues/838
      }
      return true;
    }
    /**
     * Wraps addEventListener to capture UI breadcrumbs
     * @param handler function that will be triggered
     * @param globalListener indicates whether event was captured by the global event listener
     * @returns wrapped breadcrumb events handler
     * @hidden
     */
    function makeDOMEventHandler(handler, globalListener) {
      if (globalListener === void 0) { globalListener = false; }
      return function (event) {
        // It's possible this handler might trigger multiple times for the same
        // event (e.g. event propagation through node ancestors).
        // Ignore if we've already captured that event.
        if (!event || lastCapturedEvent === event) {
          return;
        }
        // We always want to skip _some_ events.
        if (shouldSkipDOMEvent(event)) {
          return;
        }
        var name = event.type === 'keypress' ? 'input' : event.type;
        // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.
        if (debounceTimerID === undefined) {
          handler({
            event: event,
            name: name,
            global: globalListener,
          });
          lastCapturedEvent = event;
        }
        // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.
        // If that's the case, emit the previous event and store locally the newly-captured DOM event.
        else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {
          handler({
            event: event,
            name: name,
            global: globalListener,
          });
          lastCapturedEvent = event;
        }
        // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.
        clearTimeout(debounceTimerID);
        debounceTimerID = global.setTimeout(function () {
          debounceTimerID = undefined;
        }, debounceDuration);
      };
    }
    /** JSDoc */
    function instrumentDOM() {
      if (!('document' in global)) {
        return;
      }
      // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom
      // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before
      // we instrument `addEventListener` so that we don't end up attaching this handler twice.
      var triggerDOMHandler = triggerHandlers.bind(null, 'dom');
      var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
      global.document.addEventListener('click', globalDOMEventHandler, false);
      global.document.addEventListener('keypress', globalDOMEventHandler, false);
      // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled
      // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That
      // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler
      // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still
      // guaranteed to fire at least once.)
      ['EventTarget', 'Node'].forEach(function (target) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        var proto = global[target] && global[target].prototype;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins
        if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {
          return;
        }
        object_1.fill(proto, 'addEventListener', function (originalAddEventListener) {
          return function (type, listener, options) {
            if (type === 'click' || type == 'keypress') {
              try {
                var el = this;
                var handlers_1 = (el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {});
                var handlerForType = (handlers_1[type] = handlers_1[type] || { refCount: 0 });
                if (!handlerForType.handler) {
                  var handler = makeDOMEventHandler(triggerDOMHandler);
                  handlerForType.handler = handler;
                  originalAddEventListener.call(this, type, handler, options);
                }
                handlerForType.refCount += 1;
              }
              catch (e) {
                // Accessing dom properties is always fragile.
                // Also allows us to skip `addEventListenrs` calls with no proper `this` context.
              }
            }
            return originalAddEventListener.call(this, type, listener, options);
          };
        });
        object_1.fill(proto, 'removeEventListener', function (originalRemoveEventListener) {
          return function (type, listener, options) {
            if (type === 'click' || type == 'keypress') {
              try {
                var el = this;
                var handlers_2 = el.__sentry_instrumentation_handlers__ || {};
                var handlerForType = handlers_2[type];
                if (handlerForType) {
                  handlerForType.refCount -= 1;
                  // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.
                  if (handlerForType.refCount <= 0) {
                    originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                    handlerForType.handler = undefined;
                    delete handlers_2[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete
                  }
                  // If there are no longer any custom handlers of any type on this element, cleanup everything.
                  if (Object.keys(handlers_2).length === 0) {
                    delete el.__sentry_instrumentation_handlers__;
                  }
                }
              }
              catch (e) {
                // Accessing dom properties is always fragile.
                // Also allows us to skip `addEventListenrs` calls with no proper `this` context.
              }
            }
            return originalRemoveEventListener.call(this, type, listener, options);
          };
        });
      });
    }
    var _oldOnErrorHandler = null;
    /** JSDoc */
    function instrumentError() {
      _oldOnErrorHandler = global.onerror;
      global.onerror = function (msg, url, line, column, error) {
        triggerHandlers('error', {
          column: column,
          error: error,
          line: line,
          msg: msg,
          url: url,
        });
        if (_oldOnErrorHandler) {
          // eslint-disable-next-line prefer-rest-params
          return _oldOnErrorHandler.apply(this, arguments);
        }
        return false;
      };
    }
    var _oldOnUnhandledRejectionHandler = null;
    /** JSDoc */
    function instrumentUnhandledRejection() {
      _oldOnUnhandledRejectionHandler = global.onunhandledrejection;
      global.onunhandledrejection = function (e) {
        triggerHandlers('unhandledrejection', e);
        if (_oldOnUnhandledRejectionHandler) {
          // eslint-disable-next-line prefer-rest-params
          return _oldOnUnhandledRejectionHandler.apply(this, arguments);
        }
        return true;
      };
    }

  }, { "./flags": 93, "./global": 94, "./is": 97, "./logger": 98, "./object": 103, "./stacktrace": 109, "./supports": 112, "tslib": 181 }], 97: [function (require, module, exports) {
    /* eslint-disable @typescript-eslint/no-explicit-any */
    /* eslint-disable @typescript-eslint/explicit-module-boundary-types */
    Object.defineProperty(exports, "__esModule", { value: true });
    // eslint-disable-next-line @typescript-eslint/unbound-method
    var objectToString = Object.prototype.toString;
    /**
     * Checks whether given value's type is one of a few Error or Error-like
     * {@link isError}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isError(wat) {
      switch (objectToString.call(wat)) {
        case '[object Error]':
        case '[object Exception]':
        case '[object DOMException]':
          return true;
        default:
          return isInstanceOf(wat, Error);
      }
    }
    exports.isError = isError;
    function isBuiltin(wat, ty) {
      return objectToString.call(wat) === "[object " + ty + "]";
    }
    /**
     * Checks whether given value's type is ErrorEvent
     * {@link isErrorEvent}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isErrorEvent(wat) {
      return isBuiltin(wat, 'ErrorEvent');
    }
    exports.isErrorEvent = isErrorEvent;
    /**
     * Checks whether given value's type is DOMError
     * {@link isDOMError}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isDOMError(wat) {
      return isBuiltin(wat, 'DOMError');
    }
    exports.isDOMError = isDOMError;
    /**
     * Checks whether given value's type is DOMException
     * {@link isDOMException}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isDOMException(wat) {
      return isBuiltin(wat, 'DOMException');
    }
    exports.isDOMException = isDOMException;
    /**
     * Checks whether given value's type is a string
     * {@link isString}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isString(wat) {
      return isBuiltin(wat, 'String');
    }
    exports.isString = isString;
    /**
     * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)
     * {@link isPrimitive}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isPrimitive(wat) {
      return wat === null || (typeof wat !== 'object' && typeof wat !== 'function');
    }
    exports.isPrimitive = isPrimitive;
    /**
     * Checks whether given value's type is an object literal
     * {@link isPlainObject}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isPlainObject(wat) {
      return isBuiltin(wat, 'Object');
    }
    exports.isPlainObject = isPlainObject;
    /**
     * Checks whether given value's type is an Event instance
     * {@link isEvent}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isEvent(wat) {
      return typeof Event !== 'undefined' && isInstanceOf(wat, Event);
    }
    exports.isEvent = isEvent;
    /**
     * Checks whether given value's type is an Element instance
     * {@link isElement}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isElement(wat) {
      return typeof Element !== 'undefined' && isInstanceOf(wat, Element);
    }
    exports.isElement = isElement;
    /**
     * Checks whether given value's type is an regexp
     * {@link isRegExp}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isRegExp(wat) {
      return isBuiltin(wat, 'RegExp');
    }
    exports.isRegExp = isRegExp;
    /**
     * Checks whether given value has a then function.
     * @param wat A value to be checked.
     */
    function isThenable(wat) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      return Boolean(wat && wat.then && typeof wat.then === 'function');
    }
    exports.isThenable = isThenable;
    /**
     * Checks whether given value's type is a SyntheticEvent
     * {@link isSyntheticEvent}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isSyntheticEvent(wat) {
      return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;
    }
    exports.isSyntheticEvent = isSyntheticEvent;
    /**
     * Checks whether given value is NaN
     * {@link isNaN}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isNaN(wat) {
      return typeof wat === 'number' && wat !== wat;
    }
    exports.isNaN = isNaN;
    /**
     * Checks whether given value's type is an instance of provided constructor.
     * {@link isInstanceOf}.
     *
     * @param wat A value to be checked.
     * @param base A constructor to be used in a check.
     * @returns A boolean representing the result.
     */
    function isInstanceOf(wat, base) {
      try {
        return wat instanceof base;
      }
      catch (_e) {
        return false;
      }
    }
    exports.isInstanceOf = isInstanceOf;

  }, {}], 98: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var flags_1 = require("./flags");
    var global_1 = require("./global");
    // TODO: Implement different loggers for different environments
    var global = global_1.getGlobalObject();
    /** Prefix for logging strings */
    var PREFIX = 'Sentry Logger ';
    exports.CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert'];
    /**
     * Temporarily disable sentry console instrumentations.
     *
     * @param callback The function to run against the original `console` messages
     * @returns The results of the callback
     */
    function consoleSandbox(callback) {
      var global = global_1.getGlobalObject();
      if (!('console' in global)) {
        return callback();
      }
      var originalConsole = global.console;
      var wrappedLevels = {};
      // Restore all wrapped console methods
      exports.CONSOLE_LEVELS.forEach(function (level) {
        // TODO(v7): Remove this check as it's only needed for Node 6
        var originalWrappedFunc = originalConsole[level] && originalConsole[level].__sentry_original__;
        if (level in global.console && originalWrappedFunc) {
          wrappedLevels[level] = originalConsole[level];
          originalConsole[level] = originalWrappedFunc;
        }
      });
      try {
        return callback();
      }
      finally {
        // Revert restoration to wrapped state
        Object.keys(wrappedLevels).forEach(function (level) {
          originalConsole[level] = wrappedLevels[level];
        });
      }
    }
    exports.consoleSandbox = consoleSandbox;
    function makeLogger() {
      var enabled = false;
      var logger = {
        enable: function () {
          enabled = true;
        },
        disable: function () {
          enabled = false;
        },
      };
      if (flags_1.IS_DEBUG_BUILD) {
        exports.CONSOLE_LEVELS.forEach(function (name) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          logger[name] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (enabled) {
              consoleSandbox(function () {
                var _a;
                (_a = global.console)[name].apply(_a, tslib_1.__spread([PREFIX + "[" + name + "]:"], args));
              });
            }
          };
        });
      }
      else {
        exports.CONSOLE_LEVELS.forEach(function (name) {
          logger[name] = function () { return undefined; };
        });
      }
      return logger;
    }
    // Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used
    var logger;
    exports.logger = logger;
    if (flags_1.IS_DEBUG_BUILD) {
      exports.logger = logger = global_1.getGlobalSingleton('logger', makeLogger);
    }
    else {
      exports.logger = logger = makeLogger();
    }

  }, { "./flags": 93, "./global": 94, "tslib": 181 }], 99: [function (require, module, exports) {
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    /* eslint-disable @typescript-eslint/no-explicit-any */
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Helper to decycle json objects
     */
    function memoBuilder() {
      var hasWeakSet = typeof WeakSet === 'function';
      var inner = hasWeakSet ? new WeakSet() : [];
      function memoize(obj) {
        if (hasWeakSet) {
          if (inner.has(obj)) {
            return true;
          }
          inner.add(obj);
          return false;
        }
        // eslint-disable-next-line @typescript-eslint/prefer-for-of
        for (var i = 0; i < inner.length; i++) {
          var value = inner[i];
          if (value === obj) {
            return true;
          }
        }
        inner.push(obj);
        return false;
      }
      function unmemoize(obj) {
        if (hasWeakSet) {
          inner.delete(obj);
        }
        else {
          for (var i = 0; i < inner.length; i++) {
            if (inner[i] === obj) {
              inner.splice(i, 1);
              break;
            }
          }
        }
      }
      return [memoize, unmemoize];
    }
    exports.memoBuilder = memoBuilder;

  }, {}], 100: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var global_1 = require("./global");
    var object_1 = require("./object");
    var string_1 = require("./string");
    /**
     * UUID4 generator
     *
     * @returns string Generated UUID4.
     */
    function uuid4() {
      var global = global_1.getGlobalObject();
      var crypto = global.crypto || global.msCrypto;
      if (!(crypto === void 0) && crypto.getRandomValues) {
        // Use window.crypto API if available
        var arr = new Uint16Array(8);
        crypto.getRandomValues(arr);
        // set 4 in byte 7
        // eslint-disable-next-line no-bitwise
        arr[3] = (arr[3] & 0xfff) | 0x4000;
        // set 2 most significant bits of byte 9 to '10'
        // eslint-disable-next-line no-bitwise
        arr[4] = (arr[4] & 0x3fff) | 0x8000;
        var pad = function (num) {
          var v = num.toString(16);
          while (v.length < 4) {
            v = "0" + v;
          }
          return v;
        };
        return (pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]));
      }
      // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
      return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        // eslint-disable-next-line no-bitwise
        var r = (Math.random() * 16) | 0;
        // eslint-disable-next-line no-bitwise
        var v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
      });
    }
    exports.uuid4 = uuid4;
    /**
     * Parses string form of URL into an object
     * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
     * // intentionally using regex and not <a/> href parsing trick because React Native and other
     * // environments where DOM might not be available
     * @returns parsed URL object
     */
    function parseUrl(url) {
      if (!url) {
        return {};
      }
      var match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
      if (!match) {
        return {};
      }
      // coerce to undefined values to empty string so we don't get 'undefined'
      var query = match[6] || '';
      var fragment = match[8] || '';
      return {
        host: match[4],
        path: match[5],
        protocol: match[2],
        relative: match[5] + query + fragment,
      };
    }
    exports.parseUrl = parseUrl;
    function getFirstException(event) {
      return event.exception && event.exception.values ? event.exception.values[0] : undefined;
    }
    /**
     * Extracts either message or type+value from an event that can be used for user-facing logs
     * @returns event's description
     */
    function getEventDescription(event) {
      var message = event.message, eventId = event.event_id;
      if (message) {
        return message;
      }
      var firstException = getFirstException(event);
      if (firstException) {
        if (firstException.type && firstException.value) {
          return firstException.type + ": " + firstException.value;
        }
        return firstException.type || firstException.value || eventId || '<unknown>';
      }
      return eventId || '<unknown>';
    }
    exports.getEventDescription = getEventDescription;
    /**
     * Adds exception values, type and value to an synthetic Exception.
     * @param event The event to modify.
     * @param value Value of the exception.
     * @param type Type of the exception.
     * @hidden
     */
    function addExceptionTypeValue(event, value, type) {
      var exception = (event.exception = event.exception || {});
      var values = (exception.values = exception.values || []);
      var firstException = (values[0] = values[0] || {});
      if (!firstException.value) {
        firstException.value = value || '';
      }
      if (!firstException.type) {
        firstException.type = type || 'Error';
      }
    }
    exports.addExceptionTypeValue = addExceptionTypeValue;
    /**
     * Adds exception mechanism data to a given event. Uses defaults if the second parameter is not passed.
     *
     * @param event The event to modify.
     * @param newMechanism Mechanism data to add to the event.
     * @hidden
     */
    function addExceptionMechanism(event, newMechanism) {
      var firstException = getFirstException(event);
      if (!firstException) {
        return;
      }
      var defaultMechanism = { type: 'generic', handled: true };
      var currentMechanism = firstException.mechanism;
      firstException.mechanism = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, defaultMechanism), currentMechanism), newMechanism);
      if (newMechanism && 'data' in newMechanism) {
        var mergedData = tslib_1.__assign(tslib_1.__assign({}, (currentMechanism && currentMechanism.data)), newMechanism.data);
        firstException.mechanism.data = mergedData;
      }
    }
    exports.addExceptionMechanism = addExceptionMechanism;
    // https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string
    var SEMVER_REGEXP = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
    /**
     * Parses input into a SemVer interface
     * @param input string representation of a semver version
     */
    function parseSemver(input) {
      var match = input.match(SEMVER_REGEXP) || [];
      var major = parseInt(match[1], 10);
      var minor = parseInt(match[2], 10);
      var patch = parseInt(match[3], 10);
      return {
        buildmetadata: match[5],
        major: isNaN(major) ? undefined : major,
        minor: isNaN(minor) ? undefined : minor,
        patch: isNaN(patch) ? undefined : patch,
        prerelease: match[4],
      };
    }
    exports.parseSemver = parseSemver;
    /**
     * This function adds context (pre/post/line) lines to the provided frame
     *
     * @param lines string[] containing all lines
     * @param frame StackFrame that will be mutated
     * @param linesOfContext number of context lines we want to add pre/post
     */
    function addContextToFrame(lines, frame, linesOfContext) {
      if (linesOfContext === void 0) { linesOfContext = 5; }
      var lineno = frame.lineno || 0;
      var maxLines = lines.length;
      var sourceLine = Math.max(Math.min(maxLines, lineno - 1), 0);
      frame.pre_context = lines
        .slice(Math.max(0, sourceLine - linesOfContext), sourceLine)
        .map(function (line) { return string_1.snipLine(line, 0); });
      frame.context_line = string_1.snipLine(lines[Math.min(maxLines - 1, sourceLine)], frame.colno || 0);
      frame.post_context = lines
        .slice(Math.min(sourceLine + 1, maxLines), sourceLine + 1 + linesOfContext)
        .map(function (line) { return string_1.snipLine(line, 0); });
    }
    exports.addContextToFrame = addContextToFrame;
    /**
     * Strip the query string and fragment off of a given URL or path (if present)
     *
     * @param urlPath Full URL or path, including possible query string and/or fragment
     * @returns URL or path without query string or fragment
     */
    function stripUrlQueryAndFragment(urlPath) {
      // eslint-disable-next-line no-useless-escape
      return urlPath.split(/[\?#]/, 1)[0];
    }
    exports.stripUrlQueryAndFragment = stripUrlQueryAndFragment;
    /**
     * Checks whether or not we've already captured the given exception (note: not an identical exception - the very object
     * in question), and marks it captured if not.
     *
     * This is useful because it's possible for an error to get captured by more than one mechanism. After we intercept and
     * record an error, we rethrow it (assuming we've intercepted it before it's reached the top-level global handlers), so
     * that we don't interfere with whatever effects the error might have had were the SDK not there. At that point, because
     * the error has been rethrown, it's possible for it to bubble up to some other code we've instrumented. If it's not
     * caught after that, it will bubble all the way up to the global handlers (which of course we also instrument). This
     * function helps us ensure that even if we encounter the same error more than once, we only record it the first time we
     * see it.
     *
     * Note: It will ignore primitives (always return `false` and not mark them as seen), as properties can't be set on
     * them. {@link: Object.objectify} can be used on exceptions to convert any that are primitives into their equivalent
     * object wrapper forms so that this check will always work. However, because we need to flag the exact object which
     * will get rethrown, and because that rethrowing happens outside of the event processing pipeline, the objectification
     * must be done before the exception captured.
     *
     * @param A thrown exception to check or flag as having been seen
     * @returns `true` if the exception has already been captured, `false` if not (with the side effect of marking it seen)
     */
    function checkOrSetAlreadyCaught(exception) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      if (exception && exception.__sentry_captured__) {
        return true;
      }
      try {
        // set it this way rather than by assignment so that it's not ennumerable and therefore isn't recorded by the
        // `ExtraErrorData` integration
        object_1.addNonEnumerableProperty(exception, '__sentry_captured__', true);
      }
      catch (err) {
        // `exception` is a primitive, so we can't mark it seen
      }
      return false;
    }
    exports.checkOrSetAlreadyCaught = checkOrSetAlreadyCaught;

  }, { "./global": 94, "./object": 103, "./string": 111, "tslib": 181 }], 101: [function (require, module, exports) {
    (function (process) {
      (function () {
        /**
         * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
         * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
         */
        Object.defineProperty(exports, "__esModule", { value: true });
        var env_1 = require("./env");
        /**
         * Checks whether we're in the Node.js or Browser environment
         *
         * @returns Answer to given question
         */
        function isNodeEnv() {
          // explicitly check for browser bundles as those can be optimized statically
          // by terser/rollup.
          return (!env_1.isBrowserBundle() &&
            Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]');
        }
        exports.isNodeEnv = isNodeEnv;
        /**
         * Requires a module which is protected against bundler minification.
         *
         * @param request The module path to resolve
         */
        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
        function dynamicRequire(mod, request) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          return mod.require(request);
        }
        exports.dynamicRequire = dynamicRequire;
        /**
         * Helper for dynamically loading module that should work with linked dependencies.
         * The problem is that we _should_ be using `require(require.resolve(moduleName, { paths: [cwd()] }))`
         * However it's _not possible_ to do that with Webpack, as it has to know all the dependencies during
         * build time. `require.resolve` is also not available in any other way, so we cannot create,
         * a fake helper like we do with `dynamicRequire`.
         *
         * We always prefer to use local package, thus the value is not returned early from each `try/catch` block.
         * That is to mimic the behavior of `require.resolve` exactly.
         *
         * @param moduleName module name to require
         * @returns possibly required module
         */
        function loadModule(moduleName) {
          var mod;
          try {
            mod = dynamicRequire(module, moduleName);
          }
          catch (e) {
            // no-empty
          }
          try {
            var cwd = dynamicRequire(module, 'process').cwd;
            mod = dynamicRequire(module, cwd() + "/node_modules/" + moduleName);
          }
          catch (e) {
            // no-empty
          }
          return mod;
        }
        exports.loadModule = loadModule;

      }).call(this)
    }).call(this, require('_process'))
  }, { "./env": 90, "_process": 163 }], 102: [function (require, module, exports) {
    (function (global) {
      (function () {
        Object.defineProperty(exports, "__esModule", { value: true });
        var tslib_1 = require("tslib");
        var is_1 = require("./is");
        var memo_1 = require("./memo");
        var object_1 = require("./object");
        var stacktrace_1 = require("./stacktrace");
        /**
         * Recursively normalizes the given object.
         *
         * - Creates a copy to prevent original input mutation
         * - Skips non-enumerable properties
         * - When stringifying, calls `toJSON` if implemented
         * - Removes circular references
         * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format
         * - Translates known global objects/classes to a string representations
         * - Takes care of `Error` object serialization
         * - Optionally limits depth of final output
         * - Optionally limits number of properties/elements included in any single object/array
         *
         * @param input The object to be normalized.
         * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)
         * @param maxProperties The max number of elements or properties to be included in any single array or
         * object in the normallized output..
         * @returns A normalized version of the object, or `"**non-serializable**"` if any errors are thrown during normalization.
         */
        function normalize(input, depth, maxProperties) {
          if (depth === void 0) { depth = +Infinity; }
          if (maxProperties === void 0) { maxProperties = +Infinity; }
          try {
            // since we're at the outermost level, there is no key
            return visit('', input, depth, maxProperties);
          }
          catch (err) {
            return { ERROR: "**non-serializable** (" + err + ")" };
          }
        }
        exports.normalize = normalize;
        /** JSDoc */
        function normalizeToSize(object,
          // Default Node.js REPL depth
          depth,
          // 100kB, as 200kB is max payload size, so half sounds reasonable
          maxSize) {
          if (depth === void 0) { depth = 3; }
          if (maxSize === void 0) { maxSize = 100 * 1024; }
          var normalized = normalize(object, depth);
          if (jsonSize(normalized) > maxSize) {
            return normalizeToSize(object, depth - 1, maxSize);
          }
          return normalized;
        }
        exports.normalizeToSize = normalizeToSize;
        /**
         * Visits a node to perform normalization on it
         *
         * @param key The key corresponding to the given node
         * @param value The node to be visited
         * @param depth Optional number indicating the maximum recursion depth
         * @param maxProperties Optional maximum number of properties/elements included in any single object/array
         * @param memo Optional Memo class handling decycling
         */
        function visit(key, value, depth, maxProperties, memo) {
          if (depth === void 0) { depth = +Infinity; }
          if (maxProperties === void 0) { maxProperties = +Infinity; }
          if (memo === void 0) { memo = memo_1.memoBuilder(); }
          var _a = tslib_1.__read(memo, 2), memoize = _a[0], unmemoize = _a[1];
          // If the value has a `toJSON` method, see if we can bail and let it do the work
          var valueWithToJSON = value;
          if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {
            try {
              return valueWithToJSON.toJSON();
            }
            catch (err) {
              // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)
            }
          }
          // Get the simple cases out of the way first
          if (value === null || (['number', 'boolean', 'string'].includes(typeof value) && !is_1.isNaN(value))) {
            return value;
          }
          var stringified = stringifyValue(key, value);
          // Anything we could potentially dig into more (objects or arrays) will have come back as `"[object XXXX]"`.
          // Everything else will have already been serialized, so if we don't see that pattern, we're done.
          if (!stringified.startsWith('[object ')) {
            return stringified;
          }
          // We're also done if we've reached the max depth
          if (depth === 0) {
            // At this point we know `serialized` is a string of the form `"[object XXXX]"`. Clean it up so it's just `"[XXXX]"`.
            return stringified.replace('object ', '');
          }
          // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.
          if (memoize(value)) {
            return '[Circular ~]';
          }
          // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse
          // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each
          // property/entry, and keep track of the number of items we add to it.
          var normalized = (Array.isArray(value) ? [] : {});
          var numAdded = 0;
          // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant
          // properties are non-enumerable and otherwise would get missed.
          var visitable = (is_1.isError(value) || is_1.isEvent(value) ? object_1.convertToPlainObject(value) : value);
          for (var visitKey in visitable) {
            // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.
            if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
              continue;
            }
            if (numAdded >= maxProperties) {
              normalized[visitKey] = '[MaxProperties ~]';
              break;
            }
            // Recursively visit all the child nodes
            var visitValue = visitable[visitKey];
            normalized[visitKey] = visit(visitKey, visitValue, depth - 1, maxProperties, memo);
            numAdded += 1;
          }
          // Once we've visited all the branches, remove the parent from memo storage
          unmemoize(value);
          // Return accumulated values
          return normalized;
        }
        exports.walk = visit;
        /**
         * Stringify the given value. Handles various known special values and types.
         *
         * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn
         * the number 1231 into "[Object Number]", nor on `null`, as it will throw.
         *
         * @param value The value to stringify
         * @returns A stringified representation of the given value
         */
        function stringifyValue(key,
          // this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for
          // our internal use, it'll do
          value) {
          try {
            if (key === 'domain' && value && typeof value === 'object' && value._events) {
              return '[Domain]';
            }
            if (key === 'domainEmitter') {
              return '[DomainEmitter]';
            }
            // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first
            // which won't throw if they are not present.
            if (typeof global !== 'undefined' && value === global) {
              return '[Global]';
            }
            // eslint-disable-next-line no-restricted-globals
            if (typeof window !== 'undefined' && value === window) {
              return '[Window]';
            }
            // eslint-disable-next-line no-restricted-globals
            if (typeof document !== 'undefined' && value === document) {
              return '[Document]';
            }
            // React's SyntheticEvent thingy
            if (is_1.isSyntheticEvent(value)) {
              return '[SyntheticEvent]';
            }
            if (typeof value === 'number' && value !== value) {
              return '[NaN]';
            }
            // this catches `undefined` (but not `null`, which is a primitive and can be serialized on its own)
            if (value === void 0) {
              return '[undefined]';
            }
            if (typeof value === 'function') {
              return "[Function: " + stacktrace_1.getFunctionName(value) + "]";
            }
            if (typeof value === 'symbol') {
              return "[" + String(value) + "]";
            }
            // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion
            if (typeof value === 'bigint') {
              return "[BigInt: " + String(value) + "]";
            }
            // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting
            // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as
            // `"[object Object]"`. If we instead look at the constructor's name (which is the same as the name of the class),
            // we can make sure that only plain objects come out that way.
            return "[object " + Object.getPrototypeOf(value).constructor.name + "]";
          }
          catch (err) {
            return "**non-serializable** (" + err + ")";
          }
        }
        /** Calculates bytes size of input string */
        function utf8Length(value) {
          // eslint-disable-next-line no-bitwise
          return ~-encodeURI(value).split(/%..|./).length;
        }
        /** Calculates bytes size of input object */
        function jsonSize(value) {
          return utf8Length(JSON.stringify(value));
        }

      }).call(this)
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  }, { "./is": 97, "./memo": 99, "./object": 103, "./stacktrace": 109, "tslib": 181 }], 103: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var browser_1 = require("./browser");
    var is_1 = require("./is");
    var string_1 = require("./string");
    /**
     * Replace a method in an object with a wrapped version of itself.
     *
     * @param source An object that contains a method to be wrapped.
     * @param name The name of the method to be wrapped.
     * @param replacementFactory A higher-order function that takes the original version of the given method and returns a
     * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to
     * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other
     * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.
     * @returns void
     */
    function fill(source, name, replacementFactory) {
      if (!(name in source)) {
        return;
      }
      var original = source[name];
      var wrapped = replacementFactory(original);
      // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work
      // otherwise it'll throw "TypeError: Object.defineProperties called on non-object"
      if (typeof wrapped === 'function') {
        try {
          markFunctionWrapped(wrapped, original);
        }
        catch (_Oo) {
          // This can throw if multiple fill happens on a global object like XMLHttpRequest
          // Fixes https://github.com/getsentry/sentry-javascript/issues/2043
        }
      }
      source[name] = wrapped;
    }
    exports.fill = fill;
    /**
     * Defines a non-enumerable property on the given object.
     *
     * @param obj The object on which to set the property
     * @param name The name of the property to be set
     * @param value The value to which to set the property
     */
    function addNonEnumerableProperty(obj, name, value) {
      Object.defineProperty(obj, name, {
        // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
        value: value,
        writable: true,
        configurable: true,
      });
    }
    exports.addNonEnumerableProperty = addNonEnumerableProperty;
    /**
     * Remembers the original function on the wrapped function and
     * patches up the prototype.
     *
     * @param wrapped the wrapper function
     * @param original the original function that gets wrapped
     */
    function markFunctionWrapped(wrapped, original) {
      var proto = original.prototype || {};
      wrapped.prototype = original.prototype = proto;
      addNonEnumerableProperty(wrapped, '__sentry_original__', original);
    }
    exports.markFunctionWrapped = markFunctionWrapped;
    /**
     * This extracts the original function if available.  See
     * `markFunctionWrapped` for more information.
     *
     * @param func the function to unwrap
     * @returns the unwrapped version of the function if available.
     */
    function getOriginalFunction(func) {
      return func.__sentry_original__;
    }
    exports.getOriginalFunction = getOriginalFunction;
    /**
     * Encodes given object into url-friendly format
     *
     * @param object An object that contains serializable values
     * @returns string Encoded
     */
    function urlEncode(object) {
      return Object.keys(object)
        .map(function (key) { return encodeURIComponent(key) + "=" + encodeURIComponent(object[key]); })
        .join('&');
    }
    exports.urlEncode = urlEncode;
    /**
     * Transforms any object into an object literal with all its attributes
     * attached to it.
     *
     * @param value Initial source that we have to transform in order for it to be usable by the serializer
     */
    function convertToPlainObject(value) {
      var newObj = value;
      if (is_1.isError(value)) {
        newObj = tslib_1.__assign({ message: value.message, name: value.name, stack: value.stack }, getOwnProperties(value));
      }
      else if (is_1.isEvent(value)) {
        var event_1 = value;
        newObj = tslib_1.__assign({ type: event_1.type, target: serializeEventTarget(event_1.target), currentTarget: serializeEventTarget(event_1.currentTarget) }, getOwnProperties(event_1));
        if (typeof CustomEvent !== 'undefined' && is_1.isInstanceOf(value, CustomEvent)) {
          newObj.detail = event_1.detail;
        }
      }
      return newObj;
    }
    exports.convertToPlainObject = convertToPlainObject;
    /** Creates a string representation of the target of an `Event` object */
    function serializeEventTarget(target) {
      try {
        return is_1.isElement(target) ? browser_1.htmlTreeAsString(target) : Object.prototype.toString.call(target);
      }
      catch (_oO) {
        return '<unknown>';
      }
    }
    /** Filters out all but an object's own properties */
    function getOwnProperties(obj) {
      var extractedProps = {};
      for (var property in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, property)) {
          extractedProps[property] = obj[property];
        }
      }
      return extractedProps;
    }
    /**
     * Given any captured exception, extract its keys and create a sorted
     * and truncated list that will be used inside the event message.
     * eg. `Non-error exception captured with keys: foo, bar, baz`
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    function extractExceptionKeysForMessage(exception, maxLength) {
      if (maxLength === void 0) { maxLength = 40; }
      var keys = Object.keys(convertToPlainObject(exception));
      keys.sort();
      if (!keys.length) {
        return '[object has no keys]';
      }
      if (keys[0].length >= maxLength) {
        return string_1.truncate(keys[0], maxLength);
      }
      for (var includedKeys = keys.length; includedKeys > 0; includedKeys--) {
        var serialized = keys.slice(0, includedKeys).join(', ');
        if (serialized.length > maxLength) {
          continue;
        }
        if (includedKeys === keys.length) {
          return serialized;
        }
        return string_1.truncate(serialized, maxLength);
      }
      return '';
    }
    exports.extractExceptionKeysForMessage = extractExceptionKeysForMessage;
    /**
     * Given any object, return the new object with removed keys that value was `undefined`.
     * Works recursively on objects and arrays.
     */
    function dropUndefinedKeys(val) {
      var e_1, _a;
      if (is_1.isPlainObject(val)) {
        var rv = {};
        try {
          for (var _b = tslib_1.__values(Object.keys(val)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            if (typeof val[key] !== 'undefined') {
              rv[key] = dropUndefinedKeys(val[key]);
            }
          }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          }
          finally { if (e_1) throw e_1.error; }
        }
        return rv;
      }
      if (Array.isArray(val)) {
        return val.map(dropUndefinedKeys);
      }
      return val;
    }
    exports.dropUndefinedKeys = dropUndefinedKeys;
    /**
     * Ensure that something is an object.
     *
     * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper
     * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.
     *
     * @param wat The subject of the objectification
     * @returns A version of `wat` which can safely be used with `Object` class methods
     */
    function objectify(wat) {
      var objectified;
      switch (true) {
        case wat === undefined || wat === null:
          objectified = new String(wat);
          break;
        // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason
        // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as
        // an object in order to wrap it.
        case typeof wat === 'symbol' || typeof wat === 'bigint':
          objectified = Object(wat);
          break;
        // this will catch the remaining primitives: `String`, `Number`, and `Boolean`
        case is_1.isPrimitive(wat):
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          objectified = new wat.constructor(wat);
          break;
        // by process of elimination, at this point we know that `wat` must already be an object
        default:
          objectified = wat;
          break;
      }
      return objectified;
    }
    exports.objectify = objectify;

  }, { "./browser": 86, "./is": 97, "./string": 111, "tslib": 181 }], 104: [function (require, module, exports) {
    // Slightly modified (no IE8 support, ES6) and transcribed to TypeScript
    // https://raw.githubusercontent.com/calvinmetcalf/rollup-plugin-node-builtins/master/src/es6/path.js
    Object.defineProperty(exports, "__esModule", { value: true });
    /** JSDoc */
    function normalizeArray(parts, allowAboveRoot) {
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
          parts.splice(i, 1);
        }
        else if (last === '..') {
          parts.splice(i, 1);
          // eslint-disable-next-line no-plusplus
          up++;
        }
        else if (up) {
          parts.splice(i, 1);
          // eslint-disable-next-line no-plusplus
          up--;
        }
      }
      // if the path is allowed to go above the root, restore leading ..s
      if (allowAboveRoot) {
        // eslint-disable-next-line no-plusplus
        for (; up--; up) {
          parts.unshift('..');
        }
      }
      return parts;
    }
    // Split a filename into [root, dir, basename, ext], unix version
    // 'root' is just a slash, or nothing.
    var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^/]+?|)(\.[^./]*|))(?:[/]*)$/;
    /** JSDoc */
    function splitPath(filename) {
      var parts = splitPathRe.exec(filename);
      return parts ? parts.slice(1) : [];
    }
    // path.resolve([from ...], to)
    // posix version
    /** JSDoc */
    function resolve() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resolvedPath = '';
      var resolvedAbsolute = false;
      for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? args[i] : '/';
        // Skip empty entries
        if (!path) {
          continue;
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = path.charAt(0) === '/';
      }
      // At this point the path should be resolved to a full absolute path, but
      // handle relative paths to be safe (might happen when process.cwd() fails)
      // Normalize the path
      resolvedPath = normalizeArray(resolvedPath.split('/').filter(function (p) { return !!p; }), !resolvedAbsolute).join('/');
      return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
    }
    exports.resolve = resolve;
    /** JSDoc */
    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== '') {
          break;
        }
      }
      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== '') {
          break;
        }
      }
      if (start > end) {
        return [];
      }
      return arr.slice(start, end - start + 1);
    }
    // path.relative(from, to)
    // posix version
    /** JSDoc */
    function relative(from, to) {
      /* eslint-disable no-param-reassign */
      from = resolve(from).substr(1);
      to = resolve(to).substr(1);
      /* eslint-enable no-param-reassign */
      var fromParts = trim(from.split('/'));
      var toParts = trim(to.split('/'));
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push('..');
      }
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
      return outputParts.join('/');
    }
    exports.relative = relative;
    // path.normalize(path)
    // posix version
    /** JSDoc */
    function normalizePath(path) {
      var isPathAbsolute = isAbsolute(path);
      var trailingSlash = path.substr(-1) === '/';
      // Normalize the path
      var normalizedPath = normalizeArray(path.split('/').filter(function (p) { return !!p; }), !isPathAbsolute).join('/');
      if (!normalizedPath && !isPathAbsolute) {
        normalizedPath = '.';
      }
      if (normalizedPath && trailingSlash) {
        normalizedPath += '/';
      }
      return (isPathAbsolute ? '/' : '') + normalizedPath;
    }
    exports.normalizePath = normalizePath;
    // posix version
    /** JSDoc */
    function isAbsolute(path) {
      return path.charAt(0) === '/';
    }
    exports.isAbsolute = isAbsolute;
    // posix version
    /** JSDoc */
    function join() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return normalizePath(args.join('/'));
    }
    exports.join = join;
    /** JSDoc */
    function dirname(path) {
      var result = splitPath(path);
      var root = result[0];
      var dir = result[1];
      if (!root && !dir) {
        // No dirname whatsoever
        return '.';
      }
      if (dir) {
        // It has a dirname, strip trailing slash
        dir = dir.substr(0, dir.length - 1);
      }
      return root + dir;
    }
    exports.dirname = dirname;
    /** JSDoc */
    function basename(path, ext) {
      var f = splitPath(path)[2];
      if (ext && f.substr(ext.length * -1) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    }
    exports.basename = basename;

  }, {}], 105: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setPrototypeOf = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
    /**
     * setPrototypeOf polyfill using __proto__
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    function setProtoOf(obj, proto) {
      // @ts-ignore __proto__ does not exist on obj
      obj.__proto__ = proto;
      return obj;
    }
    /**
     * setPrototypeOf polyfill using mixin
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    function mixinProperties(obj, proto) {
      for (var prop in proto) {
        if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
          // @ts-ignore typescript complains about indexing so we remove
          obj[prop] = proto[prop];
        }
      }
      return obj;
    }

  }, {}], 106: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var error_1 = require("./error");
    var syncpromise_1 = require("./syncpromise");
    /**
     * Creates an new PromiseBuffer object with the specified limit
     * @param limit max number of promises that can be stored in the buffer
     */
    function makePromiseBuffer(limit) {
      var buffer = [];
      function isReady() {
        return limit === undefined || buffer.length < limit;
      }
      /**
       * Remove a promise from the queue.
       *
       * @param task Can be any PromiseLike<T>
       * @returns Removed promise.
       */
      function remove(task) {
        return buffer.splice(buffer.indexOf(task), 1)[0];
      }
      /**
       * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.
       *
       * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:
       *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor
       *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By
       *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer
       *        limit check.
       * @returns The original promise.
       */
      function add(taskProducer) {
        if (!isReady()) {
          return syncpromise_1.rejectedSyncPromise(new error_1.SentryError('Not adding Promise due to buffer limit reached.'));
        }
        // start the task and add its promise to the queue
        var task = taskProducer();
        if (buffer.indexOf(task) === -1) {
          buffer.push(task);
        }
        void task
          .then(function () { return remove(task); })
          // Use `then(null, rejectionHandler)` rather than `catch(rejectionHandler)` so that we can use `PromiseLike`
          // rather than `Promise`. `PromiseLike` doesn't have a `.catch` method, making its polyfill smaller. (ES5 didn't
          // have promises, so TS has to polyfill when down-compiling.)
          .then(null, function () {
            return remove(task).then(null, function () {
              // We have to add another catch here because `remove()` starts a new promise chain.
            });
          });
        return task;
      }
      /**
       * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.
       *
       * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or
       * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to
       * `true`.
       * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and
       * `false` otherwise
       */
      function drain(timeout) {
        return new syncpromise_1.SyncPromise(function (resolve, reject) {
          var counter = buffer.length;
          if (!counter) {
            return resolve(true);
          }
          // wait for `timeout` ms and then resolve to `false` (if not cancelled first)
          var capturedSetTimeout = setTimeout(function () {
            if (timeout && timeout > 0) {
              resolve(false);
            }
          }, timeout);
          // if all promises resolve in time, cancel the timer and resolve to `true`
          buffer.forEach(function (item) {
            void syncpromise_1.resolvedSyncPromise(item).then(function () {
              // eslint-disable-next-line no-plusplus
              if (!--counter) {
                clearTimeout(capturedSetTimeout);
                resolve(true);
              }
            }, reject);
          });
        });
      }
      return {
        $: buffer,
        add: add,
        drain: drain,
      };
    }
    exports.makePromiseBuffer = makePromiseBuffer;

  }, { "./error": 92, "./syncpromise": 113 }], 107: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    exports.DEFAULT_RETRY_AFTER = 60 * 1000; // 60 seconds
    /**
     * Extracts Retry-After value from the request header or returns default value
     * @param header string representation of 'Retry-After' header
     * @param now current unix timestamp
     *
     */
    function parseRetryAfterHeader(header, now) {
      if (now === void 0) { now = Date.now(); }
      var headerDelay = parseInt("" + header, 10);
      if (!isNaN(headerDelay)) {
        return headerDelay * 1000;
      }
      var headerDate = Date.parse("" + header);
      if (!isNaN(headerDate)) {
        return headerDate - now;
      }
      return exports.DEFAULT_RETRY_AFTER;
    }
    exports.parseRetryAfterHeader = parseRetryAfterHeader;
    /**
     * Gets the time that given category is disabled until for rate limiting
     */
    function disabledUntil(limits, category) {
      return limits[category] || limits.all || 0;
    }
    exports.disabledUntil = disabledUntil;
    /**
     * Checks if a category is rate limited
     */
    function isRateLimited(limits, category, now) {
      if (now === void 0) { now = Date.now(); }
      return disabledUntil(limits, category) > now;
    }
    exports.isRateLimited = isRateLimited;
    /**
     * Update ratelimits from incoming headers.
     * Returns true if headers contains a non-empty rate limiting header.
     */
    function updateRateLimits(limits, headers, now) {
      var e_1, _a, e_2, _b;
      if (now === void 0) { now = Date.now(); }
      var updatedRateLimits = tslib_1.__assign({}, limits);
      // "The name is case-insensitive."
      // https://developer.mozilla.org/en-US/docs/Web/API/Headers/get
      var rateLimitHeader = headers['x-sentry-rate-limits'];
      var retryAfterHeader = headers['retry-after'];
      if (rateLimitHeader) {
        try {
          /**
           * rate limit headers are of the form
           *     <header>,<header>,..
           * where each <header> is of the form
           *     <retry_after>: <categories>: <scope>: <reason_code>
           * where
           *     <retry_after> is a delay in seconds
           *     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form
           *         <category>;<category>;...
           *     <scope> is what's being limited (org, project, or key) - ignored by SDK
           *     <reason_code> is an arbitrary string like "org_quota" - ignored by SDK
           */
          for (var _c = tslib_1.__values(rateLimitHeader.trim().split(',')), _d = _c.next(); !_d.done; _d = _c.next()) {
            var limit = _d.value;
            var parameters = limit.split(':', 2);
            var headerDelay = parseInt(parameters[0], 10);
            var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default
            if (!parameters[1]) {
              updatedRateLimits.all = now + delay;
            }
            else {
              try {
                for (var _e = (e_2 = void 0, tslib_1.__values(parameters[1].split(';'))), _f = _e.next(); !_f.done; _f = _e.next()) {
                  var category = _f.value;
                  updatedRateLimits[category] = now + delay;
                }
              }
              catch (e_2_1) { e_2 = { error: e_2_1 }; }
              finally {
                try {
                  if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
              }
            }
          }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
          try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
          }
          finally { if (e_1) throw e_1.error; }
        }
      }
      else if (retryAfterHeader) {
        updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
      }
      return updatedRateLimits;
    }
    exports.updateRateLimits = updateRateLimits;

  }, { "tslib": 181 }], 108: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var types_1 = require("@sentry/types");
    var enums_1 = require("./enums");
    function isSupportedSeverity(level) {
      return enums_1.SeverityLevels.indexOf(level) !== -1;
    }
    /**
     * Converts a string-based level into a {@link Severity}.
     *
     * @param level string representation of Severity
     * @returns Severity
     */
    function severityFromString(level) {
      if (level === 'warn')
        return types_1.Severity.Warning;
      if (isSupportedSeverity(level)) {
        return level;
      }
      return types_1.Severity.Log;
    }
    exports.severityFromString = severityFromString;

  }, { "./enums": 89, "@sentry/types": 83 }], 109: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var STACKTRACE_LIMIT = 50;
    /**
     * Creates a stack parser with the supplied line parsers
     *
     * StackFrames are returned in the correct order for Sentry Exception
     * frames and with Sentry SDK internal frames removed from the top and bottom
     *
     */
    function createStackParser() {
      var parsers = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        parsers[_i] = arguments[_i];
      }
      var sortedParsers = parsers.sort(function (a, b) { return a[0] - b[0]; }).map(function (p) { return p[1]; });
      return function (stack, skipFirst) {
        var e_1, _a, e_2, _b;
        if (skipFirst === void 0) { skipFirst = 0; }
        var frames = [];
        try {
          for (var _c = tslib_1.__values(stack.split('\n').slice(skipFirst)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var line = _d.value;
            try {
              for (var sortedParsers_1 = (e_2 = void 0, tslib_1.__values(sortedParsers)), sortedParsers_1_1 = sortedParsers_1.next(); !sortedParsers_1_1.done; sortedParsers_1_1 = sortedParsers_1.next()) {
                var parser = sortedParsers_1_1.value;
                var frame = parser(line);
                if (frame) {
                  frames.push(frame);
                  break;
                }
              }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
              try {
                if (sortedParsers_1_1 && !sortedParsers_1_1.done && (_b = sortedParsers_1.return)) _b.call(sortedParsers_1);
              }
              finally { if (e_2) throw e_2.error; }
            }
          }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
          try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
          }
          finally { if (e_1) throw e_1.error; }
        }
        return stripSentryFramesAndReverse(frames);
      };
    }
    exports.createStackParser = createStackParser;
    /**
     * @hidden
     */
    function stripSentryFramesAndReverse(stack) {
      if (!stack.length) {
        return [];
      }
      var localStack = stack;
      var firstFrameFunction = localStack[0].function || '';
      var lastFrameFunction = localStack[localStack.length - 1].function || '';
      // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)
      if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {
        localStack = localStack.slice(1);
      }
      // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)
      if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {
        localStack = localStack.slice(0, -1);
      }
      // The frame where the crash happened, should be the last entry in the array
      return localStack
        .slice(0, STACKTRACE_LIMIT)
        .map(function (frame) { return (tslib_1.__assign(tslib_1.__assign({}, frame), { filename: frame.filename || localStack[0].filename, function: frame.function || '?' })); })
        .reverse();
    }
    exports.stripSentryFramesAndReverse = stripSentryFramesAndReverse;
    var defaultFunctionName = '<anonymous>';
    /**
     * Safely extract function name from itself
     */
    function getFunctionName(fn) {
      try {
        if (!fn || typeof fn !== 'function') {
          return defaultFunctionName;
        }
        return fn.name || defaultFunctionName;
      }
      catch (e) {
        // Just accessing custom props in some Selenium environments
        // can cause a "Permission denied" exception (see raven-js#495).
        return defaultFunctionName;
      }
    }
    exports.getFunctionName = getFunctionName;

  }, { "tslib": 181 }], 110: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Converts an HTTP status code to sentry status {@link EventStatus}.
     *
     * @param code number HTTP status code
     * @returns EventStatus
     */
    function eventStatusFromHttpCode(code) {
      if (code >= 200 && code < 300) {
        return 'success';
      }
      if (code === 429) {
        return 'rate_limit';
      }
      if (code >= 400 && code < 500) {
        return 'invalid';
      }
      if (code >= 500) {
        return 'failed';
      }
      return 'unknown';
    }
    exports.eventStatusFromHttpCode = eventStatusFromHttpCode;

  }, {}], 111: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var is_1 = require("./is");
    /**
     * Truncates given string to the maximum characters count
     *
     * @param str An object that contains serializable values
     * @param max Maximum number of characters in truncated string (0 = unlimited)
     * @returns string Encoded
     */
    function truncate(str, max) {
      if (max === void 0) { max = 0; }
      if (typeof str !== 'string' || max === 0) {
        return str;
      }
      return str.length <= max ? str : str.substr(0, max) + "...";
    }
    exports.truncate = truncate;
    /**
     * This is basically just `trim_line` from
     * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67
     *
     * @param str An object that contains serializable values
     * @param max Maximum number of characters in truncated string
     * @returns string Encoded
     */
    function snipLine(line, colno) {
      var newLine = line;
      var lineLength = newLine.length;
      if (lineLength <= 150) {
        return newLine;
      }
      if (colno > lineLength) {
        // eslint-disable-next-line no-param-reassign
        colno = lineLength;
      }
      var start = Math.max(colno - 60, 0);
      if (start < 5) {
        start = 0;
      }
      var end = Math.min(start + 140, lineLength);
      if (end > lineLength - 5) {
        end = lineLength;
      }
      if (end === lineLength) {
        start = Math.max(end - 140, 0);
      }
      newLine = newLine.slice(start, end);
      if (start > 0) {
        newLine = "'{snip} " + newLine;
      }
      if (end < lineLength) {
        newLine += ' {snip}';
      }
      return newLine;
    }
    exports.snipLine = snipLine;
    /**
     * Join values in array
     * @param input array of values to be joined together
     * @param delimiter string to be placed in-between values
     * @returns Joined values
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function safeJoin(input, delimiter) {
      if (!Array.isArray(input)) {
        return '';
      }
      var output = [];
      // eslint-disable-next-line @typescript-eslint/prefer-for-of
      for (var i = 0; i < input.length; i++) {
        var value = input[i];
        try {
          output.push(String(value));
        }
        catch (e) {
          output.push('[value cannot be serialized]');
        }
      }
      return output.join(delimiter);
    }
    exports.safeJoin = safeJoin;
    /**
     * Checks if the value matches a regex or includes the string
     * @param value The string value to be checked against
     * @param pattern Either a regex or a string that must be contained in value
     */
    function isMatchingPattern(value, pattern) {
      if (!is_1.isString(value)) {
        return false;
      }
      if (is_1.isRegExp(pattern)) {
        return pattern.test(value);
      }
      if (typeof pattern === 'string') {
        return value.indexOf(pattern) !== -1;
      }
      return false;
    }
    exports.isMatchingPattern = isMatchingPattern;
    /**
     * Given a string, escape characters which have meaning in the regex grammar, such that the result is safe to feed to
     * `new RegExp()`.
     *
     * Based on https://github.com/sindresorhus/escape-string-regexp. Vendored to a) reduce the size by skipping the runtime
     * type-checking, and b) ensure it gets down-compiled for old versions of Node (the published package only supports Node
     * 12+).
     *
     * @param regexString The string to escape
     * @returns An version of the string with all special regex characters escaped
     */
    function escapeStringForRegex(regexString) {
      // escape the hyphen separately so we can also replace it with a unicode literal hyphen, to avoid the problems
      // discussed in https://github.com/sindresorhus/escape-string-regexp/issues/20.
      return regexString.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
    }
    exports.escapeStringForRegex = escapeStringForRegex;

  }, { "./is": 97 }], 112: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var flags_1 = require("./flags");
    var global_1 = require("./global");
    var logger_1 = require("./logger");
    /**
     * Tells whether current environment supports ErrorEvent objects
     * {@link supportsErrorEvent}.
     *
     * @returns Answer to the given question.
     */
    function supportsErrorEvent() {
      try {
        new ErrorEvent('');
        return true;
      }
      catch (e) {
        return false;
      }
    }
    exports.supportsErrorEvent = supportsErrorEvent;
    /**
     * Tells whether current environment supports DOMError objects
     * {@link supportsDOMError}.
     *
     * @returns Answer to the given question.
     */
    function supportsDOMError() {
      try {
        // Chrome: VM89:1 Uncaught TypeError: Failed to construct 'DOMError':
        // 1 argument required, but only 0 present.
        // @ts-ignore It really needs 1 argument, not 0.
        new DOMError('');
        return true;
      }
      catch (e) {
        return false;
      }
    }
    exports.supportsDOMError = supportsDOMError;
    /**
     * Tells whether current environment supports DOMException objects
     * {@link supportsDOMException}.
     *
     * @returns Answer to the given question.
     */
    function supportsDOMException() {
      try {
        new DOMException('');
        return true;
      }
      catch (e) {
        return false;
      }
    }
    exports.supportsDOMException = supportsDOMException;
    /**
     * Tells whether current environment supports Fetch API
     * {@link supportsFetch}.
     *
     * @returns Answer to the given question.
     */
    function supportsFetch() {
      if (!('fetch' in global_1.getGlobalObject())) {
        return false;
      }
      try {
        new Headers();
        new Request('');
        new Response();
        return true;
      }
      catch (e) {
        return false;
      }
    }
    exports.supportsFetch = supportsFetch;
    /**
     * isNativeFetch checks if the given function is a native implementation of fetch()
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    function isNativeFetch(func) {
      return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
    }
    exports.isNativeFetch = isNativeFetch;
    /**
     * Tells whether current environment supports Fetch API natively
     * {@link supportsNativeFetch}.
     *
     * @returns true if `window.fetch` is natively implemented, false otherwise
     */
    function supportsNativeFetch() {
      if (!supportsFetch()) {
        return false;
      }
      var global = global_1.getGlobalObject();
      // Fast path to avoid DOM I/O
      // eslint-disable-next-line @typescript-eslint/unbound-method
      if (isNativeFetch(global.fetch)) {
        return true;
      }
      // window.fetch is implemented, but is polyfilled or already wrapped (e.g: by a chrome extension)
      // so create a "pure" iframe to see if that has native fetch
      var result = false;
      var doc = global.document;
      // eslint-disable-next-line deprecation/deprecation
      if (doc && typeof doc.createElement === 'function') {
        try {
          var sandbox = doc.createElement('iframe');
          sandbox.hidden = true;
          doc.head.appendChild(sandbox);
          if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            result = isNativeFetch(sandbox.contentWindow.fetch);
          }
          doc.head.removeChild(sandbox);
        }
        catch (err) {
          flags_1.IS_DEBUG_BUILD &&
            logger_1.logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', err);
        }
      }
      return result;
    }
    exports.supportsNativeFetch = supportsNativeFetch;
    /**
     * Tells whether current environment supports ReportingObserver API
     * {@link supportsReportingObserver}.
     *
     * @returns Answer to the given question.
     */
    function supportsReportingObserver() {
      return 'ReportingObserver' in global_1.getGlobalObject();
    }
    exports.supportsReportingObserver = supportsReportingObserver;
    /**
     * Tells whether current environment supports Referrer Policy API
     * {@link supportsReferrerPolicy}.
     *
     * @returns Answer to the given question.
     */
    function supportsReferrerPolicy() {
      // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default'
      // (see https://caniuse.com/#feat=referrer-policy),
      // it doesn't. And it throws an exception instead of ignoring this parameter...
      // REF: https://github.com/getsentry/raven-js/issues/1233
      if (!supportsFetch()) {
        return false;
      }
      try {
        new Request('_', {
          referrerPolicy: 'origin',
        });
        return true;
      }
      catch (e) {
        return false;
      }
    }
    exports.supportsReferrerPolicy = supportsReferrerPolicy;
    /**
     * Tells whether current environment supports History API
     * {@link supportsHistory}.
     *
     * @returns Answer to the given question.
     */
    function supportsHistory() {
      // NOTE: in Chrome App environment, touching history.pushState, *even inside
      //       a try/catch block*, will cause Chrome to output an error to console.error
      // borrowed from: https://github.com/angular/angular.js/pull/13945/files
      var global = global_1.getGlobalObject();
      /* eslint-disable @typescript-eslint/no-unsafe-member-access */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var chrome = global.chrome;
      var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
      /* eslint-enable @typescript-eslint/no-unsafe-member-access */
      var hasHistoryApi = 'history' in global && !!global.history.pushState && !!global.history.replaceState;
      return !isChromePackagedApp && hasHistoryApi;
    }
    exports.supportsHistory = supportsHistory;

  }, { "./flags": 93, "./global": 94, "./logger": 98 }], 113: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    /* eslint-disable @typescript-eslint/explicit-function-return-type */
    /* eslint-disable @typescript-eslint/typedef */
    /* eslint-disable @typescript-eslint/explicit-module-boundary-types */
    /* eslint-disable @typescript-eslint/no-explicit-any */
    var is_1 = require("./is");
    /**
     * Creates a resolved sync promise.
     *
     * @param value the value to resolve the promise with
     * @returns the resolved sync promise
     */
    function resolvedSyncPromise(value) {
      return new SyncPromise(function (resolve) {
        resolve(value);
      });
    }
    exports.resolvedSyncPromise = resolvedSyncPromise;
    /**
     * Creates a rejected sync promise.
     *
     * @param value the value to reject the promise with
     * @returns the rejected sync promise
     */
    function rejectedSyncPromise(reason) {
      return new SyncPromise(function (_, reject) {
        reject(reason);
      });
    }
    exports.rejectedSyncPromise = rejectedSyncPromise;
    /**
     * Thenable class that behaves like a Promise and follows it's interface
     * but is not async internally
     */
    var SyncPromise = /** @class */ (function () {
      function SyncPromise(executor) {
        var _this = this;
        this._state = 0 /* PENDING */;
        this._handlers = [];
        /** JSDoc */
        this._resolve = function (value) {
          _this._setResult(1 /* RESOLVED */, value);
        };
        /** JSDoc */
        this._reject = function (reason) {
          _this._setResult(2 /* REJECTED */, reason);
        };
        /** JSDoc */
        this._setResult = function (state, value) {
          if (_this._state !== 0 /* PENDING */) {
            return;
          }
          if (is_1.isThenable(value)) {
            void value.then(_this._resolve, _this._reject);
            return;
          }
          _this._state = state;
          _this._value = value;
          _this._executeHandlers();
        };
        /** JSDoc */
        this._executeHandlers = function () {
          if (_this._state === 0 /* PENDING */) {
            return;
          }
          var cachedHandlers = _this._handlers.slice();
          _this._handlers = [];
          cachedHandlers.forEach(function (handler) {
            if (handler[0]) {
              return;
            }
            if (_this._state === 1 /* RESOLVED */) {
              // eslint-disable-next-line @typescript-eslint/no-floating-promises
              handler[1](_this._value);
            }
            if (_this._state === 2 /* REJECTED */) {
              handler[2](_this._value);
            }
            handler[0] = true;
          });
        };
        try {
          executor(this._resolve, this._reject);
        }
        catch (e) {
          this._reject(e);
        }
      }
      /** JSDoc */
      SyncPromise.prototype.then = function (onfulfilled, onrejected) {
        var _this = this;
        return new SyncPromise(function (resolve, reject) {
          _this._handlers.push([
            false,
            function (result) {
              if (!onfulfilled) {
                // TODO: ¯\_(ツ)_/¯
                // TODO: FIXME
                resolve(result);
              }
              else {
                try {
                  resolve(onfulfilled(result));
                }
                catch (e) {
                  reject(e);
                }
              }
            },
            function (reason) {
              if (!onrejected) {
                reject(reason);
              }
              else {
                try {
                  resolve(onrejected(reason));
                }
                catch (e) {
                  reject(e);
                }
              }
            },
          ]);
          _this._executeHandlers();
        });
      };
      /** JSDoc */
      SyncPromise.prototype.catch = function (onrejected) {
        return this.then(function (val) { return val; }, onrejected);
      };
      /** JSDoc */
      SyncPromise.prototype.finally = function (onfinally) {
        var _this = this;
        return new SyncPromise(function (resolve, reject) {
          var val;
          var isRejected;
          return _this.then(function (value) {
            isRejected = false;
            val = value;
            if (onfinally) {
              onfinally();
            }
          }, function (reason) {
            isRejected = true;
            val = reason;
            if (onfinally) {
              onfinally();
            }
          }).then(function () {
            if (isRejected) {
              reject(val);
              return;
            }
            resolve(val);
          });
        });
      };
      return SyncPromise;
    }());
    exports.SyncPromise = SyncPromise;

  }, { "./is": 97 }], 114: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var global_1 = require("./global");
    var node_1 = require("./node");
    /**
     * A TimestampSource implementation for environments that do not support the Performance Web API natively.
     *
     * Note that this TimestampSource does not use a monotonic clock. A call to `nowSeconds` may return a timestamp earlier
     * than a previously returned value. We do not try to emulate a monotonic behavior in order to facilitate debugging. It
     * is more obvious to explain "why does my span have negative duration" than "why my spans have zero duration".
     */
    var dateTimestampSource = {
      nowSeconds: function () { return Date.now() / 1000; },
    };
    /**
     * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not
     * support the API.
     *
     * Wrapping the native API works around differences in behavior from different browsers.
     */
    function getBrowserPerformance() {
      var performance = global_1.getGlobalObject().performance;
      if (!performance || !performance.now) {
        return undefined;
      }
      // Replace performance.timeOrigin with our own timeOrigin based on Date.now().
      //
      // This is a partial workaround for browsers reporting performance.timeOrigin such that performance.timeOrigin +
      // performance.now() gives a date arbitrarily in the past.
      //
      // Additionally, computing timeOrigin in this way fills the gap for browsers where performance.timeOrigin is
      // undefined.
      //
      // The assumption that performance.timeOrigin + performance.now() ~= Date.now() is flawed, but we depend on it to
      // interact with data coming out of performance entries.
      //
      // Note that despite recommendations against it in the spec, browsers implement the Performance API with a clock that
      // might stop when the computer is asleep (and perhaps under other circumstances). Such behavior causes
      // performance.timeOrigin + performance.now() to have an arbitrary skew over Date.now(). In laptop computers, we have
      // observed skews that can be as long as days, weeks or months.
      //
      // See https://github.com/getsentry/sentry-javascript/issues/2590.
      //
      // BUG: despite our best intentions, this workaround has its limitations. It mostly addresses timings of pageload
      // transactions, but ignores the skew built up over time that can aversely affect timestamps of navigation
      // transactions of long-lived web pages.
      var timeOrigin = Date.now() - performance.now();
      return {
        now: function () { return performance.now(); },
        timeOrigin: timeOrigin,
      };
    }
    /**
     * Returns the native Performance API implementation from Node.js. Returns undefined in old Node.js versions that don't
     * implement the API.
     */
    function getNodePerformance() {
      try {
        var perfHooks = node_1.dynamicRequire(module, 'perf_hooks');
        return perfHooks.performance;
      }
      catch (_) {
        return undefined;
      }
    }
    /**
     * The Performance API implementation for the current platform, if available.
     */
    var platformPerformance = node_1.isNodeEnv() ? getNodePerformance() : getBrowserPerformance();
    var timestampSource = platformPerformance === undefined
      ? dateTimestampSource
      : {
        nowSeconds: function () { return (platformPerformance.timeOrigin + platformPerformance.now()) / 1000; },
      };
    /**
     * Returns a timestamp in seconds since the UNIX epoch using the Date API.
     */
    exports.dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);
    /**
     * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the
     * availability of the Performance API.
     *
     * See `usingPerformanceAPI` to test whether the Performance API is used.
     *
     * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is
     * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The
     * skew can grow to arbitrary amounts like days, weeks or months.
     * See https://github.com/getsentry/sentry-javascript/issues/2590.
     */
    exports.timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);
    // Re-exported with an old name for backwards-compatibility.
    exports.timestampWithMs = exports.timestampInSeconds;
    /**
     * A boolean that is true when timestampInSeconds uses the Performance API to produce monotonic timestamps.
     */
    exports.usingPerformanceAPI = platformPerformance !== undefined;
    /**
     * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the
     * performance API is available.
     */
    exports.browserPerformanceTimeOrigin = (function () {
      // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or
      // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin
      // data as reliable if they are within a reasonable threshold of the current time.
      var performance = global_1.getGlobalObject().performance;
      if (!performance || !performance.now) {
        exports._browserPerformanceTimeOriginMode = 'none';
        return undefined;
      }
      var threshold = 3600 * 1000;
      var performanceNow = performance.now();
      var dateNow = Date.now();
      // if timeOrigin isn't available set delta to threshold so it isn't used
      var timeOriginDelta = performance.timeOrigin
        ? Math.abs(performance.timeOrigin + performanceNow - dateNow)
        : threshold;
      var timeOriginIsReliable = timeOriginDelta < threshold;
      // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin
      // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.
      // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always
      // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the
      // Date API.
      // eslint-disable-next-line deprecation/deprecation
      var navigationStart = performance.timing && performance.timing.navigationStart;
      var hasNavigationStart = typeof navigationStart === 'number';
      // if navigationStart isn't available set delta to threshold so it isn't used
      var navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
      var navigationStartIsReliable = navigationStartDelta < threshold;
      if (timeOriginIsReliable || navigationStartIsReliable) {
        // Use the more reliable time origin
        if (timeOriginDelta <= navigationStartDelta) {
          exports._browserPerformanceTimeOriginMode = 'timeOrigin';
          return performance.timeOrigin;
        }
        else {
          exports._browserPerformanceTimeOriginMode = 'navigationStart';
          return navigationStart;
        }
      }
      // Either both timeOrigin and navigationStart are skewed or neither is available, fallback to Date.
      exports._browserPerformanceTimeOriginMode = 'dateNow';
      return dateNow;
    })();

  }, { "./global": 94, "./node": 101 }], 115: [function (require, module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TRACEPARENT_REGEXP = new RegExp('^[ \\t]*' + // whitespace
      '([0-9a-f]{32})?' + // trace_id
      '-?([0-9a-f]{16})?' + // span_id
      '-?([01])?' + // sampled
      '[ \\t]*$');
    /**
     * Extract transaction context data from a `sentry-trace` header.
     *
     * @param traceparent Traceparent string
     *
     * @returns Object containing data from the header, or undefined if traceparent string is malformed
     */
    function extractTraceparentData(traceparent) {
      var matches = traceparent.match(exports.TRACEPARENT_REGEXP);
      if (matches) {
        var parentSampled = void 0;
        if (matches[3] === '1') {
          parentSampled = true;
        }
        else if (matches[3] === '0') {
          parentSampled = false;
        }
        return {
          traceId: matches[1],
          parentSampled: parentSampled,
          parentSpanId: matches[2],
        };
      }
      return undefined;
    }
    exports.extractTraceparentData = extractTraceparentData;

  }, {}], 116: [function (require, module, exports) {

    /**
     * Array#filter.
     *
     * @param {Array} arr
     * @param {Function} fn
     * @param {Object=} self
     * @return {Array}
     * @throw TypeError
     */

    module.exports = function (arr, fn, self) {
      if (arr.filter) return arr.filter(fn, self);
      if (void 0 === arr || null === arr) throw new TypeError;
      if ('function' != typeof fn) throw new TypeError;
      var ret = [];
      for (var i = 0; i < arr.length; i++) {
        if (!hasOwn.call(arr, i)) continue;
        var val = arr[i];
        if (fn.call(self, val, i, arr)) ret.push(val);
      }
      return ret;
    };

    var hasOwn = Object.prototype.hasOwnProperty;

  }, {}], 117: [function (require, module, exports) {
    (function (global) {
      (function () {
        'use strict';

        var objectAssign = require('object-assign');

        // compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
        // original notice:

        /*!
         * The buffer module from node.js, for the browser.
         *
         * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
         * @license  MIT
         */
        function compare(a, b) {
          if (a === b) {
            return 0;
          }

          var x = a.length;
          var y = b.length;

          for (var i = 0, len = Math.min(x, y); i < len; ++i) {
            if (a[i] !== b[i]) {
              x = a[i];
              y = b[i];
              break;
            }
          }

          if (x < y) {
            return -1;
          }
          if (y < x) {
            return 1;
          }
          return 0;
        }
        function isBuffer(b) {
          if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
            return global.Buffer.isBuffer(b);
          }
          return !!(b != null && b._isBuffer);
        }

        // based on node assert, original notice:
        // NB: The URL to the CommonJS spec is kept just for tradition.
        //     node-assert has evolved a lot since then, both in API and behavior.

        // http://wiki.commonjs.org/wiki/Unit_Testing/1.0
        //
        // THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
        //
        // Originally from narwhal.js (http://narwhaljs.org)
        // Copyright (c) 2009 Thomas Robinson <280north.com>
        //
        // Permission is hereby granted, free of charge, to any person obtaining a copy
        // of this software and associated documentation files (the 'Software'), to
        // deal in the Software without restriction, including without limitation the
        // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
        // sell copies of the Software, and to permit persons to whom the Software is
        // furnished to do so, subject to the following conditions:
        //
        // The above copyright notice and this permission notice shall be included in
        // all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
        // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
        // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

        var util = require('util/');
        var hasOwn = Object.prototype.hasOwnProperty;
        var pSlice = Array.prototype.slice;
        var functionsHaveNames = (function () {
          return function foo() { }.name === 'foo';
        }());
        function pToString(obj) {
          return Object.prototype.toString.call(obj);
        }
        function isView(arrbuf) {
          if (isBuffer(arrbuf)) {
            return false;
          }
          if (typeof global.ArrayBuffer !== 'function') {
            return false;
          }
          if (typeof ArrayBuffer.isView === 'function') {
            return ArrayBuffer.isView(arrbuf);
          }
          if (!arrbuf) {
            return false;
          }
          if (arrbuf instanceof DataView) {
            return true;
          }
          if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
            return true;
          }
          return false;
        }
        // 1. The assert module provides functions that throw
        // AssertionError's when particular conditions are not met. The
        // assert module must conform to the following interface.

        var assert = module.exports = ok;

        // 2. The AssertionError is defined in assert.
        // new assert.AssertionError({ message: message,
        //                             actual: actual,
        //                             expected: expected })

        var regex = /\s*function\s+([^\(\s]*)\s*/;
        // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
        function getName(func) {
          if (!util.isFunction(func)) {
            return;
          }
          if (functionsHaveNames) {
            return func.name;
          }
          var str = func.toString();
          var match = str.match(regex);
          return match && match[1];
        }
        assert.AssertionError = function AssertionError(options) {
          this.name = 'AssertionError';
          this.actual = options.actual;
          this.expected = options.expected;
          this.operator = options.operator;
          if (options.message) {
            this.message = options.message;
            this.generatedMessage = false;
          } else {
            this.message = getMessage(this);
            this.generatedMessage = true;
          }
          var stackStartFunction = options.stackStartFunction || fail;
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, stackStartFunction);
          } else {
            // non v8 browsers so we can have a stacktrace
            var err = new Error();
            if (err.stack) {
              var out = err.stack;

              // try to strip useless frames
              var fn_name = getName(stackStartFunction);
              var idx = out.indexOf('\n' + fn_name);
              if (idx >= 0) {
                // once we have located the function frame
                // we need to strip out everything before it (and its line)
                var next_line = out.indexOf('\n', idx + 1);
                out = out.substring(next_line + 1);
              }

              this.stack = out;
            }
          }
        };

        // assert.AssertionError instanceof Error
        util.inherits(assert.AssertionError, Error);

        function truncate(s, n) {
          if (typeof s === 'string') {
            return s.length < n ? s : s.slice(0, n);
          } else {
            return s;
          }
        }
        function inspect(something) {
          if (functionsHaveNames || !util.isFunction(something)) {
            return util.inspect(something);
          }
          var rawname = getName(something);
          var name = rawname ? ': ' + rawname : '';
          return '[Function' + name + ']';
        }
        function getMessage(self) {
          return truncate(inspect(self.actual), 128) + ' ' +
            self.operator + ' ' +
            truncate(inspect(self.expected), 128);
        }

        // At present only the three keys mentioned above are used and
        // understood by the spec. Implementations or sub modules can pass
        // other keys to the AssertionError's constructor - they will be
        // ignored.

        // 3. All of the following functions must throw an AssertionError
        // when a corresponding condition is not met, with a message that
        // may be undefined if not provided.  All assertion methods provide
        // both the actual and expected values to the assertion error for
        // display purposes.

        function fail(actual, expected, message, operator, stackStartFunction) {
          throw new assert.AssertionError({
            message: message,
            actual: actual,
            expected: expected,
            operator: operator,
            stackStartFunction: stackStartFunction
          });
        }

        // EXTENSION! allows for well behaved errors defined elsewhere.
        assert.fail = fail;

        // 4. Pure assertion tests whether a value is truthy, as determined
        // by !!guard.
        // assert.ok(guard, message_opt);
        // This statement is equivalent to assert.equal(true, !!guard,
        // message_opt);. To test strictly for the value true, use
        // assert.strictEqual(true, guard, message_opt);.

        function ok(value, message) {
          if (!value) fail(value, true, message, '==', assert.ok);
        }
        assert.ok = ok;

        // 5. The equality assertion tests shallow, coercive equality with
        // ==.
        // assert.equal(actual, expected, message_opt);

        assert.equal = function equal(actual, expected, message) {
          if (actual != expected) fail(actual, expected, message, '==', assert.equal);
        };

        // 6. The non-equality assertion tests for whether two objects are not equal
        // with != assert.notEqual(actual, expected, message_opt);

        assert.notEqual = function notEqual(actual, expected, message) {
          if (actual == expected) {
            fail(actual, expected, message, '!=', assert.notEqual);
          }
        };

        // 7. The equivalence assertion tests a deep equality relation.
        // assert.deepEqual(actual, expected, message_opt);

        assert.deepEqual = function deepEqual(actual, expected, message) {
          if (!_deepEqual(actual, expected, false)) {
            fail(actual, expected, message, 'deepEqual', assert.deepEqual);
          }
        };

        assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
          if (!_deepEqual(actual, expected, true)) {
            fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
          }
        };

        function _deepEqual(actual, expected, strict, memos) {
          // 7.1. All identical values are equivalent, as determined by ===.
          if (actual === expected) {
            return true;
          } else if (isBuffer(actual) && isBuffer(expected)) {
            return compare(actual, expected) === 0;

            // 7.2. If the expected value is a Date object, the actual value is
            // equivalent if it is also a Date object that refers to the same time.
          } else if (util.isDate(actual) && util.isDate(expected)) {
            return actual.getTime() === expected.getTime();

            // 7.3 If the expected value is a RegExp object, the actual value is
            // equivalent if it is also a RegExp object with the same source and
            // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
          } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
            return actual.source === expected.source &&
              actual.global === expected.global &&
              actual.multiline === expected.multiline &&
              actual.lastIndex === expected.lastIndex &&
              actual.ignoreCase === expected.ignoreCase;

            // 7.4. Other pairs that do not both pass typeof value == 'object',
            // equivalence is determined by ==.
          } else if ((actual === null || typeof actual !== 'object') &&
            (expected === null || typeof expected !== 'object')) {
            return strict ? actual === expected : actual == expected;

            // If both values are instances of typed arrays, wrap their underlying
            // ArrayBuffers in a Buffer each to increase performance
            // This optimization requires the arrays to have the same type as checked by
            // Object.prototype.toString (aka pToString). Never perform binary
            // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
            // bit patterns are not identical.
          } else if (isView(actual) && isView(expected) &&
            pToString(actual) === pToString(expected) &&
            !(actual instanceof Float32Array ||
              actual instanceof Float64Array)) {
            return compare(new Uint8Array(actual.buffer),
              new Uint8Array(expected.buffer)) === 0;

            // 7.5 For all other Object pairs, including Array objects, equivalence is
            // determined by having the same number of owned properties (as verified
            // with Object.prototype.hasOwnProperty.call), the same set of keys
            // (although not necessarily the same order), equivalent values for every
            // corresponding key, and an identical 'prototype' property. Note: this
            // accounts for both named and indexed properties on Arrays.
          } else if (isBuffer(actual) !== isBuffer(expected)) {
            return false;
          } else {
            memos = memos || { actual: [], expected: [] };

            var actualIndex = memos.actual.indexOf(actual);
            if (actualIndex !== -1) {
              if (actualIndex === memos.expected.indexOf(expected)) {
                return true;
              }
            }

            memos.actual.push(actual);
            memos.expected.push(expected);

            return objEquiv(actual, expected, strict, memos);
          }
        }

        function isArguments(object) {
          return Object.prototype.toString.call(object) == '[object Arguments]';
        }

        function objEquiv(a, b, strict, actualVisitedObjects) {
          if (a === null || a === undefined || b === null || b === undefined)
            return false;
          // if one is a primitive, the other must be same
          if (util.isPrimitive(a) || util.isPrimitive(b))
            return a === b;
          if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
            return false;
          var aIsArgs = isArguments(a);
          var bIsArgs = isArguments(b);
          if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
            return false;
          if (aIsArgs) {
            a = pSlice.call(a);
            b = pSlice.call(b);
            return _deepEqual(a, b, strict);
          }
          var ka = objectKeys(a);
          var kb = objectKeys(b);
          var key, i;
          // having the same number of owned properties (keys incorporates
          // hasOwnProperty)
          if (ka.length !== kb.length)
            return false;
          //the same set of keys (although not necessarily the same order),
          ka.sort();
          kb.sort();
          //~~~cheap key test
          for (i = ka.length - 1; i >= 0; i--) {
            if (ka[i] !== kb[i])
              return false;
          }
          //equivalent values for every corresponding key, and
          //~~~possibly expensive deep test
          for (i = ka.length - 1; i >= 0; i--) {
            key = ka[i];
            if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
              return false;
          }
          return true;
        }

        // 8. The non-equivalence assertion tests for any deep inequality.
        // assert.notDeepEqual(actual, expected, message_opt);

        assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
          if (_deepEqual(actual, expected, false)) {
            fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
          }
        };

        assert.notDeepStrictEqual = notDeepStrictEqual;
        function notDeepStrictEqual(actual, expected, message) {
          if (_deepEqual(actual, expected, true)) {
            fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
          }
        }


        // 9. The strict equality assertion tests strict equality, as determined by ===.
        // assert.strictEqual(actual, expected, message_opt);

        assert.strictEqual = function strictEqual(actual, expected, message) {
          if (actual !== expected) {
            fail(actual, expected, message, '===', assert.strictEqual);
          }
        };

        // 10. The strict non-equality assertion tests for strict inequality, as
        // determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

        assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
          if (actual === expected) {
            fail(actual, expected, message, '!==', assert.notStrictEqual);
          }
        };

        function expectedException(actual, expected) {
          if (!actual || !expected) {
            return false;
          }

          if (Object.prototype.toString.call(expected) == '[object RegExp]') {
            return expected.test(actual);
          }

          try {
            if (actual instanceof expected) {
              return true;
            }
          } catch (e) {
            // Ignore.  The instanceof check doesn't work for arrow functions.
          }

          if (Error.isPrototypeOf(expected)) {
            return false;
          }

          return expected.call({}, actual) === true;
        }

        function _tryBlock(block) {
          var error;
          try {
            block();
          } catch (e) {
            error = e;
          }
          return error;
        }

        function _throws(shouldThrow, block, expected, message) {
          var actual;

          if (typeof block !== 'function') {
            throw new TypeError('"block" argument must be a function');
          }

          if (typeof expected === 'string') {
            message = expected;
            expected = null;
          }

          actual = _tryBlock(block);

          message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

          if (shouldThrow && !actual) {
            fail(actual, expected, 'Missing expected exception' + message);
          }

          var userProvidedMessage = typeof message === 'string';
          var isUnwantedException = !shouldThrow && util.isError(actual);
          var isUnexpectedException = !shouldThrow && actual && !expected;

          if ((isUnwantedException &&
            userProvidedMessage &&
            expectedException(actual, expected)) ||
            isUnexpectedException) {
            fail(actual, expected, 'Got unwanted exception' + message);
          }

          if ((shouldThrow && actual && expected &&
            !expectedException(actual, expected)) || (!shouldThrow && actual)) {
            throw actual;
          }
        }

        // 11. Expected to throw an error:
        // assert.throws(block, Error_opt, message_opt);

        assert.throws = function (block, /*optional*/error, /*optional*/message) {
          _throws(true, block, error, message);
        };

        // EXTENSION! This is annoying to write outside this module.
        assert.doesNotThrow = function (block, /*optional*/error, /*optional*/message) {
          _throws(false, block, error, message);
        };

        assert.ifError = function (err) { if (err) throw err; };

        // Expose a strict only variant of assert
        function strict(value, message) {
          if (!value) fail(value, true, message, '==', strict);
        }
        assert.strict = objectAssign(strict, assert, {
          equal: assert.strictEqual,
          deepEqual: assert.deepStrictEqual,
          notEqual: assert.notStrictEqual,
          notDeepEqual: assert.notDeepStrictEqual
        });
        assert.strict.strict = assert.strict;

        var objectKeys = Object.keys || function (obj) {
          var keys = [];
          for (var key in obj) {
            if (hasOwn.call(obj, key)) keys.push(key);
          }
          return keys;
        };

      }).call(this)
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  }, { "object-assign": 151, "util/": 120 }], 118: [function (require, module, exports) {
    if (typeof Object.create === 'function') {
      // implementation from standard node.js 'util' module
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      // old school shim for old browsers
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor
        var TempCtor = function () { }
        TempCtor.prototype = superCtor.prototype
        ctor.prototype = new TempCtor()
        ctor.prototype.constructor = ctor
      }
    }

  }, {}], 119: [function (require, module, exports) {
    module.exports = function isBuffer(arg) {
      return arg && typeof arg === 'object'
        && typeof arg.copy === 'function'
        && typeof arg.fill === 'function'
        && typeof arg.readUInt8 === 'function';
    }
  }, {}], 120: [function (require, module, exports) {
    (function (process, global) {
      (function () {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        var formatRegExp = /%[sdj%]/g;
        exports.format = function (f) {
          if (!isString(f)) {
            var objects = [];
            for (var i = 0; i < arguments.length; i++) {
              objects.push(inspect(arguments[i]));
            }
            return objects.join(' ');
          }

          var i = 1;
          var args = arguments;
          var len = args.length;
          var str = String(f).replace(formatRegExp, function (x) {
            if (x === '%%') return '%';
            if (i >= len) return x;
            switch (x) {
              case '%s': return String(args[i++]);
              case '%d': return Number(args[i++]);
              case '%j':
                try {
                  return JSON.stringify(args[i++]);
                } catch (_) {
                  return '[Circular]';
                }
              default:
                return x;
            }
          });
          for (var x = args[i]; i < len; x = args[++i]) {
            if (isNull(x) || !isObject(x)) {
              str += ' ' + x;
            } else {
              str += ' ' + inspect(x);
            }
          }
          return str;
        };


        // Mark that a method should not be used.
        // Returns a modified function which warns once by default.
        // If --no-deprecation is set, then it is a no-op.
        exports.deprecate = function (fn, msg) {
          // Allow for deprecating things in the process of starting up.
          if (isUndefined(global.process)) {
            return function () {
              return exports.deprecate(fn, msg).apply(this, arguments);
            };
          }

          if (process.noDeprecation === true) {
            return fn;
          }

          var warned = false;
          function deprecated() {
            if (!warned) {
              if (process.throwDeprecation) {
                throw new Error(msg);
              } else if (process.traceDeprecation) {
                console.trace(msg);
              } else {
                console.error(msg);
              }
              warned = true;
            }
            return fn.apply(this, arguments);
          }

          return deprecated;
        };


        var debugs = {};
        var debugEnviron;
        exports.debuglog = function (set) {
          if (isUndefined(debugEnviron))
            debugEnviron = process.env.NODE_DEBUG || '';
          set = set.toUpperCase();
          if (!debugs[set]) {
            if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
              var pid = process.pid;
              debugs[set] = function () {
                var msg = exports.format.apply(exports, arguments);
                console.error('%s %d: %s', set, pid, msg);
              };
            } else {
              debugs[set] = function () { };
            }
          }
          return debugs[set];
        };


        /**
         * Echos the value of a value. Trys to print the value out
         * in the best way possible given the different types.
         *
         * @param {Object} obj The object to print out.
         * @param {Object} opts Optional options object that alters the output.
         */
        /* legacy: obj, showHidden, depth, colors*/
        function inspect(obj, opts) {
          // default options
          var ctx = {
            seen: [],
            stylize: stylizeNoColor
          };
          // legacy...
          if (arguments.length >= 3) ctx.depth = arguments[2];
          if (arguments.length >= 4) ctx.colors = arguments[3];
          if (isBoolean(opts)) {
            // legacy...
            ctx.showHidden = opts;
          } else if (opts) {
            // got an "options" object
            exports._extend(ctx, opts);
          }
          // set default options
          if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
          if (isUndefined(ctx.depth)) ctx.depth = 2;
          if (isUndefined(ctx.colors)) ctx.colors = false;
          if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
          if (ctx.colors) ctx.stylize = stylizeWithColor;
          return formatValue(ctx, obj, ctx.depth);
        }
        exports.inspect = inspect;


        // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
        inspect.colors = {
          'bold': [1, 22],
          'italic': [3, 23],
          'underline': [4, 24],
          'inverse': [7, 27],
          'white': [37, 39],
          'grey': [90, 39],
          'black': [30, 39],
          'blue': [34, 39],
          'cyan': [36, 39],
          'green': [32, 39],
          'magenta': [35, 39],
          'red': [31, 39],
          'yellow': [33, 39]
        };

        // Don't use 'blue' not visible on cmd.exe
        inspect.styles = {
          'special': 'cyan',
          'number': 'yellow',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red'
        };


        function stylizeWithColor(str, styleType) {
          var style = inspect.styles[styleType];

          if (style) {
            return '\u001b[' + inspect.colors[style][0] + 'm' + str +
              '\u001b[' + inspect.colors[style][1] + 'm';
          } else {
            return str;
          }
        }


        function stylizeNoColor(str, styleType) {
          return str;
        }


        function arrayToHash(array) {
          var hash = {};

          array.forEach(function (val, idx) {
            hash[val] = true;
          });

          return hash;
        }


        function formatValue(ctx, value, recurseTimes) {
          // Provide a hook for user-specified inspect functions.
          // Check that value is an object with an inspect function on it
          if (ctx.customInspect &&
            value &&
            isFunction(value.inspect) &&
            // Filter out the util module, it's inspect function is special
            value.inspect !== exports.inspect &&
            // Also filter out any prototype objects using the circular check.
            !(value.constructor && value.constructor.prototype === value)) {
            var ret = value.inspect(recurseTimes, ctx);
            if (!isString(ret)) {
              ret = formatValue(ctx, ret, recurseTimes);
            }
            return ret;
          }

          // Primitive types cannot have properties
          var primitive = formatPrimitive(ctx, value);
          if (primitive) {
            return primitive;
          }

          // Look up the keys of the object.
          var keys = Object.keys(value);
          var visibleKeys = arrayToHash(keys);

          if (ctx.showHidden) {
            keys = Object.getOwnPropertyNames(value);
          }

          // IE doesn't make error fields non-enumerable
          // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
          if (isError(value)
            && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
            return formatError(value);
          }

          // Some type of object without properties can be shortcutted.
          if (keys.length === 0) {
            if (isFunction(value)) {
              var name = value.name ? ': ' + value.name : '';
              return ctx.stylize('[Function' + name + ']', 'special');
            }
            if (isRegExp(value)) {
              return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
            }
            if (isDate(value)) {
              return ctx.stylize(Date.prototype.toString.call(value), 'date');
            }
            if (isError(value)) {
              return formatError(value);
            }
          }

          var base = '', array = false, braces = ['{', '}'];

          // Make Array say that they are Array
          if (isArray(value)) {
            array = true;
            braces = ['[', ']'];
          }

          // Make functions say that they are functions
          if (isFunction(value)) {
            var n = value.name ? ': ' + value.name : '';
            base = ' [Function' + n + ']';
          }

          // Make RegExps say that they are RegExps
          if (isRegExp(value)) {
            base = ' ' + RegExp.prototype.toString.call(value);
          }

          // Make dates with properties first say the date
          if (isDate(value)) {
            base = ' ' + Date.prototype.toUTCString.call(value);
          }

          // Make error with message first say the error
          if (isError(value)) {
            base = ' ' + formatError(value);
          }

          if (keys.length === 0 && (!array || value.length == 0)) {
            return braces[0] + base + braces[1];
          }

          if (recurseTimes < 0) {
            if (isRegExp(value)) {
              return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
            } else {
              return ctx.stylize('[Object]', 'special');
            }
          }

          ctx.seen.push(value);

          var output;
          if (array) {
            output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
          } else {
            output = keys.map(function (key) {
              return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
            });
          }

          ctx.seen.pop();

          return reduceToSingleString(output, base, braces);
        }


        function formatPrimitive(ctx, value) {
          if (isUndefined(value))
            return ctx.stylize('undefined', 'undefined');
          if (isString(value)) {
            var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
              .replace(/'/g, "\\'")
              .replace(/\\"/g, '"') + '\'';
            return ctx.stylize(simple, 'string');
          }
          if (isNumber(value))
            return ctx.stylize('' + value, 'number');
          if (isBoolean(value))
            return ctx.stylize('' + value, 'boolean');
          // For some reason typeof null is "object", so special case here.
          if (isNull(value))
            return ctx.stylize('null', 'null');
        }


        function formatError(value) {
          return '[' + Error.prototype.toString.call(value) + ']';
        }


        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
          var output = [];
          for (var i = 0, l = value.length; i < l; ++i) {
            if (hasOwnProperty(value, String(i))) {
              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                String(i), true));
            } else {
              output.push('');
            }
          }
          keys.forEach(function (key) {
            if (!key.match(/^\d+$/)) {
              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                key, true));
            }
          });
          return output;
        }


        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
          var name, str, desc;
          desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
          if (desc.get) {
            if (desc.set) {
              str = ctx.stylize('[Getter/Setter]', 'special');
            } else {
              str = ctx.stylize('[Getter]', 'special');
            }
          } else {
            if (desc.set) {
              str = ctx.stylize('[Setter]', 'special');
            }
          }
          if (!hasOwnProperty(visibleKeys, key)) {
            name = '[' + key + ']';
          }
          if (!str) {
            if (ctx.seen.indexOf(desc.value) < 0) {
              if (isNull(recurseTimes)) {
                str = formatValue(ctx, desc.value, null);
              } else {
                str = formatValue(ctx, desc.value, recurseTimes - 1);
              }
              if (str.indexOf('\n') > -1) {
                if (array) {
                  str = str.split('\n').map(function (line) {
                    return '  ' + line;
                  }).join('\n').substr(2);
                } else {
                  str = '\n' + str.split('\n').map(function (line) {
                    return '   ' + line;
                  }).join('\n');
                }
              }
            } else {
              str = ctx.stylize('[Circular]', 'special');
            }
          }
          if (isUndefined(name)) {
            if (array && key.match(/^\d+$/)) {
              return str;
            }
            name = JSON.stringify('' + key);
            if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
              name = name.substr(1, name.length - 2);
              name = ctx.stylize(name, 'name');
            } else {
              name = name.replace(/'/g, "\\'")
                .replace(/\\"/g, '"')
                .replace(/(^"|"$)/g, "'");
              name = ctx.stylize(name, 'string');
            }
          }

          return name + ': ' + str;
        }


        function reduceToSingleString(output, base, braces) {
          var numLinesEst = 0;
          var length = output.reduce(function (prev, cur) {
            numLinesEst++;
            if (cur.indexOf('\n') >= 0) numLinesEst++;
            return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
          }, 0);

          if (length > 60) {
            return braces[0] +
              (base === '' ? '' : base + '\n ') +
              ' ' +
              output.join(',\n  ') +
              ' ' +
              braces[1];
          }

          return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
        }


        // NOTE: These type checking functions intentionally don't use `instanceof`
        // because it is fragile and can be easily faked with `Object.create()`.
        function isArray(ar) {
          return Array.isArray(ar);
        }
        exports.isArray = isArray;

        function isBoolean(arg) {
          return typeof arg === 'boolean';
        }
        exports.isBoolean = isBoolean;

        function isNull(arg) {
          return arg === null;
        }
        exports.isNull = isNull;

        function isNullOrUndefined(arg) {
          return arg == null;
        }
        exports.isNullOrUndefined = isNullOrUndefined;

        function isNumber(arg) {
          return typeof arg === 'number';
        }
        exports.isNumber = isNumber;

        function isString(arg) {
          return typeof arg === 'string';
        }
        exports.isString = isString;

        function isSymbol(arg) {
          return typeof arg === 'symbol';
        }
        exports.isSymbol = isSymbol;

        function isUndefined(arg) {
          return arg === void 0;
        }
        exports.isUndefined = isUndefined;

        function isRegExp(re) {
          return isObject(re) && objectToString(re) === '[object RegExp]';
        }
        exports.isRegExp = isRegExp;

        function isObject(arg) {
          return typeof arg === 'object' && arg !== null;
        }
        exports.isObject = isObject;

        function isDate(d) {
          return isObject(d) && objectToString(d) === '[object Date]';
        }
        exports.isDate = isDate;

        function isError(e) {
          return isObject(e) &&
            (objectToString(e) === '[object Error]' || e instanceof Error);
        }
        exports.isError = isError;

        function isFunction(arg) {
          return typeof arg === 'function';
        }
        exports.isFunction = isFunction;

        function isPrimitive(arg) {
          return arg === null ||
            typeof arg === 'boolean' ||
            typeof arg === 'number' ||
            typeof arg === 'string' ||
            typeof arg === 'symbol' ||  // ES6 symbol
            typeof arg === 'undefined';
        }
        exports.isPrimitive = isPrimitive;

        exports.isBuffer = require('./support/isBuffer');

        function objectToString(o) {
          return Object.prototype.toString.call(o);
        }


        function pad(n) {
          return n < 10 ? '0' + n.toString(10) : n.toString(10);
        }


        var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
          'Oct', 'Nov', 'Dec'];

        // 26 Feb 16:19:34
        function timestamp() {
          var d = new Date();
          var time = [pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())].join(':');
          return [d.getDate(), months[d.getMonth()], time].join(' ');
        }


        // log is just a thin wrapper to console.log that prepends a timestamp
        exports.log = function () {
          console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
        };


        /**
         * Inherit the prototype methods from one constructor into another.
         *
         * The Function.prototype.inherits from lang.js rewritten as a standalone
         * function (not on Function.prototype). NOTE: If this file is to be loaded
         * during bootstrapping this function needs to be rewritten using some native
         * functions as prototype setup using normal JavaScript does not work as
         * expected during bootstrapping (see mirror.js in r114903).
         *
         * @param {function} ctor Constructor function which needs to inherit the
         *     prototype.
         * @param {function} superCtor Constructor function to inherit prototype from.
         */
        exports.inherits = require('inherits');

        exports._extend = function (origin, add) {
          // Don't do anything if add isn't an object
          if (!add || !isObject(add)) return origin;

          var keys = Object.keys(add);
          var i = keys.length;
          while (i--) {
            origin[keys[i]] = add[keys[i]];
          }
          return origin;
        };

        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }

      }).call(this)
    }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  }, { "./support/isBuffer": 119, "_process": 163, "inherits": 118 }], 121: [function (require, module, exports) {
    (function (global) {
      (function () {
        'use strict';

        var filter = require('array-filter');

        module.exports = function availableTypedArrays() {
          return filter([
            'BigInt64Array',
            'BigUint64Array',
            'Float32Array',
            'Float64Array',
            'Int16Array',
            'Int32Array',
            'Int8Array',
            'Uint16Array',
            'Uint32Array',
            'Uint8Array',
            'Uint8ClampedArray'
          ], function (typedArray) {
            return typeof global[typedArray] === 'function';
          });
        };

      }).call(this)
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  }, { "array-filter": 116 }], 122: [function (require, module, exports) {
    'use strict'

    exports.byteLength = byteLength
    exports.toByteArray = toByteArray
    exports.fromByteArray = fromByteArray

    var lookup = []
    var revLookup = []
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i]
      revLookup[code.charCodeAt(i)] = i
    }

    // Support decoding URL-safe base64 strings, as Node.js does.
    // See: https://en.wikipedia.org/wiki/Base64#URL_applications
    revLookup['-'.charCodeAt(0)] = 62
    revLookup['_'.charCodeAt(0)] = 63

    function getLens(b64) {
      var len = b64.length

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

      // Trim off extra bytes after placeholder bytes are found
      // See: https://github.com/beatgammit/base64-js/issues/42
      var validLen = b64.indexOf('=')
      if (validLen === -1) validLen = len

      var placeHoldersLen = validLen === len
        ? 0
        : 4 - (validLen % 4)

      return [validLen, placeHoldersLen]
    }

    // base64 is 4/3 + up to two characters of the original data
    function byteLength(b64) {
      var lens = getLens(b64)
      var validLen = lens[0]
      var placeHoldersLen = lens[1]
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }

    function _byteLength(b64, validLen, placeHoldersLen) {
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }

    function toByteArray(b64) {
      var tmp
      var lens = getLens(b64)
      var validLen = lens[0]
      var placeHoldersLen = lens[1]

      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

      var curByte = 0

      // if there are placeholders, only get up to the last complete 4 chars
      var len = placeHoldersLen > 0
        ? validLen - 4
        : validLen

      var i
      for (i = 0; i < len; i += 4) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 18) |
          (revLookup[b64.charCodeAt(i + 1)] << 12) |
          (revLookup[b64.charCodeAt(i + 2)] << 6) |
          revLookup[b64.charCodeAt(i + 3)]
        arr[curByte++] = (tmp >> 16) & 0xFF
        arr[curByte++] = (tmp >> 8) & 0xFF
        arr[curByte++] = tmp & 0xFF
      }

      if (placeHoldersLen === 2) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 2) |
          (revLookup[b64.charCodeAt(i + 1)] >> 4)
        arr[curByte++] = tmp & 0xFF
      }

      if (placeHoldersLen === 1) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 10) |
          (revLookup[b64.charCodeAt(i + 1)] << 4) |
          (revLookup[b64.charCodeAt(i + 2)] >> 2)
        arr[curByte++] = (tmp >> 8) & 0xFF
        arr[curByte++] = tmp & 0xFF
      }

      return arr
    }

    function tripletToBase64(num) {
      return lookup[num >> 18 & 0x3F] +
        lookup[num >> 12 & 0x3F] +
        lookup[num >> 6 & 0x3F] +
        lookup[num & 0x3F]
    }

    function encodeChunk(uint8, start, end) {
      var tmp
      var output = []
      for (var i = start; i < end; i += 3) {
        tmp =
          ((uint8[i] << 16) & 0xFF0000) +
          ((uint8[i + 1] << 8) & 0xFF00) +
          (uint8[i + 2] & 0xFF)
        output.push(tripletToBase64(tmp))
      }
      return output.join('')
    }

    function fromByteArray(uint8) {
      var tmp
      var len = uint8.length
      var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
      var parts = []
      var maxChunkLength = 16383 // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1]
        parts.push(
          lookup[tmp >> 2] +
          lookup[(tmp << 4) & 0x3F] +
          '=='
        )
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1]
        parts.push(
          lookup[tmp >> 10] +
          lookup[(tmp >> 4) & 0x3F] +
          lookup[(tmp << 2) & 0x3F] +
          '='
        )
      }

      return parts.join('')
    }

  }, {}], 123: [function (require, module, exports) {

  }, {}], 124: [function (require, module, exports) {
    (function (process, Buffer) {
      (function () {
        'use strict';
        /* eslint camelcase: "off" */

        var assert = require('assert');

        var Zstream = require('pako/lib/zlib/zstream');
        var zlib_deflate = require('pako/lib/zlib/deflate.js');
        var zlib_inflate = require('pako/lib/zlib/inflate.js');
        var constants = require('pako/lib/zlib/constants');

        for (var key in constants) {
          exports[key] = constants[key];
        }

        // zlib modes
        exports.NONE = 0;
        exports.DEFLATE = 1;
        exports.INFLATE = 2;
        exports.GZIP = 3;
        exports.GUNZIP = 4;
        exports.DEFLATERAW = 5;
        exports.INFLATERAW = 6;
        exports.UNZIP = 7;

        var GZIP_HEADER_ID1 = 0x1f;
        var GZIP_HEADER_ID2 = 0x8b;

        /**
         * Emulate Node's zlib C++ layer for use by the JS layer in index.js
         */
        function Zlib(mode) {
          if (typeof mode !== 'number' || mode < exports.DEFLATE || mode > exports.UNZIP) {
            throw new TypeError('Bad argument');
          }

          this.dictionary = null;
          this.err = 0;
          this.flush = 0;
          this.init_done = false;
          this.level = 0;
          this.memLevel = 0;
          this.mode = mode;
          this.strategy = 0;
          this.windowBits = 0;
          this.write_in_progress = false;
          this.pending_close = false;
          this.gzip_id_bytes_read = 0;
        }

        Zlib.prototype.close = function () {
          if (this.write_in_progress) {
            this.pending_close = true;
            return;
          }

          this.pending_close = false;

          assert(this.init_done, 'close before init');
          assert(this.mode <= exports.UNZIP);

          if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
            zlib_deflate.deflateEnd(this.strm);
          } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
            zlib_inflate.inflateEnd(this.strm);
          }

          this.mode = exports.NONE;

          this.dictionary = null;
        };

        Zlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {
          return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
        };

        Zlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {
          return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
        };

        Zlib.prototype._write = function (async, flush, input, in_off, in_len, out, out_off, out_len) {
          assert.equal(arguments.length, 8);

          assert(this.init_done, 'write before init');
          assert(this.mode !== exports.NONE, 'already finalized');
          assert.equal(false, this.write_in_progress, 'write already in progress');
          assert.equal(false, this.pending_close, 'close is pending');

          this.write_in_progress = true;

          assert.equal(false, flush === undefined, 'must provide flush value');

          this.write_in_progress = true;

          if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
            throw new Error('Invalid flush value');
          }

          if (input == null) {
            input = Buffer.alloc(0);
            in_len = 0;
            in_off = 0;
          }

          this.strm.avail_in = in_len;
          this.strm.input = input;
          this.strm.next_in = in_off;
          this.strm.avail_out = out_len;
          this.strm.output = out;
          this.strm.next_out = out_off;
          this.flush = flush;

          if (!async) {
            // sync version
            this._process();

            if (this._checkError()) {
              return this._afterSync();
            }
            return;
          }

          // async version
          var self = this;
          process.nextTick(function () {
            self._process();
            self._after();
          });

          return this;
        };

        Zlib.prototype._afterSync = function () {
          var avail_out = this.strm.avail_out;
          var avail_in = this.strm.avail_in;

          this.write_in_progress = false;

          return [avail_in, avail_out];
        };

        Zlib.prototype._process = function () {
          var next_expected_header_byte = null;

          // If the avail_out is left at 0, then it means that it ran out
          // of room.  If there was avail_out left over, then it means
          // that all of the input was consumed.
          switch (this.mode) {
            case exports.DEFLATE:
            case exports.GZIP:
            case exports.DEFLATERAW:
              this.err = zlib_deflate.deflate(this.strm, this.flush);
              break;
            case exports.UNZIP:
              if (this.strm.avail_in > 0) {
                next_expected_header_byte = this.strm.next_in;
              }

              switch (this.gzip_id_bytes_read) {
                case 0:
                  if (next_expected_header_byte === null) {
                    break;
                  }

                  if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
                    this.gzip_id_bytes_read = 1;
                    next_expected_header_byte++;

                    if (this.strm.avail_in === 1) {
                      // The only available byte was already read.
                      break;
                    }
                  } else {
                    this.mode = exports.INFLATE;
                    break;
                  }

                // fallthrough
                case 1:
                  if (next_expected_header_byte === null) {
                    break;
                  }

                  if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
                    this.gzip_id_bytes_read = 2;
                    this.mode = exports.GUNZIP;
                  } else {
                    // There is no actual difference between INFLATE and INFLATERAW
                    // (after initialization).
                    this.mode = exports.INFLATE;
                  }

                  break;
                default:
                  throw new Error('invalid number of gzip magic number bytes read');
              }

            // fallthrough
            case exports.INFLATE:
            case exports.GUNZIP:
            case exports.INFLATERAW:
              this.err = zlib_inflate.inflate(this.strm, this.flush

                // If data was encoded with dictionary
              ); if (this.err === exports.Z_NEED_DICT && this.dictionary) {
                // Load it
                this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
                if (this.err === exports.Z_OK) {
                  // And try to decode again
                  this.err = zlib_inflate.inflate(this.strm, this.flush);
                } else if (this.err === exports.Z_DATA_ERROR) {
                  // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.
                  // Make it possible for After() to tell a bad dictionary from bad
                  // input.
                  this.err = exports.Z_NEED_DICT;
                }
              }
              while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0x00) {
                // Bytes remain in input buffer. Perhaps this is another compressed
                // member in the same archive, or just trailing garbage.
                // Trailing zero bytes are okay, though, since they are frequently
                // used for padding.

                this.reset();
                this.err = zlib_inflate.inflate(this.strm, this.flush);
              }
              break;
            default:
              throw new Error('Unknown mode ' + this.mode);
          }
        };

        Zlib.prototype._checkError = function () {
          // Acceptable error states depend on the type of zlib stream.
          switch (this.err) {
            case exports.Z_OK:
            case exports.Z_BUF_ERROR:
              if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
                this._error('unexpected end of file');
                return false;
              }
              break;
            case exports.Z_STREAM_END:
              // normal statuses, not fatal
              break;
            case exports.Z_NEED_DICT:
              if (this.dictionary == null) {
                this._error('Missing dictionary');
              } else {
                this._error('Bad dictionary');
              }
              return false;
            default:
              // something else.
              this._error('Zlib error');
              return false;
          }

          return true;
        };

        Zlib.prototype._after = function () {
          if (!this._checkError()) {
            return;
          }

          var avail_out = this.strm.avail_out;
          var avail_in = this.strm.avail_in;

          this.write_in_progress = false;

          // call the write() cb
          this.callback(avail_in, avail_out);

          if (this.pending_close) {
            this.close();
          }
        };

        Zlib.prototype._error = function (message) {
          if (this.strm.msg) {
            message = this.strm.msg;
          }
          this.onerror(message, this.err

            // no hope of rescue.
          ); this.write_in_progress = false;
          if (this.pending_close) {
            this.close();
          }
        };

        Zlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {
          assert(arguments.length === 4 || arguments.length === 5, 'init(windowBits, level, memLevel, strategy, [dictionary])');

          assert(windowBits >= 8 && windowBits <= 15, 'invalid windowBits');
          assert(level >= -1 && level <= 9, 'invalid compression level');

          assert(memLevel >= 1 && memLevel <= 9, 'invalid memlevel');

          assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, 'invalid strategy');

          this._init(level, windowBits, memLevel, strategy, dictionary);
          this._setDictionary();
        };

        Zlib.prototype.params = function () {
          throw new Error('deflateParams Not supported');
        };

        Zlib.prototype.reset = function () {
          this._reset();
          this._setDictionary();
        };

        Zlib.prototype._init = function (level, windowBits, memLevel, strategy, dictionary) {
          this.level = level;
          this.windowBits = windowBits;
          this.memLevel = memLevel;
          this.strategy = strategy;

          this.flush = exports.Z_NO_FLUSH;

          this.err = exports.Z_OK;

          if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
            this.windowBits += 16;
          }

          if (this.mode === exports.UNZIP) {
            this.windowBits += 32;
          }

          if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
            this.windowBits = -1 * this.windowBits;
          }

          this.strm = new Zstream();

          switch (this.mode) {
            case exports.DEFLATE:
            case exports.GZIP:
            case exports.DEFLATERAW:
              this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
              break;
            case exports.INFLATE:
            case exports.GUNZIP:
            case exports.INFLATERAW:
            case exports.UNZIP:
              this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
              break;
            default:
              throw new Error('Unknown mode ' + this.mode);
          }

          if (this.err !== exports.Z_OK) {
            this._error('Init error');
          }

          this.dictionary = dictionary;

          this.write_in_progress = false;
          this.init_done = true;
        };

        Zlib.prototype._setDictionary = function () {
          if (this.dictionary == null) {
            return;
          }

          this.err = exports.Z_OK;

          switch (this.mode) {
            case exports.DEFLATE:
            case exports.DEFLATERAW:
              this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
              break;
            default:
              break;
          }

          if (this.err !== exports.Z_OK) {
            this._error('Failed to set dictionary');
          }
        };

        Zlib.prototype._reset = function () {
          this.err = exports.Z_OK;

          switch (this.mode) {
            case exports.DEFLATE:
            case exports.DEFLATERAW:
            case exports.GZIP:
              this.err = zlib_deflate.deflateReset(this.strm);
              break;
            case exports.INFLATE:
            case exports.INFLATERAW:
            case exports.GUNZIP:
              this.err = zlib_inflate.inflateReset(this.strm);
              break;
            default:
              break;
          }

          if (this.err !== exports.Z_OK) {
            this._error('Failed to reset stream');
          }
        };

        exports.Zlib = Zlib;
      }).call(this)
    }).call(this, require('_process'), require("buffer").Buffer)
  }, { "_process": 163, "assert": 117, "buffer": 126, "pako/lib/zlib/constants": 154, "pako/lib/zlib/deflate.js": 156, "pako/lib/zlib/inflate.js": 158, "pako/lib/zlib/zstream": 162 }], 125: [function (require, module, exports) {
    (function (process) {
      (function () {
        'use strict';

        var Buffer = require('buffer').Buffer;
        var Transform = require('stream').Transform;
        var binding = require('./binding');
        var util = require('util');
        var assert = require('assert').ok;
        var kMaxLength = require('buffer').kMaxLength;
        var kRangeErrorMessage = 'Cannot create final Buffer. It would be larger ' + 'than 0x' + kMaxLength.toString(16) + ' bytes';

        // zlib doesn't provide these, so kludge them in following the same
        // const naming scheme zlib uses.
        binding.Z_MIN_WINDOWBITS = 8;
        binding.Z_MAX_WINDOWBITS = 15;
        binding.Z_DEFAULT_WINDOWBITS = 15;

        // fewer than 64 bytes per chunk is stupid.
        // technically it could work with as few as 8, but even 64 bytes
        // is absurdly low.  Usually a MB or more is best.
        binding.Z_MIN_CHUNK = 64;
        binding.Z_MAX_CHUNK = Infinity;
        binding.Z_DEFAULT_CHUNK = 16 * 1024;

        binding.Z_MIN_MEMLEVEL = 1;
        binding.Z_MAX_MEMLEVEL = 9;
        binding.Z_DEFAULT_MEMLEVEL = 8;

        binding.Z_MIN_LEVEL = -1;
        binding.Z_MAX_LEVEL = 9;
        binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;

        // expose all the zlib constants
        var bkeys = Object.keys(binding);
        for (var bk = 0; bk < bkeys.length; bk++) {
          var bkey = bkeys[bk];
          if (bkey.match(/^Z/)) {
            Object.defineProperty(exports, bkey, {
              enumerable: true, value: binding[bkey], writable: false
            });
          }
        }

        // translation table for return codes.
        var codes = {
          Z_OK: binding.Z_OK,
          Z_STREAM_END: binding.Z_STREAM_END,
          Z_NEED_DICT: binding.Z_NEED_DICT,
          Z_ERRNO: binding.Z_ERRNO,
          Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
          Z_DATA_ERROR: binding.Z_DATA_ERROR,
          Z_MEM_ERROR: binding.Z_MEM_ERROR,
          Z_BUF_ERROR: binding.Z_BUF_ERROR,
          Z_VERSION_ERROR: binding.Z_VERSION_ERROR
        };

        var ckeys = Object.keys(codes);
        for (var ck = 0; ck < ckeys.length; ck++) {
          var ckey = ckeys[ck];
          codes[codes[ckey]] = ckey;
        }

        Object.defineProperty(exports, 'codes', {
          enumerable: true, value: Object.freeze(codes), writable: false
        });

        exports.Deflate = Deflate;
        exports.Inflate = Inflate;
        exports.Gzip = Gzip;
        exports.Gunzip = Gunzip;
        exports.DeflateRaw = DeflateRaw;
        exports.InflateRaw = InflateRaw;
        exports.Unzip = Unzip;

        exports.createDeflate = function (o) {
          return new Deflate(o);
        };

        exports.createInflate = function (o) {
          return new Inflate(o);
        };

        exports.createDeflateRaw = function (o) {
          return new DeflateRaw(o);
        };

        exports.createInflateRaw = function (o) {
          return new InflateRaw(o);
        };

        exports.createGzip = function (o) {
          return new Gzip(o);
        };

        exports.createGunzip = function (o) {
          return new Gunzip(o);
        };

        exports.createUnzip = function (o) {
          return new Unzip(o);
        };

        // Convenience methods.
        // compress/decompress a string or buffer in one step.
        exports.deflate = function (buffer, opts, callback) {
          if (typeof opts === 'function') {
            callback = opts;
            opts = {};
          }
          return zlibBuffer(new Deflate(opts), buffer, callback);
        };

        exports.deflateSync = function (buffer, opts) {
          return zlibBufferSync(new Deflate(opts), buffer);
        };

        exports.gzip = function (buffer, opts, callback) {
          if (typeof opts === 'function') {
            callback = opts;
            opts = {};
          }
          return zlibBuffer(new Gzip(opts), buffer, callback);
        };

        exports.gzipSync = function (buffer, opts) {
          return zlibBufferSync(new Gzip(opts), buffer);
        };

        exports.deflateRaw = function (buffer, opts, callback) {
          if (typeof opts === 'function') {
            callback = opts;
            opts = {};
          }
          return zlibBuffer(new DeflateRaw(opts), buffer, callback);
        };

        exports.deflateRawSync = function (buffer, opts) {
          return zlibBufferSync(new DeflateRaw(opts), buffer);
        };

        exports.unzip = function (buffer, opts, callback) {
          if (typeof opts === 'function') {
            callback = opts;
            opts = {};
          }
          return zlibBuffer(new Unzip(opts), buffer, callback);
        };

        exports.unzipSync = function (buffer, opts) {
          return zlibBufferSync(new Unzip(opts), buffer);
        };

        exports.inflate = function (buffer, opts, callback) {
          if (typeof opts === 'function') {
            callback = opts;
            opts = {};
          }
          return zlibBuffer(new Inflate(opts), buffer, callback);
        };

        exports.inflateSync = function (buffer, opts) {
          return zlibBufferSync(new Inflate(opts), buffer);
        };

        exports.gunzip = function (buffer, opts, callback) {
          if (typeof opts === 'function') {
            callback = opts;
            opts = {};
          }
          return zlibBuffer(new Gunzip(opts), buffer, callback);
        };

        exports.gunzipSync = function (buffer, opts) {
          return zlibBufferSync(new Gunzip(opts), buffer);
        };

        exports.inflateRaw = function (buffer, opts, callback) {
          if (typeof opts === 'function') {
            callback = opts;
            opts = {};
          }
          return zlibBuffer(new InflateRaw(opts), buffer, callback);
        };

        exports.inflateRawSync = function (buffer, opts) {
          return zlibBufferSync(new InflateRaw(opts), buffer);
        };

        function zlibBuffer(engine, buffer, callback) {
          var buffers = [];
          var nread = 0;

          engine.on('error', onError);
          engine.on('end', onEnd);

          engine.end(buffer);
          flow();

          function flow() {
            var chunk;
            while (null !== (chunk = engine.read())) {
              buffers.push(chunk);
              nread += chunk.length;
            }
            engine.once('readable', flow);
          }

          function onError(err) {
            engine.removeListener('end', onEnd);
            engine.removeListener('readable', flow);
            callback(err);
          }

          function onEnd() {
            var buf;
            var err = null;

            if (nread >= kMaxLength) {
              err = new RangeError(kRangeErrorMessage);
            } else {
              buf = Buffer.concat(buffers, nread);
            }

            buffers = [];
            engine.close();
            callback(err, buf);
          }
        }

        function zlibBufferSync(engine, buffer) {
          if (typeof buffer === 'string') buffer = Buffer.from(buffer);

          if (!Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');

          var flushFlag = engine._finishFlushFlag;

          return engine._processChunk(buffer, flushFlag);
        }

        // generic zlib
        // minimal 2-byte header
        function Deflate(opts) {
          if (!(this instanceof Deflate)) return new Deflate(opts);
          Zlib.call(this, opts, binding.DEFLATE);
        }

        function Inflate(opts) {
          if (!(this instanceof Inflate)) return new Inflate(opts);
          Zlib.call(this, opts, binding.INFLATE);
        }

        // gzip - bigger header, same deflate compression
        function Gzip(opts) {
          if (!(this instanceof Gzip)) return new Gzip(opts);
          Zlib.call(this, opts, binding.GZIP);
        }

        function Gunzip(opts) {
          if (!(this instanceof Gunzip)) return new Gunzip(opts);
          Zlib.call(this, opts, binding.GUNZIP);
        }

        // raw - no header
        function DeflateRaw(opts) {
          if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
          Zlib.call(this, opts, binding.DEFLATERAW);
        }

        function InflateRaw(opts) {
          if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
          Zlib.call(this, opts, binding.INFLATERAW);
        }

        // auto-detect header.
        function Unzip(opts) {
          if (!(this instanceof Unzip)) return new Unzip(opts);
          Zlib.call(this, opts, binding.UNZIP);
        }

        function isValidFlushFlag(flag) {
          return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;
        }

        // the Zlib class they all inherit from
        // This thing manages the queue of requests, and returns
        // true or false if there is anything in the queue when
        // you call the .write() method.

        function Zlib(opts, mode) {
          var _this = this;

          this._opts = opts = opts || {};
          this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

          Transform.call(this, opts);

          if (opts.flush && !isValidFlushFlag(opts.flush)) {
            throw new Error('Invalid flush flag: ' + opts.flush);
          }
          if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
            throw new Error('Invalid flush flag: ' + opts.finishFlush);
          }

          this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
          this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : binding.Z_FINISH;

          if (opts.chunkSize) {
            if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {
              throw new Error('Invalid chunk size: ' + opts.chunkSize);
            }
          }

          if (opts.windowBits) {
            if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {
              throw new Error('Invalid windowBits: ' + opts.windowBits);
            }
          }

          if (opts.level) {
            if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {
              throw new Error('Invalid compression level: ' + opts.level);
            }
          }

          if (opts.memLevel) {
            if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {
              throw new Error('Invalid memLevel: ' + opts.memLevel);
            }
          }

          if (opts.strategy) {
            if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {
              throw new Error('Invalid strategy: ' + opts.strategy);
            }
          }

          if (opts.dictionary) {
            if (!Buffer.isBuffer(opts.dictionary)) {
              throw new Error('Invalid dictionary: it should be a Buffer instance');
            }
          }

          this._handle = new binding.Zlib(mode);

          var self = this;
          this._hadError = false;
          this._handle.onerror = function (message, errno) {
            // there is no way to cleanly recover.
            // continuing only obscures problems.
            _close(self);
            self._hadError = true;

            var error = new Error(message);
            error.errno = errno;
            error.code = exports.codes[errno];
            self.emit('error', error);
          };

          var level = exports.Z_DEFAULT_COMPRESSION;
          if (typeof opts.level === 'number') level = opts.level;

          var strategy = exports.Z_DEFAULT_STRATEGY;
          if (typeof opts.strategy === 'number') strategy = opts.strategy;

          this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);

          this._buffer = Buffer.allocUnsafe(this._chunkSize);
          this._offset = 0;
          this._level = level;
          this._strategy = strategy;

          this.once('end', this.close);

          Object.defineProperty(this, '_closed', {
            get: function () {
              return !_this._handle;
            },
            configurable: true,
            enumerable: true
          });
        }

        util.inherits(Zlib, Transform);

        Zlib.prototype.params = function (level, strategy, callback) {
          if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
            throw new RangeError('Invalid compression level: ' + level);
          }
          if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
            throw new TypeError('Invalid strategy: ' + strategy);
          }

          if (this._level !== level || this._strategy !== strategy) {
            var self = this;
            this.flush(binding.Z_SYNC_FLUSH, function () {
              assert(self._handle, 'zlib binding closed');
              self._handle.params(level, strategy);
              if (!self._hadError) {
                self._level = level;
                self._strategy = strategy;
                if (callback) callback();
              }
            });
          } else {
            process.nextTick(callback);
          }
        };

        Zlib.prototype.reset = function () {
          assert(this._handle, 'zlib binding closed');
          return this._handle.reset();
        };

        // This is the _flush function called by the transform class,
        // internally, when the last chunk has been written.
        Zlib.prototype._flush = function (callback) {
          this._transform(Buffer.alloc(0), '', callback);
        };

        Zlib.prototype.flush = function (kind, callback) {
          var _this2 = this;

          var ws = this._writableState;

          if (typeof kind === 'function' || kind === undefined && !callback) {
            callback = kind;
            kind = binding.Z_FULL_FLUSH;
          }

          if (ws.ended) {
            if (callback) process.nextTick(callback);
          } else if (ws.ending) {
            if (callback) this.once('end', callback);
          } else if (ws.needDrain) {
            if (callback) {
              this.once('drain', function () {
                return _this2.flush(kind, callback);
              });
            }
          } else {
            this._flushFlag = kind;
            this.write(Buffer.alloc(0), '', callback);
          }
        };

        Zlib.prototype.close = function (callback) {
          _close(this, callback);
          process.nextTick(emitCloseNT, this);
        };

        function _close(engine, callback) {
          if (callback) process.nextTick(callback);

          // Caller may invoke .close after a zlib error (which will null _handle).
          if (!engine._handle) return;

          engine._handle.close();
          engine._handle = null;
        }

        function emitCloseNT(self) {
          self.emit('close');
        }

        Zlib.prototype._transform = function (chunk, encoding, cb) {
          var flushFlag;
          var ws = this._writableState;
          var ending = ws.ending || ws.ended;
          var last = ending && (!chunk || ws.length === chunk.length);

          if (chunk !== null && !Buffer.isBuffer(chunk)) return cb(new Error('invalid input'));

          if (!this._handle) return cb(new Error('zlib binding closed'));

          // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag
          // (or whatever flag was provided using opts.finishFlush).
          // If it's explicitly flushing at some other time, then we use
          // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
          // goodness.
          if (last) flushFlag = this._finishFlushFlag; else {
            flushFlag = this._flushFlag;
            // once we've flushed the last of the queue, stop flushing and
            // go back to the normal behavior.
            if (chunk.length >= ws.length) {
              this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
            }
          }

          this._processChunk(chunk, flushFlag, cb);
        };

        Zlib.prototype._processChunk = function (chunk, flushFlag, cb) {
          var availInBefore = chunk && chunk.length;
          var availOutBefore = this._chunkSize - this._offset;
          var inOff = 0;

          var self = this;

          var async = typeof cb === 'function';

          if (!async) {
            var buffers = [];
            var nread = 0;

            var error;
            this.on('error', function (er) {
              error = er;
            });

            assert(this._handle, 'zlib binding closed');
            do {
              var res = this._handle.writeSync(flushFlag, chunk, // in
                inOff, // in_off
                availInBefore, // in_len
                this._buffer, // out
                this._offset, //out_off
                availOutBefore); // out_len
            } while (!this._hadError && callback(res[0], res[1]));

            if (this._hadError) {
              throw error;
            }

            if (nread >= kMaxLength) {
              _close(this);
              throw new RangeError(kRangeErrorMessage);
            }

            var buf = Buffer.concat(buffers, nread);
            _close(this);

            return buf;
          }

          assert(this._handle, 'zlib binding closed');
          var req = this._handle.write(flushFlag, chunk, // in
            inOff, // in_off
            availInBefore, // in_len
            this._buffer, // out
            this._offset, //out_off
            availOutBefore); // out_len

          req.buffer = chunk;
          req.callback = callback;

          function callback(availInAfter, availOutAfter) {
            // When the callback is used in an async write, the callback's
            // context is the `req` object that was created. The req object
            // is === this._handle, and that's why it's important to null
            // out the values after they are done being used. `this._handle`
            // can stay in memory longer than the callback and buffer are needed.
            if (this) {
              this.buffer = null;
              this.callback = null;
            }

            if (self._hadError) return;

            var have = availOutBefore - availOutAfter;
            assert(have >= 0, 'have should not go down');

            if (have > 0) {
              var out = self._buffer.slice(self._offset, self._offset + have);
              self._offset += have;
              // serve some output to the consumer.
              if (async) {
                self.push(out);
              } else {
                buffers.push(out);
                nread += out.length;
              }
            }

            // exhausted the output buffer, or used all the input create a new one.
            if (availOutAfter === 0 || self._offset >= self._chunkSize) {
              availOutBefore = self._chunkSize;
              self._offset = 0;
              self._buffer = Buffer.allocUnsafe(self._chunkSize);
            }

            if (availOutAfter === 0) {
              // Not actually done.  Need to reprocess.
              // Also, update the availInBefore to the availInAfter value,
              // so that if we have to hit it a third (fourth, etc.) time,
              // it'll have the correct byte counts.
              inOff += availInBefore - availInAfter;
              availInBefore = availInAfter;

              if (!async) return true;

              var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);
              newReq.callback = callback; // this same function
              newReq.buffer = chunk;
              return;
            }

            if (!async) return false;

            // finished with the chunk.
            cb();
          }
        };

        util.inherits(Deflate, Zlib);
        util.inherits(Inflate, Zlib);
        util.inherits(Gzip, Zlib);
        util.inherits(Gunzip, Zlib);
        util.inherits(DeflateRaw, Zlib);
        util.inherits(InflateRaw, Zlib);
        util.inherits(Unzip, Zlib);
      }).call(this)
    }).call(this, require('_process'))
  }, { "./binding": 124, "_process": 163, "assert": 117, "buffer": 126, "stream": 165, "util": 185 }], 126: [function (require, module, exports) {
    (function (Buffer) {
      (function () {
        /*!
         * The buffer module from node.js, for the browser.
         *
         * @author   Feross Aboukhadijeh <https://feross.org>
         * @license  MIT
         */
        /* eslint-disable no-proto */

        'use strict'

        var base64 = require('base64-js')
        var ieee754 = require('ieee754')

        exports.Buffer = Buffer
        exports.SlowBuffer = SlowBuffer
        exports.INSPECT_MAX_BYTES = 50

        var K_MAX_LENGTH = 0x7fffffff
        exports.kMaxLength = K_MAX_LENGTH

        /**
         * If `Buffer.TYPED_ARRAY_SUPPORT`:
         *   === true    Use Uint8Array implementation (fastest)
         *   === false   Print warning and recommend using `buffer` v4.x which has an Object
         *               implementation (most compatible, even IE6)
         *
         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
         * Opera 11.6+, iOS 4.2+.
         *
         * We report that the browser does not support typed arrays if the are not subclassable
         * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
         * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
         * for __proto__ and has a buggy typed array implementation.
         */
        Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

        if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
          typeof console.error === 'function') {
          console.error(
            'This browser lacks typed array (Uint8Array) support which is required by ' +
            '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
          )
        }

        function typedArraySupport() {
          // Can typed array instances can be augmented?
          try {
            var arr = new Uint8Array(1)
            arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
            return arr.foo() === 42
          } catch (e) {
            return false
          }
        }

        Object.defineProperty(Buffer.prototype, 'parent', {
          enumerable: true,
          get: function () {
            if (!Buffer.isBuffer(this)) return undefined
            return this.buffer
          }
        })

        Object.defineProperty(Buffer.prototype, 'offset', {
          enumerable: true,
          get: function () {
            if (!Buffer.isBuffer(this)) return undefined
            return this.byteOffset
          }
        })

        function createBuffer(length) {
          if (length > K_MAX_LENGTH) {
            throw new RangeError('The value "' + length + '" is invalid for option "size"')
          }
          // Return an augmented `Uint8Array` instance
          var buf = new Uint8Array(length)
          buf.__proto__ = Buffer.prototype
          return buf
        }

        /**
         * The Buffer constructor returns instances of `Uint8Array` that have their
         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
         * and the `Uint8Array` methods. Square bracket notation works as expected -- it
         * returns a single octet.
         *
         * The `Uint8Array` prototype remains unmodified.
         */

        function Buffer(arg, encodingOrOffset, length) {
          // Common case.
          if (typeof arg === 'number') {
            if (typeof encodingOrOffset === 'string') {
              throw new TypeError(
                'The "string" argument must be of type string. Received type number'
              )
            }
            return allocUnsafe(arg)
          }
          return from(arg, encodingOrOffset, length)
        }

        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
        if (typeof Symbol !== 'undefined' && Symbol.species != null &&
          Buffer[Symbol.species] === Buffer) {
          Object.defineProperty(Buffer, Symbol.species, {
            value: null,
            configurable: true,
            enumerable: false,
            writable: false
          })
        }

        Buffer.poolSize = 8192 // not used by this implementation

        function from(value, encodingOrOffset, length) {
          if (typeof value === 'string') {
            return fromString(value, encodingOrOffset)
          }

          if (ArrayBuffer.isView(value)) {
            return fromArrayLike(value)
          }

          if (value == null) {
            throw TypeError(
              'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
              'or Array-like Object. Received type ' + (typeof value)
            )
          }

          if (isInstance(value, ArrayBuffer) ||
            (value && isInstance(value.buffer, ArrayBuffer))) {
            return fromArrayBuffer(value, encodingOrOffset, length)
          }

          if (typeof value === 'number') {
            throw new TypeError(
              'The "value" argument must not be of type number. Received type number'
            )
          }

          var valueOf = value.valueOf && value.valueOf()
          if (valueOf != null && valueOf !== value) {
            return Buffer.from(valueOf, encodingOrOffset, length)
          }

          var b = fromObject(value)
          if (b) return b

          if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
            typeof value[Symbol.toPrimitive] === 'function') {
            return Buffer.from(
              value[Symbol.toPrimitive]('string'), encodingOrOffset, length
            )
          }

          throw new TypeError(
            'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
            'or Array-like Object. Received type ' + (typeof value)
          )
        }

        /**
         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
         * if value is a number.
         * Buffer.from(str[, encoding])
         * Buffer.from(array)
         * Buffer.from(buffer)
         * Buffer.from(arrayBuffer[, byteOffset[, length]])
         **/
        Buffer.from = function (value, encodingOrOffset, length) {
          return from(value, encodingOrOffset, length)
        }

        // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
        // https://github.com/feross/buffer/pull/148
        Buffer.prototype.__proto__ = Uint8Array.prototype
        Buffer.__proto__ = Uint8Array

        function assertSize(size) {
          if (typeof size !== 'number') {
            throw new TypeError('"size" argument must be of type number')
          } else if (size < 0) {
            throw new RangeError('The value "' + size + '" is invalid for option "size"')
          }
        }

        function alloc(size, fill, encoding) {
          assertSize(size)
          if (size <= 0) {
            return createBuffer(size)
          }
          if (fill !== undefined) {
            // Only pay attention to encoding if it's a string. This
            // prevents accidentally sending in a number that would
            // be interpretted as a start offset.
            return typeof encoding === 'string'
              ? createBuffer(size).fill(fill, encoding)
              : createBuffer(size).fill(fill)
          }
          return createBuffer(size)
        }

        /**
         * Creates a new filled Buffer instance.
         * alloc(size[, fill[, encoding]])
         **/
        Buffer.alloc = function (size, fill, encoding) {
          return alloc(size, fill, encoding)
        }

        function allocUnsafe(size) {
          assertSize(size)
          return createBuffer(size < 0 ? 0 : checked(size) | 0)
        }

        /**
         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
         * */
        Buffer.allocUnsafe = function (size) {
          return allocUnsafe(size)
        }
        /**
         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
         */
        Buffer.allocUnsafeSlow = function (size) {
          return allocUnsafe(size)
        }

        function fromString(string, encoding) {
          if (typeof encoding !== 'string' || encoding === '') {
            encoding = 'utf8'
          }

          if (!Buffer.isEncoding(encoding)) {
            throw new TypeError('Unknown encoding: ' + encoding)
          }

          var length = byteLength(string, encoding) | 0
          var buf = createBuffer(length)

          var actual = buf.write(string, encoding)

          if (actual !== length) {
            // Writing a hex string, for example, that contains invalid characters will
            // cause everything after the first invalid character to be ignored. (e.g.
            // 'abxxcd' will be treated as 'ab')
            buf = buf.slice(0, actual)
          }

          return buf
        }

        function fromArrayLike(array) {
          var length = array.length < 0 ? 0 : checked(array.length) | 0
          var buf = createBuffer(length)
          for (var i = 0; i < length; i += 1) {
            buf[i] = array[i] & 255
          }
          return buf
        }

        function fromArrayBuffer(array, byteOffset, length) {
          if (byteOffset < 0 || array.byteLength < byteOffset) {
            throw new RangeError('"offset" is outside of buffer bounds')
          }

          if (array.byteLength < byteOffset + (length || 0)) {
            throw new RangeError('"length" is outside of buffer bounds')
          }

          var buf
          if (byteOffset === undefined && length === undefined) {
            buf = new Uint8Array(array)
          } else if (length === undefined) {
            buf = new Uint8Array(array, byteOffset)
          } else {
            buf = new Uint8Array(array, byteOffset, length)
          }

          // Return an augmented `Uint8Array` instance
          buf.__proto__ = Buffer.prototype
          return buf
        }

        function fromObject(obj) {
          if (Buffer.isBuffer(obj)) {
            var len = checked(obj.length) | 0
            var buf = createBuffer(len)

            if (buf.length === 0) {
              return buf
            }

            obj.copy(buf, 0, 0, len)
            return buf
          }

          if (obj.length !== undefined) {
            if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
              return createBuffer(0)
            }
            return fromArrayLike(obj)
          }

          if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
            return fromArrayLike(obj.data)
          }
        }

        function checked(length) {
          // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
          // length is NaN (which is otherwise coerced to zero.)
          if (length >= K_MAX_LENGTH) {
            throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
              'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
          }
          return length | 0
        }

        function SlowBuffer(length) {
          if (+length != length) { // eslint-disable-line eqeqeq
            length = 0
          }
          return Buffer.alloc(+length)
        }

        Buffer.isBuffer = function isBuffer(b) {
          return b != null && b._isBuffer === true &&
            b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
        }

        Buffer.compare = function compare(a, b) {
          if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
          if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
            throw new TypeError(
              'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
            )
          }

          if (a === b) return 0

          var x = a.length
          var y = b.length

          for (var i = 0, len = Math.min(x, y); i < len; ++i) {
            if (a[i] !== b[i]) {
              x = a[i]
              y = b[i]
              break
            }
          }

          if (x < y) return -1
          if (y < x) return 1
          return 0
        }

        Buffer.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'latin1':
            case 'binary':
            case 'base64':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return true
            default:
              return false
          }
        }

        Buffer.concat = function concat(list, length) {
          if (!Array.isArray(list)) {
            throw new TypeError('"list" argument must be an Array of Buffers')
          }

          if (list.length === 0) {
            return Buffer.alloc(0)
          }

          var i
          if (length === undefined) {
            length = 0
            for (i = 0; i < list.length; ++i) {
              length += list[i].length
            }
          }

          var buffer = Buffer.allocUnsafe(length)
          var pos = 0
          for (i = 0; i < list.length; ++i) {
            var buf = list[i]
            if (isInstance(buf, Uint8Array)) {
              buf = Buffer.from(buf)
            }
            if (!Buffer.isBuffer(buf)) {
              throw new TypeError('"list" argument must be an Array of Buffers')
            }
            buf.copy(buffer, pos)
            pos += buf.length
          }
          return buffer
        }

        function byteLength(string, encoding) {
          if (Buffer.isBuffer(string)) {
            return string.length
          }
          if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
            return string.byteLength
          }
          if (typeof string !== 'string') {
            throw new TypeError(
              'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
              'Received type ' + typeof string
            )
          }

          var len = string.length
          var mustMatch = (arguments.length > 2 && arguments[2] === true)
          if (!mustMatch && len === 0) return 0

          // Use a for loop to avoid recursion
          var loweredCase = false
          for (; ;) {
            switch (encoding) {
              case 'ascii':
              case 'latin1':
              case 'binary':
                return len
              case 'utf8':
              case 'utf-8':
                return utf8ToBytes(string).length
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return len * 2
              case 'hex':
                return len >>> 1
              case 'base64':
                return base64ToBytes(string).length
              default:
                if (loweredCase) {
                  return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
                }
                encoding = ('' + encoding).toLowerCase()
                loweredCase = true
            }
          }
        }
        Buffer.byteLength = byteLength

        function slowToString(encoding, start, end) {
          var loweredCase = false

          // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
          // property of a typed array.

          // This behaves neither like String nor Uint8Array in that we set start/end
          // to their upper/lower bounds if the value passed is out of range.
          // undefined is handled specially as per ECMA-262 6th Edition,
          // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
          if (start === undefined || start < 0) {
            start = 0
          }
          // Return early if start > this.length. Done here to prevent potential uint32
          // coercion fail below.
          if (start > this.length) {
            return ''
          }

          if (end === undefined || end > this.length) {
            end = this.length
          }

          if (end <= 0) {
            return ''
          }

          // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
          end >>>= 0
          start >>>= 0

          if (end <= start) {
            return ''
          }

          if (!encoding) encoding = 'utf8'

          while (true) {
            switch (encoding) {
              case 'hex':
                return hexSlice(this, start, end)

              case 'utf8':
              case 'utf-8':
                return utf8Slice(this, start, end)

              case 'ascii':
                return asciiSlice(this, start, end)

              case 'latin1':
              case 'binary':
                return latin1Slice(this, start, end)

              case 'base64':
                return base64Slice(this, start, end)

              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return utf16leSlice(this, start, end)

              default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                encoding = (encoding + '').toLowerCase()
                loweredCase = true
            }
          }
        }

        // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
        // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
        // reliably in a browserify context because there could be multiple different
        // copies of the 'buffer' package in use. This method works even for Buffer
        // instances that were created from another copy of the `buffer` package.
        // See: https://github.com/feross/buffer/issues/154
        Buffer.prototype._isBuffer = true

        function swap(b, n, m) {
          var i = b[n]
          b[n] = b[m]
          b[m] = i
        }

        Buffer.prototype.swap16 = function swap16() {
          var len = this.length
          if (len % 2 !== 0) {
            throw new RangeError('Buffer size must be a multiple of 16-bits')
          }
          for (var i = 0; i < len; i += 2) {
            swap(this, i, i + 1)
          }
          return this
        }

        Buffer.prototype.swap32 = function swap32() {
          var len = this.length
          if (len % 4 !== 0) {
            throw new RangeError('Buffer size must be a multiple of 32-bits')
          }
          for (var i = 0; i < len; i += 4) {
            swap(this, i, i + 3)
            swap(this, i + 1, i + 2)
          }
          return this
        }

        Buffer.prototype.swap64 = function swap64() {
          var len = this.length
          if (len % 8 !== 0) {
            throw new RangeError('Buffer size must be a multiple of 64-bits')
          }
          for (var i = 0; i < len; i += 8) {
            swap(this, i, i + 7)
            swap(this, i + 1, i + 6)
            swap(this, i + 2, i + 5)
            swap(this, i + 3, i + 4)
          }
          return this
        }

        Buffer.prototype.toString = function toString() {
          var length = this.length
          if (length === 0) return ''
          if (arguments.length === 0) return utf8Slice(this, 0, length)
          return slowToString.apply(this, arguments)
        }

        Buffer.prototype.toLocaleString = Buffer.prototype.toString

        Buffer.prototype.equals = function equals(b) {
          if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
          if (this === b) return true
          return Buffer.compare(this, b) === 0
        }

        Buffer.prototype.inspect = function inspect() {
          var str = ''
          var max = exports.INSPECT_MAX_BYTES
          str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
          if (this.length > max) str += ' ... '
          return '<Buffer ' + str + '>'
        }

        Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
          if (isInstance(target, Uint8Array)) {
            target = Buffer.from(target, target.offset, target.byteLength)
          }
          if (!Buffer.isBuffer(target)) {
            throw new TypeError(
              'The "target" argument must be one of type Buffer or Uint8Array. ' +
              'Received type ' + (typeof target)
            )
          }

          if (start === undefined) {
            start = 0
          }
          if (end === undefined) {
            end = target ? target.length : 0
          }
          if (thisStart === undefined) {
            thisStart = 0
          }
          if (thisEnd === undefined) {
            thisEnd = this.length
          }

          if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
            throw new RangeError('out of range index')
          }

          if (thisStart >= thisEnd && start >= end) {
            return 0
          }
          if (thisStart >= thisEnd) {
            return -1
          }
          if (start >= end) {
            return 1
          }

          start >>>= 0
          end >>>= 0
          thisStart >>>= 0
          thisEnd >>>= 0

          if (this === target) return 0

          var x = thisEnd - thisStart
          var y = end - start
          var len = Math.min(x, y)

          var thisCopy = this.slice(thisStart, thisEnd)
          var targetCopy = target.slice(start, end)

          for (var i = 0; i < len; ++i) {
            if (thisCopy[i] !== targetCopy[i]) {
              x = thisCopy[i]
              y = targetCopy[i]
              break
            }
          }

          if (x < y) return -1
          if (y < x) return 1
          return 0
        }

        // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
        // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
        //
        // Arguments:
        // - buffer - a Buffer to search
        // - val - a string, Buffer, or number
        // - byteOffset - an index into `buffer`; will be clamped to an int32
        // - encoding - an optional encoding, relevant is val is a string
        // - dir - true for indexOf, false for lastIndexOf
        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
          // Empty buffer means no match
          if (buffer.length === 0) return -1

          // Normalize byteOffset
          if (typeof byteOffset === 'string') {
            encoding = byteOffset
            byteOffset = 0
          } else if (byteOffset > 0x7fffffff) {
            byteOffset = 0x7fffffff
          } else if (byteOffset < -0x80000000) {
            byteOffset = -0x80000000
          }
          byteOffset = +byteOffset // Coerce to Number.
          if (numberIsNaN(byteOffset)) {
            // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
            byteOffset = dir ? 0 : (buffer.length - 1)
          }

          // Normalize byteOffset: negative offsets start from the end of the buffer
          if (byteOffset < 0) byteOffset = buffer.length + byteOffset
          if (byteOffset >= buffer.length) {
            if (dir) return -1
            else byteOffset = buffer.length - 1
          } else if (byteOffset < 0) {
            if (dir) byteOffset = 0
            else return -1
          }

          // Normalize val
          if (typeof val === 'string') {
            val = Buffer.from(val, encoding)
          }

          // Finally, search either indexOf (if dir is true) or lastIndexOf
          if (Buffer.isBuffer(val)) {
            // Special case: looking for empty string/buffer always fails
            if (val.length === 0) {
              return -1
            }
            return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
          } else if (typeof val === 'number') {
            val = val & 0xFF // Search for a byte value [0-255]
            if (typeof Uint8Array.prototype.indexOf === 'function') {
              if (dir) {
                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
              } else {
                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
              }
            }
            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
          }

          throw new TypeError('val must be string, number or Buffer')
        }

        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
          var indexSize = 1
          var arrLength = arr.length
          var valLength = val.length

          if (encoding !== undefined) {
            encoding = String(encoding).toLowerCase()
            if (encoding === 'ucs2' || encoding === 'ucs-2' ||
              encoding === 'utf16le' || encoding === 'utf-16le') {
              if (arr.length < 2 || val.length < 2) {
                return -1
              }
              indexSize = 2
              arrLength /= 2
              valLength /= 2
              byteOffset /= 2
            }
          }

          function read(buf, i) {
            if (indexSize === 1) {
              return buf[i]
            } else {
              return buf.readUInt16BE(i * indexSize)
            }
          }

          var i
          if (dir) {
            var foundIndex = -1
            for (i = byteOffset; i < arrLength; i++) {
              if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1) foundIndex = i
                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
              } else {
                if (foundIndex !== -1) i -= i - foundIndex
                foundIndex = -1
              }
            }
          } else {
            if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
            for (i = byteOffset; i >= 0; i--) {
              var found = true
              for (var j = 0; j < valLength; j++) {
                if (read(arr, i + j) !== read(val, j)) {
                  found = false
                  break
                }
              }
              if (found) return i
            }
          }

          return -1
        }

        Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
          return this.indexOf(val, byteOffset, encoding) !== -1
        }

        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
        }

        Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
        }

        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0
          var remaining = buf.length - offset
          if (!length) {
            length = remaining
          } else {
            length = Number(length)
            if (length > remaining) {
              length = remaining
            }
          }

          var strLen = string.length

          if (length > strLen / 2) {
            length = strLen / 2
          }
          for (var i = 0; i < length; ++i) {
            var parsed = parseInt(string.substr(i * 2, 2), 16)
            if (numberIsNaN(parsed)) return i
            buf[offset + i] = parsed
          }
          return i
        }

        function utf8Write(buf, string, offset, length) {
          return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
        }

        function asciiWrite(buf, string, offset, length) {
          return blitBuffer(asciiToBytes(string), buf, offset, length)
        }

        function latin1Write(buf, string, offset, length) {
          return asciiWrite(buf, string, offset, length)
        }

        function base64Write(buf, string, offset, length) {
          return blitBuffer(base64ToBytes(string), buf, offset, length)
        }

        function ucs2Write(buf, string, offset, length) {
          return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
        }

        Buffer.prototype.write = function write(string, offset, length, encoding) {
          // Buffer#write(string)
          if (offset === undefined) {
            encoding = 'utf8'
            length = this.length
            offset = 0
            // Buffer#write(string, encoding)
          } else if (length === undefined && typeof offset === 'string') {
            encoding = offset
            length = this.length
            offset = 0
            // Buffer#write(string, offset[, length][, encoding])
          } else if (isFinite(offset)) {
            offset = offset >>> 0
            if (isFinite(length)) {
              length = length >>> 0
              if (encoding === undefined) encoding = 'utf8'
            } else {
              encoding = length
              length = undefined
            }
          } else {
            throw new Error(
              'Buffer.write(string, encoding, offset[, length]) is no longer supported'
            )
          }

          var remaining = this.length - offset
          if (length === undefined || length > remaining) length = remaining

          if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
            throw new RangeError('Attempt to write outside buffer bounds')
          }

          if (!encoding) encoding = 'utf8'

          var loweredCase = false
          for (; ;) {
            switch (encoding) {
              case 'hex':
                return hexWrite(this, string, offset, length)

              case 'utf8':
              case 'utf-8':
                return utf8Write(this, string, offset, length)

              case 'ascii':
                return asciiWrite(this, string, offset, length)

              case 'latin1':
              case 'binary':
                return latin1Write(this, string, offset, length)

              case 'base64':
                // Warning: maxLength not taken into account in base64Write
                return base64Write(this, string, offset, length)

              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return ucs2Write(this, string, offset, length)

              default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                encoding = ('' + encoding).toLowerCase()
                loweredCase = true
            }
          }
        }

        Buffer.prototype.toJSON = function toJSON() {
          return {
            type: 'Buffer',
            data: Array.prototype.slice.call(this._arr || this, 0)
          }
        }

        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf)
          } else {
            return base64.fromByteArray(buf.slice(start, end))
          }
        }

        function utf8Slice(buf, start, end) {
          end = Math.min(buf.length, end)
          var res = []

          var i = start
          while (i < end) {
            var firstByte = buf[i]
            var codePoint = null
            var bytesPerSequence = (firstByte > 0xEF) ? 4
              : (firstByte > 0xDF) ? 3
                : (firstByte > 0xBF) ? 2
                  : 1

            if (i + bytesPerSequence <= end) {
              var secondByte, thirdByte, fourthByte, tempCodePoint

              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 0x80) {
                    codePoint = firstByte
                  }
                  break
                case 2:
                  secondByte = buf[i + 1]
                  if ((secondByte & 0xC0) === 0x80) {
                    tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                    if (tempCodePoint > 0x7F) {
                      codePoint = tempCodePoint
                    }
                  }
                  break
                case 3:
                  secondByte = buf[i + 1]
                  thirdByte = buf[i + 2]
                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                    tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                    if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                      codePoint = tempCodePoint
                    }
                  }
                  break
                case 4:
                  secondByte = buf[i + 1]
                  thirdByte = buf[i + 2]
                  fourthByte = buf[i + 3]
                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                    tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                    if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                      codePoint = tempCodePoint
                    }
                  }
              }
            }

            if (codePoint === null) {
              // we did not generate a valid codePoint so insert a
              // replacement char (U+FFFD) and advance only 1 byte
              codePoint = 0xFFFD
              bytesPerSequence = 1
            } else if (codePoint > 0xFFFF) {
              // encode to utf16 (surrogate pair dance)
              codePoint -= 0x10000
              res.push(codePoint >>> 10 & 0x3FF | 0xD800)
              codePoint = 0xDC00 | codePoint & 0x3FF
            }

            res.push(codePoint)
            i += bytesPerSequence
          }

          return decodeCodePointsArray(res)
        }

        // Based on http://stackoverflow.com/a/22747272/680742, the browser with
        // the lowest limit is Chrome, with 0x10000 args.
        // We go 1 magnitude less, for safety
        var MAX_ARGUMENTS_LENGTH = 0x1000

        function decodeCodePointsArray(codePoints) {
          var len = codePoints.length
          if (len <= MAX_ARGUMENTS_LENGTH) {
            return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
          }

          // Decode in chunks to avoid "call stack size exceeded".
          var res = ''
          var i = 0
          while (i < len) {
            res += String.fromCharCode.apply(
              String,
              codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
            )
          }
          return res
        }

        function asciiSlice(buf, start, end) {
          var ret = ''
          end = Math.min(buf.length, end)

          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i] & 0x7F)
          }
          return ret
        }

        function latin1Slice(buf, start, end) {
          var ret = ''
          end = Math.min(buf.length, end)

          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i])
          }
          return ret
        }

        function hexSlice(buf, start, end) {
          var len = buf.length

          if (!start || start < 0) start = 0
          if (!end || end < 0 || end > len) end = len

          var out = ''
          for (var i = start; i < end; ++i) {
            out += toHex(buf[i])
          }
          return out
        }

        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end)
          var res = ''
          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
          }
          return res
        }

        Buffer.prototype.slice = function slice(start, end) {
          var len = this.length
          start = ~~start
          end = end === undefined ? len : ~~end

          if (start < 0) {
            start += len
            if (start < 0) start = 0
          } else if (start > len) {
            start = len
          }

          if (end < 0) {
            end += len
            if (end < 0) end = 0
          } else if (end > len) {
            end = len
          }

          if (end < start) end = start

          var newBuf = this.subarray(start, end)
          // Return an augmented `Uint8Array` instance
          newBuf.__proto__ = Buffer.prototype
          return newBuf
        }

        /*
         * Need to make sure that buffer isn't trying to write out of bounds.
         */
        function checkOffset(offset, ext, length) {
          if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
          if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
        }

        Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) checkOffset(offset, byteLength, this.length)

          var val = this[offset]
          var mul = 1
          var i = 0
          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul
          }

          return val
        }

        Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) {
            checkOffset(offset, byteLength, this.length)
          }

          var val = this[offset + --byteLength]
          var mul = 1
          while (byteLength > 0 && (mul *= 0x100)) {
            val += this[offset + --byteLength] * mul
          }

          return val
        }

        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 1, this.length)
          return this[offset]
        }

        Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          return this[offset] | (this[offset + 1] << 8)
        }

        Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          return (this[offset] << 8) | this[offset + 1]
        }

        Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return ((this[offset]) |
            (this[offset + 1] << 8) |
            (this[offset + 2] << 16)) +
            (this[offset + 3] * 0x1000000)
        }

        Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return (this[offset] * 0x1000000) +
            ((this[offset + 1] << 16) |
              (this[offset + 2] << 8) |
              this[offset + 3])
        }

        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) checkOffset(offset, byteLength, this.length)

          var val = this[offset]
          var mul = 1
          var i = 0
          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul
          }
          mul *= 0x80

          if (val >= mul) val -= Math.pow(2, 8 * byteLength)

          return val
        }

        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) checkOffset(offset, byteLength, this.length)

          var i = byteLength
          var mul = 1
          var val = this[offset + --i]
          while (i > 0 && (mul *= 0x100)) {
            val += this[offset + --i] * mul
          }
          mul *= 0x80

          if (val >= mul) val -= Math.pow(2, 8 * byteLength)

          return val
        }

        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 1, this.length)
          if (!(this[offset] & 0x80)) return (this[offset])
          return ((0xff - this[offset] + 1) * -1)
        }

        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          var val = this[offset] | (this[offset + 1] << 8)
          return (val & 0x8000) ? val | 0xFFFF0000 : val
        }

        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          var val = this[offset + 1] | (this[offset] << 8)
          return (val & 0x8000) ? val | 0xFFFF0000 : val
        }

        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return (this[offset]) |
            (this[offset + 1] << 8) |
            (this[offset + 2] << 16) |
            (this[offset + 3] << 24)
        }

        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return (this[offset] << 24) |
            (this[offset + 1] << 16) |
            (this[offset + 2] << 8) |
            (this[offset + 3])
        }

        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)
          return ieee754.read(this, offset, true, 23, 4)
        }

        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)
          return ieee754.read(this, offset, false, 23, 4)
        }

        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 8, this.length)
          return ieee754.read(this, offset, true, 52, 8)
        }

        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 8, this.length)
          return ieee754.read(this, offset, false, 52, 8)
        }

        function checkInt(buf, value, offset, ext, max, min) {
          if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
          if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
          if (offset + ext > buf.length) throw new RangeError('Index out of range')
        }

        Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
          value = +value
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1
            checkInt(this, value, offset, byteLength, maxBytes, 0)
          }

          var mul = 1
          var i = 0
          this[offset] = value & 0xFF
          while (++i < byteLength && (mul *= 0x100)) {
            this[offset + i] = (value / mul) & 0xFF
          }

          return offset + byteLength
        }

        Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
          value = +value
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1
            checkInt(this, value, offset, byteLength, maxBytes, 0)
          }

          var i = byteLength - 1
          var mul = 1
          this[offset + i] = value & 0xFF
          while (--i >= 0 && (mul *= 0x100)) {
            this[offset + i] = (value / mul) & 0xFF
          }

          return offset + byteLength
        }

        Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
          this[offset] = (value & 0xff)
          return offset + 1
        }

        Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
          this[offset] = (value & 0xff)
          this[offset + 1] = (value >>> 8)
          return offset + 2
        }

        Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
          this[offset] = (value >>> 8)
          this[offset + 1] = (value & 0xff)
          return offset + 2
        }

        Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
          this[offset + 3] = (value >>> 24)
          this[offset + 2] = (value >>> 16)
          this[offset + 1] = (value >>> 8)
          this[offset] = (value & 0xff)
          return offset + 4
        }

        Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
          this[offset] = (value >>> 24)
          this[offset + 1] = (value >>> 16)
          this[offset + 2] = (value >>> 8)
          this[offset + 3] = (value & 0xff)
          return offset + 4
        }

        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            var limit = Math.pow(2, (8 * byteLength) - 1)

            checkInt(this, value, offset, byteLength, limit - 1, -limit)
          }

          var i = 0
          var mul = 1
          var sub = 0
          this[offset] = value & 0xFF
          while (++i < byteLength && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
              sub = 1
            }
            this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
          }

          return offset + byteLength
        }

        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            var limit = Math.pow(2, (8 * byteLength) - 1)

            checkInt(this, value, offset, byteLength, limit - 1, -limit)
          }

          var i = byteLength - 1
          var mul = 1
          var sub = 0
          this[offset + i] = value & 0xFF
          while (--i >= 0 && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
              sub = 1
            }
            this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
          }

          return offset + byteLength
        }

        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
          if (value < 0) value = 0xff + value + 1
          this[offset] = (value & 0xff)
          return offset + 1
        }

        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
          this[offset] = (value & 0xff)
          this[offset + 1] = (value >>> 8)
          return offset + 2
        }

        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
          this[offset] = (value >>> 8)
          this[offset + 1] = (value & 0xff)
          return offset + 2
        }

        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
          this[offset] = (value & 0xff)
          this[offset + 1] = (value >>> 8)
          this[offset + 2] = (value >>> 16)
          this[offset + 3] = (value >>> 24)
          return offset + 4
        }

        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
          if (value < 0) value = 0xffffffff + value + 1
          this[offset] = (value >>> 24)
          this[offset + 1] = (value >>> 16)
          this[offset + 2] = (value >>> 8)
          this[offset + 3] = (value & 0xff)
          return offset + 4
        }

        function checkIEEE754(buf, value, offset, ext, max, min) {
          if (offset + ext > buf.length) throw new RangeError('Index out of range')
          if (offset < 0) throw new RangeError('Index out of range')
        }

        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
          }
          ieee754.write(buf, value, offset, littleEndian, 23, 4)
          return offset + 4
        }

        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
          return writeFloat(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
          return writeFloat(this, value, offset, false, noAssert)
        }

        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
          }
          ieee754.write(buf, value, offset, littleEndian, 52, 8)
          return offset + 8
        }

        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
          return writeDouble(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
          return writeDouble(this, value, offset, false, noAssert)
        }

        // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
        Buffer.prototype.copy = function copy(target, targetStart, start, end) {
          if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
          if (!start) start = 0
          if (!end && end !== 0) end = this.length
          if (targetStart >= target.length) targetStart = target.length
          if (!targetStart) targetStart = 0
          if (end > 0 && end < start) end = start

          // Copy 0 bytes; we're done
          if (end === start) return 0
          if (target.length === 0 || this.length === 0) return 0

          // Fatal error conditions
          if (targetStart < 0) {
            throw new RangeError('targetStart out of bounds')
          }
          if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
          if (end < 0) throw new RangeError('sourceEnd out of bounds')

          // Are we oob?
          if (end > this.length) end = this.length
          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start
          }

          var len = end - start

          if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
            // Use built-in when available, missing from IE11
            this.copyWithin(targetStart, start, end)
          } else if (this === target && start < targetStart && targetStart < end) {
            // descending copy from end
            for (var i = len - 1; i >= 0; --i) {
              target[i + targetStart] = this[i + start]
            }
          } else {
            Uint8Array.prototype.set.call(
              target,
              this.subarray(start, end),
              targetStart
            )
          }

          return len
        }

        // Usage:
        //    buffer.fill(number[, offset[, end]])
        //    buffer.fill(buffer[, offset[, end]])
        //    buffer.fill(string[, offset[, end]][, encoding])
        Buffer.prototype.fill = function fill(val, start, end, encoding) {
          // Handle string cases:
          if (typeof val === 'string') {
            if (typeof start === 'string') {
              encoding = start
              start = 0
              end = this.length
            } else if (typeof end === 'string') {
              encoding = end
              end = this.length
            }
            if (encoding !== undefined && typeof encoding !== 'string') {
              throw new TypeError('encoding must be a string')
            }
            if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
              throw new TypeError('Unknown encoding: ' + encoding)
            }
            if (val.length === 1) {
              var code = val.charCodeAt(0)
              if ((encoding === 'utf8' && code < 128) ||
                encoding === 'latin1') {
                // Fast path: If `val` fits into a single byte, use that numeric value.
                val = code
              }
            }
          } else if (typeof val === 'number') {
            val = val & 255
          }

          // Invalid ranges are not set to a default, so can range check early.
          if (start < 0 || this.length < start || this.length < end) {
            throw new RangeError('Out of range index')
          }

          if (end <= start) {
            return this
          }

          start = start >>> 0
          end = end === undefined ? this.length : end >>> 0

          if (!val) val = 0

          var i
          if (typeof val === 'number') {
            for (i = start; i < end; ++i) {
              this[i] = val
            }
          } else {
            var bytes = Buffer.isBuffer(val)
              ? val
              : Buffer.from(val, encoding)
            var len = bytes.length
            if (len === 0) {
              throw new TypeError('The value "' + val +
                '" is invalid for argument "value"')
            }
            for (i = 0; i < end - start; ++i) {
              this[i + start] = bytes[i % len]
            }
          }

          return this
        }

        // HELPER FUNCTIONS
        // ================

        var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

        function base64clean(str) {
          // Node takes equal signs as end of the Base64 encoding
          str = str.split('=')[0]
          // Node strips out invalid characters like \n and \t from the string, base64-js does not
          str = str.trim().replace(INVALID_BASE64_RE, '')
          // Node converts strings with length < 2 to ''
          if (str.length < 2) return ''
          // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
          while (str.length % 4 !== 0) {
            str = str + '='
          }
          return str
        }

        function toHex(n) {
          if (n < 16) return '0' + n.toString(16)
          return n.toString(16)
        }

        function utf8ToBytes(string, units) {
          units = units || Infinity
          var codePoint
          var length = string.length
          var leadSurrogate = null
          var bytes = []

          for (var i = 0; i < length; ++i) {
            codePoint = string.charCodeAt(i)

            // is surrogate component
            if (codePoint > 0xD7FF && codePoint < 0xE000) {
              // last char was a lead
              if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                  // unexpected trail
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                  continue
                } else if (i + 1 === length) {
                  // unpaired lead
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                  continue
                }

                // valid lead
                leadSurrogate = codePoint

                continue
              }

              // 2 leads in a row
              if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                leadSurrogate = codePoint
                continue
              }

              // valid surrogate pair
              codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
            } else if (leadSurrogate) {
              // valid bmp char, but last char was a lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            }

            leadSurrogate = null

            // encode utf8
            if (codePoint < 0x80) {
              if ((units -= 1) < 0) break
              bytes.push(codePoint)
            } else if (codePoint < 0x800) {
              if ((units -= 2) < 0) break
              bytes.push(
                codePoint >> 0x6 | 0xC0,
                codePoint & 0x3F | 0x80
              )
            } else if (codePoint < 0x10000) {
              if ((units -= 3) < 0) break
              bytes.push(
                codePoint >> 0xC | 0xE0,
                codePoint >> 0x6 & 0x3F | 0x80,
                codePoint & 0x3F | 0x80
              )
            } else if (codePoint < 0x110000) {
              if ((units -= 4) < 0) break
              bytes.push(
                codePoint >> 0x12 | 0xF0,
                codePoint >> 0xC & 0x3F | 0x80,
                codePoint >> 0x6 & 0x3F | 0x80,
                codePoint & 0x3F | 0x80
              )
            } else {
              throw new Error('Invalid code point')
            }
          }

          return bytes
        }

        function asciiToBytes(str) {
          var byteArray = []
          for (var i = 0; i < str.length; ++i) {
            // Node's code seems to be doing this and not & 0x7F..
            byteArray.push(str.charCodeAt(i) & 0xFF)
          }
          return byteArray
        }

        function utf16leToBytes(str, units) {
          var c, hi, lo
          var byteArray = []
          for (var i = 0; i < str.length; ++i) {
            if ((units -= 2) < 0) break

            c = str.charCodeAt(i)
            hi = c >> 8
            lo = c % 256
            byteArray.push(lo)
            byteArray.push(hi)
          }

          return byteArray
        }

        function base64ToBytes(str) {
          return base64.toByteArray(base64clean(str))
        }

        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; ++i) {
            if ((i + offset >= dst.length) || (i >= src.length)) break
            dst[i + offset] = src[i]
          }
          return i
        }

        // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
        // the `instanceof` check but they should be treated as of that type.
        // See: https://github.com/feross/buffer/issues/166
        function isInstance(obj, type) {
          return obj instanceof type ||
            (obj != null && obj.constructor != null && obj.constructor.name != null &&
              obj.constructor.name === type.name)
        }
        function numberIsNaN(obj) {
          // For IE11 support
          return obj !== obj // eslint-disable-line no-self-compare
        }

      }).call(this)
    }).call(this, require("buffer").Buffer)
  }, { "base64-js": 122, "buffer": 126, "ieee754": 143 }], 127: [function (require, module, exports) {
    'use strict';

    var GetIntrinsic = require('get-intrinsic');

    var callBind = require('./');

    var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };

  }, { "./": 128, "get-intrinsic": 138 }], 128: [function (require, module, exports) {
    'use strict';

    var bind = require('function-bind');
    var GetIntrinsic = require('get-intrinsic');

    var $apply = GetIntrinsic('%Function.prototype.apply%');
    var $call = GetIntrinsic('%Function.prototype.call%');
    var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

    var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

    if ($defineProperty) {
      try {
        $defineProperty({}, 'a', { value: 1 });
      } catch (e) {
        // IE 8 has a broken defineProperty
        $defineProperty = null;
      }
    }

    module.exports = function callBind() {
      return $reflectApply(bind, $call, arguments);
    };

    var applyBind = function applyBind() {
      return $reflectApply(bind, $apply, arguments);
    };

    if ($defineProperty) {
      $defineProperty(module.exports, 'apply', { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }

  }, { "function-bind": 137, "get-intrinsic": 138 }], 129: [function (require, module, exports) {
    "use strict";

    function dedent(strings) {

      var raw = void 0;
      if (typeof strings === "string") {
        // dedent can be used as a plain function
        raw = [strings];
      } else {
        raw = strings.raw;
      }

      // first, perform interpolation
      var result = "";
      for (var i = 0; i < raw.length; i++) {
        result += raw[i].
          // join lines when there is a suppressed newline
          replace(/\\\n[ \t]*/g, "").

          // handle escaped backticks
          replace(/\\`/g, "`");

        if (i < (arguments.length <= 1 ? 0 : arguments.length - 1)) {
          result += arguments.length <= i + 1 ? undefined : arguments[i + 1];
        }
      }

      // now strip indentation
      var lines = result.split("\n");
      var mindent = null;
      lines.forEach(function (l) {
        var m = l.match(/^(\s+)\S+/);
        if (m) {
          var indent = m[1].length;
          if (!mindent) {
            // this is the first indented line
            mindent = indent;
          } else {
            mindent = Math.min(mindent, indent);
          }
        }
      });

      if (mindent !== null) {
        result = lines.map(function (l) {
          return l[0] === " " ? l.slice(mindent) : l;
        }).join("\n");
      }

      // dedent eats leading and trailing whitespace too
      result = result.trim();

      // handle escaped newlines at the end to ensure they don't get stripped too
      return result.replace(/\\n/g, "\n");
    }

    if (typeof module !== "undefined") {
      module.exports = dedent;
    }

  }, {}], 130: [function (require, module, exports) {
    'use strict';

    /* globals
      Atomics,
      SharedArrayBuffer,
    */

    var undefined;

    var $TypeError = TypeError;

    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, '');
      } catch (e) {
        $gOPD = null; // this is IE 8, which has a broken gOPD
      }
    }

    var throwTypeError = function () { throw new $TypeError(); };
    var ThrowTypeError = $gOPD
      ? (function () {
        try {
          // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
          arguments.callee; // IE 8 does not throw here
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, 'callee').get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }())
      : throwTypeError;

    var hasSymbols = require('has-symbols')();

    var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

    var generator; // = function * () {};
    var generatorFunction = generator ? getProto(generator) : undefined;
    var asyncFn; // async function() {};
    var asyncFunction = asyncFn ? asyncFn.constructor : undefined;
    var asyncGen; // async function * () {};
    var asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined;
    var asyncGenIterator = asyncGen ? asyncGen() : undefined;

    var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

    var INTRINSICS = {
      '%Array%': Array,
      '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
      '%ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer.prototype,
      '%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
      '%ArrayPrototype%': Array.prototype,
      '%ArrayProto_entries%': Array.prototype.entries,
      '%ArrayProto_forEach%': Array.prototype.forEach,
      '%ArrayProto_keys%': Array.prototype.keys,
      '%ArrayProto_values%': Array.prototype.values,
      '%AsyncFromSyncIteratorPrototype%': undefined,
      '%AsyncFunction%': asyncFunction,
      '%AsyncFunctionPrototype%': asyncFunction ? asyncFunction.prototype : undefined,
      '%AsyncGenerator%': asyncGen ? getProto(asyncGenIterator) : undefined,
      '%AsyncGeneratorFunction%': asyncGenFunction,
      '%AsyncGeneratorPrototype%': asyncGenFunction ? asyncGenFunction.prototype : undefined,
      '%AsyncIteratorPrototype%': asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined,
      '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
      '%Boolean%': Boolean,
      '%BooleanPrototype%': Boolean.prototype,
      '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
      '%DataViewPrototype%': typeof DataView === 'undefined' ? undefined : DataView.prototype,
      '%Date%': Date,
      '%DatePrototype%': Date.prototype,
      '%decodeURI%': decodeURI,
      '%decodeURIComponent%': decodeURIComponent,
      '%encodeURI%': encodeURI,
      '%encodeURIComponent%': encodeURIComponent,
      '%Error%': Error,
      '%ErrorPrototype%': Error.prototype,
      '%eval%': eval, // eslint-disable-line no-eval
      '%EvalError%': EvalError,
      '%EvalErrorPrototype%': EvalError.prototype,
      '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
      '%Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined : Float32Array.prototype,
      '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
      '%Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined : Float64Array.prototype,
      '%Function%': Function,
      '%FunctionPrototype%': Function.prototype,
      '%Generator%': generator ? getProto(generator()) : undefined,
      '%GeneratorFunction%': generatorFunction,
      '%GeneratorPrototype%': generatorFunction ? generatorFunction.prototype : undefined,
      '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
      '%Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined : Int8Array.prototype,
      '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
      '%Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined : Int8Array.prototype,
      '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
      '%Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined : Int32Array.prototype,
      '%isFinite%': isFinite,
      '%isNaN%': isNaN,
      '%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
      '%JSON%': typeof JSON === 'object' ? JSON : undefined,
      '%JSONParse%': typeof JSON === 'object' ? JSON.parse : undefined,
      '%Map%': typeof Map === 'undefined' ? undefined : Map,
      '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
      '%MapPrototype%': typeof Map === 'undefined' ? undefined : Map.prototype,
      '%Math%': Math,
      '%Number%': Number,
      '%NumberPrototype%': Number.prototype,
      '%Object%': Object,
      '%ObjectPrototype%': Object.prototype,
      '%ObjProto_toString%': Object.prototype.toString,
      '%ObjProto_valueOf%': Object.prototype.valueOf,
      '%parseFloat%': parseFloat,
      '%parseInt%': parseInt,
      '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
      '%PromisePrototype%': typeof Promise === 'undefined' ? undefined : Promise.prototype,
      '%PromiseProto_then%': typeof Promise === 'undefined' ? undefined : Promise.prototype.then,
      '%Promise_all%': typeof Promise === 'undefined' ? undefined : Promise.all,
      '%Promise_reject%': typeof Promise === 'undefined' ? undefined : Promise.reject,
      '%Promise_resolve%': typeof Promise === 'undefined' ? undefined : Promise.resolve,
      '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
      '%RangeError%': RangeError,
      '%RangeErrorPrototype%': RangeError.prototype,
      '%ReferenceError%': ReferenceError,
      '%ReferenceErrorPrototype%': ReferenceError.prototype,
      '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
      '%RegExp%': RegExp,
      '%RegExpPrototype%': RegExp.prototype,
      '%Set%': typeof Set === 'undefined' ? undefined : Set,
      '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
      '%SetPrototype%': typeof Set === 'undefined' ? undefined : Set.prototype,
      '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
      '%SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer.prototype,
      '%String%': String,
      '%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
      '%StringPrototype%': String.prototype,
      '%Symbol%': hasSymbols ? Symbol : undefined,
      '%SymbolPrototype%': hasSymbols ? Symbol.prototype : undefined,
      '%SyntaxError%': SyntaxError,
      '%SyntaxErrorPrototype%': SyntaxError.prototype,
      '%ThrowTypeError%': ThrowTypeError,
      '%TypedArray%': TypedArray,
      '%TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined,
      '%TypeError%': $TypeError,
      '%TypeErrorPrototype%': $TypeError.prototype,
      '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
      '%Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array.prototype,
      '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
      '%Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray.prototype,
      '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
      '%Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array.prototype,
      '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
      '%Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array.prototype,
      '%URIError%': URIError,
      '%URIErrorPrototype%': URIError.prototype,
      '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
      '%WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined : WeakMap.prototype,
      '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
      '%WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined : WeakSet.prototype
    };

    var bind = require('function-bind');
    var $replace = bind.call(Function.call, String.prototype.replace);

    /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
    var stringToPath = function stringToPath(string) {
      var result = [];
      $replace(string, rePropName, function (match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : (number || match);
      });
      return result;
    };
    /* end adaptation */

    var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
      if (!(name in INTRINSICS)) {
        throw new SyntaxError('intrinsic ' + name + ' does not exist!');
      }

      // istanbul ignore if // hopefully this is impossible to test :-)
      if (typeof INTRINSICS[name] === 'undefined' && !allowMissing) {
        throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
      }

      return INTRINSICS[name];
    };

    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== 'string' || name.length === 0) {
        throw new TypeError('intrinsic name must be a non-empty string');
      }
      if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
        throw new TypeError('"allowMissing" argument must be a boolean');
      }

      var parts = stringToPath(name);

      var value = getBaseIntrinsic('%' + (parts.length > 0 ? parts[0] : '') + '%', allowMissing);
      for (var i = 1; i < parts.length; i += 1) {
        if (value != null) {
          if ($gOPD && (i + 1) >= parts.length) {
            var desc = $gOPD(value, parts[i]);
            if (!allowMissing && !(parts[i] in value)) {
              throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
            }
            // By convention, when a data property is converted to an accessor
            // property to emulate a data property that does not suffer from
            // the override mistake, that accessor's getter is marked with
            // an `originalValue` property. Here, when we detect this, we
            // uphold the illusion by pretending to see that original data
            // property, i.e., returning the value rather than the getter
            // itself.
            value = desc && 'get' in desc && !('originalValue' in desc.get) ? desc.get : value[parts[i]];
          } else {
            value = value[parts[i]];
          }
        }
      }
      return value;
    };

  }, { "function-bind": 137, "has-symbols": 140 }], 131: [function (require, module, exports) {
    'use strict';

    var bind = require('function-bind');

    var GetIntrinsic = require('../GetIntrinsic');

    var $apply = GetIntrinsic('%Function.prototype.apply%');
    var $call = GetIntrinsic('%Function.prototype.call%');
    var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

    var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

    if ($defineProperty) {
      try {
        $defineProperty({}, 'a', { value: 1 });
      } catch (e) {
        // IE 8 has a broken defineProperty
        $defineProperty = null;
      }
    }

    module.exports = function callBind() {
      return $reflectApply(bind, $call, arguments);
    };

    var applyBind = function applyBind() {
      return $reflectApply(bind, $apply, arguments);
    };

    if ($defineProperty) {
      $defineProperty(module.exports, 'apply', { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }

  }, { "../GetIntrinsic": 130, "function-bind": 137 }], 132: [function (require, module, exports) {
    'use strict';

    var GetIntrinsic = require('../GetIntrinsic');

    var callBind = require('./callBind');

    var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.')) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };

  }, { "../GetIntrinsic": 130, "./callBind": 131 }], 133: [function (require, module, exports) {
    'use strict';

    var GetIntrinsic = require('../GetIntrinsic');

    var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');
    if ($gOPD) {
      try {
        $gOPD([], 'length');
      } catch (e) {
        // IE 8 has a broken gOPD
        $gOPD = null;
      }
    }

    module.exports = $gOPD;

  }, { "../GetIntrinsic": 130 }], 134: [function (require, module, exports) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    'use strict';

    var R = typeof Reflect === 'object' ? Reflect : null
    var ReflectApply = R && typeof R.apply === 'function'
      ? R.apply
      : function ReflectApply(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      }

    var ReflectOwnKeys
    if (R && typeof R.ownKeys === 'function') {
      ReflectOwnKeys = R.ownKeys
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target)
          .concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target);
      };
    }

    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }

    var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
      return value !== value;
    }

    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;

    // Backwards-compat with node 0.10.x
    EventEmitter.EventEmitter = EventEmitter;

    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = undefined;

    // By default EventEmitters will print a warning if more than 10 listeners are
    // added to it. This is a useful default which helps finding memory leaks.
    var defaultMaxListeners = 10;

    function checkListener(listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }

    Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
      enumerable: true,
      get: function () {
        return defaultMaxListeners;
      },
      set: function (arg) {
        if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
        }
        defaultMaxListeners = arg;
      }
    });

    EventEmitter.init = function () {

      if (this._events === undefined ||
        this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
      }

      this._maxListeners = this._maxListeners || undefined;
    };

    // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
      }
      this._maxListeners = n;
      return this;
    };

    function _getMaxListeners(that) {
      if (that._maxListeners === undefined)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }

    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };

    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = (type === 'error');

      var events = this._events;
      if (events !== undefined)
        doError = (doError && events.error === undefined);
      else if (!doError)
        return false;

      // If there is no 'error' event listener then throw.
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          // Note: The comments on the `throw` lines are intentional, they show
          // up in Node's output if this results in an unhandled exception.
          throw er; // Unhandled 'error' event
        }
        // At least give some kind of context to the user
        var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
        err.context = er;
        throw err; // Unhandled 'error' event
      }

      var handler = events[type];

      if (handler === undefined)
        return false;

      if (typeof handler === 'function') {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }

      return true;
    };

    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;

      checkListener(listener);

      events = target._events;
      if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
      } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
          target.emit('newListener', type,
            listener.listener ? listener.listener : listener);

          // Re-assign `events` because a newListener handler could have caused the
          // this._events to be assigned to a new object
          events = target._events;
        }
        existing = events[type];
      }

      if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === 'function') {
          // Adding the second element, need to change to array.
          existing = events[type] =
            prepend ? [listener, existing] : [existing, listener];
          // If we've already got an array, just append.
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }

        // Check for listener leak
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          // No error code for this since it is a Warning
          // eslint-disable-next-line no-restricted-syntax
          var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' ' + String(type) + ' listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit');
          w.name = 'MaxListenersExceededWarning';
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }

      return target;
    }

    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };

    EventEmitter.prototype.on = EventEmitter.prototype.addListener;

    EventEmitter.prototype.prependListener =
      function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };

    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }

    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }

    EventEmitter.prototype.once = function once(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };

    EventEmitter.prototype.prependOnceListener =
      function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };

    // Emits a 'removeListener' event if and only if the listener was removed.
    EventEmitter.prototype.removeListener =
      function removeListener(type, listener) {
        var list, events, position, i, originalListener;

        checkListener(listener);

        events = this._events;
        if (events === undefined)
          return this;

        list = events[type];
        if (list === undefined)
          return this;

        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit('removeListener', type, list.listener || listener);
          }
        } else if (typeof list !== 'function') {
          position = -1;

          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }

          if (position < 0)
            return this;

          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }

          if (list.length === 1)
            events[type] = list[0];

          if (events.removeListener !== undefined)
            this.emit('removeListener', type, originalListener || listener);
        }

        return this;
      };

    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

    EventEmitter.prototype.removeAllListeners =
      function removeAllListeners(type) {
        var listeners, events, i;

        events = this._events;
        if (events === undefined)
          return this;

        // not listening for removeListener, no need to emit
        if (events.removeListener === undefined) {
          if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0)
              this._events = Object.create(null);
            else
              delete events[type];
          }
          return this;
        }

        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners('removeListener');
          this._events = Object.create(null);
          this._eventsCount = 0;
          return this;
        }

        listeners = events[type];

        if (typeof listeners === 'function') {
          this.removeListener(type, listeners);
        } else if (listeners !== undefined) {
          // LIFO order
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }

        return this;
      };

    function _listeners(target, type, unwrap) {
      var events = target._events;

      if (events === undefined)
        return [];

      var evlistener = events[type];
      if (evlistener === undefined)
        return [];

      if (typeof evlistener === 'function')
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];

      return unwrap ?
        unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }

    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };

    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };

    EventEmitter.listenerCount = function (emitter, type) {
      if (typeof emitter.listenerCount === 'function') {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };

    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;

      if (events !== undefined) {
        var evlistener = events[type];

        if (typeof evlistener === 'function') {
          return 1;
        } else if (evlistener !== undefined) {
          return evlistener.length;
        }
      }

      return 0;
    }

    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };

    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }

    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }

    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }

    function once(emitter, name) {
      return new Promise(function (resolve, reject) {
        function eventListener() {
          if (errorListener !== undefined) {
            emitter.removeListener('error', errorListener);
          }
          resolve([].slice.call(arguments));
        };
        var errorListener;

        // Adding an error listener is not optional because
        // if an error is thrown on an event emitter we cannot
        // guarantee that the actual event we are waiting will
        // be fired. The result could be a silent way to create
        // memory or file descriptor leaks, which is something
        // we should avoid.
        if (name !== 'error') {
          errorListener = function errorListener(err) {
            emitter.removeListener(name, eventListener);
            reject(err);
          };

          emitter.once('error', errorListener);
        }

        emitter.once(name, eventListener);
      });
    }

  }, {}], 135: [function (require, module, exports) {

    var hasOwn = Object.prototype.hasOwnProperty;
    var toString = Object.prototype.toString;

    module.exports = function forEach(obj, fn, ctx) {
      if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
      }
      var l = obj.length;
      if (l === +l) {
        for (var i = 0; i < l; i++) {
          fn.call(ctx, obj[i], i, obj);
        }
      } else {
        for (var k in obj) {
          if (hasOwn.call(obj, k)) {
            fn.call(ctx, obj[k], k, obj);
          }
        }
      }
    };


  }, {}], 136: [function (require, module, exports) {
    'use strict';

    /* eslint no-invalid-this: 1 */

    var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = '[object Function]';

    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);

      var bound;
      var binder = function () {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };

      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
      }

      bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

      if (target.prototype) {
        var Empty = function Empty() { };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }

      return bound;
    };

  }, {}], 137: [function (require, module, exports) {
    'use strict';

    var implementation = require('./implementation');

    module.exports = Function.prototype.bind || implementation;

  }, { "./implementation": 136 }], 138: [function (require, module, exports) {
    'use strict';

    var undefined;

    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;

    // eslint-disable-next-line consistent-return
    var getEvalledConstructor = function (expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
      } catch (e) { }
    };

    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, '');
      } catch (e) {
        $gOPD = null; // this is IE 8, which has a broken gOPD
      }
    }

    var throwTypeError = function () {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD
      ? (function () {
        try {
          // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
          arguments.callee; // IE 8 does not throw here
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, 'callee').get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }())
      : throwTypeError;

    var hasSymbols = require('has-symbols')();
    var hasProto = require('has-proto')();

    var getProto = Object.getPrototypeOf || (
      hasProto
        ? function (x) { return x.__proto__; } // eslint-disable-line no-proto
        : null
    );

    var needsEval = {};

    var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

    var INTRINSICS = {
      '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
      '%Array%': Array,
      '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
      '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
      '%AsyncFromSyncIteratorPrototype%': undefined,
      '%AsyncFunction%': needsEval,
      '%AsyncGenerator%': needsEval,
      '%AsyncGeneratorFunction%': needsEval,
      '%AsyncIteratorPrototype%': needsEval,
      '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
      '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
      '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
      '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
      '%Boolean%': Boolean,
      '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
      '%Date%': Date,
      '%decodeURI%': decodeURI,
      '%decodeURIComponent%': decodeURIComponent,
      '%encodeURI%': encodeURI,
      '%encodeURIComponent%': encodeURIComponent,
      '%Error%': Error,
      '%eval%': eval, // eslint-disable-line no-eval
      '%EvalError%': EvalError,
      '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
      '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
      '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
      '%Function%': $Function,
      '%GeneratorFunction%': needsEval,
      '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
      '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
      '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
      '%isFinite%': isFinite,
      '%isNaN%': isNaN,
      '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
      '%JSON%': typeof JSON === 'object' ? JSON : undefined,
      '%Map%': typeof Map === 'undefined' ? undefined : Map,
      '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
      '%Math%': Math,
      '%Number%': Number,
      '%Object%': Object,
      '%parseFloat%': parseFloat,
      '%parseInt%': parseInt,
      '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
      '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
      '%RangeError%': RangeError,
      '%ReferenceError%': ReferenceError,
      '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
      '%RegExp%': RegExp,
      '%Set%': typeof Set === 'undefined' ? undefined : Set,
      '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
      '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
      '%String%': String,
      '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
      '%Symbol%': hasSymbols ? Symbol : undefined,
      '%SyntaxError%': $SyntaxError,
      '%ThrowTypeError%': ThrowTypeError,
      '%TypedArray%': TypedArray,
      '%TypeError%': $TypeError,
      '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
      '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
      '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
      '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
      '%URIError%': URIError,
      '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
      '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
      '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
    };

    if (getProto) {
      try {
        null.error; // eslint-disable-line no-unused-expressions
      } catch (e) {
        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
        var errorProto = getProto(getProto(e));
        INTRINSICS['%Error.prototype%'] = errorProto;
      }
    }

    var doEval = function doEval(name) {
      var value;
      if (name === '%AsyncFunction%') {
        value = getEvalledConstructor('async function () {}');
      } else if (name === '%GeneratorFunction%') {
        value = getEvalledConstructor('function* () {}');
      } else if (name === '%AsyncGeneratorFunction%') {
        value = getEvalledConstructor('async function* () {}');
      } else if (name === '%AsyncGenerator%') {
        var fn = doEval('%AsyncGeneratorFunction%');
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === '%AsyncIteratorPrototype%') {
        var gen = doEval('%AsyncGenerator%');
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }

      INTRINSICS[name] = value;

      return value;
    };

    var LEGACY_ALIASES = {
      '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
      '%ArrayPrototype%': ['Array', 'prototype'],
      '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
      '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
      '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
      '%ArrayProto_values%': ['Array', 'prototype', 'values'],
      '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
      '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
      '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
      '%BooleanPrototype%': ['Boolean', 'prototype'],
      '%DataViewPrototype%': ['DataView', 'prototype'],
      '%DatePrototype%': ['Date', 'prototype'],
      '%ErrorPrototype%': ['Error', 'prototype'],
      '%EvalErrorPrototype%': ['EvalError', 'prototype'],
      '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
      '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
      '%FunctionPrototype%': ['Function', 'prototype'],
      '%Generator%': ['GeneratorFunction', 'prototype'],
      '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
      '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
      '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
      '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
      '%JSONParse%': ['JSON', 'parse'],
      '%JSONStringify%': ['JSON', 'stringify'],
      '%MapPrototype%': ['Map', 'prototype'],
      '%NumberPrototype%': ['Number', 'prototype'],
      '%ObjectPrototype%': ['Object', 'prototype'],
      '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
      '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
      '%PromisePrototype%': ['Promise', 'prototype'],
      '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
      '%Promise_all%': ['Promise', 'all'],
      '%Promise_reject%': ['Promise', 'reject'],
      '%Promise_resolve%': ['Promise', 'resolve'],
      '%RangeErrorPrototype%': ['RangeError', 'prototype'],
      '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
      '%RegExpPrototype%': ['RegExp', 'prototype'],
      '%SetPrototype%': ['Set', 'prototype'],
      '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
      '%StringPrototype%': ['String', 'prototype'],
      '%SymbolPrototype%': ['Symbol', 'prototype'],
      '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
      '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
      '%TypeErrorPrototype%': ['TypeError', 'prototype'],
      '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
      '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
      '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
      '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
      '%URIErrorPrototype%': ['URIError', 'prototype'],
      '%WeakMapPrototype%': ['WeakMap', 'prototype'],
      '%WeakSetPrototype%': ['WeakSet', 'prototype']
    };

    var bind = require('function-bind');
    var hasOwn = require('has');
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);

    /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
    var stringToPath = function stringToPath(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === '%' && last !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
      } else if (last === '%' && first !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
      }
      var result = [];
      $replace(string, rePropName, function (match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
      });
      return result;
    };
    /* end adaptation */

    var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = '%' + alias[0] + '%';
      }

      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === 'undefined' && !allowMissing) {
          throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
        }

        return {
          alias: alias,
          name: intrinsicName,
          value: value
        };
      }

      throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
    };

    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== 'string' || name.length === 0) {
        throw new $TypeError('intrinsic name must be a non-empty string');
      }
      if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }

      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

      var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;

      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }

      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if (
          (
            (first === '"' || first === "'" || first === '`')
            || (last === '"' || last === "'" || last === '`')
          )
          && first !== last
        ) {
          throw new $SyntaxError('property names with quotes must have matching quotes');
        }
        if (part === 'constructor' || !isOwn) {
          skipFurtherCaching = true;
        }

        intrinsicBaseName += '.' + part;
        intrinsicRealName = '%' + intrinsicBaseName + '%';

        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
            }
            return void undefined;
          }
          if ($gOPD && (i + 1) >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;

            // By convention, when a data property is converted to an accessor
            // property to emulate a data property that does not suffer from
            // the override mistake, that accessor's getter is marked with
            // an `originalValue` property. Here, when we detect this, we
            // uphold the illusion by pretending to see that original data
            // property, i.e., returning the value rather than the getter
            // itself.
            if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }

          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };

  }, { "function-bind": 137, "has": 142, "has-proto": 139, "has-symbols": 140 }], 139: [function (require, module, exports) {
    'use strict';

    var test = {
      foo: {}
    };

    var $Object = Object;

    module.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };

  }, {}], 140: [function (require, module, exports) {
    'use strict';

    var origSymbol = typeof Symbol !== 'undefined' && Symbol;
    var hasSymbolSham = require('./shams');

    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== 'function') { return false; }
      if (typeof Symbol !== 'function') { return false; }
      if (typeof origSymbol('foo') !== 'symbol') { return false; }
      if (typeof Symbol('bar') !== 'symbol') { return false; }

      return hasSymbolSham();
    };

  }, { "./shams": 141 }], 141: [function (require, module, exports) {
    'use strict';

    /* eslint complexity: [2, 18], max-statements: [2, 33] */
    module.exports = function hasSymbols() {
      if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
      if (typeof Symbol.iterator === 'symbol') { return true; }

      var obj = {};
      var sym = Symbol('test');
      var symObj = Object(sym);
      if (typeof sym === 'string') { return false; }

      if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
      if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

      // temp disabled per https://github.com/ljharb/object.assign/issues/17
      // if (sym instanceof Symbol) { return false; }
      // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
      // if (!(symObj instanceof Symbol)) { return false; }

      // if (typeof Symbol.prototype.toString !== 'function') { return false; }
      // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
      if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

      if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) { return false; }

      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

      if (typeof Object.getOwnPropertyDescriptor === 'function') {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
      }

      return true;
    };

  }, {}], 142: [function (require, module, exports) {
    'use strict';

    var bind = require('function-bind');

    module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

  }, { "function-bind": 137 }], 143: [function (require, module, exports) {
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    exports.read = function (buffer, offset, isLE, mLen, nBytes) {
      var e, m
      var eLen = (nBytes * 8) - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var nBits = -7
      var i = isLE ? (nBytes - 1) : 0
      var d = isLE ? -1 : 1
      var s = buffer[offset + i]

      i += d

      e = s & ((1 << (-nBits)) - 1)
      s >>= (-nBits)
      nBits += eLen
      for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) { }

      m = e & ((1 << (-nBits)) - 1)
      e >>= (-nBits)
      nBits += mLen
      for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) { }

      if (e === 0) {
        e = 1 - eBias
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen)
        e = e - eBias
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }

    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c
      var eLen = (nBytes * 8) - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
      var i = isLE ? 0 : (nBytes - 1)
      var d = isLE ? 1 : -1
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

      value = Math.abs(value)

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0
        e = eMax
      } else {
        e = Math.floor(Math.log(value) / Math.LN2)
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--
          c *= 2
        }
        if (e + eBias >= 1) {
          value += rt / c
        } else {
          value += rt * Math.pow(2, 1 - eBias)
        }
        if (value * c >= 2) {
          e++
          c /= 2
        }

        if (e + eBias >= eMax) {
          m = 0
          e = eMax
        } else if (e + eBias >= 1) {
          m = ((value * c) - 1) * Math.pow(2, mLen)
          e = e + eBias
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
          e = 0
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) { }

      e = (e << mLen) | m
      eLen += mLen
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) { }

      buffer[offset + i - d] |= s * 128
    }

  }, {}], 144: [function (require, module, exports) {
    if (typeof Object.create === 'function') {
      // implementation from standard node.js 'util' module
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          })
        }
      };
    } else {
      // old school shim for old browsers
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor
          var TempCtor = function () { }
          TempCtor.prototype = superCtor.prototype
          ctor.prototype = new TempCtor()
          ctor.prototype.constructor = ctor
        }
      }
    }

  }, {}], 145: [function (require, module, exports) {
    'use strict';

    var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
    var callBound = require('call-bind/callBound');

    var $toString = callBound('Object.prototype.toString');

    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === '[object Arguments]';
    };

    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null &&
        typeof value === 'object' &&
        typeof value.length === 'number' &&
        value.length >= 0 &&
        $toString(value) !== '[object Array]' &&
        $toString(value.callee) === '[object Function]';
    };

    var supportsStandardArguments = (function () {
      return isStandardArguments(arguments);
    }());

    isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

  }, { "call-bind/callBound": 127 }], 146: [function (require, module, exports) {
    'use strict';

    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function () { // eslint-disable-line consistent-return
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function('return function*() {}')();
      } catch (e) {
      }
    };
    var generatorFunc = getGeneratorFunc();
    var GeneratorFunction = getProto && generatorFunc ? getProto(generatorFunc) : false;

    module.exports = function isGeneratorFunction(fn) {
      if (typeof fn !== 'function') {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === '[object GeneratorFunction]';
      }
      return getProto && getProto(fn) === GeneratorFunction;
    };

  }, {}], 147: [function (require, module, exports) {
    (function (global) {
      (function () {
        'use strict';

        var forEach = require('foreach');
        var availableTypedArrays = require('available-typed-arrays');
        var callBound = require('es-abstract/helpers/callBound');

        var $toString = callBound('Object.prototype.toString');
        var hasSymbols = require('has-symbols')();
        var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';

        var typedArrays = availableTypedArrays();

        var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
          for (var i = 0; i < array.length; i += 1) {
            if (array[i] === value) {
              return i;
            }
          }
          return -1;
        };
        var $slice = callBound('String.prototype.slice');
        var toStrTags = {};
        var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
        var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
        if (hasToStringTag && gOPD && getPrototypeOf) {
          forEach(typedArrays, function (typedArray) {
            var arr = new global[typedArray]();
            if (!(Symbol.toStringTag in arr)) {
              throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
            }
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          });
        }

        var tryTypedArrays = function tryAllTypedArrays(value) {
          var anyTrue = false;
          forEach(toStrTags, function (getter, typedArray) {
            if (!anyTrue) {
              try {
                anyTrue = getter.call(value) === typedArray;
              } catch (e) { /**/ }
            }
          });
          return anyTrue;
        };

        module.exports = function isTypedArray(value) {
          if (!value || typeof value !== 'object') { return false; }
          if (!hasToStringTag) {
            var tag = $slice($toString(value), 8, -1);
            return $indexOf(typedArrays, tag) > -1;
          }
          if (!gOPD) { return false; }
          return tryTypedArrays(value);
        };

      }).call(this)
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  }, { "available-typed-arrays": 121, "es-abstract/helpers/callBound": 132, "es-abstract/helpers/getOwnPropertyDescriptor": 133, "foreach": 135, "has-symbols": 140 }], 148: [function (require, module, exports) {
    (function (process, global, Buffer) {
      (function () {
        'use strict'
        const EE = require('events')
        const Stream = require('stream')
        const Yallist = require('yallist')
        const SD = require('string_decoder').StringDecoder

        const EOF = Symbol('EOF')
        const MAYBE_EMIT_END = Symbol('maybeEmitEnd')
        const EMITTED_END = Symbol('emittedEnd')
        const EMITTING_END = Symbol('emittingEnd')
        const CLOSED = Symbol('closed')
        const READ = Symbol('read')
        const FLUSH = Symbol('flush')
        const FLUSHCHUNK = Symbol('flushChunk')
        const ENCODING = Symbol('encoding')
        const DECODER = Symbol('decoder')
        const FLOWING = Symbol('flowing')
        const PAUSED = Symbol('paused')
        const RESUME = Symbol('resume')
        const BUFFERLENGTH = Symbol('bufferLength')
        const BUFFERPUSH = Symbol('bufferPush')
        const BUFFERSHIFT = Symbol('bufferShift')
        const OBJECTMODE = Symbol('objectMode')
        const DESTROYED = Symbol('destroyed')

        // TODO remove when Node v8 support drops
        const doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1'
        const ASYNCITERATOR = doIter && Symbol.asyncIterator
          || Symbol('asyncIterator not implemented')
        const ITERATOR = doIter && Symbol.iterator
          || Symbol('iterator not implemented')

        // events that mean 'the stream is over'
        // these are treated specially, and re-emitted
        // if they are listened for after emitting.
        const isEndish = ev =>
          ev === 'end' ||
          ev === 'finish' ||
          ev === 'prefinish'

        const isArrayBuffer = b => b instanceof ArrayBuffer ||
          typeof b === 'object' &&
          b.constructor &&
          b.constructor.name === 'ArrayBuffer' &&
          b.byteLength >= 0

        const isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)

        module.exports = class Minipass extends Stream {
          constructor(options) {
            super()
            this[FLOWING] = false
            // whether we're explicitly paused
            this[PAUSED] = false
            this.pipes = new Yallist()
            this.buffer = new Yallist()
            this[OBJECTMODE] = options && options.objectMode || false
            if (this[OBJECTMODE])
              this[ENCODING] = null
            else
              this[ENCODING] = options && options.encoding || null
            if (this[ENCODING] === 'buffer')
              this[ENCODING] = null
            this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null
            this[EOF] = false
            this[EMITTED_END] = false
            this[EMITTING_END] = false
            this[CLOSED] = false
            this.writable = true
            this.readable = true
            this[BUFFERLENGTH] = 0
            this[DESTROYED] = false
          }

          get bufferLength() { return this[BUFFERLENGTH] }

          get encoding() { return this[ENCODING] }
          set encoding(enc) {
            if (this[OBJECTMODE])
              throw new Error('cannot set encoding in objectMode')

            if (this[ENCODING] && enc !== this[ENCODING] &&
              (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
              throw new Error('cannot change encoding')

            if (this[ENCODING] !== enc) {
              this[DECODER] = enc ? new SD(enc) : null
              if (this.buffer.length)
                this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))
            }

            this[ENCODING] = enc
          }

          setEncoding(enc) {
            this.encoding = enc
          }

          get objectMode() { return this[OBJECTMODE] }
          set objectMode(om) { this[OBJECTMODE] = this[OBJECTMODE] || !!om }

          write(chunk, encoding, cb) {
            if (this[EOF])
              throw new Error('write after end')

            if (this[DESTROYED]) {
              this.emit('error', Object.assign(
                new Error('Cannot call write after a stream was destroyed'),
                { code: 'ERR_STREAM_DESTROYED' }
              ))
              return true
            }

            if (typeof encoding === 'function')
              cb = encoding, encoding = 'utf8'

            if (!encoding)
              encoding = 'utf8'

            // convert array buffers and typed array views into buffers
            // at some point in the future, we may want to do the opposite!
            // leave strings and buffers as-is
            // anything else switches us into object mode
            if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
              if (isArrayBufferView(chunk))
                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)
              else if (isArrayBuffer(chunk))
                chunk = Buffer.from(chunk)
              else if (typeof chunk !== 'string')
                // use the setter so we throw if we have encoding set
                this.objectMode = true
            }

            // this ensures at this point that the chunk is a buffer or string
            // don't buffer it up or send it to the decoder
            if (!this.objectMode && !chunk.length) {
              if (this[BUFFERLENGTH] !== 0)
                this.emit('readable')
              if (cb)
                cb()
              return this.flowing
            }

            // fast-path writing strings of same encoding to a stream with
            // an empty buffer, skipping the buffer/decoder dance
            if (typeof chunk === 'string' && !this[OBJECTMODE] &&
              // unless it is a string already ready for us to use
              !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
              chunk = Buffer.from(chunk, encoding)
            }

            if (Buffer.isBuffer(chunk) && this[ENCODING])
              chunk = this[DECODER].write(chunk)

            if (this.flowing) {
              // if we somehow have something in the buffer, but we think we're
              // flowing, then we need to flush all that out first, or we get
              // chunks coming in out of order.  Can't emit 'drain' here though,
              // because we're mid-write, so that'd be bad.
              if (this[BUFFERLENGTH] !== 0)
                this[FLUSH](true)
              this.emit('data', chunk)
            } else
              this[BUFFERPUSH](chunk)

            if (this[BUFFERLENGTH] !== 0)
              this.emit('readable')

            if (cb)
              cb()

            return this.flowing
          }

          read(n) {
            if (this[DESTROYED])
              return null

            try {
              if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])
                return null

              if (this[OBJECTMODE])
                n = null

              if (this.buffer.length > 1 && !this[OBJECTMODE]) {
                if (this.encoding)
                  this.buffer = new Yallist([
                    Array.from(this.buffer).join('')
                  ])
                else
                  this.buffer = new Yallist([
                    Buffer.concat(Array.from(this.buffer), this[BUFFERLENGTH])
                  ])
              }

              return this[READ](n || null, this.buffer.head.value)
            } finally {
              this[MAYBE_EMIT_END]()
            }
          }

          [READ](n, chunk) {
            if (n === chunk.length || n === null)
              this[BUFFERSHIFT]()
            else {
              this.buffer.head.value = chunk.slice(n)
              chunk = chunk.slice(0, n)
              this[BUFFERLENGTH] -= n
            }

            this.emit('data', chunk)

            if (!this.buffer.length && !this[EOF])
              this.emit('drain')

            return chunk
          }

          end(chunk, encoding, cb) {
            if (typeof chunk === 'function')
              cb = chunk, chunk = null
            if (typeof encoding === 'function')
              cb = encoding, encoding = 'utf8'
            if (chunk)
              this.write(chunk, encoding)
            if (cb)
              this.once('end', cb)
            this[EOF] = true
            this.writable = false

            // if we haven't written anything, then go ahead and emit,
            // even if we're not reading.
            // we'll re-emit if a new 'end' listener is added anyway.
            // This makes MP more suitable to write-only use cases.
            if (this.flowing || !this[PAUSED])
              this[MAYBE_EMIT_END]()
            return this
          }

          // don't let the internal resume be overwritten
          [RESUME]() {
            if (this[DESTROYED])
              return

            this[PAUSED] = false
            this[FLOWING] = true
            this.emit('resume')
            if (this.buffer.length)
              this[FLUSH]()
            else if (this[EOF])
              this[MAYBE_EMIT_END]()
            else
              this.emit('drain')
          }

          resume() {
            return this[RESUME]()
          }

          pause() {
            this[FLOWING] = false
            this[PAUSED] = true
          }

          get destroyed() {
            return this[DESTROYED]
          }

          get flowing() {
            return this[FLOWING]
          }

          get paused() {
            return this[PAUSED]
          }

          [BUFFERPUSH](chunk) {
            if (this[OBJECTMODE])
              this[BUFFERLENGTH] += 1
            else
              this[BUFFERLENGTH] += chunk.length
            return this.buffer.push(chunk)
          }

          [BUFFERSHIFT]() {
            if (this.buffer.length) {
              if (this[OBJECTMODE])
                this[BUFFERLENGTH] -= 1
              else
                this[BUFFERLENGTH] -= this.buffer.head.value.length
            }
            return this.buffer.shift()
          }

          [FLUSH](noDrain) {
            do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))

            if (!noDrain && !this.buffer.length && !this[EOF])
              this.emit('drain')
          }

          [FLUSHCHUNK](chunk) {
            return chunk ? (this.emit('data', chunk), this.flowing) : false
          }

          pipe(dest, opts) {
            if (this[DESTROYED])
              return

            const ended = this[EMITTED_END]
            opts = opts || {}
            if (dest === process.stdout || dest === process.stderr)
              opts.end = false
            else
              opts.end = opts.end !== false

            const p = { dest: dest, opts: opts, ondrain: _ => this[RESUME]() }
            this.pipes.push(p)

            dest.on('drain', p.ondrain)
            this[RESUME]()
            // piping an ended stream ends immediately
            if (ended && p.opts.end)
              p.dest.end()
            return dest
          }

          addListener(ev, fn) {
            return this.on(ev, fn)
          }

          on(ev, fn) {
            try {
              return super.on(ev, fn)
            } finally {
              if (ev === 'data' && !this.pipes.length && !this.flowing)
                this[RESUME]()
              else if (isEndish(ev) && this[EMITTED_END]) {
                super.emit(ev)
                this.removeAllListeners(ev)
              }
            }
          }

          get emittedEnd() {
            return this[EMITTED_END]
          }

          [MAYBE_EMIT_END]() {
            if (!this[EMITTING_END] &&
              !this[EMITTED_END] &&
              !this[DESTROYED] &&
              this.buffer.length === 0 &&
              this[EOF]) {
              this[EMITTING_END] = true
              this.emit('end')
              this.emit('prefinish')
              this.emit('finish')
              if (this[CLOSED])
                this.emit('close')
              this[EMITTING_END] = false
            }
          }

          emit(ev, data) {
            // error and close are only events allowed after calling destroy()
            if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])
              return
            else if (ev === 'data') {
              if (!data)
                return

              if (this.pipes.length)
                this.pipes.forEach(p =>
                  p.dest.write(data) === false && this.pause())
            } else if (ev === 'end') {
              // only actual end gets this treatment
              if (this[EMITTED_END] === true)
                return

              this[EMITTED_END] = true
              this.readable = false

              if (this[DECODER]) {
                data = this[DECODER].end()
                if (data) {
                  this.pipes.forEach(p => p.dest.write(data))
                  super.emit('data', data)
                }
              }

              this.pipes.forEach(p => {
                p.dest.removeListener('drain', p.ondrain)
                if (p.opts.end)
                  p.dest.end()
              })
            } else if (ev === 'close') {
              this[CLOSED] = true
              // don't emit close before 'end' and 'finish'
              if (!this[EMITTED_END] && !this[DESTROYED])
                return
            }

            // TODO: replace with a spread operator when Node v4 support drops
            const args = new Array(arguments.length)
            args[0] = ev
            args[1] = data
            if (arguments.length > 2) {
              for (let i = 2; i < arguments.length; i++) {
                args[i] = arguments[i]
              }
            }

            try {
              return super.emit.apply(this, args)
            } finally {
              if (!isEndish(ev))
                this[MAYBE_EMIT_END]()
              else
                this.removeAllListeners(ev)
            }
          }

          // const all = await stream.collect()
          collect() {
            const buf = []
            if (!this[OBJECTMODE])
              buf.dataLength = 0
            // set the promise first, in case an error is raised
            // by triggering the flow here.
            const p = this.promise()
            this.on('data', c => {
              buf.push(c)
              if (!this[OBJECTMODE])
                buf.dataLength += c.length
            })
            return p.then(() => buf)
          }

          // const data = await stream.concat()
          concat() {
            return this[OBJECTMODE]
              ? Promise.reject(new Error('cannot concat in objectMode'))
              : this.collect().then(buf =>
                this[OBJECTMODE]
                  ? Promise.reject(new Error('cannot concat in objectMode'))
                  : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength))
          }

          // stream.promise().then(() => done, er => emitted error)
          promise() {
            return new Promise((resolve, reject) => {
              this.on(DESTROYED, () => reject(new Error('stream destroyed')))
              this.on('end', () => resolve())
              this.on('error', er => reject(er))
            })
          }

          // for await (let chunk of stream)
          [ASYNCITERATOR]() {
            const next = () => {
              const res = this.read()
              if (res !== null)
                return Promise.resolve({ done: false, value: res })

              if (this[EOF])
                return Promise.resolve({ done: true })

              let resolve = null
              let reject = null
              const onerr = er => {
                this.removeListener('data', ondata)
                this.removeListener('end', onend)
                reject(er)
              }
              const ondata = value => {
                this.removeListener('error', onerr)
                this.removeListener('end', onend)
                this.pause()
                resolve({ value: value, done: !!this[EOF] })
              }
              const onend = () => {
                this.removeListener('error', onerr)
                this.removeListener('data', ondata)
                resolve({ done: true })
              }
              const ondestroy = () => onerr(new Error('stream destroyed'))
              return new Promise((res, rej) => {
                reject = rej
                resolve = res
                this.once(DESTROYED, ondestroy)
                this.once('error', onerr)
                this.once('end', onend)
                this.once('data', ondata)
              })
            }

            return { next }
          }

          // for (let chunk of stream)
          [ITERATOR]() {
            const next = () => {
              const value = this.read()
              const done = value === null
              return { value, done }
            }
            return { next }
          }

          destroy(er) {
            if (this[DESTROYED]) {
              if (er)
                this.emit('error', er)
              else
                this.emit(DESTROYED)
              return this
            }

            this[DESTROYED] = true

            // throw away all buffered data, it's never coming out
            this.buffer = new Yallist()
            this[BUFFERLENGTH] = 0

            if (typeof this.close === 'function' && !this[CLOSED])
              this.close()

            if (er)
              this.emit('error', er)
            else // if no error to emit, still reject pending promises
              this.emit(DESTROYED)

            return this
          }

          static isStream(s) {
            return !!s && (s instanceof Minipass || s instanceof Stream ||
              s instanceof EE && (
                typeof s.pipe === 'function' || // readable
                (typeof s.write === 'function' && typeof s.end === 'function') // writable
              ))
          }
        }

      }).call(this)
    }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require("buffer").Buffer)
  }, { "_process": 163, "buffer": 126, "events": 134, "stream": 165, "string_decoder": 180, "yallist": 188 }], 149: [function (require, module, exports) {
    // Update with any zlib constants that are added or changed in the future.
    // Node v6 didn't export this, so we just hard code the version and rely
    // on all the other hard-coded values from zlib v4736.  When node v6
    // support drops, we can just export the realZlibConstants object.
    const realZlibConstants = require('zlib').constants ||
  /* istanbul ignore next */ { ZLIB_VERNUM: 4736 }

    module.exports = Object.freeze(Object.assign(Object.create(null), {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_VERSION_ERROR: -6,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      DEFLATE: 1,
      INFLATE: 2,
      GZIP: 3,
      GUNZIP: 4,
      DEFLATERAW: 5,
      INFLATERAW: 6,
      UNZIP: 7,
      BROTLI_DECODE: 8,
      BROTLI_ENCODE: 9,
      Z_MIN_WINDOWBITS: 8,
      Z_MAX_WINDOWBITS: 15,
      Z_DEFAULT_WINDOWBITS: 15,
      Z_MIN_CHUNK: 64,
      Z_MAX_CHUNK: Infinity,
      Z_DEFAULT_CHUNK: 16384,
      Z_MIN_MEMLEVEL: 1,
      Z_MAX_MEMLEVEL: 9,
      Z_DEFAULT_MEMLEVEL: 8,
      Z_MIN_LEVEL: -1,
      Z_MAX_LEVEL: 9,
      Z_DEFAULT_LEVEL: -1,
      BROTLI_OPERATION_PROCESS: 0,
      BROTLI_OPERATION_FLUSH: 1,
      BROTLI_OPERATION_FINISH: 2,
      BROTLI_OPERATION_EMIT_METADATA: 3,
      BROTLI_MODE_GENERIC: 0,
      BROTLI_MODE_TEXT: 1,
      BROTLI_MODE_FONT: 2,
      BROTLI_DEFAULT_MODE: 0,
      BROTLI_MIN_QUALITY: 0,
      BROTLI_MAX_QUALITY: 11,
      BROTLI_DEFAULT_QUALITY: 11,
      BROTLI_MIN_WINDOW_BITS: 10,
      BROTLI_MAX_WINDOW_BITS: 24,
      BROTLI_LARGE_MAX_WINDOW_BITS: 30,
      BROTLI_DEFAULT_WINDOW: 22,
      BROTLI_MIN_INPUT_BLOCK_BITS: 16,
      BROTLI_MAX_INPUT_BLOCK_BITS: 24,
      BROTLI_PARAM_MODE: 0,
      BROTLI_PARAM_QUALITY: 1,
      BROTLI_PARAM_LGWIN: 2,
      BROTLI_PARAM_LGBLOCK: 3,
      BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
      BROTLI_PARAM_SIZE_HINT: 5,
      BROTLI_PARAM_LARGE_WINDOW: 6,
      BROTLI_PARAM_NPOSTFIX: 7,
      BROTLI_PARAM_NDIRECT: 8,
      BROTLI_DECODER_RESULT_ERROR: 0,
      BROTLI_DECODER_RESULT_SUCCESS: 1,
      BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
      BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
      BROTLI_DECODER_NO_ERROR: 0,
      BROTLI_DECODER_SUCCESS: 1,
      BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
      BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
      BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
      BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
      BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
      BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
      BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
      BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
      BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
      BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
      BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
      BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
      BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
      BROTLI_DECODER_ERROR_UNREACHABLE: -31,
    }, realZlibConstants))

  }, { "zlib": 125 }], 150: [function (require, module, exports) {
    'use strict'

    const assert = require('assert')
    const Buffer = require('buffer').Buffer
    const realZlib = require('zlib')

    const constants = exports.constants = require('./constants.js')
    const Minipass = require('minipass')

    const OriginalBufferConcat = Buffer.concat

    const _superWrite = Symbol('_superWrite')
    class ZlibError extends Error {
      constructor(err) {
        super('zlib: ' + err.message)
        this.code = err.code
        this.errno = err.errno
        /* istanbul ignore if */
        if (!this.code)
          this.code = 'ZLIB_ERROR'

        this.message = 'zlib: ' + err.message
        Error.captureStackTrace(this, this.constructor)
      }

      get name() {
        return 'ZlibError'
      }
    }

    // the Zlib class they all inherit from
    // This thing manages the queue of requests, and returns
    // true or false if there is anything in the queue when
    // you call the .write() method.
    const _opts = Symbol('opts')
    const _flushFlag = Symbol('flushFlag')
    const _finishFlushFlag = Symbol('finishFlushFlag')
    const _fullFlushFlag = Symbol('fullFlushFlag')
    const _handle = Symbol('handle')
    const _onError = Symbol('onError')
    const _sawError = Symbol('sawError')
    const _level = Symbol('level')
    const _strategy = Symbol('strategy')
    const _ended = Symbol('ended')
    const _defaultFullFlush = Symbol('_defaultFullFlush')

    class ZlibBase extends Minipass {
      constructor(opts, mode) {
        if (!opts || typeof opts !== 'object')
          throw new TypeError('invalid options for ZlibBase constructor')

        super(opts)
        this[_sawError] = false
        this[_ended] = false
        this[_opts] = opts

        this[_flushFlag] = opts.flush
        this[_finishFlushFlag] = opts.finishFlush
        // this will throw if any options are invalid for the class selected
        try {
          this[_handle] = new realZlib[mode](opts)
        } catch (er) {
          // make sure that all errors get decorated properly
          throw new ZlibError(er)
        }

        this[_onError] = (err) => {
          // no sense raising multiple errors, since we abort on the first one.
          if (this[_sawError])
            return

          this[_sawError] = true

          // there is no way to cleanly recover.
          // continuing only obscures problems.
          this.close()
          this.emit('error', err)
        }

        this[_handle].on('error', er => this[_onError](new ZlibError(er)))
        this.once('end', () => this.close)
      }

      close() {
        if (this[_handle]) {
          this[_handle].close()
          this[_handle] = null
          this.emit('close')
        }
      }

      reset() {
        if (!this[_sawError]) {
          assert(this[_handle], 'zlib binding closed')
          return this[_handle].reset()
        }
      }

      flush(flushFlag) {
        if (this.ended)
          return

        if (typeof flushFlag !== 'number')
          flushFlag = this[_fullFlushFlag]
        this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))
      }

      end(chunk, encoding, cb) {
        if (chunk)
          this.write(chunk, encoding)
        this.flush(this[_finishFlushFlag])
        this[_ended] = true
        return super.end(null, null, cb)
      }

      get ended() {
        return this[_ended]
      }

      write(chunk, encoding, cb) {
        // process the chunk using the sync process
        // then super.write() all the outputted chunks
        if (typeof encoding === 'function')
          cb = encoding, encoding = 'utf8'

        if (typeof chunk === 'string')
          chunk = Buffer.from(chunk, encoding)

        if (this[_sawError])
          return
        assert(this[_handle], 'zlib binding closed')

        // _processChunk tries to .close() the native handle after it's done, so we
        // intercept that by temporarily making it a no-op.
        const nativeHandle = this[_handle]._handle
        const originalNativeClose = nativeHandle.close
        nativeHandle.close = () => { }
        const originalClose = this[_handle].close
        this[_handle].close = () => { }
        // It also calls `Buffer.concat()` at the end, which may be convenient
        // for some, but which we are not interested in as it slows us down.
        Buffer.concat = (args) => args
        let result
        try {
          const flushFlag = typeof chunk[_flushFlag] === 'number'
            ? chunk[_flushFlag] : this[_flushFlag]
          result = this[_handle]._processChunk(chunk, flushFlag)
          // if we don't throw, reset it back how it was
          Buffer.concat = OriginalBufferConcat
        } catch (err) {
          // or if we do, put Buffer.concat() back before we emit error
          // Error events call into user code, which may call Buffer.concat()
          Buffer.concat = OriginalBufferConcat
          this[_onError](new ZlibError(err))
        } finally {
          if (this[_handle]) {
            // Core zlib resets `_handle` to null after attempting to close the
            // native handle. Our no-op handler prevented actual closure, but we
            // need to restore the `._handle` property.
            this[_handle]._handle = nativeHandle
            nativeHandle.close = originalNativeClose
            this[_handle].close = originalClose
            // `_processChunk()` adds an 'error' listener. If we don't remove it
            // after each call, these handlers start piling up.
            this[_handle].removeAllListeners('error')
            // make sure OUR error listener is still attached tho
          }
        }

        if (this[_handle])
          this[_handle].on('error', er => this[_onError](new ZlibError(er)))

        let writeReturn
        if (result) {
          if (Array.isArray(result) && result.length > 0) {
            // The first buffer is always `handle._outBuffer`, which would be
            // re-used for later invocations; so, we always have to copy that one.
            writeReturn = this[_superWrite](Buffer.from(result[0]))
            for (let i = 1; i < result.length; i++) {
              writeReturn = this[_superWrite](result[i])
            }
          } else {
            writeReturn = this[_superWrite](Buffer.from(result))
          }
        }

        if (cb)
          cb()
        return writeReturn
      }

      [_superWrite](data) {
        return super.write(data)
      }
    }

    class Zlib extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {}

        opts.flush = opts.flush || constants.Z_NO_FLUSH
        opts.finishFlush = opts.finishFlush || constants.Z_FINISH
        super(opts, mode)

        this[_fullFlushFlag] = constants.Z_FULL_FLUSH
        this[_level] = opts.level
        this[_strategy] = opts.strategy
      }

      params(level, strategy) {
        if (this[_sawError])
          return

        if (!this[_handle])
          throw new Error('cannot switch params when binding is closed')

        // no way to test this without also not supporting params at all
        /* istanbul ignore if */
        if (!this[_handle].params)
          throw new Error('not supported in this implementation')

        if (this[_level] !== level || this[_strategy] !== strategy) {
          this.flush(constants.Z_SYNC_FLUSH)
          assert(this[_handle], 'zlib binding closed')
          // .params() calls .flush(), but the latter is always async in the
          // core zlib. We override .flush() temporarily to intercept that and
          // flush synchronously.
          const origFlush = this[_handle].flush
          this[_handle].flush = (flushFlag, cb) => {
            this.flush(flushFlag)
            cb()
          }
          try {
            this[_handle].params(level, strategy)
          } finally {
            this[_handle].flush = origFlush
          }
          /* istanbul ignore else */
          if (this[_handle]) {
            this[_level] = level
            this[_strategy] = strategy
          }
        }
      }
    }

    // minimal 2-byte header
    class Deflate extends Zlib {
      constructor(opts) {
        super(opts, 'Deflate')
      }
    }

    class Inflate extends Zlib {
      constructor(opts) {
        super(opts, 'Inflate')
      }
    }

    // gzip - bigger header, same deflate compression
    const _portable = Symbol('_portable')
    class Gzip extends Zlib {
      constructor(opts) {
        super(opts, 'Gzip')
        this[_portable] = opts && !!opts.portable
      }

      [_superWrite](data) {
        if (!this[_portable])
          return super[_superWrite](data)

        // we'll always get the header emitted in one first chunk
        // overwrite the OS indicator byte with 0xFF
        this[_portable] = false
        data[9] = 255
        return super[_superWrite](data)
      }
    }

    class Gunzip extends Zlib {
      constructor(opts) {
        super(opts, 'Gunzip')
      }
    }

    // raw - no header
    class DeflateRaw extends Zlib {
      constructor(opts) {
        super(opts, 'DeflateRaw')
      }
    }

    class InflateRaw extends Zlib {
      constructor(opts) {
        super(opts, 'InflateRaw')
      }
    }

    // auto-detect header.
    class Unzip extends Zlib {
      constructor(opts) {
        super(opts, 'Unzip')
      }
    }

    class Brotli extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {}

        opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS
        opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH

        super(opts, mode)

        this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH
      }
    }

    class BrotliCompress extends Brotli {
      constructor(opts) {
        super(opts, 'BrotliCompress')
      }
    }

    class BrotliDecompress extends Brotli {
      constructor(opts) {
        super(opts, 'BrotliDecompress')
      }
    }

    exports.Deflate = Deflate
    exports.Inflate = Inflate
    exports.Gzip = Gzip
    exports.Gunzip = Gunzip
    exports.DeflateRaw = DeflateRaw
    exports.InflateRaw = InflateRaw
    exports.Unzip = Unzip
    /* istanbul ignore else */
    if (typeof realZlib.BrotliCompress === 'function') {
      exports.BrotliCompress = BrotliCompress
      exports.BrotliDecompress = BrotliDecompress
    } else {
      exports.BrotliCompress = exports.BrotliDecompress = class {
        constructor() {
          throw new Error('Brotli is not supported in this version of Node.js')
        }
      }
    }

  }, { "./constants.js": 149, "assert": 117, "buffer": 126, "minipass": 148, "zlib": 125 }], 151: [function (require, module, exports) {
    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */

    'use strict';
    /* eslint-disable no-unused-vars */
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;

    function toObject(val) {
      if (val === null || val === undefined) {
        throw new TypeError('Object.assign cannot be called with null or undefined');
      }

      return Object(val);
    }

    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }

        // Detect buggy property enumeration order in older V8 versions.

        // https://bugs.chromium.org/p/v8/issues/detail?id=4118
        var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
        test1[5] = 'de';
        if (Object.getOwnPropertyNames(test1)[0] === '5') {
          return false;
        }

        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2['_' + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
          return test2[n];
        });
        if (order2.join('') !== '0123456789') {
          return false;
        }

        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        var test3 = {};
        'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join('') !==
          'abcdefghijklmnopqrst') {
          return false;
        }

        return true;
      } catch (err) {
        // We don't expect any of the above to throw, but better to be safe.
        return false;
      }
    }

    module.exports = shouldUseNative() ? Object.assign : function (target, source) {
      var from;
      var to = toObject(target);
      var symbols;

      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);

        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }

        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }

      return to;
    };

  }, {}], 152: [function (require, module, exports) {
    'use strict';


    var TYPED_OK = (typeof Uint8Array !== 'undefined') &&
      (typeof Uint16Array !== 'undefined') &&
      (typeof Int32Array !== 'undefined');

    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }

    exports.assign = function (obj /*from1, from2, from3, ...*/) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) { continue; }

        if (typeof source !== 'object') {
          throw new TypeError(source + 'must be non-object');
        }

        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }

      return obj;
    };


    // reduce buffer size, avoiding mem copy
    exports.shrinkBuf = function (buf, size) {
      if (buf.length === size) { return buf; }
      if (buf.subarray) { return buf.subarray(0, size); }
      buf.length = size;
      return buf;
    };


    var fnTyped = {
      arraySet: function (dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        // Fallback to ordinary array
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function (chunks) {
        var i, l, len, pos, chunk, result;

        // calculate data length
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }

        // join chunks
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }

        return result;
      }
    };

    var fnUntyped = {
      arraySet: function (dest, src, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function (chunks) {
        return [].concat.apply([], chunks);
      }
    };


    // Enable/Disable typed arrays use, for testing
    //
    exports.setTyped = function (on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };

    exports.setTyped(TYPED_OK);

  }, {}], 153: [function (require, module, exports) {
    'use strict';

    // Note: adler32 takes 12% for level 0 and 2% for level 6.
    // It isn't worth it to make additional optimizations as in original.
    // Small size is preferable.

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    function adler32(adler, buf, len, pos) {
      var s1 = (adler & 0xffff) | 0,
        s2 = ((adler >>> 16) & 0xffff) | 0,
        n = 0;

      while (len !== 0) {
        // Set limit ~ twice less than 5552, to keep
        // s2 in 31-bits, because we force signed ints.
        // in other case %= will fail.
        n = len > 2000 ? 2000 : len;
        len -= n;

        do {
          s1 = (s1 + buf[pos++]) | 0;
          s2 = (s2 + s1) | 0;
        } while (--n);

        s1 %= 65521;
        s2 %= 65521;
      }

      return (s1 | (s2 << 16)) | 0;
    }


    module.exports = adler32;

  }, {}], 154: [function (require, module, exports) {
    'use strict';

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    module.exports = {

      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,

      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,

      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,


      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,

      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,

      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };

  }, {}], 155: [function (require, module, exports) {
    'use strict';

    // Note: we can't get significant speed boost here.
    // So write code to minimize size - no pregenerated tables
    // and array tools dependencies.

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    // Use ordinary array, since untyped makes no boost here
    function makeTable() {
      var c, table = [];

      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        table[n] = c;
      }

      return table;
    }

    // Create table on load. Just 255 signed longs. Not a problem.
    var crcTable = makeTable();


    function crc32(crc, buf, len, pos) {
      var t = crcTable,
        end = pos + len;

      crc ^= -1;

      for (var i = pos; i < end; i++) {
        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
      }

      return (crc ^ (-1)); // >>> 0;
    }


    module.exports = crc32;

  }, {}], 156: [function (require, module, exports) {
    'use strict';

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    var utils = require('../utils/common');
    var trees = require('./trees');
    var adler32 = require('./adler32');
    var crc32 = require('./crc32');
    var msg = require('./messages');

    /* Public constants ==========================================================*/
    /* ===========================================================================*/


    /* Allowed flush values; see deflate() and inflate() below for details */
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    //var Z_SYNC_FLUSH    = 2;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    //var Z_TREES         = 6;


    /* Return codes for the compression/decompression functions. Negative values
     * are errors, positive values are used for special but normal events.
     */
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    //var Z_NEED_DICT     = 2;
    //var Z_ERRNO         = -1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    //var Z_MEM_ERROR     = -4;
    var Z_BUF_ERROR = -5;
    //var Z_VERSION_ERROR = -6;


    /* compression levels */
    //var Z_NO_COMPRESSION      = 0;
    //var Z_BEST_SPEED          = 1;
    //var Z_BEST_COMPRESSION    = 9;
    var Z_DEFAULT_COMPRESSION = -1;


    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;

    /* Possible values of the data_type field (though see inflate()) */
    //var Z_BINARY              = 0;
    //var Z_TEXT                = 1;
    //var Z_ASCII               = 1; // = Z_TEXT
    var Z_UNKNOWN = 2;


    /* The deflate compression method */
    var Z_DEFLATED = 8;

    /*============================================================================*/


    var MAX_MEM_LEVEL = 9;
    /* Maximum value for memLevel in deflateInit2 */
    var MAX_WBITS = 15;
    /* 32K LZ77 window */
    var DEF_MEM_LEVEL = 8;


    var LENGTH_CODES = 29;
    /* number of length codes, not counting the special END_BLOCK code */
    var LITERALS = 256;
    /* number of literal bytes 0..255 */
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    /* number of Literal or Length codes, including the END_BLOCK code */
    var D_CODES = 30;
    /* number of distance codes */
    var BL_CODES = 19;
    /* number of codes used to transfer the bit lengths */
    var HEAP_SIZE = 2 * L_CODES + 1;
    /* maximum heap size */
    var MAX_BITS = 15;
    /* All codes must not exceed MAX_BITS bits */

    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

    var PRESET_DICT = 0x20;

    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;

    var BS_NEED_MORE = 1; /* block not completed, need more input or more output */
    var BS_BLOCK_DONE = 2; /* block flush performed */
    var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
    var BS_FINISH_DONE = 4; /* finish done, accept no more input or output */

    var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }

    function rank(f) {
      return ((f) << 1) - ((f) > 4 ? 9 : 0);
    }

    function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


    /* =========================================================================
     * Flush as much pending output as possible. All deflate() output goes
     * through this function so some applications may wish to modify it
     * to avoid allocating a large strm->output buffer and copying into it.
     * (See also read_buf()).
     */
    function flush_pending(strm) {
      var s = strm.state;

      //_tr_flush_bits(s);
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) { return; }

      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }


    function flush_block_only(s, last) {
      trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }


    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }


    /* =========================================================================
     * Put a short in the pending buffer. The 16-bit value is put in MSB order.
     * IN assertion: the stream state is correct and there is enough room in
     * pending_buf.
     */
    function putShortMSB(s, b) {
      //  put_byte(s, (Byte)(b >> 8));
      //  put_byte(s, (Byte)(b & 0xff));
      s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
      s.pending_buf[s.pending++] = b & 0xff;
    }


    /* ===========================================================================
     * Read a new buffer from the current input stream, update the adler32
     * and total number of bytes read.  All deflate() input goes through
     * this function so some applications may wish to modify it to avoid
     * allocating a large strm->input buffer and copying from it.
     * (See also flush_pending()).
     */
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;

      if (len > size) { len = size; }
      if (len === 0) { return 0; }

      strm.avail_in -= len;

      // zmemcpy(buf, strm->next_in, len);
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      }

      else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }

      strm.next_in += len;
      strm.total_in += len;

      return len;
    }


    /* ===========================================================================
     * Set match_start to the longest match starting at the given string and
     * return its length. Matches shorter or equal to prev_length are discarded,
     * in which case the result is equal to prev_length and match_start is
     * garbage.
     * IN assertions: cur_match is the head of the hash chain for the current
     *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
     * OUT assertion: the match length is not greater than s->lookahead.
     */
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;      /* max hash chain length */
      var scan = s.strstart; /* current string */
      var match;                       /* matched string */
      var len;                           /* length of current match */
      var best_len = s.prev_length;              /* best match length so far */
      var nice_match = s.nice_match;             /* stop if match long enough */
      var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
        s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

      var _win = s.window; // shortcut

      var wmask = s.w_mask;
      var prev = s.prev;

      /* Stop when cur_match becomes <= limit. To simplify the code,
       * we prevent matches with the string of window index 0.
       */

      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];

      /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
       * It is easy to get rid of this optimization if necessary.
       */
      // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

      /* Do not waste too much time if we already have a good match: */
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      /* Do not look for matches beyond the end of the input. This is necessary
       * to make deflate deterministic.
       */
      if (nice_match > s.lookahead) { nice_match = s.lookahead; }

      // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

      do {
        // Assert(cur_match < s->strstart, "no future");
        match = cur_match;

        /* Skip to next match if the match length cannot increase
         * or if the match length is less than 2.  Note that the checks below
         * for insufficient lookahead only occur occasionally for performance
         * reasons.  Therefore uninitialized memory will be accessed, and
         * conditional jumps will be made that depend on those values.
         * However the length of the match is limited to the lookahead, so
         * the output of deflate is not affected by the uninitialized values.
         */

        if (_win[match + best_len] !== scan_end ||
          _win[match + best_len - 1] !== scan_end1 ||
          _win[match] !== _win[scan] ||
          _win[++match] !== _win[scan + 1]) {
          continue;
        }

        /* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS >= 8.
         */
        scan += 2;
        match++;
        // Assert(*scan == *match, "match[2]?");

        /* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */
        do {
          /*jshint noempty:false*/
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
        _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
        _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
        _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
          scan < strend);

        // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;

        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }


    /* ===========================================================================
     * Fill the window when the lookahead becomes insufficient.
     * Updates strstart and lookahead.
     *
     * IN assertion: lookahead < MIN_LOOKAHEAD
     * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
     *    At least one byte has been read, or avail_in == 0; reads are
     *    performed for at least two bytes (required for the zip translate_eol
     *    option -- not supported here).
     */
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;

      //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

      do {
        more = s.window_size - s.lookahead - s.strstart;

        // JS ints have 32 bit, block below not needed
        /* Deal with !@#$% 64K limit: */
        //if (sizeof(int) <= 2) {
        //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
        //        more = wsize;
        //
        //  } else if (more == (unsigned)(-1)) {
        //        /* Very unlikely, but possible on 16 bit machine if
        //         * strstart == 0 && lookahead == 1 (input done a byte at time)
        //         */
        //        more--;
        //    }
        //}


        /* If the window is almost full and there is insufficient lookahead,
         * move the upper half to the lower one to make room in the upper half.
         */
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          /* we now have strstart >= MAX_DIST */
          s.block_start -= _w_size;

          /* Slide the hash table (could be avoided with 32 bit values
           at the expense of memory usage). We slide even when level == 0
           to keep the hash table consistent if we switch back to level > 0
           later. (Using level 0 permanently is not an optimal usage of
           zlib, so we don't care about this pathological case.)
           */

          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = (m >= _w_size ? m - _w_size : 0);
          } while (--n);

          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = (m >= _w_size ? m - _w_size : 0);
            /* If n is not on any hash chain, prev[n] is garbage but
             * its value will never be used.
             */
          } while (--n);

          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }

        /* If there was no sliding:
         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
         *    more == window_size - lookahead - strstart
         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
         * => more >= window_size - 2*WSIZE + 2
         * In the BIG_MEM or MMAP case (not yet supported),
         *   window_size == input_size + MIN_LOOKAHEAD  &&
         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
         * Otherwise, window_size == 2*WSIZE so more >= 2.
         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
         */
        //Assert(more >= 2, "more < 2");
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;

        /* Initialize the hash value now that we have some input: */
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];

          /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
          //#if MIN_MATCH != 3
          //        Call update_hash() MIN_MATCH-3 more times
          //#endif
          while (s.insert) {
            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
         * but this is not important since only literal bytes will be emitted.
         */

      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

      /* If the WIN_INIT bytes after the end of the current data have never been
       * written, then zero those bytes in order to avoid memory check reports of
       * the use of uninitialized (or uninitialised as Julian writes) bytes by
       * the longest match routines.  Update the high water mark for the next
       * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
       * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
       */
      //  if (s.high_water < s.window_size) {
      //    var curr = s.strstart + s.lookahead;
      //    var init = 0;
      //
      //    if (s.high_water < curr) {
      //      /* Previous high water mark below current data -- zero WIN_INIT
      //       * bytes or up to end of window, whichever is less.
      //       */
      //      init = s.window_size - curr;
      //      if (init > WIN_INIT)
      //        init = WIN_INIT;
      //      zmemzero(s->window + curr, (unsigned)init);
      //      s->high_water = curr + init;
      //    }
      //    else if (s->high_water < (ulg)curr + WIN_INIT) {
      //      /* High water mark at or above current data, but below current data
      //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
      //       * to end of window, whichever is less.
      //       */
      //      init = (ulg)curr + WIN_INIT - s->high_water;
      //      if (init > s->window_size - s->high_water)
      //        init = s->window_size - s->high_water;
      //      zmemzero(s->window + s->high_water, (unsigned)init);
      //      s->high_water += init;
      //    }
      //  }
      //
      //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
      //    "not enough room for search");
    }

    /* ===========================================================================
     * Copy without compression as much as possible from the input stream, return
     * the current block state.
     * This function does not insert new strings in the dictionary since
     * uncompressible data is probably not useful. This function is used
     * only for the level=0 compression option.
     * NOTE: this function should be optimized to avoid extra copying from
     * window to pending_buf.
     */
    function deflate_stored(s, flush) {
      /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
       * to pending_buf_size, and each stored block has a 5 byte header:
       */
      var max_block_size = 0xffff;

      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }

      /* Copy as much as possible from input to output: */
      for (; ;) {
        /* Fill the window as much as possible: */
        if (s.lookahead <= 1) {

          //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
          //  s->block_start >= (long)s->w_size, "slide too late");
          //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
          //        s.block_start >= s.w_size)) {
          //        throw  new Error("slide too late");
          //      }

          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }

          if (s.lookahead === 0) {
            break;
          }
          /* flush the current block */
        }
        //Assert(s->block_start >= 0L, "block gone");
        //    if (s.block_start < 0) throw new Error("block gone");

        s.strstart += s.lookahead;
        s.lookahead = 0;

        /* Emit a stored block if pending_buf will be full: */
        var max_start = s.block_start + max_block_size;

        if (s.strstart === 0 || s.strstart >= max_start) {
          /* strstart == 0 is possible when wraparound on 16-bit machine */
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/


        }
        /* Flush if we may have to slide, otherwise block_start may become
         * negative and the data will be gone:
         */
        if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }
      }

      s.insert = 0;

      if (flush === Z_FINISH) {
        /*** FLUSH_BLOCK(s, 1); ***/
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        /***/
        return BS_FINISH_DONE;
      }

      if (s.strstart > s.block_start) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

      return BS_NEED_MORE;
    }

    /* ===========================================================================
     * Compress as much as possible from the input stream, return the current
     * block state.
     * This function does not perform lazy evaluation of matches and inserts
     * new strings in the dictionary only for unmatched strings or for short
     * matches. It is used only for the fast compression options.
     */
    function deflate_fast(s, flush) {
      var hash_head;        /* head of the hash chain */
      var bflush;           /* set if current block must be flushed */

      for (; ;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break; /* flush the current block */
          }
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        hash_head = 0/*NIL*/;
        if (s.lookahead >= MIN_MATCH) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }

        /* Find the longest match, discarding those <= prev_length.
         * At this point we have always match_length < MIN_MATCH
         */
        if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
          /* To simplify the code, we prevent matches with the string
           * of window index 0 (in particular we have to avoid a match
           * of the string with itself at the start of the input file).
           */
          s.match_length = longest_match(s, hash_head);
          /* longest_match() sets match_start */
        }
        if (s.match_length >= MIN_MATCH) {
          // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

          /*** _tr_tally_dist(s, s.strstart - s.match_start,
                         s.match_length - MIN_MATCH, bflush); ***/
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

          s.lookahead -= s.match_length;

          /* Insert new strings in the hash table only if the match length
           * is not too large. This saves time but degrades compression.
           */
          if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
            s.match_length--; /* string at strstart already in table */
            do {
              s.strstart++;
              /*** INSERT_STRING(s, s.strstart, hash_head); ***/
              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
              /***/
              /* strstart never exceeds WSIZE-MAX_MATCH, so there are
               * always MIN_MATCH bytes ahead.
               */
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

            //#if MIN_MATCH != 3
            //                Call UPDATE_HASH() MIN_MATCH-3 more times
            //#endif
            /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
             * matter since it will be recomputed at next deflate call.
             */
          }
        } else {
          /* No match, output a literal byte */
          //Tracevv((stderr,"%c", s.window[s.strstart]));
          /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }
      }
      s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
      if (flush === Z_FINISH) {
        /*** FLUSH_BLOCK(s, 1); ***/
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        /***/
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }
      return BS_BLOCK_DONE;
    }

    /* ===========================================================================
     * Same as above, but achieves better compression. We use a lazy
     * evaluation for matches: a match is finally adopted only if there is
     * no better match at the next window position.
     */
    function deflate_slow(s, flush) {
      var hash_head;          /* head of hash chain */
      var bflush;              /* set if current block must be flushed */

      var max_insert;

      /* Process the input block. */
      for (; ;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) { break; } /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        hash_head = 0/*NIL*/;
        if (s.lookahead >= MIN_MATCH) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }

        /* Find the longest match, discarding those <= prev_length.
         */
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;

        if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
          s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
          /* To simplify the code, we prevent matches with the string
           * of window index 0 (in particular we have to avoid a match
           * of the string with itself at the start of the input file).
           */
          s.match_length = longest_match(s, hash_head);
          /* longest_match() sets match_start */

          if (s.match_length <= 5 &&
            (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

            /* If prev_match is also MIN_MATCH, match_start is garbage
             * but we will ignore the current match anyway.
             */
            s.match_length = MIN_MATCH - 1;
          }
        }
        /* If there was a match at the previous step and the current
         * match is not better, output the previous match:
         */
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          /* Do not insert strings in hash table beyond this. */

          //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

          /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                         s.prev_length - MIN_MATCH, bflush);***/
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          /* Insert in hash table all strings up to the end of the match.
           * strstart-1 and strstart are already inserted. If there is not
           * enough lookahead, the last two strings are not inserted in
           * the hash table.
           */
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              /*** INSERT_STRING(s, s.strstart, hash_head); ***/
              s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
              /***/
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;

          if (bflush) {
            /*** FLUSH_BLOCK(s, 0); ***/
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
            /***/
          }

        } else if (s.match_available) {
          /* If there was no match at the previous position, output a
           * single literal. If there was a match but the current match
           * is longer, truncate the previous match to a single literal.
           */
          //Tracevv((stderr,"%c", s->window[s->strstart-1]));
          /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

          if (bflush) {
            /*** FLUSH_BLOCK_ONLY(s, 0) ***/
            flush_block_only(s, false);
            /***/
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          /* There is no previous match to compare with, wait for
           * the next step to decide.
           */
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      //Assert (flush != Z_NO_FLUSH, "no flush?");
      if (s.match_available) {
        //Tracevv((stderr,"%c", s->window[s->strstart-1]));
        /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        /*** FLUSH_BLOCK(s, 1); ***/
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        /***/
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

      return BS_BLOCK_DONE;
    }


    /* ===========================================================================
     * For Z_RLE, simply look for runs of bytes, generate matches only of distance
     * one.  Do not maintain a hash table.  (It will be regenerated if this run of
     * deflate switches away from Z_RLE.)
     */
    function deflate_rle(s, flush) {
      var bflush;            /* set if current block must be flushed */
      var prev;              /* byte at distance one to match */
      var scan, strend;      /* scan goes up to strend for length of run */

      var _win = s.window;

      for (; ;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the longest run, plus one for the unrolled loop.
         */
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) { break; } /* flush the current block */
        }

        /* See how many times the previous byte repeats */
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
              /*jshint noempty:false*/
            } while (prev === _win[++scan] && prev === _win[++scan] &&
            prev === _win[++scan] && prev === _win[++scan] &&
            prev === _win[++scan] && prev === _win[++scan] &&
            prev === _win[++scan] && prev === _win[++scan] &&
              scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
          //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
        }

        /* Emit match if have run of MIN_MATCH or longer, else emit literal */
        if (s.match_length >= MIN_MATCH) {
          //check_match(s, s.strstart, s.strstart - 1, s.match_length);

          /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          /* No match, output a literal byte */
          //Tracevv((stderr,"%c", s->window[s->strstart]));
          /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        /*** FLUSH_BLOCK(s, 1); ***/
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        /***/
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }
      return BS_BLOCK_DONE;
    }

    /* ===========================================================================
     * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
     * (It will be regenerated if this run of deflate switches away from Huffman.)
     */
    function deflate_huff(s, flush) {
      var bflush;             /* set if current block must be flushed */

      for (; ;) {
        /* Make sure that we have a literal to write. */
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;      /* flush the current block */
          }
        }

        /* Output a literal byte */
        s.match_length = 0;
        //Tracevv((stderr,"%c", s->window[s->strstart]));
        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        /*** FLUSH_BLOCK(s, 1); ***/
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        /***/
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }
      return BS_BLOCK_DONE;
    }

    /* Values for max_lazy_match, good_match and max_chain_length, depending on
     * the desired pack level (0..9). The values given below have been tuned to
     * exclude worst case performance for pathological files. Better values may be
     * found for specific files.
     */
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }

    var configuration_table;

    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

      new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
    ];


    /* ===========================================================================
     * Initialize the "longest match" routines for a new zlib stream
     */
    function lm_init(s) {
      s.window_size = 2 * s.w_size;

      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);

      /* Set the default configuration parameters:
       */
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;

      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }


    function DeflateState() {
      this.strm = null;            /* pointer back to this zlib stream */
      this.status = 0;            /* as the name implies */
      this.pending_buf = null;      /* output still pending */
      this.pending_buf_size = 0;  /* size of pending_buf */
      this.pending_out = 0;       /* next pending byte to output to the stream */
      this.pending = 0;           /* nb of bytes in the pending buffer */
      this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
      this.gzhead = null;         /* gzip header information to write */
      this.gzindex = 0;           /* where in extra, name, or comment */
      this.method = Z_DEFLATED; /* can only be DEFLATED */
      this.last_flush = -1;   /* value of flush param for previous deflate call */

      this.w_size = 0;  /* LZ77 window size (32K by default) */
      this.w_bits = 0;  /* log2(w_size)  (8..16) */
      this.w_mask = 0;  /* w_size - 1 */

      this.window = null;
      /* Sliding window. Input bytes are read into the second half of the window,
       * and move to the first half later to keep a dictionary of at least wSize
       * bytes. With this organization, matches are limited to a distance of
       * wSize-MAX_MATCH bytes, but this ensures that IO is always
       * performed with a length multiple of the block size.
       */

      this.window_size = 0;
      /* Actual size of window: 2*wSize, except when the user input buffer
       * is directly used as sliding window.
       */

      this.prev = null;
      /* Link to older string with same hash index. To limit the size of this
       * array to 64K, this link is maintained only for the last 32K strings.
       * An index in this array is thus a window index modulo 32K.
       */

      this.head = null;   /* Heads of the hash chains or NIL. */

      this.ins_h = 0;       /* hash index of string to be inserted */
      this.hash_size = 0;   /* number of elements in hash table */
      this.hash_bits = 0;   /* log2(hash_size) */
      this.hash_mask = 0;   /* hash_size-1 */

      this.hash_shift = 0;
      /* Number of bits by which ins_h must be shifted at each input
       * step. It must be such that after MIN_MATCH steps, the oldest
       * byte no longer takes part in the hash key, that is:
       *   hash_shift * MIN_MATCH >= hash_bits
       */

      this.block_start = 0;
      /* Window position at the beginning of the current output block. Gets
       * negative when the window is moved backwards.
       */

      this.match_length = 0;      /* length of best match */
      this.prev_match = 0;        /* previous match */
      this.match_available = 0;   /* set if previous match exists */
      this.strstart = 0;          /* start of string to insert */
      this.match_start = 0;       /* start of matching string */
      this.lookahead = 0;         /* number of valid bytes ahead in window */

      this.prev_length = 0;
      /* Length of the best match at previous step. Matches not greater than this
       * are discarded. This is used in the lazy match evaluation.
       */

      this.max_chain_length = 0;
      /* To speed up deflation, hash chains are never searched beyond this
       * length.  A higher limit improves compression ratio but degrades the
       * speed.
       */

      this.max_lazy_match = 0;
      /* Attempt to find a better match only when the current match is strictly
       * smaller than this value. This mechanism is used only for compression
       * levels >= 4.
       */
      // That's alias to max_lazy_match, don't use directly
      //this.max_insert_length = 0;
      /* Insert new strings in the hash table only if the match length is not
       * greater than this length. This saves time but degrades compression.
       * max_insert_length is used only for compression levels <= 3.
       */

      this.level = 0;     /* compression level (1..9) */
      this.strategy = 0;  /* favor or force Huffman coding*/

      this.good_match = 0;
      /* Use a faster search when the previous match is longer than this */

      this.nice_match = 0; /* Stop searching when current match exceeds this */

      /* used by trees.c: */

      /* Didn't use ct_data typedef below to suppress compiler warning */

      // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
      // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
      // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

      // Use flat array of DOUBLE size, with interleaved fata,
      // because JS does not support effective
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);

      this.l_desc = null;         /* desc. for literal tree */
      this.d_desc = null;         /* desc. for distance tree */
      this.bl_desc = null;         /* desc. for bit length tree */

      //ush bl_count[MAX_BITS+1];
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      /* number of codes at each bit length for an optimal tree */

      //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
      this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
      zero(this.heap);

      this.heap_len = 0;               /* number of elements in the heap */
      this.heap_max = 0;               /* element of largest frequency */
      /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
       * The same heap array is used to build all trees.
       */

      this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
      zero(this.depth);
      /* Depth of each subtree used as tie breaker for trees of equal frequency
       */

      this.l_buf = 0;          /* buffer index for literals or lengths */

      this.lit_bufsize = 0;
      /* Size of match buffer for literals/lengths.  There are 4 reasons for
       * limiting lit_bufsize to 64K:
       *   - frequencies can be kept in 16 bit counters
       *   - if compression is not successful for the first block, all input
       *     data is still in the window so we can still emit a stored block even
       *     when input comes from standard input.  (This can also be done for
       *     all blocks if lit_bufsize is not greater than 32K.)
       *   - if compression is not successful for a file smaller than 64K, we can
       *     even emit a stored file instead of a stored block (saving 5 bytes).
       *     This is applicable only for zip (not gzip or zlib).
       *   - creating new Huffman trees less frequently may not provide fast
       *     adaptation to changes in the input data statistics. (Take for
       *     example a binary file with poorly compressible code followed by
       *     a highly compressible string table.) Smaller buffer sizes give
       *     fast adaptation but have of course the overhead of transmitting
       *     trees more frequently.
       *   - I can't count above 4
       */

      this.last_lit = 0;      /* running index in l_buf */

      this.d_buf = 0;
      /* Buffer index for distances. To simplify the code, d_buf and l_buf have
       * the same number of elements. To use different lengths, an extra flag
       * array would be necessary.
       */

      this.opt_len = 0;       /* bit length of current block with optimal trees */
      this.static_len = 0;    /* bit length of current block with static trees */
      this.matches = 0;       /* number of string matches in current block */
      this.insert = 0;        /* bytes at end of window left to insert */


      this.bi_buf = 0;
      /* Output buffer. bits are inserted starting at the bottom (least
       * significant bits).
       */
      this.bi_valid = 0;
      /* Number of valid bits in bi_buf.  All bits above the last valid bit
       * are always zero.
       */

      // Used for window memory init. We safely ignore it for JS. That makes
      // sense only for pointers and memory check tools.
      //this.high_water = 0;
      /* High water mark offset in window for initialized bytes -- bytes above
       * this are set to zero in order to avoid memory check warnings when
       * longest match routines access bytes past the input.  This is then
       * updated to the new high water mark.
       */
    }


    function deflateResetKeep(strm) {
      var s;

      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }

      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;

      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;

      if (s.wrap < 0) {
        s.wrap = -s.wrap;
        /* was made negative by deflate(..., Z_FINISH); */
      }
      s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
      strm.adler = (s.wrap === 2) ?
        0  // crc32(0, Z_NULL, 0)
        :
        1; // adler32(0, Z_NULL, 0)
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }


    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }


    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) { return Z_STREAM_ERROR; }
      if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
      strm.state.gzhead = head;
      return Z_OK;
    }


    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) { // === Z_NULL
        return Z_STREAM_ERROR;
      }
      var wrap = 1;

      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }

      if (windowBits < 0) { /* suppress zlib wrapper */
        wrap = 0;
        windowBits = -windowBits;
      }

      else if (windowBits > 15) {
        wrap = 2;           /* write gzip wrapper instead */
        windowBits -= 16;
      }


      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
        strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }


      if (windowBits === 8) {
        windowBits = 9;
      }
      /* until 256-byte window bug fixed */

      var s = new DeflateState();

      strm.state = s;
      s.strm = strm;

      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;

      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);

      // Don't need mem init magic for JS.
      //s.high_water = 0;  /* nothing written to s->window yet */

      s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

      s.pending_buf_size = s.lit_bufsize * 4;

      //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
      //s->pending_buf = (uchf *) overlay;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);

      // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
      //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
      s.d_buf = 1 * s.lit_bufsize;

      //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;

      s.level = level;
      s.strategy = strategy;
      s.method = method;

      return deflateReset(strm);
    }

    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }


    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val; // for gzip header write only

      if (!strm || !strm.state ||
        flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }

      s = strm.state;

      if (!strm.output ||
        (!strm.input && strm.avail_in !== 0) ||
        (s.status === FINISH_STATE && flush !== Z_FINISH)) {
        return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }

      s.strm = strm; /* just in case */
      old_flush = s.last_flush;
      s.last_flush = flush;

      /* Write the header */
      if (s.status === INIT_STATE) {

        if (s.wrap === 2) { // GZIP header
          strm.adler = 0;  //crc32(0L, Z_NULL, 0);
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) { // s->gzhead == Z_NULL
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 :
              (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                4 : 0));
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          }
          else {
            put_byte(s, (s.gzhead.text ? 1 : 0) +
              (s.gzhead.hcrc ? 2 : 0) +
              (!s.gzhead.extra ? 0 : 4) +
              (!s.gzhead.name ? 0 : 8) +
              (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 0xff);
            put_byte(s, (s.gzhead.time >> 8) & 0xff);
            put_byte(s, (s.gzhead.time >> 16) & 0xff);
            put_byte(s, (s.gzhead.time >> 24) & 0xff);
            put_byte(s, s.level === 9 ? 2 :
              (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                4 : 0));
            put_byte(s, s.gzhead.os & 0xff);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 0xff);
              put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        }
        else // DEFLATE header
        {
          var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
          var level_flags = -1;

          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= (level_flags << 6);
          if (s.strstart !== 0) { header |= PRESET_DICT; }
          header += 31 - (header % 31);

          s.status = BUSY_STATE;
          putShortMSB(s, header);

          /* Save the adler32 of the preset dictionary: */
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 0xffff);
          }
          strm.adler = 1; // adler32(0L, Z_NULL, 0);
        }
      }

      //#ifdef GZIP
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra/* != Z_NULL*/) {
          beg = s.pending;  /* start of bytes to update crc */

          while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        }
        else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name/* != Z_NULL*/) {
          beg = s.pending;  /* start of bytes to update crc */
          //int val;

          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            // JS specific: little magic to add zero terminator to end of string
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);

          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        }
        else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment/* != Z_NULL*/) {
          beg = s.pending;  /* start of bytes to update crc */
          //int val;

          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            // JS specific: little magic to add zero terminator to end of string
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);

          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        }
        else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 0xff);
            put_byte(s, (strm.adler >> 8) & 0xff);
            strm.adler = 0; //crc32(0L, Z_NULL, 0);
            s.status = BUSY_STATE;
          }
        }
        else {
          s.status = BUSY_STATE;
        }
      }
      //#endif

      /* Flush as much pending output as possible */
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          /* Since avail_out is 0, deflate will be called again with
           * more output space, but possibly with both pending and
           * avail_in equal to zero. There won't be anything to do,
           * but this is not an error situation so make sure we
           * return OK instead of BUF_ERROR at next call of deflate:
           */
          s.last_flush = -1;
          return Z_OK;
        }

        /* Make sure there is something to do and avoid duplicate consecutive
         * flushes. For repeated and useless calls with Z_FINISH, we keep
         * returning Z_STREAM_END instead of Z_BUF_ERROR.
         */
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
        flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }

      /* User must not provide more input after the first FINISH: */
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }

      /* Start a new block or continue the current one.
       */
      if (strm.avail_in !== 0 || s.lookahead !== 0 ||
        (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
        var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
          (s.strategy === Z_RLE ? deflate_rle(s, flush) :
            configuration_table[s.level].func(s, flush));

        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            /* avoid BUF_ERROR next call, see above */
          }
          return Z_OK;
          /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
           * of deflate should use the same flush parameter to make sure
           * that the flush is complete. So we don't have to output an
           * empty block here, this will be done at next call. This also
           * ensures that for a very small output buffer, we emit at most
           * one empty block.
           */
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          }
          else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

            trees._tr_stored_block(s, 0, 0, false);
            /* For a full flush, this empty block will be recognized
             * as a special marker by inflate_sync().
             */
            if (flush === Z_FULL_FLUSH) {
              /*** CLEAR_HASH(s); ***/             /* forget history */
              zero(s.head); // Fill with NIL (= 0);

              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
            return Z_OK;
          }
        }
      }
      //Assert(strm->avail_out > 0, "bug2");
      //if (strm.avail_out <= 0) { throw new Error("bug2");}

      if (flush !== Z_FINISH) { return Z_OK; }
      if (s.wrap <= 0) { return Z_STREAM_END; }

      /* Write the trailer */
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        put_byte(s, (strm.adler >> 16) & 0xff);
        put_byte(s, (strm.adler >> 24) & 0xff);
        put_byte(s, strm.total_in & 0xff);
        put_byte(s, (strm.total_in >> 8) & 0xff);
        put_byte(s, (strm.total_in >> 16) & 0xff);
        put_byte(s, (strm.total_in >> 24) & 0xff);
      }
      else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }

      flush_pending(strm);
      /* If avail_out is zero, the application will call deflate again
       * to flush the rest.
       */
      if (s.wrap > 0) { s.wrap = -s.wrap; }
      /* write the trailer only once! */
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }

    function deflateEnd(strm) {
      var status;

      if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
        return Z_STREAM_ERROR;
      }

      status = strm.state.status;
      if (status !== INIT_STATE &&
        status !== EXTRA_STATE &&
        status !== NAME_STATE &&
        status !== COMMENT_STATE &&
        status !== HCRC_STATE &&
        status !== BUSY_STATE &&
        status !== FINISH_STATE
      ) {
        return err(strm, Z_STREAM_ERROR);
      }

      strm.state = null;

      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }


    /* =========================================================================
     * Initializes the compression dictionary from the given byte
     * sequence without producing any compressed output.
     */
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;

      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;

      if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
        return Z_STREAM_ERROR;
      }

      s = strm.state;
      wrap = s.wrap;

      if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
        return Z_STREAM_ERROR;
      }

      /* when using zlib wrappers, compute Adler-32 for provided dictionary */
      if (wrap === 1) {
        /* adler32(strm->adler, dictionary, dictLength); */
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }

      s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

      /* if dictionary would fill window, just replace the history */
      if (dictLength >= s.w_size) {
        if (wrap === 0) {            /* already empty otherwise */
          /*** CLEAR_HASH(s); ***/
          zero(s.head); // Fill with NIL (= 0);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        /* use the tail */
        // dictionary = dictionary.slice(dictLength - s.w_size);
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      /* insert dictionary into window and hash */
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

          s.prev[str & s.w_mask] = s.head[s.ins_h];

          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }


    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = 'pako deflate (from Nodeca project)';

    /* Not implemented
    exports.deflateBound = deflateBound;
    exports.deflateCopy = deflateCopy;
    exports.deflateParams = deflateParams;
    exports.deflatePending = deflatePending;
    exports.deflatePrime = deflatePrime;
    exports.deflateTune = deflateTune;
    */

  }, { "../utils/common": 152, "./adler32": 153, "./crc32": 155, "./messages": 160, "./trees": 161 }], 157: [function (require, module, exports) {
    'use strict';

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    // See state defs from inflate.js
    var BAD = 30;       /* got a data error -- remain here until reset */
    var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

    /*
       Decode literal, length, and distance codes and write out the resulting
       literal and match bytes until either not enough input or output is
       available, an end-of-block is encountered, or a data error is encountered.
       When large enough input and output buffers are supplied to inflate(), for
       example, a 16K input buffer and a 64K output buffer, more than 95% of the
       inflate execution time is spent in this routine.
    
       Entry assumptions:
    
            state.mode === LEN
            strm.avail_in >= 6
            strm.avail_out >= 258
            start >= strm.avail_out
            state.bits < 8
    
       On return, state.mode is one of:
    
            LEN -- ran out of enough output space or enough available input
            TYPE -- reached end of block code, inflate() to interpret next block
            BAD -- error in block data
    
       Notes:
    
        - The maximum input bits used by a length/distance pair is 15 bits for the
          length code, 5 bits for the length extra, 15 bits for the distance code,
          and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
          Therefore if strm.avail_in >= 6, then there is enough input to avoid
          checking for available input while decoding.
    
        - The maximum bytes that a single length/distance pair can output is 258
          bytes, which is the maximum length that can be coded.  inflate_fast()
          requires strm.avail_out >= 258 for each loop to avoid checking for
          output space.
     */
    module.exports = function inflate_fast(strm, start) {
      var state;
      var _in;                    /* local strm.input */
      var last;                   /* have enough input while in < last */
      var _out;                   /* local strm.output */
      var beg;                    /* inflate()'s initial strm.output */
      var end;                    /* while out < end, enough space available */
      //#ifdef INFLATE_STRICT
      var dmax;                   /* maximum distance from zlib header */
      //#endif
      var wsize;                  /* window size or zero if not using window */
      var whave;                  /* valid bytes in the window */
      var wnext;                  /* window write index */
      // Use `s_window` instead `window`, avoid conflict with instrumentation tools
      var s_window;               /* allocated sliding window, if wsize != 0 */
      var hold;                   /* local strm.hold */
      var bits;                   /* local strm.bits */
      var lcode;                  /* local strm.lencode */
      var dcode;                  /* local strm.distcode */
      var lmask;                  /* mask for first level of length codes */
      var dmask;                  /* mask for first level of distance codes */
      var here;                   /* retrieved table entry */
      var op;                     /* code bits, operation, extra bits, or */
      /*  window position, window bytes to copy */
      var len;                    /* match length, unused bytes */
      var dist;                   /* match distance */
      var from;                   /* where to copy match from */
      var from_source;


      var input, output; // JS specific, because we have no pointers

      /* copy state to local variables */
      state = strm.state;
      //here = state.here;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      //#ifdef INFLATE_STRICT
      dmax = state.dmax;
      //#endif
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;


      /* decode literals and length/distances until end-of-block or not enough
         input data or output space */

      top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }

        here = lcode[hold & lmask];

        dolen:
        for (; ;) { // Goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;
          if (op === 0) {                          /* literal */
            //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
            //        "inflate:         literal '%c'\n" :
            //        "inflate:         literal 0x%02x\n", here.val));
            output[_out++] = here & 0xffff/*here.val*/;
          }
          else if (op & 16) {                     /* length base */
            len = here & 0xffff/*here.val*/;
            op &= 15;                           /* number of extra bits */
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & ((1 << op) - 1);
              hold >>>= op;
              bits -= op;
            }
            //Tracevv((stderr, "inflate:         length %u\n", len));
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];

            dodist:
            for (; ;) { // goto emulation
              op = here >>> 24/*here.bits*/;
              hold >>>= op;
              bits -= op;
              op = (here >>> 16) & 0xff/*here.op*/;

              if (op & 16) {                      /* distance base */
                dist = here & 0xffff/*here.val*/;
                op &= 15;                       /* number of extra bits */
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                }
                dist += hold & ((1 << op) - 1);
                //#ifdef INFLATE_STRICT
                if (dist > dmax) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }
                //#endif
                hold >>>= op;
                bits -= op;
                //Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = _out - beg;                /* max distance in output */
                if (dist > op) {                /* see if copy from window */
                  op = dist - op;               /* distance back in window */
                  if (op > whave) {
                    if (state.sane) {
                      strm.msg = 'invalid distance too far back';
                      state.mode = BAD;
                      break top;
                    }

                    // (!) This block is disabled in zlib defaults,
                    // don't enable it for binary compatibility
                    //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                    //                if (len <= op - whave) {
                    //                  do {
                    //                    output[_out++] = 0;
                    //                  } while (--len);
                    //                  continue top;
                    //                }
                    //                len -= op - whave;
                    //                do {
                    //                  output[_out++] = 0;
                    //                } while (--op > whave);
                    //                if (op === 0) {
                    //                  from = _out - dist;
                    //                  do {
                    //                    output[_out++] = output[from++];
                    //                  } while (--len);
                    //                  continue top;
                    //                }
                    //#endif
                  }
                  from = 0; // window index
                  from_source = s_window;
                  if (wnext === 0) {           /* very common case */
                    from += wsize - op;
                    if (op < len) {         /* some from window */
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist;  /* rest from output */
                      from_source = output;
                    }
                  }
                  else if (wnext < op) {      /* wrap around window */
                    from += wsize + wnext - op;
                    op -= wnext;
                    if (op < len) {         /* some from end of window */
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = 0;
                      if (wnext < len) {  /* some from start of window */
                        op = wnext;
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;      /* rest from output */
                        from_source = output;
                      }
                    }
                  }
                  else {                      /* contiguous in window */
                    from += wnext - op;
                    if (op < len) {         /* some from window */
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist;  /* rest from output */
                      from_source = output;
                    }
                  }
                  while (len > 2) {
                    output[_out++] = from_source[from++];
                    output[_out++] = from_source[from++];
                    output[_out++] = from_source[from++];
                    len -= 3;
                  }
                  if (len) {
                    output[_out++] = from_source[from++];
                    if (len > 1) {
                      output[_out++] = from_source[from++];
                    }
                  }
                }
                else {
                  from = _out - dist;          /* copy direct from output */
                  do {                        /* minimum length is three */
                    output[_out++] = output[from++];
                    output[_out++] = output[from++];
                    output[_out++] = output[from++];
                    len -= 3;
                  } while (len > 2);
                  if (len) {
                    output[_out++] = output[from++];
                    if (len > 1) {
                      output[_out++] = output[from++];
                    }
                  }
                }
              }
              else if ((op & 64) === 0) {          /* 2nd level distance code */
                here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
                continue dodist;
              }
              else {
                strm.msg = 'invalid distance code';
                state.mode = BAD;
                break top;
              }

              break; // need to emulate goto via "continue"
            }
          }
          else if ((op & 64) === 0) {              /* 2nd level length code */
            here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dolen;
          }
          else if (op & 32) {                     /* end-of-block */
            //Tracevv((stderr, "inflate:         end of block\n"));
            state.mode = TYPE;
            break top;
          }
          else {
            strm.msg = 'invalid literal/length code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      } while (_in < last && _out < end);

      /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;

      /* update state and return */
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
      strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
      state.hold = hold;
      state.bits = bits;
      return;
    };

  }, {}], 158: [function (require, module, exports) {
    'use strict';

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    var utils = require('../utils/common');
    var adler32 = require('./adler32');
    var crc32 = require('./crc32');
    var inflate_fast = require('./inffast');
    var inflate_table = require('./inftrees');

    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;

    /* Public constants ==========================================================*/
    /* ===========================================================================*/


    /* Allowed flush values; see deflate() and inflate() below for details */
    //var Z_NO_FLUSH      = 0;
    //var Z_PARTIAL_FLUSH = 1;
    //var Z_SYNC_FLUSH    = 2;
    //var Z_FULL_FLUSH    = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;


    /* Return codes for the compression/decompression functions. Negative values
     * are errors, positive values are used for special but normal events.
     */
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    //var Z_ERRNO         = -1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    //var Z_VERSION_ERROR = -6;

    /* The deflate compression method */
    var Z_DEFLATED = 8;


    /* STATES ====================================================================*/
    /* ===========================================================================*/


    var HEAD = 1;       /* i: waiting for magic header */
    var FLAGS = 2;      /* i: waiting for method and flags (gzip) */
    var TIME = 3;       /* i: waiting for modification time (gzip) */
    var OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
    var EXLEN = 5;      /* i: waiting for extra length (gzip) */
    var EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
    var NAME = 7;       /* i: waiting for end of file name (gzip) */
    var COMMENT = 8;    /* i: waiting for end of comment (gzip) */
    var HCRC = 9;       /* i: waiting for header crc (gzip) */
    var DICTID = 10;    /* i: waiting for dictionary check value */
    var DICT = 11;      /* waiting for inflateSetDictionary() call */
    var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
    var TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
    var STORED = 14;    /* i: waiting for stored size (length and complement) */
    var COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
    var COPY = 16;      /* i/o: waiting for input or output to copy stored block */
    var TABLE = 17;     /* i: waiting for dynamic block table lengths */
    var LENLENS = 18;   /* i: waiting for code length code lengths */
    var CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
    var LEN_ = 20;      /* i: same as LEN below, but only first time in */
    var LEN = 21;       /* i: waiting for length/lit/eob code */
    var LENEXT = 22;    /* i: waiting for length extra bits */
    var DIST = 23;      /* i: waiting for distance code */
    var DISTEXT = 24;   /* i: waiting for distance extra bits */
    var MATCH = 25;     /* o: waiting for output space to copy string */
    var LIT = 26;       /* o: waiting for output space to write literal */
    var CHECK = 27;     /* i: waiting for 32-bit check value */
    var LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
    var DONE = 29;      /* finished check, done -- remain here until reset */
    var BAD = 30;       /* got a data error -- remain here until reset */
    var MEM = 31;       /* got an inflate() memory error -- remain here until reset */
    var SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

    /* ===========================================================================*/



    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    //var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

    var MAX_WBITS = 15;
    /* 32K LZ77 window */
    var DEF_WBITS = MAX_WBITS;


    function zswap32(q) {
      return (((q >>> 24) & 0xff) +
        ((q >>> 8) & 0xff00) +
        ((q & 0xff00) << 8) +
        ((q & 0xff) << 24));
    }


    function InflateState() {
      this.mode = 0;             /* current inflate mode */
      this.last = false;          /* true if processing last block */
      this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
      this.havedict = false;      /* true if dictionary provided */
      this.flags = 0;             /* gzip header method and flags (0 if zlib) */
      this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
      this.check = 0;             /* protected copy of check value */
      this.total = 0;             /* protected copy of output count */
      // TODO: may be {}
      this.head = null;           /* where to save gzip header information */

      /* sliding window */
      this.wbits = 0;             /* log base 2 of requested window size */
      this.wsize = 0;             /* window size or zero if not using window */
      this.whave = 0;             /* valid bytes in the window */
      this.wnext = 0;             /* window write index */
      this.window = null;         /* allocated sliding window, if needed */

      /* bit accumulator */
      this.hold = 0;              /* input bit accumulator */
      this.bits = 0;              /* number of bits in "in" */

      /* for string and stored block copying */
      this.length = 0;            /* literal or length of data to copy */
      this.offset = 0;            /* distance back to copy string from */

      /* for table and code decoding */
      this.extra = 0;             /* extra bits needed */

      /* fixed and dynamic code tables */
      this.lencode = null;          /* starting table for length/literal codes */
      this.distcode = null;         /* starting table for distance codes */
      this.lenbits = 0;           /* index bits for lencode */
      this.distbits = 0;          /* index bits for distcode */

      /* dynamic table building */
      this.ncode = 0;             /* number of code length code lengths */
      this.nlen = 0;              /* number of length code lengths */
      this.ndist = 0;             /* number of distance code lengths */
      this.have = 0;              /* number of code lengths in lens[] */
      this.next = null;              /* next available space in codes[] */

      this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
      this.work = new utils.Buf16(288); /* work area for code table building */

      /*
       because we don't have pointers in js, we use lencode and distcode directly
       as buffers so we don't need codes
      */
      //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
      this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
      this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
      this.sane = 0;                   /* if false, allow invalid distance too far */
      this.back = 0;                   /* bits back of last unprocessed length/lit */
      this.was = 0;                    /* initial length of match */
    }

    function inflateResetKeep(strm) {
      var state;

      if (!strm || !strm.state) { return Z_STREAM_ERROR; }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = ''; /*Z_NULL*/
      if (state.wrap) {       /* to support ill-conceived Java test suite */
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null/*Z_NULL*/;
      state.hold = 0;
      state.bits = 0;
      //state.lencode = state.distcode = state.next = state.codes;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

      state.sane = 1;
      state.back = -1;
      //Tracev((stderr, "inflate: reset\n"));
      return Z_OK;
    }

    function inflateReset(strm) {
      var state;

      if (!strm || !strm.state) { return Z_STREAM_ERROR; }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);

    }

    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;

      /* get the state */
      if (!strm || !strm.state) { return Z_STREAM_ERROR; }
      state = strm.state;

      /* extract wrap request from windowBits parameter */
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      }
      else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }

      /* set number of window bits, free window if different */
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }

      /* update state and reset the rest of it */
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }

    function inflateInit2(strm, windowBits) {
      var ret;
      var state;

      if (!strm) { return Z_STREAM_ERROR; }
      //strm.msg = Z_NULL;                 /* in case we return an error */

      state = new InflateState();

      //if (state === Z_NULL) return Z_MEM_ERROR;
      //Tracev((stderr, "inflate: allocated\n"));
      strm.state = state;
      state.window = null/*Z_NULL*/;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null/*Z_NULL*/;
      }
      return ret;
    }

    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }


    /*
     Return state with length and distance decoding tables and index sizes set to
     fixed code decoding.  Normally this returns fixed tables from inffixed.h.
     If BUILDFIXED is defined, then instead this routine builds the tables the
     first time it's called, and returns those tables the first time and
     thereafter.  This reduces the size of the code by about 2K bytes, in
     exchange for a little execution time.  However, BUILDFIXED should not be
     used for threaded applications, since the rewriting of the tables and virgin
     may not be thread-safe.
     */
    var virgin = true;

    var lenfix, distfix; // We have no pointers in JS, so keep tables separate

    function fixedtables(state) {
      /* build fixed huffman tables if first call (may not be thread safe) */
      if (virgin) {
        var sym;

        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);

        /* literal/length table */
        sym = 0;
        while (sym < 144) { state.lens[sym++] = 8; }
        while (sym < 256) { state.lens[sym++] = 9; }
        while (sym < 280) { state.lens[sym++] = 7; }
        while (sym < 288) { state.lens[sym++] = 8; }

        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });

        /* distance table */
        sym = 0;
        while (sym < 32) { state.lens[sym++] = 5; }

        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });

        /* do this just once */
        virgin = false;
      }

      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }


    /*
     Update the window with the last wsize (normally 32K) bytes written before
     returning.  If window does not exist yet, create it.  This is only called
     when a window is already in use, or when output has been written during this
     inflate call, but the end of the deflate stream has not been reached yet.
     It is also called to create a window for dictionary data when a dictionary
     is loaded.
    
     Providing output buffers larger than 32K to inflate() should provide a speed
     advantage, since only the last 32K of output is copied to the sliding window
     upon return from inflate(), and since all distances after the first 32K of
     output will fall in the output data, making match copies simpler and faster.
     The advantage may be dependent on the size of the processor's data caches.
     */
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;

      /* if it hasn't been done already, allocate space for the window */
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;

        state.window = new utils.Buf8(state.wsize);
      }

      /* copy state->wsize or less output bytes into the circular window */
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      }
      else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        //zmemcpy(state->window + state->wnext, end - copy, dist);
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          //zmemcpy(state->window, end - copy, copy);
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        }
        else {
          state.wnext += dist;
          if (state.wnext === state.wsize) { state.wnext = 0; }
          if (state.whave < state.wsize) { state.whave += dist; }
        }
      }
      return 0;
    }

    function inflate(strm, flush) {
      var state;
      var input, output;          // input/output buffers
      var next;                   /* next input INDEX */
      var put;                    /* next output INDEX */
      var have, left;             /* available input and output */
      var hold;                   /* bit buffer */
      var bits;                   /* bits in bit buffer */
      var _in, _out;              /* save starting available input and output */
      var copy;                   /* number of stored or match bytes to copy */
      var from;                   /* where to copy match bytes from */
      var from_source;
      var here = 0;               /* current decoding table entry */
      var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
      //var last;                   /* parent table entry */
      var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
      var len;                    /* length to copy for repeats, bits to drop */
      var ret;                    /* return code */
      var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
      var opts;

      var n; // temporary var for NEED_BITS

      var order = /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];


      if (!strm || !strm.state || !strm.output ||
        (!strm.input && strm.avail_in !== 0)) {
        return Z_STREAM_ERROR;
      }

      state = strm.state;
      if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


      //--- LOAD() ---
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      //---

      _in = have;
      _out = left;
      ret = Z_OK;

      inf_leave: // goto emulation
      for (; ;) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            //=== NEEDBITS(16);
            while (bits < 16) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
              state.check = 0/*crc32(0L, Z_NULL, 0)*/;
              //=== CRC2(state.check, hold);
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
              //===//

              //=== INITBITS();
              hold = 0;
              bits = 0;
              //===//
              state.mode = FLAGS;
              break;
            }
            state.flags = 0;           /* expect zlib header */
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) ||   /* check if zlib header allowed */
              (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
              strm.msg = 'incorrect header check';
              state.mode = BAD;
              break;
            }
            if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
              strm.msg = 'unknown compression method';
              state.mode = BAD;
              break;
            }
            //--- DROPBITS(4) ---//
            hold >>>= 4;
            bits -= 4;
            //---//
            len = (hold & 0x0f)/*BITS(4)*/ + 8;
            if (state.wbits === 0) {
              state.wbits = len;
            }
            else if (len > state.wbits) {
              strm.msg = 'invalid window size';
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << len;
            //Tracev((stderr, "inflate:   zlib header ok\n"));
            strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
            state.mode = hold & 0x200 ? DICTID : TYPE;
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            break;
          case FLAGS:
            //=== NEEDBITS(16); */
            while (bits < 16) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            state.flags = hold;
            if ((state.flags & 0xff) !== Z_DEFLATED) {
              strm.msg = 'unknown compression method';
              state.mode = BAD;
              break;
            }
            if (state.flags & 0xe000) {
              strm.msg = 'unknown header flags set';
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = ((hold >> 8) & 1);
            }
            if (state.flags & 0x0200) {
              //=== CRC2(state.check, hold);
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
              //===//
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            state.mode = TIME;
          /* falls through */
          case TIME:
            //=== NEEDBITS(32); */
            while (bits < 32) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 0x0200) {
              //=== CRC4(state.check, hold)
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              hbuf[2] = (hold >>> 16) & 0xff;
              hbuf[3] = (hold >>> 24) & 0xff;
              state.check = crc32(state.check, hbuf, 4, 0);
              //===
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            state.mode = OS;
          /* falls through */
          case OS:
            //=== NEEDBITS(16); */
            while (bits < 16) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            if (state.head) {
              state.head.xflags = (hold & 0xff);
              state.head.os = (hold >> 8);
            }
            if (state.flags & 0x0200) {
              //=== CRC2(state.check, hold);
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              state.check = crc32(state.check, hbuf, 2, 0);
              //===//
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            state.mode = EXLEN;
          /* falls through */
          case EXLEN:
            if (state.flags & 0x0400) {
              //=== NEEDBITS(16); */
              while (bits < 16) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 0x0200) {
                //=== CRC2(state.check, hold);
                hbuf[0] = hold & 0xff;
                hbuf[1] = (hold >>> 8) & 0xff;
                state.check = crc32(state.check, hbuf, 2, 0);
                //===//
              }
              //=== INITBITS();
              hold = 0;
              bits = 0;
              //===//
            }
            else if (state.head) {
              state.head.extra = null/*Z_NULL*/;
            }
            state.mode = EXTRA;
          /* falls through */
          case EXTRA:
            if (state.flags & 0x0400) {
              copy = state.length;
              if (copy > have) { copy = have; }
              if (copy) {
                if (state.head) {
                  len = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    // Use untyped array for more convenient processing later
                    state.head.extra = new Array(state.head.extra_len);
                  }
                  utils.arraySet(
                    state.head.extra,
                    input,
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    copy,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                  //zmemcpy(state.head.extra + len, next,
                  //        len + copy > state.head.extra_max ?
                  //        state.head.extra_max - len : copy);
                }
                if (state.flags & 0x0200) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state.length -= copy;
              }
              if (state.length) { break inf_leave; }
            }
            state.length = 0;
            state.mode = NAME;
          /* falls through */
          case NAME:
            if (state.flags & 0x0800) {
              if (have === 0) { break inf_leave; }
              copy = 0;
              do {
                // TODO: 2 or 1 bytes?
                len = input[next + copy++];
                /* use constant limit because in js we should not preallocate memory */
                if (state.head && len &&
                  (state.length < 65536 /*state.head.name_max*/)) {
                  state.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);

              if (state.flags & 0x0200) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) { break inf_leave; }
            }
            else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          /* falls through */
          case COMMENT:
            if (state.flags & 0x1000) {
              if (have === 0) { break inf_leave; }
              copy = 0;
              do {
                len = input[next + copy++];
                /* use constant limit because in js we should not preallocate memory */
                if (state.head && len &&
                  (state.length < 65536 /*state.head.comm_max*/)) {
                  state.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state.flags & 0x0200) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) { break inf_leave; }
            }
            else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          /* falls through */
          case HCRC:
            if (state.flags & 0x0200) {
              //=== NEEDBITS(16); */
              while (bits < 16) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              if (hold !== (state.check & 0xffff)) {
                strm.msg = 'header crc mismatch';
                state.mode = BAD;
                break;
              }
              //=== INITBITS();
              hold = 0;
              bits = 0;
              //===//
            }
            if (state.head) {
              state.head.hcrc = ((state.flags >> 9) & 1);
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            //=== NEEDBITS(32); */
            while (bits < 32) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            strm.adler = state.check = zswap32(hold);
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            state.mode = DICT;
          /* falls through */
          case DICT:
            if (state.havedict === 0) {
              //--- RESTORE() ---
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              //---
              return Z_NEED_DICT;
            }
            strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
            state.mode = TYPE;
          /* falls through */
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
          /* falls through */
          case TYPEDO:
            if (state.last) {
              //--- BYTEBITS() ---//
              hold >>>= bits & 7;
              bits -= bits & 7;
              //---//
              state.mode = CHECK;
              break;
            }
            //=== NEEDBITS(3); */
            while (bits < 3) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            state.last = (hold & 0x01)/*BITS(1)*/;
            //--- DROPBITS(1) ---//
            hold >>>= 1;
            bits -= 1;
            //---//

            switch ((hold & 0x03)/*BITS(2)*/) {
              case 0:                             /* stored block */
                //Tracev((stderr, "inflate:     stored block%s\n",
                //        state.last ? " (last)" : ""));
                state.mode = STORED;
                break;
              case 1:                             /* fixed block */
                fixedtables(state);
                //Tracev((stderr, "inflate:     fixed codes block%s\n",
                //        state.last ? " (last)" : ""));
                state.mode = LEN_;             /* decode codes */
                if (flush === Z_TREES) {
                  //--- DROPBITS(2) ---//
                  hold >>>= 2;
                  bits -= 2;
                  //---//
                  break inf_leave;
                }
                break;
              case 2:                             /* dynamic block */
                //Tracev((stderr, "inflate:     dynamic codes block%s\n",
                //        state.last ? " (last)" : ""));
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = 'invalid block type';
                state.mode = BAD;
            }
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
            break;
          case STORED:
            //--- BYTEBITS() ---// /* go to byte boundary */
            hold >>>= bits & 7;
            bits -= bits & 7;
            //---//
            //=== NEEDBITS(32); */
            while (bits < 32) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
              strm.msg = 'invalid stored block lengths';
              state.mode = BAD;
              break;
            }
            state.length = hold & 0xffff;
            //Tracev((stderr, "inflate:       stored length %u\n",
            //        state.length));
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            state.mode = COPY_;
            if (flush === Z_TREES) { break inf_leave; }
          /* falls through */
          case COPY_:
            state.mode = COPY;
          /* falls through */
          case COPY:
            copy = state.length;
            if (copy) {
              if (copy > have) { copy = have; }
              if (copy > left) { copy = left; }
              if (copy === 0) { break inf_leave; }
              //--- zmemcpy(put, next, copy); ---
              utils.arraySet(output, input, next, copy, put);
              //---//
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state.length -= copy;
              break;
            }
            //Tracev((stderr, "inflate:       stored end\n"));
            state.mode = TYPE;
            break;
          case TABLE:
            //=== NEEDBITS(14); */
            while (bits < 14) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
            //--- DROPBITS(5) ---//
            hold >>>= 5;
            bits -= 5;
            //---//
            state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
            //--- DROPBITS(5) ---//
            hold >>>= 5;
            bits -= 5;
            //---//
            state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
            //--- DROPBITS(4) ---//
            hold >>>= 4;
            bits -= 4;
            //---//
            //#ifndef PKZIP_BUG_WORKAROUND
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = 'too many length or distance symbols';
              state.mode = BAD;
              break;
            }
            //#endif
            //Tracev((stderr, "inflate:       table sizes ok\n"));
            state.have = 0;
            state.mode = LENLENS;
          /* falls through */
          case LENLENS:
            while (state.have < state.ncode) {
              //=== NEEDBITS(3);
              while (bits < 3) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            // We have separate tables & no pointers. 2 commented lines below not needed.
            //state.next = state.codes;
            //state.lencode = state.next;
            // Switch to use dynamic table
            state.lencode = state.lendyn;
            state.lenbits = 7;

            opts = { bits: state.lenbits };
            ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;

            if (ret) {
              strm.msg = 'invalid code lengths set';
              state.mode = BAD;
              break;
            }
            //Tracev((stderr, "inflate:       code lengths ok\n"));
            state.have = 0;
            state.mode = CODELENS;
          /* falls through */
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ;) {
                here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;

                if ((here_bits) <= bits) { break; }
                //--- PULLBYTE() ---//
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
                //---//
              }
              if (here_val < 16) {
                //--- DROPBITS(here.bits) ---//
                hold >>>= here_bits;
                bits -= here_bits;
                //---//
                state.lens[state.have++] = here_val;
              }
              else {
                if (here_val === 16) {
                  //=== NEEDBITS(here.bits + 2);
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) { break inf_leave; }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  //===//
                  //--- DROPBITS(here.bits) ---//
                  hold >>>= here_bits;
                  bits -= here_bits;
                  //---//
                  if (state.have === 0) {
                    strm.msg = 'invalid bit length repeat';
                    state.mode = BAD;
                    break;
                  }
                  len = state.lens[state.have - 1];
                  copy = 3 + (hold & 0x03);//BITS(2);
                  //--- DROPBITS(2) ---//
                  hold >>>= 2;
                  bits -= 2;
                  //---//
                }
                else if (here_val === 17) {
                  //=== NEEDBITS(here.bits + 3);
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) { break inf_leave; }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  //===//
                  //--- DROPBITS(here.bits) ---//
                  hold >>>= here_bits;
                  bits -= here_bits;
                  //---//
                  len = 0;
                  copy = 3 + (hold & 0x07);//BITS(3);
                  //--- DROPBITS(3) ---//
                  hold >>>= 3;
                  bits -= 3;
                  //---//
                }
                else {
                  //=== NEEDBITS(here.bits + 7);
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) { break inf_leave; }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  //===//
                  //--- DROPBITS(here.bits) ---//
                  hold >>>= here_bits;
                  bits -= here_bits;
                  //---//
                  len = 0;
                  copy = 11 + (hold & 0x7f);//BITS(7);
                  //--- DROPBITS(7) ---//
                  hold >>>= 7;
                  bits -= 7;
                  //---//
                }
                if (state.have + copy > state.nlen + state.ndist) {
                  strm.msg = 'invalid bit length repeat';
                  state.mode = BAD;
                  break;
                }
                while (copy--) {
                  state.lens[state.have++] = len;
                }
              }
            }

            /* handle error breaks in while */
            if (state.mode === BAD) { break; }

            /* check for end-of-block code (better have one) */
            if (state.lens[256] === 0) {
              strm.msg = 'invalid code -- missing end-of-block';
              state.mode = BAD;
              break;
            }

            /* build code tables -- note: do not change the lenbits or distbits
               values here (9 and 6) without reading the comments in inftrees.h
               concerning the ENOUGH constants, which depend on those values */
            state.lenbits = 9;

            opts = { bits: state.lenbits };
            ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            // We have separate tables & no pointers. 2 commented lines below not needed.
            // state.next_index = opts.table_index;
            state.lenbits = opts.bits;
            // state.lencode = state.next;

            if (ret) {
              strm.msg = 'invalid literal/lengths set';
              state.mode = BAD;
              break;
            }

            state.distbits = 6;
            //state.distcode.copy(state.codes);
            // Switch to use dynamic table
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            // We have separate tables & no pointers. 2 commented lines below not needed.
            // state.next_index = opts.table_index;
            state.distbits = opts.bits;
            // state.distcode = state.next;

            if (ret) {
              strm.msg = 'invalid distances set';
              state.mode = BAD;
              break;
            }
            //Tracev((stderr, 'inflate:       codes ok\n'));
            state.mode = LEN_;
            if (flush === Z_TREES) { break inf_leave; }
          /* falls through */
          case LEN_:
            state.mode = LEN;
          /* falls through */
          case LEN:
            if (have >= 6 && left >= 258) {
              //--- RESTORE() ---
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              //---
              inflate_fast(strm, _out);
              //--- LOAD() ---
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              //---

              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ;) {
              here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;

              if (here_bits <= bits) { break; }
              //--- PULLBYTE() ---//
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
              //---//
            }
            if (here_op && (here_op & 0xf0) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ;) {
                here = state.lencode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;

                if ((last_bits + here_bits) <= bits) { break; }
                //--- PULLBYTE() ---//
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
                //---//
              }
              //--- DROPBITS(last.bits) ---//
              hold >>>= last_bits;
              bits -= last_bits;
              //---//
              state.back += last_bits;
            }
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
              //        "inflate:         literal '%c'\n" :
              //        "inflate:         literal 0x%02x\n", here.val));
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              //Tracevv((stderr, "inflate:         end of block\n"));
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = 'invalid literal/length code';
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          /* falls through */
          case LENEXT:
            if (state.extra) {
              //=== NEEDBITS(state.extra);
              n = state.extra;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
              //--- DROPBITS(state.extra) ---//
              hold >>>= state.extra;
              bits -= state.extra;
              //---//
              state.back += state.extra;
            }
            //Tracevv((stderr, "inflate:         length %u\n", state.length));
            state.was = state.length;
            state.mode = DIST;
          /* falls through */
          case DIST:
            for (; ;) {
              here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;

              if ((here_bits) <= bits) { break; }
              //--- PULLBYTE() ---//
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
              //---//
            }
            if ((here_op & 0xf0) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ;) {
                here = state.distcode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
                here_bits = here >>> 24;
                here_op = (here >>> 16) & 0xff;
                here_val = here & 0xffff;

                if ((last_bits + here_bits) <= bits) { break; }
                //--- PULLBYTE() ---//
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
                //---//
              }
              //--- DROPBITS(last.bits) ---//
              hold >>>= last_bits;
              bits -= last_bits;
              //---//
              state.back += last_bits;
            }
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = 'invalid distance code';
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = (here_op) & 15;
            state.mode = DISTEXT;
          /* falls through */
          case DISTEXT:
            if (state.extra) {
              //=== NEEDBITS(state.extra);
              n = state.extra;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
              //--- DROPBITS(state.extra) ---//
              hold >>>= state.extra;
              bits -= state.extra;
              //---//
              state.back += state.extra;
            }
            //#ifdef INFLATE_STRICT
            if (state.offset > state.dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
            //#endif
            //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
            state.mode = MATCH;
          /* falls through */
          case MATCH:
            if (left === 0) { break inf_leave; }
            copy = _out - left;
            if (state.offset > copy) {         /* copy from window */
              copy = state.offset - copy;
              if (copy > state.whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break;
                }
                // (!) This block is disabled in zlib defaults,
                // don't enable it for binary compatibility
                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                //          Trace((stderr, "inflate.c too far\n"));
                //          copy -= state.whave;
                //          if (copy > state.length) { copy = state.length; }
                //          if (copy > left) { copy = left; }
                //          left -= copy;
                //          state.length -= copy;
                //          do {
                //            output[put++] = 0;
                //          } while (--copy);
                //          if (state.length === 0) { state.mode = LEN; }
                //          break;
                //#endif
              }
              if (copy > state.wnext) {
                copy -= state.wnext;
                from = state.wsize - copy;
              }
              else {
                from = state.wnext - copy;
              }
              if (copy > state.length) { copy = state.length; }
              from_source = state.window;
            }
            else {                              /* copy from output */
              from_source = output;
              from = put - state.offset;
              copy = state.length;
            }
            if (copy > left) { copy = left; }
            left -= copy;
            state.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state.length === 0) { state.mode = LEN; }
            break;
          case LIT:
            if (left === 0) { break inf_leave; }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              //=== NEEDBITS(32);
              while (bits < 32) {
                if (have === 0) { break inf_leave; }
                have--;
                // Use '|' instead of '+' to make sure that result is signed
                hold |= input[next++] << bits;
                bits += 8;
              }
              //===//
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (_out) {
                strm.adler = state.check =
                  /*UPDATE(state.check, put - _out, _out);*/
                  (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

              }
              _out = left;
              // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
              if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = 'incorrect data check';
                state.mode = BAD;
                break;
              }
              //=== INITBITS();
              hold = 0;
              bits = 0;
              //===//
              //Tracev((stderr, "inflate:   check matches trailer\n"));
            }
            state.mode = LENGTH;
          /* falls through */
          case LENGTH:
            if (state.wrap && state.flags) {
              //=== NEEDBITS(32);
              while (bits < 32) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              if (hold !== (state.total & 0xffffffff)) {
                strm.msg = 'incorrect length check';
                state.mode = BAD;
                break;
              }
              //=== INITBITS();
              hold = 0;
              bits = 0;
              //===//
              //Tracev((stderr, "inflate:   length matches trailer\n"));
            }
            state.mode = DONE;
          /* falls through */
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          /* falls through */
          default:
            return Z_STREAM_ERROR;
        }
      }

      // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

      /*
         Return from inflate(), updating the total counts and the check value.
         If there was no progress during the inflate() call, return a buffer
         error.  Call updatewindow() to create and/or update the window state.
         Note: a memory error from inflate() is non-recoverable.
       */

      //--- RESTORE() ---
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      //---

      if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
        (state.mode < CHECK || flush !== Z_FINISH))) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
          (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) +
        (state.mode === TYPE ? 128 : 0) +
        (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }

    function inflateEnd(strm) {

      if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
        return Z_STREAM_ERROR;
      }

      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }

    function inflateGetHeader(strm, head) {
      var state;

      /* check state */
      if (!strm || !strm.state) { return Z_STREAM_ERROR; }
      state = strm.state;
      if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

      /* save header structure */
      state.head = head;
      head.done = false;
      return Z_OK;
    }

    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;

      var state;
      var dictid;
      var ret;

      /* check state */
      if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
      state = strm.state;

      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }

      /* check for correct dictionary identifier */
      if (state.mode === DICT) {
        dictid = 1; /* adler32(0, null, 0)*/
        /* dictid = adler32(dictid, dictionary, dictLength); */
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      /* copy dictionary to window using updatewindow(), which will amend the
       existing dictionary if appropriate */
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      // Tracev((stderr, "inflate:   dictionary set\n"));
      return Z_OK;
    }

    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = 'pako inflate (from Nodeca project)';

    /* Not implemented
    exports.inflateCopy = inflateCopy;
    exports.inflateGetDictionary = inflateGetDictionary;
    exports.inflateMark = inflateMark;
    exports.inflatePrime = inflatePrime;
    exports.inflateSync = inflateSync;
    exports.inflateSyncPoint = inflateSyncPoint;
    exports.inflateUndermine = inflateUndermine;
    */

  }, { "../utils/common": 152, "./adler32": 153, "./crc32": 155, "./inffast": 157, "./inftrees": 159 }], 159: [function (require, module, exports) {
    'use strict';

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    var utils = require('../utils/common');

    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    //var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;

    var lbase = [ /* Length codes 257..285 base */
      3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
      35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
    ];

    var lext = [ /* Length codes 257..285 extra */
      16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
      19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
    ];

    var dbase = [ /* Distance codes 0..29 base */
      1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
      257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
      8193, 12289, 16385, 24577, 0, 0
    ];

    var dext = [ /* Distance codes 0..29 extra */
      16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
      23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
      28, 28, 29, 29, 64, 64
    ];

    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

      var len = 0;               /* a code's length in bits */
      var sym = 0;               /* index of code symbols */
      var min = 0, max = 0;          /* minimum and maximum code lengths */
      var root = 0;              /* number of index bits for root table */
      var curr = 0;              /* number of index bits for current table */
      var drop = 0;              /* code bits to drop for sub-table */
      var left = 0;                   /* number of prefix codes available */
      var used = 0;              /* code entries in table used */
      var huff = 0;              /* Huffman code */
      var incr;              /* for incrementing code, index */
      var fill;              /* index for replicating entries */
      var low;               /* low bits for current root entry */
      var mask;              /* mask for low root bits */
      var next;             /* next available space in table */
      var base = null;     /* base value table to use */
      var base_index = 0;
      //  var shoextra;    /* extra bits table to use */
      var end;                    /* use base and extra for symbol > end */
      var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
      var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
      var extra = null;
      var extra_index = 0;

      var here_bits, here_op, here_val;

      /*
       Process a set of code lengths to create a canonical Huffman code.  The
       code lengths are lens[0..codes-1].  Each length corresponds to the
       symbols 0..codes-1.  The Huffman code is generated by first sorting the
       symbols by length from short to long, and retaining the symbol order
       for codes with equal lengths.  Then the code starts with all zero bits
       for the first code of the shortest length, and the codes are integer
       increments for the same length, and zeros are appended as the length
       increases.  For the deflate format, these bits are stored backwards
       from their more natural integer increment ordering, and so when the
       decoding tables are built in the large loop below, the integer codes
       are incremented backwards.
    
       This routine assumes, but does not check, that all of the entries in
       lens[] are in the range 0..MAXBITS.  The caller must assure this.
       1..MAXBITS is interpreted as that code length.  zero means that that
       symbol does not occur in this code.
    
       The codes are sorted by computing a count of codes for each length,
       creating from that a table of starting indices for each length in the
       sorted table, and then entering the symbols in order in the sorted
       table.  The sorted table is work[], with that space being provided by
       the caller.
    
       The length counts are used for other purposes as well, i.e. finding
       the minimum and maximum length codes, determining if there are any
       codes at all, checking for a valid set of lengths, and looking ahead
       at length counts to determine sub-table sizes when building the
       decoding tables.
       */

      /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }

      /* bound code lengths, force root to be within code lengths */
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) { break; }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {                     /* no symbols to code at all */
        //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
        //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
        //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
        table[table_index++] = (1 << 24) | (64 << 16) | 0;


        //table.op[opts.table_index] = 64;
        //table.bits[opts.table_index] = 1;
        //table.val[opts.table_index++] = 0;
        table[table_index++] = (1 << 24) | (64 << 16) | 0;

        opts.bits = 1;
        return 0;     /* no symbols, but wait for decoding to report error */
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) { break; }
      }
      if (root < min) {
        root = min;
      }

      /* check for an over-subscribed or incomplete set of lengths */
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }        /* over-subscribed */
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;                      /* incomplete set */
      }

      /* generate offsets into symbol table for each length for sorting */
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }

      /* sort symbols by length, by symbol order within each length */
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }

      /*
       Create and fill in decoding tables.  In this loop, the table being
       filled is at next and has curr index bits.  The code being used is huff
       with length len.  That code is converted to an index by dropping drop
       bits off of the bottom.  For codes where len is less than drop + curr,
       those top drop + curr - len bits are incremented through all values to
       fill the table with replicated entries.
    
       root is the number of index bits for the root table.  When len exceeds
       root, sub-tables are created pointed to by the root entry with an index
       of the low root bits of huff.  This is saved in low to check for when a
       new sub-table should be started.  drop is zero when the root table is
       being filled, and drop is root when sub-tables are being filled.
    
       When a new sub-table is needed, it is necessary to look ahead in the
       code lengths to determine what size sub-table is needed.  The length
       counts are used for this, and so count[] is decremented as codes are
       entered in the tables.
    
       used keeps track of how many table entries have been allocated from the
       provided *table space.  It is checked for LENS and DIST tables against
       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
       the initial root table size constants.  See the comments in inftrees.h
       for more information.
    
       sym increments through all symbols, and the loop terminates when
       all codes of length max, i.e. all codes, have been processed.  This
       routine permits incomplete codes, so another loop after this one fills
       in the rest of the decoding tables with invalid code markers.
       */

      /* set up for code type */
      // poor man optimization - use if-else instead of switch,
      // to avoid deopts in old v8
      if (type === CODES) {
        base = extra = work;    /* dummy value--not used */
        end = 19;

      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;

      } else {                    /* DISTS */
        base = dbase;
        extra = dext;
        end = -1;
      }

      /* initialize opts for loop */
      huff = 0;                   /* starting code */
      sym = 0;                    /* starting code symbol */
      len = min;                  /* starting code length */
      next = table_index;              /* current table to fill in */
      curr = root;                /* current table index bits */
      drop = 0;                   /* current bits to drop from code for index */
      low = -1;                   /* trigger new sub-table when len > root */
      used = 1 << root;          /* use root table entries */
      mask = used - 1;            /* mask for comparing low */

      /* check available table space */
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* process all codes and make table entries */
      for (; ;) {
        /* create table entry */
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        }
        else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        }
        else {
          here_op = 32 + 64;         /* end of block */
          here_val = 0;
        }

        /* replicate for those indices with low len bits equal to huff */
        incr = 1 << (len - drop);
        fill = 1 << curr;
        min = fill;                 /* save offset to next table */
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val | 0;
        } while (fill !== 0);

        /* backwards increment the len-bit code huff */
        incr = 1 << (len - 1);
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }

        /* go to next symbol, update count, len */
        sym++;
        if (--count[len] === 0) {
          if (len === max) { break; }
          len = lens[lens_index + work[sym]];
        }

        /* create new sub-table if needed */
        if (len > root && (huff & mask) !== low) {
          /* if first time, transition to sub-tables */
          if (drop === 0) {
            drop = root;
          }

          /* increment past last table */
          next += min;            /* here min is 1 << curr */

          /* determine length of next table */
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) { break; }
            curr++;
            left <<= 1;
          }

          /* check for enough space */
          used += 1 << curr;
          if ((type === LENS && used > ENOUGH_LENS) ||
            (type === DISTS && used > ENOUGH_DISTS)) {
            return 1;
          }

          /* point entry in root table to sub-table */
          low = huff & mask;
          /*table.op[low] = curr;
          table.bits[low] = root;
          table.val[low] = next - opts.table_index;*/
          table[low] = (root << 24) | (curr << 16) | (next - table_index) | 0;
        }
      }

      /* fill in remaining table entry if code is incomplete (guaranteed to have
       at most one remaining entry, since if the code is incomplete, the
       maximum code length that was allowed to get this far is one bit) */
      if (huff !== 0) {
        //table.op[next + huff] = 64;            /* invalid code marker */
        //table.bits[next + huff] = len - drop;
        //table.val[next + huff] = 0;
        table[next + huff] = ((len - drop) << 24) | (64 << 16) | 0;
      }

      /* set return parameters */
      //opts.table_index += used;
      opts.bits = root;
      return 0;
    };

  }, { "../utils/common": 152 }], 160: [function (require, module, exports) {
    'use strict';

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    module.exports = {
      2: 'need dictionary',     /* Z_NEED_DICT       2  */
      1: 'stream end',          /* Z_STREAM_END      1  */
      0: '',                    /* Z_OK              0  */
      '-1': 'file error',          /* Z_ERRNO         (-1) */
      '-2': 'stream error',        /* Z_STREAM_ERROR  (-2) */
      '-3': 'data error',          /* Z_DATA_ERROR    (-3) */
      '-4': 'insufficient memory', /* Z_MEM_ERROR     (-4) */
      '-5': 'buffer error',        /* Z_BUF_ERROR     (-5) */
      '-6': 'incompatible version' /* Z_VERSION_ERROR (-6) */
    };

  }, {}], 161: [function (require, module, exports) {
    'use strict';

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    /* eslint-disable space-unary-ops */

    var utils = require('../utils/common');

    /* Public constants ==========================================================*/
    /* ===========================================================================*/


    //var Z_FILTERED          = 1;
    //var Z_HUFFMAN_ONLY      = 2;
    //var Z_RLE               = 3;
    var Z_FIXED = 4;
    //var Z_DEFAULT_STRATEGY  = 0;

    /* Possible values of the data_type field (though see inflate()) */
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    //var Z_ASCII             = 1; // = Z_TEXT
    var Z_UNKNOWN = 2;

    /*============================================================================*/


    function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

    // From zutil.h

    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    /* The three kinds of block type */

    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    /* The minimum and maximum match lengths */

    // From deflate.h
    /* ===========================================================================
     * Internal compression state.
     */

    var LENGTH_CODES = 29;
    /* number of length codes, not counting the special END_BLOCK code */

    var LITERALS = 256;
    /* number of literal bytes 0..255 */

    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    /* number of Literal or Length codes, including the END_BLOCK code */

    var D_CODES = 30;
    /* number of distance codes */

    var BL_CODES = 19;
    /* number of codes used to transfer the bit lengths */

    var HEAP_SIZE = 2 * L_CODES + 1;
    /* maximum heap size */

    var MAX_BITS = 15;
    /* All codes must not exceed MAX_BITS bits */

    var Buf_size = 16;
    /* size of bit buffer in bi_buf */


    /* ===========================================================================
     * Constants
     */

    var MAX_BL_BITS = 7;
    /* Bit length codes must not exceed MAX_BL_BITS bits */

    var END_BLOCK = 256;
    /* end of block literal code */

    var REP_3_6 = 16;
    /* repeat previous bit length 3-6 times (2 bits of repeat count) */

    var REPZ_3_10 = 17;
    /* repeat a zero length 3-10 times  (3 bits of repeat count) */

    var REPZ_11_138 = 18;
    /* repeat a zero length 11-138 times  (7 bits of repeat count) */

    /* eslint-disable comma-spacing,array-bracket-spacing */
    var extra_lbits =   /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];

    var extra_dbits =   /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];

    var extra_blbits =  /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];

    var bl_order =
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    /* eslint-enable comma-spacing,array-bracket-spacing */

    /* The lengths of the bit length codes are sent in order of decreasing
     * probability, to avoid transmitting the lengths for unused bit length codes.
     */

    /* ===========================================================================
     * Local data. These are initialized only once.
     */

    // We pre-fill arrays with 0 to avoid uninitialized gaps

    var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

    // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    /* The static literal tree. Since the bit lengths are imposed, there is no
     * need for the L_CODES extra codes used during heap construction. However
     * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
     * below).
     */

    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    /* The static distance tree. (Actually a trivial tree since all codes use
     * 5 bits.)
     */

    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    /* Distance codes. The first 256 values correspond to the distances
     * 3 .. 258, the last 256 values correspond to the top 8 bits of
     * the 15 bit distances.
     */

    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    /* length code for each normalized match length (0 == MIN_MATCH) */

    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    /* First normalized length for each code (0 = MIN_MATCH) */

    var base_dist = new Array(D_CODES);
    zero(base_dist);
    /* First normalized distance for each code (0 = distance of 1) */


    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

      this.static_tree = static_tree;  /* static tree or NULL */
      this.extra_bits = extra_bits;   /* extra bits for each code or NULL */
      this.extra_base = extra_base;   /* base index for extra_bits */
      this.elems = elems;        /* max number of elements in the tree */
      this.max_length = max_length;   /* max bit length for the codes */

      // show if `static_tree` has data or dummy - needed for monomorphic objects
      this.has_stree = static_tree && static_tree.length;
    }


    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;


    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;     /* the dynamic tree */
      this.max_code = 0;            /* largest code with non zero frequency */
      this.stat_desc = stat_desc;   /* the corresponding static tree */
    }



    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }


    /* ===========================================================================
     * Output a short LSB first on the stream.
     * IN assertion: there is enough room in pendingBuf.
     */
    function put_short(s, w) {
      //    put_byte(s, (uch)((w) & 0xff));
      //    put_byte(s, (uch)((ush)(w) >> 8));
      s.pending_buf[s.pending++] = (w) & 0xff;
      s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
    }


    /* ===========================================================================
     * Send a value on a given number of bits.
     * IN assertion: length <= 16 and value fits in length bits.
     */
    function send_bits(s, value, length) {
      if (s.bi_valid > (Buf_size - length)) {
        s.bi_buf |= (value << s.bi_valid) & 0xffff;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> (Buf_size - s.bi_valid);
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= (value << s.bi_valid) & 0xffff;
        s.bi_valid += length;
      }
    }


    function send_code(s, c, tree) {
      send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
    }


    /* ===========================================================================
     * Reverse the first len bits of a code, using straightforward code (a faster
     * method would use a table)
     * IN assertion: 1 <= len <= 15
     */
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }


    /* ===========================================================================
     * Flush the bit buffer, keeping at most 7 bits in it.
     */
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;

      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 0xff;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }


    /* ===========================================================================
     * Compute the optimal bit lengths for a tree and update the total bit length
     * for the current block.
     * IN assertion: the fields freq and dad are set, heap[heap_max] and
     *    above are the tree nodes sorted by increasing frequency.
     * OUT assertions: the field len is set to the optimal bit length, the
     *     array bl_count contains the frequencies for each bit length.
     *     The length opt_len is updated; static_len is also updated if stree is
     *     not null.
     */
    function gen_bitlen(s, desc)
    //    deflate_state *s;
    //    tree_desc *desc;    /* the tree descriptor */
    {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;              /* heap index */
      var n, m;           /* iterate over the tree elements */
      var bits;           /* bit length */
      var xbits;          /* extra bits */
      var f;              /* frequency */
      var overflow = 0;   /* number of elements with bit length too large */

      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }

      /* In a first pass, compute the optimal bit lengths (which may
       * overflow in the case of the bit length tree).
       */
      tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1]/*.Len*/ = bits;
        /* We overwrite tree[n].Dad which is no longer needed */

        if (n > max_code) { continue; } /* not a leaf node */

        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2]/*.Freq*/;
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
        }
      }
      if (overflow === 0) { return; }

      // Trace((stderr,"\nbit length overflow\n"));
      /* This happens for example on obj2 and pic of the Calgary corpus */

      /* Find the first bit length which could increase: */
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) { bits--; }
        s.bl_count[bits]--;      /* move one leaf down the tree */
        s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
        s.bl_count[max_length]--;
        /* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */
        overflow -= 2;
      } while (overflow > 0);

      /* Now recompute all bit lengths, scanning in increasing frequency.
       * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
       * lengths instead of fixing only the wrong ones. This idea is taken
       * from 'ar' written by Haruhiko Okumura.)
       */
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) { continue; }
          if (tree[m * 2 + 1]/*.Len*/ !== bits) {
            // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
            s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
            tree[m * 2 + 1]/*.Len*/ = bits;
          }
          n--;
        }
      }
    }


    /* ===========================================================================
     * Generate the codes for a given tree and bit counts (which need not be
     * optimal).
     * IN assertion: the array bl_count contains the bit length statistics for
     * the given tree and the field len is set for all tree elements.
     * OUT assertion: the field code is set for all tree elements of non
     *     zero code length.
     */
    function gen_codes(tree, max_code, bl_count)
    //    ct_data *tree;             /* the tree to decorate */
    //    int max_code;              /* largest code with non zero frequency */
    //    ushf *bl_count;            /* number of codes at each bit length */
    {
      var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
      var code = 0;              /* running code value */
      var bits;                  /* bit index */
      var n;                     /* code index */

      /* The distribution counts are first used to generate the code values
       * without bit reversal.
       */
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
      }
      /* Check that the bit counts in bl_count are consistent. The last code
       * must be all ones.
       */
      //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
      //        "inconsistent bit counts");
      //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1]/*.Len*/;
        if (len === 0) { continue; }
        /* Now reverse the bits */
        tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

        //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
        //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
      }
    }


    /* ===========================================================================
     * Initialize the various 'constant' tables.
     */
    function tr_static_init() {
      var n;        /* iterates over tree elements */
      var bits;     /* bit counter */
      var length;   /* length value */
      var code;     /* code value */
      var dist;     /* distance index */
      var bl_count = new Array(MAX_BITS + 1);
      /* number of codes at each bit length for an optimal tree */

      // do check in _tr_init()
      //if (static_init_done) return;

      /* For some embedded targets, global variables are not initialized: */
      /*#ifdef NO_INIT_GLOBAL_POINTERS
        static_l_desc.static_tree = static_ltree;
        static_l_desc.extra_bits = extra_lbits;
        static_d_desc.static_tree = static_dtree;
        static_d_desc.extra_bits = extra_dbits;
        static_bl_desc.extra_bits = extra_blbits;
      #endif*/

      /* Initialize the mapping length (0..255) -> length code (0..28) */
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < (1 << extra_lbits[code]); n++) {
          _length_code[length++] = code;
        }
      }
      //Assert (length == 256, "tr_static_init: length != 256");
      /* Note that the length 255 (match length 258) can be represented
       * in two different ways: code 284 + 5 bits or code 285, so we
       * overwrite length_code[255] to use the best encoding:
       */
      _length_code[length - 1] = code;

      /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < (1 << extra_dbits[code]); n++) {
          _dist_code[dist++] = code;
        }
      }
      //Assert (dist == 256, "tr_static_init: dist != 256");
      dist >>= 7; /* from now on, all distances are divided by 128 */
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      //Assert (dist == 256, "tr_static_init: 256+dist != 512");

      /* Construct the codes of the static literal tree */
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }

      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1]/*.Len*/ = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1]/*.Len*/ = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1]/*.Len*/ = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1]/*.Len*/ = 8;
        n++;
        bl_count[8]++;
      }
      /* Codes 286 and 287 do not exist, but we must include them in the
       * tree construction to get a canonical Huffman tree (longest code
       * all ones)
       */
      gen_codes(static_ltree, L_CODES + 1, bl_count);

      /* The static distance tree is trivial: */
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1]/*.Len*/ = 5;
        static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
      }

      // Now data ready and we can init static trees
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);

      //static_init_done = true;
    }


    /* ===========================================================================
     * Initialize a new block.
     */
    function init_block(s) {
      var n; /* iterates over tree elements */

      /* Initialize the trees. */
      for (n = 0; n < L_CODES; n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
      for (n = 0; n < D_CODES; n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
      for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

      s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }


    /* ===========================================================================
     * Flush the bit buffer and align the output on a byte boundary
     */
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        //put_byte(s, (Byte)s->bi_buf);
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }

    /* ===========================================================================
     * Copy a stored block, storing first the length and its
     * one's complement if requested.
     */
    function copy_block(s, buf, len, header)
    //DeflateState *s;
    //charf    *buf;    /* the input data */
    //unsigned len;     /* its length */
    //int      header;  /* true if block header must be written */
    {
      bi_windup(s);        /* align on byte boundary */

      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      //  while (len--) {
      //    put_byte(s, *buf++);
      //  }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }

    /* ===========================================================================
     * Compares to subtrees, using the tree depth as tie breaker when
     * the subtrees have equal frequency. This minimizes the worst case length.
     */
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
        (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
    }

    /* ===========================================================================
     * Restore the heap property by moving down the tree starting at node k,
     * exchanging a node with the smallest of its two sons if necessary, stopping
     * when the heap property is re-established (each father smaller than its
     * two sons).
     */
    function pqdownheap(s, tree, k)
    //    deflate_state *s;
    //    ct_data *tree;  /* the tree to restore */
    //    int k;               /* node to move down */
    {
      var v = s.heap[k];
      var j = k << 1;  /* left son of k */
      while (j <= s.heap_len) {
        /* Set j to the smallest of the two sons: */
        if (j < s.heap_len &&
          smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        /* Exit if v is smaller than both sons */
        if (smaller(tree, v, s.heap[j], s.depth)) { break; }

        /* Exchange v with the smallest son */
        s.heap[k] = s.heap[j];
        k = j;

        /* And continue down the tree, setting j to the left son of k */
        j <<= 1;
      }
      s.heap[k] = v;
    }


    // inlined manually
    // var SMALLEST = 1;

    /* ===========================================================================
     * Send the block data compressed using the given Huffman trees
     */
    function compress_block(s, ltree, dtree)
    //    deflate_state *s;
    //    const ct_data *ltree; /* literal tree */
    //    const ct_data *dtree; /* distance tree */
    {
      var dist;           /* distance of matched string */
      var lc;             /* match length or unmatched char (if dist == 0) */
      var lx = 0;         /* running index in l_buf */
      var code;           /* the code to send */
      var extra;          /* number of extra bits to send */

      if (s.last_lit !== 0) {
        do {
          dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
          lc = s.pending_buf[s.l_buf + lx];
          lx++;

          if (dist === 0) {
            send_code(s, lc, ltree); /* send a literal byte */
            //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
          } else {
            /* Here, lc is the match length - MIN_MATCH */
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree); /* send the length code */
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);       /* send the extra length bits */
            }
            dist--; /* dist is now the match distance - 1 */
            code = d_code(dist);
            //Assert (code < D_CODES, "bad d_code");

            send_code(s, code, dtree);       /* send the distance code */
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);   /* send the extra distance bits */
            }
          } /* literal or match pair ? */

          /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
          //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
          //       "pendingBuf overflow");

        } while (lx < s.last_lit);
      }

      send_code(s, END_BLOCK, ltree);
    }


    /* ===========================================================================
     * Construct one Huffman tree and assigns the code bit strings and lengths.
     * Update the total bit length for the current block.
     * IN assertion: the field freq is set for all tree elements.
     * OUT assertions: the fields len and code are set to the optimal bit length
     *     and corresponding code. The length opt_len is updated; static_len is
     *     also updated if stree is not null. The field max_code is set.
     */
    function build_tree(s, desc)
    //    deflate_state *s;
    //    tree_desc *desc; /* the tree descriptor */
    {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;          /* iterate over heap elements */
      var max_code = -1; /* largest code with non zero frequency */
      var node;          /* new node being created */

      /* Construct the initial heap, with least frequent element in
       * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
       * heap[0] is not used.
       */
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;

      for (n = 0; n < elems; n++) {
        if (tree[n * 2]/*.Freq*/ !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;

        } else {
          tree[n * 2 + 1]/*.Len*/ = 0;
        }
      }

      /* The pkzip format requires that at least one distance code exists,
       * and that at least one bit should be sent even if there is only one
       * possible code. So to avoid special checks later on we force at least
       * two codes of non zero frequency.
       */
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
        tree[node * 2]/*.Freq*/ = 1;
        s.depth[node] = 0;
        s.opt_len--;

        if (has_stree) {
          s.static_len -= stree[node * 2 + 1]/*.Len*/;
        }
        /* node is 0 or 1 so it does not have extra bits */
      }
      desc.max_code = max_code;

      /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
       * establish sub-heaps of increasing lengths:
       */
      for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

      /* Construct the Huffman tree by repeatedly combining the least two
       * frequent nodes.
       */
      node = elems;              /* next internal node of the tree */
      do {
        //pqremove(s, tree, n);  /* n = node of least frequency */
        /*** pqremove ***/
        n = s.heap[1/*SMALLEST*/];
        s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
        pqdownheap(s, tree, 1/*SMALLEST*/);
        /***/

        m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

        s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
        s.heap[--s.heap_max] = m;

        /* Create a new node father of n and m */
        tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

        /* and insert the new node in the heap */
        s.heap[1/*SMALLEST*/] = node++;
        pqdownheap(s, tree, 1/*SMALLEST*/);

      } while (s.heap_len >= 2);

      s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

      /* At this point, the fields freq and dad are set. We can now
       * generate the bit lengths.
       */
      gen_bitlen(s, desc);

      /* The field len is now set, we can generate the bit codes */
      gen_codes(tree, max_code, s.bl_count);
    }


    /* ===========================================================================
     * Scan a literal or distance tree to determine the frequencies of the codes
     * in the bit length tree.
     */
    function scan_tree(s, tree, max_code)
    //    deflate_state *s;
    //    ct_data *tree;   /* the tree to be scanned */
    //    int max_code;    /* and its largest code of non zero frequency */
    {
      var n;                     /* iterates over all tree elements */
      var prevlen = -1;          /* last emitted length */
      var curlen;                /* length of current code */

      var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

      var count = 0;             /* repeat count of the current code */
      var max_count = 7;         /* max repeat count */
      var min_count = 4;         /* min repeat count */

      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

        if (++count < max_count && curlen === nextlen) {
          continue;

        } else if (count < min_count) {
          s.bl_tree[curlen * 2]/*.Freq*/ += count;

        } else if (curlen !== 0) {

          if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
          s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

        } else {
          s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
        }

        count = 0;
        prevlen = curlen;

        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;

        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;

        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }


    /* ===========================================================================
     * Send a literal or distance tree in compressed form, using the codes in
     * bl_tree.
     */
    function send_tree(s, tree, max_code)
    //    deflate_state *s;
    //    ct_data *tree; /* the tree to be scanned */
    //    int max_code;       /* and its largest code of non zero frequency */
    {
      var n;                     /* iterates over all tree elements */
      var prevlen = -1;          /* last emitted length */
      var curlen;                /* length of current code */

      var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

      var count = 0;             /* repeat count of the current code */
      var max_count = 7;         /* max repeat count */
      var min_count = 4;         /* min repeat count */

      /* tree[max_code+1].Len = -1; */  /* guard already set */
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }

      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

        if (++count < max_count && curlen === nextlen) {
          continue;

        } else if (count < min_count) {
          do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          //Assert(count >= 3 && count <= 6, " 3_6?");
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);

        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);

        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }

        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;

        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;

        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }


    /* ===========================================================================
     * Construct the Huffman tree for the bit lengths and return the index in
     * bl_order of the last bit length code to send.
     */
    function build_bl_tree(s) {
      var max_blindex;  /* index of last bit length code of non zero freq */

      /* Determine the bit length frequencies for literal and distance trees */
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

      /* Build the bit length tree: */
      build_tree(s, s.bl_desc);
      /* opt_len now includes the length of the tree representations, except
       * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
       */

      /* Determine the number of bit length codes to send. The pkzip format
       * requires that at least 4 bit length codes be sent. (appnote.txt says
       * 3 but the actual value used is 4.)
       */
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
          break;
        }
      }
      /* Update opt_len to include the bit length tree and counts */
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
      //        s->opt_len, s->static_len));

      return max_blindex;
    }


    /* ===========================================================================
     * Send the header for a block using dynamic Huffman trees: the counts, the
     * lengths of the bit length codes, the literal tree and the distance tree.
     * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
     */
    function send_all_trees(s, lcodes, dcodes, blcodes)
    //    deflate_state *s;
    //    int lcodes, dcodes, blcodes; /* number of codes for each tree */
    {
      var rank;                    /* index in bl_order */

      //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
      //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
      //        "too many codes");
      //Tracev((stderr, "\nbl counts: "));
      send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */
      for (rank = 0; rank < blcodes; rank++) {
        //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
      }
      //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

      send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
      //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

      send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
      //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
    }


    /* ===========================================================================
     * Check if the data type is TEXT or BINARY, using the following algorithm:
     * - TEXT if the two conditions below are satisfied:
     *    a) There are no non-portable control characters belonging to the
     *       "black list" (0..6, 14..25, 28..31).
     *    b) There is at least one printable character belonging to the
     *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
     * - BINARY otherwise.
     * - The following partially-portable control characters form a
     *   "gray list" that is ignored in this detection algorithm:
     *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
     * IN assertion: the fields Freq of dyn_ltree are set.
     */
    function detect_data_type(s) {
      /* black_mask is the bit mask of black-listed bytes
       * set bits 0..6, 14..25, and 28..31
       * 0xf3ffc07f = binary 11110011111111111100000001111111
       */
      var black_mask = 0xf3ffc07f;
      var n;

      /* Check for non-textual ("black-listed") bytes. */
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
          return Z_BINARY;
        }
      }

      /* Check for textual ("white-listed") bytes. */
      if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
        s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
          return Z_TEXT;
        }
      }

      /* There are no "black-listed" or "white-listed" bytes:
       * this stream either is empty or has tolerated ("gray-listed") bytes only.
       */
      return Z_BINARY;
    }


    var static_init_done = false;

    /* ===========================================================================
     * Initialize the tree data structures for a new zlib stream.
     */
    function _tr_init(s) {

      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }

      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

      s.bi_buf = 0;
      s.bi_valid = 0;

      /* Initialize the first block of the first file: */
      init_block(s);
    }


    /* ===========================================================================
     * Send a stored block
     */
    function _tr_stored_block(s, buf, stored_len, last)
    //DeflateState *s;
    //charf *buf;       /* input block */
    //ulg stored_len;   /* length of input block */
    //int last;         /* one if this is the last block for a file */
    {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
      copy_block(s, buf, stored_len, true); /* with header */
    }


    /* ===========================================================================
     * Send one empty static block to give enough lookahead for inflate.
     * This takes 10 bits, of which 7 may remain in the bit buffer.
     */
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }


    /* ===========================================================================
     * Determine the best encoding for the current block: dynamic trees, static
     * trees or store, and output the encoded block to the zip file.
     */
    function _tr_flush_block(s, buf, stored_len, last)
    //DeflateState *s;
    //charf *buf;       /* input block, or NULL if too old */
    //ulg stored_len;   /* length of input block */
    //int last;         /* one if this is the last block for a file */
    {
      var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
      var max_blindex = 0;        /* index of last bit length code of non zero freq */

      /* Build the Huffman trees unless a stored block is forced */
      if (s.level > 0) {

        /* Check if the file is binary or text */
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }

        /* Construct the literal and distance trees */
        build_tree(s, s.l_desc);
        // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
        //        s->static_len));

        build_tree(s, s.d_desc);
        // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
        //        s->static_len));
        /* At this point, opt_len and static_len are the total bit lengths of
         * the compressed block data, excluding the tree representations.
         */

        /* Build the bit length tree for the above two trees, and get the index
         * in bl_order of the last bit length code to send.
         */
        max_blindex = build_bl_tree(s);

        /* Determine the best encoding. Compute the block lengths in bytes. */
        opt_lenb = (s.opt_len + 3 + 7) >>> 3;
        static_lenb = (s.static_len + 3 + 7) >>> 3;

        // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
        //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
        //        s->last_lit));

        if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

      } else {
        // Assert(buf != (char*)0, "lost buf");
        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
      }

      if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
        /* 4: two words for the lengths */

        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
         * transform a block into a stored block.
         */
        _tr_stored_block(s, buf, stored_len, last);

      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);

      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
      /* The above check is made mod 2^32, for files larger than 512 MB
       * and uLong implemented on 32 bits.
       */
      init_block(s);

      if (last) {
        bi_windup(s);
      }
      // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
      //       s->compressed_len-7*last));
    }

    /* ===========================================================================
     * Save the match info and tally the frequency counts. Return true if
     * the current block must be flushed.
     */
    function _tr_tally(s, dist, lc)
    //    deflate_state *s;
    //    unsigned dist;  /* distance of matched string */
    //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
    {
      //var out_length, in_length, dcode;

      s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 0xff;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

      s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
      s.last_lit++;

      if (dist === 0) {
        /* lc is the unmatched char */
        s.dyn_ltree[lc * 2]/*.Freq*/++;
      } else {
        s.matches++;
        /* Here, lc is the match length - MIN_MATCH */
        dist--;             /* dist = match distance - 1 */
        //Assert((ush)dist < (ush)MAX_DIST(s) &&
        //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
        //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
        s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
      }

      // (!) This block is disabled in zlib defaults,
      // don't enable it for binary compatibility

      //#ifdef TRUNCATE_BLOCK
      //  /* Try to guess if it is profitable to stop the current block here */
      //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
      //    /* Compute an upper bound for the compressed length */
      //    out_length = s.last_lit*8;
      //    in_length = s.strstart - s.block_start;
      //
      //    for (dcode = 0; dcode < D_CODES; dcode++) {
      //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
      //    }
      //    out_length >>>= 3;
      //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
      //    //       s->last_lit, in_length, out_length,
      //    //       100L - out_length*100L/in_length));
      //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
      //      return true;
      //    }
      //  }
      //#endif

      return (s.last_lit === s.lit_bufsize - 1);
      /* We avoid equality with lit_bufsize because of wraparound at 64K
       * on 16 bit machines and because stored blocks are restricted to
       * 64K-1 bytes.
       */
    }

    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;

  }, { "../utils/common": 152 }], 162: [function (require, module, exports) {
    'use strict';

    // (C) 1995-2013 Jean-loup Gailly and Mark Adler
    // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    // 1. The origin of this software must not be misrepresented; you must not
    //   claim that you wrote the original software. If you use this software
    //   in a product, an acknowledgment in the product documentation would be
    //   appreciated but is not required.
    // 2. Altered source versions must be plainly marked as such, and must not be
    //   misrepresented as being the original software.
    // 3. This notice may not be removed or altered from any source distribution.

    function ZStream() {
      /* next input byte */
      this.input = null; // JS specific, because we have no pointers
      this.next_in = 0;
      /* number of bytes available at input */
      this.avail_in = 0;
      /* total number of input bytes read so far */
      this.total_in = 0;
      /* next output byte should be put there */
      this.output = null; // JS specific, because we have no pointers
      this.next_out = 0;
      /* remaining free space at output */
      this.avail_out = 0;
      /* total number of bytes output so far */
      this.total_out = 0;
      /* last error message, NULL if no error */
      this.msg = ''/*Z_NULL*/;
      /* not visible by applications */
      this.state = null;
      /* best guess about the data type: binary or text */
      this.data_type = 2/*Z_UNKNOWN*/;
      /* adler32 value of the uncompressed data */
      this.adler = 0;
    }

    module.exports = ZStream;

  }, {}], 163: [function (require, module, exports) {
    // shim for using process in browser
    var process = module.exports = {};

    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.

    var cachedSetTimeout;
    var cachedClearTimeout;

    function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout() {
      throw new Error('clearTimeout has not been defined');
    }
    (function () {
      try {
        if (typeof setTimeout === 'function') {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === 'function') {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    }())
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
          // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
          return cachedSetTimeout.call(this, fun, 0);
        }
      }


    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
          return cachedClearTimeout.call(null, marker);
        } catch (e) {
          // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
          // Some versions of I.E. have different rules for clearTimeout vs setTimeout
          return cachedClearTimeout.call(this, marker);
        }
      }



    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }

    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;

      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }

    process.nextTick = function (fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function () {
      this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() { }

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;

    process.listeners = function (name) { return [] }

    process.binding = function (name) {
      throw new Error('process.binding is not supported');
    };

    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
      throw new Error('process.chdir is not supported');
    };
    process.umask = function () { return 0; };

  }, {}], 164: [function (require, module, exports) {
    /* eslint-disable node/no-deprecated-api */
    var buffer = require('buffer')
    var Buffer = buffer.Buffer

    // alternative to using Object.keys for old browsers
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key]
      }
    }
    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
      module.exports = buffer
    } else {
      // Copy properties from require('buffer')
      copyProps(buffer, exports)
      exports.Buffer = SafeBuffer
    }

    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer(arg, encodingOrOffset, length)
    }

    // Copy static methods from Buffer
    copyProps(Buffer, SafeBuffer)

    SafeBuffer.from = function (arg, encodingOrOffset, length) {
      if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number')
      }
      return Buffer(arg, encodingOrOffset, length)
    }

    SafeBuffer.alloc = function (size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number')
      }
      var buf = Buffer(size)
      if (fill !== undefined) {
        if (typeof encoding === 'string') {
          buf.fill(fill, encoding)
        } else {
          buf.fill(fill)
        }
      } else {
        buf.fill(0)
      }
      return buf
    }

    SafeBuffer.allocUnsafe = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number')
      }
      return Buffer(size)
    }

    SafeBuffer.allocUnsafeSlow = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number')
      }
      return buffer.SlowBuffer(size)
    }

  }, { "buffer": 126 }], 165: [function (require, module, exports) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    module.exports = Stream;

    var EE = require('events').EventEmitter;
    var inherits = require('inherits');

    inherits(Stream, EE);
    Stream.Readable = require('readable-stream/lib/_stream_readable.js');
    Stream.Writable = require('readable-stream/lib/_stream_writable.js');
    Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
    Stream.Transform = require('readable-stream/lib/_stream_transform.js');
    Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
    Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js')
    Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js')

    // Backwards-compat with node 0.4.x
    Stream.Stream = Stream;



    // old-style streams.  Note that the pipe method (the only relevant
    // part of this class) is overridden in the Readable class.

    function Stream() {
      EE.call(this);
    }

    Stream.prototype.pipe = function (dest, options) {
      var source = this;

      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }

      source.on('data', ondata);

      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }

      dest.on('drain', ondrain);

      // If the 'end' option is not supplied, dest.end() will be called when
      // source gets the 'end' or 'close' events.  Only dest.end() once.
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on('end', onend);
        source.on('close', onclose);
      }

      var didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;

        dest.end();
      }


      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;

        if (typeof dest.destroy === 'function') dest.destroy();
      }

      // don't leave dangling pipes when there are errors.
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, 'error') === 0) {
          throw er; // Unhandled stream error in pipe.
        }
      }

      source.on('error', onerror);
      dest.on('error', onerror);

      // remove all the event listeners that were added.
      function cleanup() {
        source.removeListener('data', ondata);
        dest.removeListener('drain', ondrain);

        source.removeListener('end', onend);
        source.removeListener('close', onclose);

        source.removeListener('error', onerror);
        dest.removeListener('error', onerror);

        source.removeListener('end', cleanup);
        source.removeListener('close', cleanup);

        dest.removeListener('close', cleanup);
      }

      source.on('end', cleanup);
      source.on('close', cleanup);

      dest.on('close', cleanup);

      dest.emit('pipe', source);

      // Allow for unix-like usage: A.pipe(B).pipe(C)
      return dest;
    };

  }, { "events": 134, "inherits": 144, "readable-stream/lib/_stream_duplex.js": 167, "readable-stream/lib/_stream_passthrough.js": 168, "readable-stream/lib/_stream_readable.js": 169, "readable-stream/lib/_stream_transform.js": 170, "readable-stream/lib/_stream_writable.js": 171, "readable-stream/lib/internal/streams/end-of-stream.js": 175, "readable-stream/lib/internal/streams/pipeline.js": 177 }], 166: [function (require, module, exports) {
    'use strict';

    function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

    var codes = {};

    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }

      function getMessage(arg1, arg2, arg3) {
        if (typeof message === 'string') {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }

      var NodeError =
        /*#__PURE__*/
        function (_Base) {
          _inheritsLoose(NodeError, _Base);

          function NodeError(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }

          return NodeError;
        }(Base);

      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function (i) {
          return String(i);
        });

        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


    function endsWith(str, search, this_len) {
      if (this_len === undefined || this_len > str.length) {
        this_len = str.length;
      }

      return str.substring(this_len - search.length, this_len) === search;
    } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


    function includes(str, search, start) {
      if (typeof start !== 'number') {
        start = 0;
      }

      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }

    createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
      // determiner: 'must be' or 'must not be'
      var determiner;

      if (typeof expected === 'string' && startsWith(expected, 'not ')) {
        determiner = 'must not be';
        expected = expected.replace(/^not /, '');
      } else {
        determiner = 'must be';
      }

      var msg;

      if (endsWith(name, ' argument')) {
        // For cases like 'first argument'
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
      } else {
        var type = includes(name, '.') ? 'property' : 'argument';
        msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
      }

      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
    createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
      return 'The ' + name + ' method is not implemented';
    });
    createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
    createErrorType('ERR_STREAM_DESTROYED', function (name) {
      return 'Cannot call ' + name + ' after a stream was destroyed';
    });
    createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
    createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
    createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
    createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
    createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
      return 'Unknown encoding: ' + arg;
    }, TypeError);
    createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
    module.exports.codes = codes;

  }, {}], 167: [function (require, module, exports) {
    (function (process) {
      (function () {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        // a duplex stream is just a stream that is both readable and writable.
        // Since JS doesn't have multiple prototypal inheritance, this class
        // prototypally inherits from Readable, and then parasitically from
        // Writable.
        'use strict';
        /*<replacement>*/

        var objectKeys = Object.keys || function (obj) {
          var keys = [];

          for (var key in obj) {
            keys.push(key);
          }

          return keys;
        };
        /*</replacement>*/


        module.exports = Duplex;

        var Readable = require('./_stream_readable');

        var Writable = require('./_stream_writable');

        require('inherits')(Duplex, Readable);

        {
          // Allow the keys array to be GC'ed.
          var keys = objectKeys(Writable.prototype);

          for (var v = 0; v < keys.length; v++) {
            var method = keys[v];
            if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
          }
        }

        function Duplex(options) {
          if (!(this instanceof Duplex)) return new Duplex(options);
          Readable.call(this, options);
          Writable.call(this, options);
          this.allowHalfOpen = true;

          if (options) {
            if (options.readable === false) this.readable = false;
            if (options.writable === false) this.writable = false;

            if (options.allowHalfOpen === false) {
              this.allowHalfOpen = false;
              this.once('end', onend);
            }
          }
        }

        Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._writableState.highWaterMark;
          }
        });
        Object.defineProperty(Duplex.prototype, 'writableBuffer', {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._writableState && this._writableState.getBuffer();
          }
        });
        Object.defineProperty(Duplex.prototype, 'writableLength', {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._writableState.length;
          }
        }); // the no-half-open enforcer

        function onend() {
          // If the writable side ended, then we're ok.
          if (this._writableState.ended) return; // no more data can be written.
          // But allow more writes to happen in this tick.

          process.nextTick(onEndNT, this);
        }

        function onEndNT(self) {
          self.end();
        }

        Object.defineProperty(Duplex.prototype, 'destroyed', {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            if (this._readableState === undefined || this._writableState === undefined) {
              return false;
            }

            return this._readableState.destroyed && this._writableState.destroyed;
          },
          set: function set(value) {
            // we ignore the value if the stream
            // has not been initialized yet
            if (this._readableState === undefined || this._writableState === undefined) {
              return;
            } // backward compatibility, the user is explicitly
            // managing destroyed


            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        });
      }).call(this)
    }).call(this, require('_process'))
  }, { "./_stream_readable": 169, "./_stream_writable": 171, "_process": 163, "inherits": 144 }], 168: [function (require, module, exports) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    // a passthrough stream.
    // basically just the most minimal sort of Transform stream.
    // Every written chunk gets output as-is.
    'use strict';

    module.exports = PassThrough;

    var Transform = require('./_stream_transform');

    require('inherits')(PassThrough, Transform);

    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }

    PassThrough.prototype._transform = function (chunk, encoding, cb) {
      cb(null, chunk);
    };
  }, { "./_stream_transform": 170, "inherits": 144 }], 169: [function (require, module, exports) {
    (function (process, global) {
      (function () {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        'use strict';

        module.exports = Readable;
        /*<replacement>*/

        var Duplex;
        /*</replacement>*/

        Readable.ReadableState = ReadableState;
        /*<replacement>*/

        var EE = require('events').EventEmitter;

        var EElistenerCount = function EElistenerCount(emitter, type) {
          return emitter.listeners(type).length;
        };
        /*</replacement>*/

        /*<replacement>*/


        var Stream = require('./internal/streams/stream');
        /*</replacement>*/


        var Buffer = require('buffer').Buffer;

        var OurUint8Array = global.Uint8Array || function () { };

        function _uint8ArrayToBuffer(chunk) {
          return Buffer.from(chunk);
        }

        function _isUint8Array(obj) {
          return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
        }
        /*<replacement>*/


        var debugUtil = require('util');

        var debug;

        if (debugUtil && debugUtil.debuglog) {
          debug = debugUtil.debuglog('stream');
        } else {
          debug = function debug() { };
        }
        /*</replacement>*/


        var BufferList = require('./internal/streams/buffer_list');

        var destroyImpl = require('./internal/streams/destroy');

        var _require = require('./internal/streams/state'),
          getHighWaterMark = _require.getHighWaterMark;

        var _require$codes = require('../errors').codes,
          ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
          ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
          ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
          ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


        var StringDecoder;
        var createReadableStreamAsyncIterator;
        var from;

        require('inherits')(Readable, Stream);

        var errorOrDestroy = destroyImpl.errorOrDestroy;
        var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

        function prependListener(emitter, event, fn) {
          // Sadly this is not cacheable as some libraries bundle their own
          // event emitter implementation with them.
          if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
          // userland ones.  NEVER DO THIS. This is here only because this code needs
          // to continue to work with older versions of Node.js that do not include
          // the prependListener() method. The goal is to eventually remove this hack.

          if (!emitter._events || !emitter._events[event]) emitter.on(event, fn); else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn); else emitter._events[event] = [fn, emitter._events[event]];
        }

        function ReadableState(options, stream, isDuplex) {
          Duplex = Duplex || require('./_stream_duplex');
          options = options || {}; // Duplex streams are both readable and writable, but share
          // the same options object.
          // However, some cases require setting options to different
          // values for the readable and the writable sides of the duplex stream.
          // These options can be provided separately as readableXXX and writableXXX.

          if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
          // make all the buffer merging and length checks go away

          this.objectMode = !!options.objectMode;
          if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
          // Note: 0 is a valid value, means "don't call _read preemptively ever"

          this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
          // linked list can remove elements from the beginning faster than
          // array.shift()

          this.buffer = new BufferList();
          this.length = 0;
          this.pipes = null;
          this.pipesCount = 0;
          this.flowing = null;
          this.ended = false;
          this.endEmitted = false;
          this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
          // immediately, or on a later tick.  We set this to true at first, because
          // any actions that shouldn't happen until "later" should generally also
          // not happen before the first read call.

          this.sync = true; // whenever we return null, then we set a flag to say
          // that we're awaiting a 'readable' event emission.

          this.needReadable = false;
          this.emittedReadable = false;
          this.readableListening = false;
          this.resumeScheduled = false;
          this.paused = true; // Should close be emitted on destroy. Defaults to true.

          this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

          this.autoDestroy = !!options.autoDestroy; // has it been destroyed

          this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
          // encoding is 'binary' so we have to make this configurable.
          // Everything else in the universe uses 'utf8', though.

          this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

          this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

          this.readingMore = false;
          this.decoder = null;
          this.encoding = null;

          if (options.encoding) {
            if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
            this.decoder = new StringDecoder(options.encoding);
            this.encoding = options.encoding;
          }
        }

        function Readable(options) {
          Duplex = Duplex || require('./_stream_duplex');
          if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
          // the ReadableState constructor, at least with V8 6.5

          var isDuplex = this instanceof Duplex;
          this._readableState = new ReadableState(options, this, isDuplex); // legacy

          this.readable = true;

          if (options) {
            if (typeof options.read === 'function') this._read = options.read;
            if (typeof options.destroy === 'function') this._destroy = options.destroy;
          }

          Stream.call(this);
        }

        Object.defineProperty(Readable.prototype, 'destroyed', {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            if (this._readableState === undefined) {
              return false;
            }

            return this._readableState.destroyed;
          },
          set: function set(value) {
            // we ignore the value if the stream
            // has not been initialized yet
            if (!this._readableState) {
              return;
            } // backward compatibility, the user is explicitly
            // managing destroyed


            this._readableState.destroyed = value;
          }
        });
        Readable.prototype.destroy = destroyImpl.destroy;
        Readable.prototype._undestroy = destroyImpl.undestroy;

        Readable.prototype._destroy = function (err, cb) {
          cb(err);
        }; // Manually shove something into the read() buffer.
        // This returns true if the highWaterMark has not been hit yet,
        // similar to how Writable.write() returns true if you should
        // write() some more.


        Readable.prototype.push = function (chunk, encoding) {
          var state = this._readableState;
          var skipChunkCheck;

          if (!state.objectMode) {
            if (typeof chunk === 'string') {
              encoding = encoding || state.defaultEncoding;

              if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = '';
              }

              skipChunkCheck = true;
            }
          } else {
            skipChunkCheck = true;
          }

          return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
        }; // Unshift should *always* be something directly out of read()


        Readable.prototype.unshift = function (chunk) {
          return readableAddChunk(this, chunk, null, true, false);
        };

        function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
          debug('readableAddChunk', chunk);
          var state = stream._readableState;

          if (chunk === null) {
            state.reading = false;
            onEofChunk(stream, state);
          } else {
            var er;
            if (!skipChunkCheck) er = chunkInvalid(state, chunk);

            if (er) {
              errorOrDestroy(stream, er);
            } else if (state.objectMode || chunk && chunk.length > 0) {
              if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                chunk = _uint8ArrayToBuffer(chunk);
              }

              if (addToFront) {
                if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT()); else addChunk(stream, state, chunk, true);
              } else if (state.ended) {
                errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
              } else if (state.destroyed) {
                return false;
              } else {
                state.reading = false;

                if (state.decoder && !encoding) {
                  chunk = state.decoder.write(chunk);
                  if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false); else maybeReadMore(stream, state);
                } else {
                  addChunk(stream, state, chunk, false);
                }
              }
            } else if (!addToFront) {
              state.reading = false;
              maybeReadMore(stream, state);
            }
          } // We can push more data if we are below the highWaterMark.
          // Also, if we have no data yet, we can stand some more bytes.
          // This is to work around cases where hwm=0, such as the repl.


          return !state.ended && (state.length < state.highWaterMark || state.length === 0);
        }

        function addChunk(stream, state, chunk, addToFront) {
          if (state.flowing && state.length === 0 && !state.sync) {
            state.awaitDrain = 0;
            stream.emit('data', chunk);
          } else {
            // update the buffer info.
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront) state.buffer.unshift(chunk); else state.buffer.push(chunk);
            if (state.needReadable) emitReadable(stream);
          }

          maybeReadMore(stream, state);
        }

        function chunkInvalid(state, chunk) {
          var er;

          if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
            er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
          }

          return er;
        }

        Readable.prototype.isPaused = function () {
          return this._readableState.flowing === false;
        }; // backwards compatibility.


        Readable.prototype.setEncoding = function (enc) {
          if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
          var decoder = new StringDecoder(enc);
          this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

          this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

          var p = this._readableState.buffer.head;
          var content = '';

          while (p !== null) {
            content += decoder.write(p.data);
            p = p.next;
          }

          this._readableState.buffer.clear();

          if (content !== '') this._readableState.buffer.push(content);
          this._readableState.length = content.length;
          return this;
        }; // Don't raise the hwm > 1GB


        var MAX_HWM = 0x40000000;

        function computeNewHighWaterMark(n) {
          if (n >= MAX_HWM) {
            // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
            n = MAX_HWM;
          } else {
            // Get the next highest power of 2 to prevent increasing hwm excessively in
            // tiny amounts
            n--;
            n |= n >>> 1;
            n |= n >>> 2;
            n |= n >>> 4;
            n |= n >>> 8;
            n |= n >>> 16;
            n++;
          }

          return n;
        } // This function is designed to be inlinable, so please take care when making
        // changes to the function body.


        function howMuchToRead(n, state) {
          if (n <= 0 || state.length === 0 && state.ended) return 0;
          if (state.objectMode) return 1;

          if (n !== n) {
            // Only flow one buffer at a time
            if (state.flowing && state.length) return state.buffer.head.data.length; else return state.length;
          } // If we're asking for more than the current hwm, then raise the hwm.


          if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
          if (n <= state.length) return n; // Don't have enough

          if (!state.ended) {
            state.needReadable = true;
            return 0;
          }

          return state.length;
        } // you can override either this method, or the async _read(n) below.


        Readable.prototype.read = function (n) {
          debug('read', n);
          n = parseInt(n, 10);
          var state = this._readableState;
          var nOrig = n;
          if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
          // already have a bunch of data in the buffer, then just trigger
          // the 'readable' event and move on.

          if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
            debug('read: emitReadable', state.length, state.ended);
            if (state.length === 0 && state.ended) endReadable(this); else emitReadable(this);
            return null;
          }

          n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

          if (n === 0 && state.ended) {
            if (state.length === 0) endReadable(this);
            return null;
          } // All the actual chunk generation logic needs to be
          // *below* the call to _read.  The reason is that in certain
          // synthetic stream cases, such as passthrough streams, _read
          // may be a completely synchronous operation which may change
          // the state of the read buffer, providing enough data when
          // before there was *not* enough.
          //
          // So, the steps are:
          // 1. Figure out what the state of things will be after we do
          // a read from the buffer.
          //
          // 2. If that resulting state will trigger a _read, then call _read.
          // Note that this may be asynchronous, or synchronous.  Yes, it is
          // deeply ugly to write APIs this way, but that still doesn't mean
          // that the Readable class should behave improperly, as streams are
          // designed to be sync/async agnostic.
          // Take note if the _read call is sync or async (ie, if the read call
          // has returned yet), so that we know whether or not it's safe to emit
          // 'readable' etc.
          //
          // 3. Actually pull the requested chunks out of the buffer and return.
          // if we need a readable event, then we need to do some reading.


          var doRead = state.needReadable;
          debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

          if (state.length === 0 || state.length - n < state.highWaterMark) {
            doRead = true;
            debug('length less than watermark', doRead);
          } // however, if we've ended, then there's no point, and if we're already
          // reading, then it's unnecessary.


          if (state.ended || state.reading) {
            doRead = false;
            debug('reading or ended', doRead);
          } else if (doRead) {
            debug('do read');
            state.reading = true;
            state.sync = true; // if the length is currently zero, then we *need* a readable event.

            if (state.length === 0) state.needReadable = true; // call internal read method

            this._read(state.highWaterMark);

            state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
            // and we need to re-evaluate how much data we can return to the user.

            if (!state.reading) n = howMuchToRead(nOrig, state);
          }

          var ret;
          if (n > 0) ret = fromList(n, state); else ret = null;

          if (ret === null) {
            state.needReadable = state.length <= state.highWaterMark;
            n = 0;
          } else {
            state.length -= n;
            state.awaitDrain = 0;
          }

          if (state.length === 0) {
            // If we have nothing in the buffer, then we want to know
            // as soon as we *do* get something into the buffer.
            if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

            if (nOrig !== n && state.ended) endReadable(this);
          }

          if (ret !== null) this.emit('data', ret);
          return ret;
        };

        function onEofChunk(stream, state) {
          debug('onEofChunk');
          if (state.ended) return;

          if (state.decoder) {
            var chunk = state.decoder.end();

            if (chunk && chunk.length) {
              state.buffer.push(chunk);
              state.length += state.objectMode ? 1 : chunk.length;
            }
          }

          state.ended = true;

          if (state.sync) {
            // if we are sync, wait until next tick to emit the data.
            // Otherwise we risk emitting data in the flow()
            // the readable code triggers during a read() call
            emitReadable(stream);
          } else {
            // emit 'readable' now to make sure it gets picked up.
            state.needReadable = false;

            if (!state.emittedReadable) {
              state.emittedReadable = true;
              emitReadable_(stream);
            }
          }
        } // Don't emit readable right away in sync mode, because this can trigger
        // another read() call => stack overflow.  This way, it might trigger
        // a nextTick recursion warning, but that's not so bad.


        function emitReadable(stream) {
          var state = stream._readableState;
          debug('emitReadable', state.needReadable, state.emittedReadable);
          state.needReadable = false;

          if (!state.emittedReadable) {
            debug('emitReadable', state.flowing);
            state.emittedReadable = true;
            process.nextTick(emitReadable_, stream);
          }
        }

        function emitReadable_(stream) {
          var state = stream._readableState;
          debug('emitReadable_', state.destroyed, state.length, state.ended);

          if (!state.destroyed && (state.length || state.ended)) {
            stream.emit('readable');
            state.emittedReadable = false;
          } // The stream needs another readable event if
          // 1. It is not flowing, as the flow mechanism will take
          //    care of it.
          // 2. It is not ended.
          // 3. It is below the highWaterMark, so we can schedule
          //    another readable later.


          state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
          flow(stream);
        } // at this point, the user has presumably seen the 'readable' event,
        // and called read() to consume some data.  that may have triggered
        // in turn another _read(n) call, in which case reading = true if
        // it's in progress.
        // However, if we're not ended, or reading, and the length < hwm,
        // then go ahead and try to read some more preemptively.


        function maybeReadMore(stream, state) {
          if (!state.readingMore) {
            state.readingMore = true;
            process.nextTick(maybeReadMore_, stream, state);
          }
        }

        function maybeReadMore_(stream, state) {
          // Attempt to read more data if we should.
          //
          // The conditions for reading more data are (one of):
          // - Not enough data buffered (state.length < state.highWaterMark). The loop
          //   is responsible for filling the buffer with enough data if such data
          //   is available. If highWaterMark is 0 and we are not in the flowing mode
          //   we should _not_ attempt to buffer any extra data. We'll get more data
          //   when the stream consumer calls read() instead.
          // - No data in the buffer, and the stream is in flowing mode. In this mode
          //   the loop below is responsible for ensuring read() is called. Failing to
          //   call read here would abort the flow and there's no other mechanism for
          //   continuing the flow if the stream consumer has just subscribed to the
          //   'data' event.
          //
          // In addition to the above conditions to keep reading data, the following
          // conditions prevent the data from being read:
          // - The stream has ended (state.ended).
          // - There is already a pending 'read' operation (state.reading). This is a
          //   case where the the stream has called the implementation defined _read()
          //   method, but they are processing the call asynchronously and have _not_
          //   called push() with new data. In this case we skip performing more
          //   read()s. The execution ends in this method again after the _read() ends
          //   up calling push() with more data.
          while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
            var len = state.length;
            debug('maybeReadMore read 0');
            stream.read(0);
            if (len === state.length) // didn't get any data, stop spinning.
              break;
          }

          state.readingMore = false;
        } // abstract method.  to be overridden in specific implementation classes.
        // call cb(er, data) where data is <= n in length.
        // for virtual (non-string, non-buffer) streams, "length" is somewhat
        // arbitrary, and perhaps not very meaningful.


        Readable.prototype._read = function (n) {
          errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
        };

        Readable.prototype.pipe = function (dest, pipeOpts) {
          var src = this;
          var state = this._readableState;

          switch (state.pipesCount) {
            case 0:
              state.pipes = dest;
              break;

            case 1:
              state.pipes = [state.pipes, dest];
              break;

            default:
              state.pipes.push(dest);
              break;
          }

          state.pipesCount += 1;
          debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
          var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
          var endFn = doEnd ? onend : unpipe;
          if (state.endEmitted) process.nextTick(endFn); else src.once('end', endFn);
          dest.on('unpipe', onunpipe);

          function onunpipe(readable, unpipeInfo) {
            debug('onunpipe');

            if (readable === src) {
              if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
              }
            }
          }

          function onend() {
            debug('onend');
            dest.end();
          } // when the dest drains, it reduces the awaitDrain counter
          // on the source.  This would be more elegant with a .once()
          // handler in flow(), but adding and removing repeatedly is
          // too slow.


          var ondrain = pipeOnDrain(src);
          dest.on('drain', ondrain);
          var cleanedUp = false;

          function cleanup() {
            debug('cleanup'); // cleanup event handlers once the pipe is broken

            dest.removeListener('close', onclose);
            dest.removeListener('finish', onfinish);
            dest.removeListener('drain', ondrain);
            dest.removeListener('error', onerror);
            dest.removeListener('unpipe', onunpipe);
            src.removeListener('end', onend);
            src.removeListener('end', unpipe);
            src.removeListener('data', ondata);
            cleanedUp = true; // if the reader is waiting for a drain event from this
            // specific writer, then it would cause it to never start
            // flowing again.
            // So, if this is awaiting a drain, then we just call it now.
            // If we don't know, then assume that we are waiting for one.

            if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
          }

          src.on('data', ondata);

          function ondata(chunk) {
            debug('ondata');
            var ret = dest.write(chunk);
            debug('dest.write', ret);

            if (ret === false) {
              // If the user unpiped during `dest.write()`, it is possible
              // to get stuck in a permanently paused state if that write
              // also returned false.
              // => Check whether `dest` is still a piping destination.
              if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug('false write response, pause', state.awaitDrain);
                state.awaitDrain++;
              }

              src.pause();
            }
          } // if the dest has an error, then stop piping into it.
          // however, don't suppress the throwing behavior for this.


          function onerror(er) {
            debug('onerror', er);
            unpipe();
            dest.removeListener('error', onerror);
            if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
          } // Make sure our error handler is attached before userland ones.


          prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

          function onclose() {
            dest.removeListener('finish', onfinish);
            unpipe();
          }

          dest.once('close', onclose);

          function onfinish() {
            debug('onfinish');
            dest.removeListener('close', onclose);
            unpipe();
          }

          dest.once('finish', onfinish);

          function unpipe() {
            debug('unpipe');
            src.unpipe(dest);
          } // tell the dest that it's being piped to


          dest.emit('pipe', src); // start the flow if it hasn't been started already.

          if (!state.flowing) {
            debug('pipe resume');
            src.resume();
          }

          return dest;
        };

        function pipeOnDrain(src) {
          return function pipeOnDrainFunctionResult() {
            var state = src._readableState;
            debug('pipeOnDrain', state.awaitDrain);
            if (state.awaitDrain) state.awaitDrain--;

            if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
              state.flowing = true;
              flow(src);
            }
          };
        }

        Readable.prototype.unpipe = function (dest) {
          var state = this._readableState;
          var unpipeInfo = {
            hasUnpiped: false
          }; // if we're not piping anywhere, then do nothing.

          if (state.pipesCount === 0) return this; // just one destination.  most common case.

          if (state.pipesCount === 1) {
            // passed in one, but it's not the right one.
            if (dest && dest !== state.pipes) return this;
            if (!dest) dest = state.pipes; // got a match.

            state.pipes = null;
            state.pipesCount = 0;
            state.flowing = false;
            if (dest) dest.emit('unpipe', this, unpipeInfo);
            return this;
          } // slow case. multiple pipe destinations.


          if (!dest) {
            // remove all.
            var dests = state.pipes;
            var len = state.pipesCount;
            state.pipes = null;
            state.pipesCount = 0;
            state.flowing = false;

            for (var i = 0; i < len; i++) {
              dests[i].emit('unpipe', this, {
                hasUnpiped: false
              });
            }

            return this;
          } // try to find the right one.


          var index = indexOf(state.pipes, dest);
          if (index === -1) return this;
          state.pipes.splice(index, 1);
          state.pipesCount -= 1;
          if (state.pipesCount === 1) state.pipes = state.pipes[0];
          dest.emit('unpipe', this, unpipeInfo);
          return this;
        }; // set up data events if they are asked for
        // Ensure readable listeners eventually get something


        Readable.prototype.on = function (ev, fn) {
          var res = Stream.prototype.on.call(this, ev, fn);
          var state = this._readableState;

          if (ev === 'data') {
            // update readableListening so that resume() may be a no-op
            // a few lines down. This is needed to support once('readable').
            state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

            if (state.flowing !== false) this.resume();
          } else if (ev === 'readable') {
            if (!state.endEmitted && !state.readableListening) {
              state.readableListening = state.needReadable = true;
              state.flowing = false;
              state.emittedReadable = false;
              debug('on readable', state.length, state.reading);

              if (state.length) {
                emitReadable(this);
              } else if (!state.reading) {
                process.nextTick(nReadingNextTick, this);
              }
            }
          }

          return res;
        };

        Readable.prototype.addListener = Readable.prototype.on;

        Readable.prototype.removeListener = function (ev, fn) {
          var res = Stream.prototype.removeListener.call(this, ev, fn);

          if (ev === 'readable') {
            // We need to check if there is someone still listening to
            // readable and reset the state. However this needs to happen
            // after readable has been emitted but before I/O (nextTick) to
            // support once('readable', fn) cycles. This means that calling
            // resume within the same tick will have no
            // effect.
            process.nextTick(updateReadableListening, this);
          }

          return res;
        };

        Readable.prototype.removeAllListeners = function (ev) {
          var res = Stream.prototype.removeAllListeners.apply(this, arguments);

          if (ev === 'readable' || ev === undefined) {
            // We need to check if there is someone still listening to
            // readable and reset the state. However this needs to happen
            // after readable has been emitted but before I/O (nextTick) to
            // support once('readable', fn) cycles. This means that calling
            // resume within the same tick will have no
            // effect.
            process.nextTick(updateReadableListening, this);
          }

          return res;
        };

        function updateReadableListening(self) {
          var state = self._readableState;
          state.readableListening = self.listenerCount('readable') > 0;

          if (state.resumeScheduled && !state.paused) {
            // flowing needs to be set to true now, otherwise
            // the upcoming resume will not flow.
            state.flowing = true; // crude way to check if we should resume
          } else if (self.listenerCount('data') > 0) {
            self.resume();
          }
        }

        function nReadingNextTick(self) {
          debug('readable nexttick read 0');
          self.read(0);
        } // pause() and resume() are remnants of the legacy readable stream API
        // If the user uses them, then switch into old mode.


        Readable.prototype.resume = function () {
          var state = this._readableState;

          if (!state.flowing) {
            debug('resume'); // we flow only if there is no one listening
            // for readable, but we still have to call
            // resume()

            state.flowing = !state.readableListening;
            resume(this, state);
          }

          state.paused = false;
          return this;
        };

        function resume(stream, state) {
          if (!state.resumeScheduled) {
            state.resumeScheduled = true;
            process.nextTick(resume_, stream, state);
          }
        }

        function resume_(stream, state) {
          debug('resume', state.reading);

          if (!state.reading) {
            stream.read(0);
          }

          state.resumeScheduled = false;
          stream.emit('resume');
          flow(stream);
          if (state.flowing && !state.reading) stream.read(0);
        }

        Readable.prototype.pause = function () {
          debug('call pause flowing=%j', this._readableState.flowing);

          if (this._readableState.flowing !== false) {
            debug('pause');
            this._readableState.flowing = false;
            this.emit('pause');
          }

          this._readableState.paused = true;
          return this;
        };

        function flow(stream) {
          var state = stream._readableState;
          debug('flow', state.flowing);

          while (state.flowing && stream.read() !== null) {
            ;
          }
        } // wrap an old-style stream as the async data source.
        // This is *not* part of the readable stream interface.
        // It is an ugly unfortunate mess of history.


        Readable.prototype.wrap = function (stream) {
          var _this = this;

          var state = this._readableState;
          var paused = false;
          stream.on('end', function () {
            debug('wrapped end');

            if (state.decoder && !state.ended) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length) _this.push(chunk);
            }

            _this.push(null);
          });
          stream.on('data', function (chunk) {
            debug('wrapped data');
            if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

            if (state.objectMode && (chunk === null || chunk === undefined)) return; else if (!state.objectMode && (!chunk || !chunk.length)) return;

            var ret = _this.push(chunk);

            if (!ret) {
              paused = true;
              stream.pause();
            }
          }); // proxy all the other methods.
          // important when wrapping filters and duplexes.

          for (var i in stream) {
            if (this[i] === undefined && typeof stream[i] === 'function') {
              this[i] = function methodWrap(method) {
                return function methodWrapReturnFunction() {
                  return stream[method].apply(stream, arguments);
                };
              }(i);
            }
          } // proxy certain important events.


          for (var n = 0; n < kProxyEvents.length; n++) {
            stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
          } // when we try to consume some more bytes, simply unpause the
          // underlying stream.


          this._read = function (n) {
            debug('wrapped _read', n);

            if (paused) {
              paused = false;
              stream.resume();
            }
          };

          return this;
        };

        if (typeof Symbol === 'function') {
          Readable.prototype[Symbol.asyncIterator] = function () {
            if (createReadableStreamAsyncIterator === undefined) {
              createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
            }

            return createReadableStreamAsyncIterator(this);
          };
        }

        Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._readableState.highWaterMark;
          }
        });
        Object.defineProperty(Readable.prototype, 'readableBuffer', {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._readableState && this._readableState.buffer;
          }
        });
        Object.defineProperty(Readable.prototype, 'readableFlowing', {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._readableState.flowing;
          },
          set: function set(state) {
            if (this._readableState) {
              this._readableState.flowing = state;
            }
          }
        }); // exposed for testing purposes only.

        Readable._fromList = fromList;
        Object.defineProperty(Readable.prototype, 'readableLength', {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._readableState.length;
          }
        }); // Pluck off n bytes from an array of buffers.
        // Length is the combined lengths of all the buffers in the list.
        // This function is designed to be inlinable, so please take care when making
        // changes to the function body.

        function fromList(n, state) {
          // nothing buffered
          if (state.length === 0) return null;
          var ret;
          if (state.objectMode) ret = state.buffer.shift(); else if (!n || n >= state.length) {
            // read it all, truncate the list
            if (state.decoder) ret = state.buffer.join(''); else if (state.buffer.length === 1) ret = state.buffer.first(); else ret = state.buffer.concat(state.length);
            state.buffer.clear();
          } else {
            // read part of list
            ret = state.buffer.consume(n, state.decoder);
          }
          return ret;
        }

        function endReadable(stream) {
          var state = stream._readableState;
          debug('endReadable', state.endEmitted);

          if (!state.endEmitted) {
            state.ended = true;
            process.nextTick(endReadableNT, state, stream);
          }
        }

        function endReadableNT(state, stream) {
          debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit('end');

            if (state.autoDestroy) {
              // In case of duplex streams we need a way to detect
              // if the writable side is ready for autoDestroy as well
              var wState = stream._writableState;

              if (!wState || wState.autoDestroy && wState.finished) {
                stream.destroy();
              }
            }
          }
        }

        if (typeof Symbol === 'function') {
          Readable.from = function (iterable, opts) {
            if (from === undefined) {
              from = require('./internal/streams/from');
            }

            return from(Readable, iterable, opts);
          };
        }

        function indexOf(xs, x) {
          for (var i = 0, l = xs.length; i < l; i++) {
            if (xs[i] === x) return i;
          }

          return -1;
        }
      }).call(this)
    }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  }, { "../errors": 166, "./_stream_duplex": 167, "./internal/streams/async_iterator": 172, "./internal/streams/buffer_list": 173, "./internal/streams/destroy": 174, "./internal/streams/from": 176, "./internal/streams/state": 178, "./internal/streams/stream": 179, "_process": 163, "buffer": 126, "events": 134, "inherits": 144, "string_decoder/": 180, "util": 123 }], 170: [function (require, module, exports) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    // a transform stream is a readable/writable stream where you do
    // something with the data.  Sometimes it's called a "filter",
    // but that's not a great name for it, since that implies a thing where
    // some bits pass through, and others are simply ignored.  (That would
    // be a valid example of a transform, of course.)
    //
    // While the output is causally related to the input, it's not a
    // necessarily symmetric or synchronous transformation.  For example,
    // a zlib stream might take multiple plain-text writes(), and then
    // emit a single compressed chunk some time in the future.
    //
    // Here's how this works:
    //
    // The Transform stream has all the aspects of the readable and writable
    // stream classes.  When you write(chunk), that calls _write(chunk,cb)
    // internally, and returns false if there's a lot of pending writes
    // buffered up.  When you call read(), that calls _read(n) until
    // there's enough pending readable data buffered up.
    //
    // In a transform stream, the written data is placed in a buffer.  When
    // _read(n) is called, it transforms the queued up data, calling the
    // buffered _write cb's as it consumes chunks.  If consuming a single
    // written chunk would result in multiple output chunks, then the first
    // outputted bit calls the readcb, and subsequent chunks just go into
    // the read buffer, and will cause it to emit 'readable' if necessary.
    //
    // This way, back-pressure is actually determined by the reading side,
    // since _read has to be called to start processing a new chunk.  However,
    // a pathological inflate type of transform can cause excessive buffering
    // here.  For example, imagine a stream where every byte of input is
    // interpreted as an integer from 0-255, and then results in that many
    // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
    // 1kb of data being output.  In this case, you could write a very small
    // amount of input, and end up with a very large amount of output.  In
    // such a pathological inflating mechanism, there'd be no way to tell
    // the system to stop doing the transform.  A single 4MB write could
    // cause the system to run out of memory.
    //
    // However, even in such a pathological case, only a single written chunk
    // would be consumed, and then the rest would wait (un-transformed) until
    // the results of the previous transformed chunk were consumed.
    'use strict';

    module.exports = Transform;

    var _require$codes = require('../errors').codes,
      ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
      ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
      ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

    var Duplex = require('./_stream_duplex');

    require('inherits')(Transform, Duplex);

    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;

      if (cb === null) {
        return this.emit('error', new ERR_MULTIPLE_CALLBACK());
      }

      ts.writechunk = null;
      ts.writecb = null;
      if (data != null) // single equals check for both `null` and `undefined`
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;

      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }

    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      }; // start out asking for a readable event once data is transformed.

      this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
      // that Readable wants before the first _read call, so unset the
      // sync guard flag.

      this._readableState.sync = false;

      if (options) {
        if (typeof options.transform === 'function') this._transform = options.transform;
        if (typeof options.flush === 'function') this._flush = options.flush;
      } // When the writable side finishes, then flush out anything remaining.


      this.on('prefinish', prefinish);
    }

    function prefinish() {
      var _this = this;

      if (typeof this._flush === 'function' && !this._readableState.destroyed) {
        this._flush(function (er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }

    Transform.prototype.push = function (chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    }; // This is the part where you do stuff!
    // override this function in implementation classes.
    // 'chunk' is an input chunk.
    //
    // Call `push(newChunk)` to pass along transformed output
    // to the readable side.  You may call 'push' zero or more times.
    //
    // Call `cb(err)` when you are done with this chunk.  If you pass
    // an error, then that'll put the hurt on the whole operation.  If you
    // never call cb(), then you'll never get another chunk.


    Transform.prototype._transform = function (chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
    };

    Transform.prototype._write = function (chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;

      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    }; // Doesn't matter what the args are here.
    // _transform does all the work.
    // That we got here means that the readable side wants more data.


    Transform.prototype._read = function (n) {
      var ts = this._transformState;

      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;

        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
      }
    };

    Transform.prototype._destroy = function (err, cb) {
      Duplex.prototype._destroy.call(this, err, function (err2) {
        cb(err2);
      });
    };

    function done(stream, er, data) {
      if (er) return stream.emit('error', er);
      if (data != null) // single equals check for both `null` and `undefined`
        stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
      // if there's nothing in the write buffer, then that means
      // that nothing more will ever be provided

      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }, { "../errors": 166, "./_stream_duplex": 167, "inherits": 144 }], 171: [function (require, module, exports) {
    (function (process, global) {
      (function () {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.
        // A bit simpler than readable streams.
        // Implement an async ._write(chunk, encoding, cb), and it'll handle all
        // the drain event emission and buffering.
        'use strict';

        module.exports = Writable;
        /* <replacement> */

        function WriteReq(chunk, encoding, cb) {
          this.chunk = chunk;
          this.encoding = encoding;
          this.callback = cb;
          this.next = null;
        } // It seems a linked list but it is not
        // there will be only 2 of these for each stream


        function CorkedRequest(state) {
          var _this = this;

          this.next = null;
          this.entry = null;

          this.finish = function () {
            onCorkedFinish(_this, state);
          };
        }
        /* </replacement> */

        /*<replacement>*/


        var Duplex;
        /*</replacement>*/

        Writable.WritableState = WritableState;
        /*<replacement>*/

        var internalUtil = {
          deprecate: require('util-deprecate')
        };
        /*</replacement>*/

        /*<replacement>*/

        var Stream = require('./internal/streams/stream');
        /*</replacement>*/


        var Buffer = require('buffer').Buffer;

        var OurUint8Array = global.Uint8Array || function () { };

        function _uint8ArrayToBuffer(chunk) {
          return Buffer.from(chunk);
        }

        function _isUint8Array(obj) {
          return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
        }

        var destroyImpl = require('./internal/streams/destroy');

        var _require = require('./internal/streams/state'),
          getHighWaterMark = _require.getHighWaterMark;

        var _require$codes = require('../errors').codes,
          ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
          ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
          ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
          ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
          ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
          ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
          ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
          ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

        var errorOrDestroy = destroyImpl.errorOrDestroy;

        require('inherits')(Writable, Stream);

        function nop() { }

        function WritableState(options, stream, isDuplex) {
          Duplex = Duplex || require('./_stream_duplex');
          options = options || {}; // Duplex streams are both readable and writable, but share
          // the same options object.
          // However, some cases require setting options to different
          // values for the readable and the writable sides of the duplex stream,
          // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

          if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
          // contains buffers or objects.

          this.objectMode = !!options.objectMode;
          if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
          // Note: 0 is a valid value, means that we always return false if
          // the entire buffer is not flushed immediately on write()

          this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

          this.finalCalled = false; // drain event flag.

          this.needDrain = false; // at the start of calling end()

          this.ending = false; // when end() has been called, and returned

          this.ended = false; // when 'finish' is emitted

          this.finished = false; // has it been destroyed

          this.destroyed = false; // should we decode strings into buffers before passing to _write?
          // this is here so that some node-core streams can optimize string
          // handling at a lower level.

          var noDecode = options.decodeStrings === false;
          this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
          // encoding is 'binary' so we have to make this configurable.
          // Everything else in the universe uses 'utf8', though.

          this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
          // of how much we're waiting to get pushed to some underlying
          // socket or file.

          this.length = 0; // a flag to see when we're in the middle of a write.

          this.writing = false; // when true all writes will be buffered until .uncork() call

          this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
          // or on a later tick.  We set this to true at first, because any
          // actions that shouldn't happen until "later" should generally also
          // not happen before the first write call.

          this.sync = true; // a flag to know if we're processing previously buffered items, which
          // may call the _write() callback in the same tick, so that we don't
          // end up in an overlapped onwrite situation.

          this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

          this.onwrite = function (er) {
            onwrite(stream, er);
          }; // the callback that the user supplies to write(chunk,encoding,cb)


          this.writecb = null; // the amount that is being written when _write is called.

          this.writelen = 0;
          this.bufferedRequest = null;
          this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
          // this must be 0 before 'finish' can be emitted

          this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
          // This is relevant for synchronous Transform streams

          this.prefinished = false; // True if the error was already emitted and should not be thrown again

          this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

          this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

          this.autoDestroy = !!options.autoDestroy; // count buffered requests

          this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
          // one allocated and free to use, and we maintain at most two

          this.corkedRequestsFree = new CorkedRequest(this);
        }

        WritableState.prototype.getBuffer = function getBuffer() {
          var current = this.bufferedRequest;
          var out = [];

          while (current) {
            out.push(current);
            current = current.next;
          }

          return out;
        };

        (function () {
          try {
            Object.defineProperty(WritableState.prototype, 'buffer', {
              get: internalUtil.deprecate(function writableStateBufferGetter() {
                return this.getBuffer();
              }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
            });
          } catch (_) { }
        })(); // Test _writableState for inheritance to account for Duplex streams,
        // whose prototype chain only points to Readable.


        var realHasInstance;

        if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
          realHasInstance = Function.prototype[Symbol.hasInstance];
          Object.defineProperty(Writable, Symbol.hasInstance, {
            value: function value(object) {
              if (realHasInstance.call(this, object)) return true;
              if (this !== Writable) return false;
              return object && object._writableState instanceof WritableState;
            }
          });
        } else {
          realHasInstance = function realHasInstance(object) {
            return object instanceof this;
          };
        }

        function Writable(options) {
          Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
          // `realHasInstance` is necessary because using plain `instanceof`
          // would return false, as no `_writableState` property is attached.
          // Trying to use the custom `instanceof` for Writable here will also break the
          // Node.js LazyTransform implementation, which has a non-trivial getter for
          // `_writableState` that would lead to infinite recursion.
          // Checking for a Stream.Duplex instance is faster here instead of inside
          // the WritableState constructor, at least with V8 6.5

          var isDuplex = this instanceof Duplex;
          if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
          this._writableState = new WritableState(options, this, isDuplex); // legacy.

          this.writable = true;

          if (options) {
            if (typeof options.write === 'function') this._write = options.write;
            if (typeof options.writev === 'function') this._writev = options.writev;
            if (typeof options.destroy === 'function') this._destroy = options.destroy;
            if (typeof options.final === 'function') this._final = options.final;
          }

          Stream.call(this);
        } // Otherwise people can pipe Writable streams, which is just wrong.


        Writable.prototype.pipe = function () {
          errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
        };

        function writeAfterEnd(stream, cb) {
          var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

          errorOrDestroy(stream, er);
          process.nextTick(cb, er);
        } // Checks that a user-supplied chunk is valid, especially for the particular
        // mode the stream is in. Currently this means that `null` is never accepted
        // and undefined/non-string values are only allowed in object mode.


        function validChunk(stream, state, chunk, cb) {
          var er;

          if (chunk === null) {
            er = new ERR_STREAM_NULL_VALUES();
          } else if (typeof chunk !== 'string' && !state.objectMode) {
            er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
          }

          if (er) {
            errorOrDestroy(stream, er);
            process.nextTick(cb, er);
            return false;
          }

          return true;
        }

        Writable.prototype.write = function (chunk, encoding, cb) {
          var state = this._writableState;
          var ret = false;

          var isBuf = !state.objectMode && _isUint8Array(chunk);

          if (isBuf && !Buffer.isBuffer(chunk)) {
            chunk = _uint8ArrayToBuffer(chunk);
          }

          if (typeof encoding === 'function') {
            cb = encoding;
            encoding = null;
          }

          if (isBuf) encoding = 'buffer'; else if (!encoding) encoding = state.defaultEncoding;
          if (typeof cb !== 'function') cb = nop;
          if (state.ending) writeAfterEnd(this, cb); else if (isBuf || validChunk(this, state, chunk, cb)) {
            state.pendingcb++;
            ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
          }
          return ret;
        };

        Writable.prototype.cork = function () {
          this._writableState.corked++;
        };

        Writable.prototype.uncork = function () {
          var state = this._writableState;

          if (state.corked) {
            state.corked--;
            if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
          }
        };

        Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
          // node::ParseEncoding() requires lower case.
          if (typeof encoding === 'string') encoding = encoding.toLowerCase();
          if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
          this._writableState.defaultEncoding = encoding;
          return this;
        };

        Object.defineProperty(Writable.prototype, 'writableBuffer', {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._writableState && this._writableState.getBuffer();
          }
        });

        function decodeChunk(state, chunk, encoding) {
          if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
            chunk = Buffer.from(chunk, encoding);
          }

          return chunk;
        }

        Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._writableState.highWaterMark;
          }
        }); // if we're already writing something, then just put this
        // in the queue, and wait our turn.  Otherwise, call _write
        // If we return false, then we need a drain event, so set that flag.

        function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
          if (!isBuf) {
            var newChunk = decodeChunk(state, chunk, encoding);

            if (chunk !== newChunk) {
              isBuf = true;
              encoding = 'buffer';
              chunk = newChunk;
            }
          }

          var len = state.objectMode ? 1 : chunk.length;
          state.length += len;
          var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

          if (!ret) state.needDrain = true;

          if (state.writing || state.corked) {
            var last = state.lastBufferedRequest;
            state.lastBufferedRequest = {
              chunk: chunk,
              encoding: encoding,
              isBuf: isBuf,
              callback: cb,
              next: null
            };

            if (last) {
              last.next = state.lastBufferedRequest;
            } else {
              state.bufferedRequest = state.lastBufferedRequest;
            }

            state.bufferedRequestCount += 1;
          } else {
            doWrite(stream, state, false, len, chunk, encoding, cb);
          }

          return ret;
        }

        function doWrite(stream, state, writev, len, chunk, encoding, cb) {
          state.writelen = len;
          state.writecb = cb;
          state.writing = true;
          state.sync = true;
          if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write')); else if (writev) stream._writev(chunk, state.onwrite); else stream._write(chunk, encoding, state.onwrite);
          state.sync = false;
        }

        function onwriteError(stream, state, sync, er, cb) {
          --state.pendingcb;

          if (sync) {
            // defer the callback if we are being called synchronously
            // to avoid piling up things on the stack
            process.nextTick(cb, er); // this can emit finish, and it will always happen
            // after error

            process.nextTick(finishMaybe, stream, state);
            stream._writableState.errorEmitted = true;
            errorOrDestroy(stream, er);
          } else {
            // the caller expect this to happen before if
            // it is async
            cb(er);
            stream._writableState.errorEmitted = true;
            errorOrDestroy(stream, er); // this can emit finish, but finish must
            // always follow error

            finishMaybe(stream, state);
          }
        }

        function onwriteStateUpdate(state) {
          state.writing = false;
          state.writecb = null;
          state.length -= state.writelen;
          state.writelen = 0;
        }

        function onwrite(stream, er) {
          var state = stream._writableState;
          var sync = state.sync;
          var cb = state.writecb;
          if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
          onwriteStateUpdate(state);
          if (er) onwriteError(stream, state, sync, er, cb); else {
            // Check if we're actually ready to finish, but don't emit yet
            var finished = needFinish(state) || stream.destroyed;

            if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
              clearBuffer(stream, state);
            }

            if (sync) {
              process.nextTick(afterWrite, stream, state, finished, cb);
            } else {
              afterWrite(stream, state, finished, cb);
            }
          }
        }

        function afterWrite(stream, state, finished, cb) {
          if (!finished) onwriteDrain(stream, state);
          state.pendingcb--;
          cb();
          finishMaybe(stream, state);
        } // Must force callback to be called on nextTick, so that we don't
        // emit 'drain' before the write() consumer gets the 'false' return
        // value, and has a chance to attach a 'drain' listener.


        function onwriteDrain(stream, state) {
          if (state.length === 0 && state.needDrain) {
            state.needDrain = false;
            stream.emit('drain');
          }
        } // if there's something in the buffer waiting, then process it


        function clearBuffer(stream, state) {
          state.bufferProcessing = true;
          var entry = state.bufferedRequest;

          if (stream._writev && entry && entry.next) {
            // Fast case, write everything using _writev()
            var l = state.bufferedRequestCount;
            var buffer = new Array(l);
            var holder = state.corkedRequestsFree;
            holder.entry = entry;
            var count = 0;
            var allBuffers = true;

            while (entry) {
              buffer[count] = entry;
              if (!entry.isBuf) allBuffers = false;
              entry = entry.next;
              count += 1;
            }

            buffer.allBuffers = allBuffers;
            doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
            // as the hot path ends with doWrite

            state.pendingcb++;
            state.lastBufferedRequest = null;

            if (holder.next) {
              state.corkedRequestsFree = holder.next;
              holder.next = null;
            } else {
              state.corkedRequestsFree = new CorkedRequest(state);
            }

            state.bufferedRequestCount = 0;
          } else {
            // Slow case, write chunks one-by-one
            while (entry) {
              var chunk = entry.chunk;
              var encoding = entry.encoding;
              var cb = entry.callback;
              var len = state.objectMode ? 1 : chunk.length;
              doWrite(stream, state, false, len, chunk, encoding, cb);
              entry = entry.next;
              state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
              // it means that we need to wait until it does.
              // also, that means that the chunk and cb are currently
              // being processed, so move the buffer counter past them.

              if (state.writing) {
                break;
              }
            }

            if (entry === null) state.lastBufferedRequest = null;
          }

          state.bufferedRequest = entry;
          state.bufferProcessing = false;
        }

        Writable.prototype._write = function (chunk, encoding, cb) {
          cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
        };

        Writable.prototype._writev = null;

        Writable.prototype.end = function (chunk, encoding, cb) {
          var state = this._writableState;

          if (typeof chunk === 'function') {
            cb = chunk;
            chunk = null;
            encoding = null;
          } else if (typeof encoding === 'function') {
            cb = encoding;
            encoding = null;
          }

          if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

          if (state.corked) {
            state.corked = 1;
            this.uncork();
          } // ignore unnecessary end() calls.


          if (!state.ending) endWritable(this, state, cb);
          return this;
        };

        Object.defineProperty(Writable.prototype, 'writableLength', {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._writableState.length;
          }
        });

        function needFinish(state) {
          return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
        }

        function callFinal(stream, state) {
          stream._final(function (err) {
            state.pendingcb--;

            if (err) {
              errorOrDestroy(stream, err);
            }

            state.prefinished = true;
            stream.emit('prefinish');
            finishMaybe(stream, state);
          });
        }

        function prefinish(stream, state) {
          if (!state.prefinished && !state.finalCalled) {
            if (typeof stream._final === 'function' && !state.destroyed) {
              state.pendingcb++;
              state.finalCalled = true;
              process.nextTick(callFinal, stream, state);
            } else {
              state.prefinished = true;
              stream.emit('prefinish');
            }
          }
        }

        function finishMaybe(stream, state) {
          var need = needFinish(state);

          if (need) {
            prefinish(stream, state);

            if (state.pendingcb === 0) {
              state.finished = true;
              stream.emit('finish');

              if (state.autoDestroy) {
                // In case of duplex streams we need a way to detect
                // if the readable side is ready for autoDestroy as well
                var rState = stream._readableState;

                if (!rState || rState.autoDestroy && rState.endEmitted) {
                  stream.destroy();
                }
              }
            }
          }

          return need;
        }

        function endWritable(stream, state, cb) {
          state.ending = true;
          finishMaybe(stream, state);

          if (cb) {
            if (state.finished) process.nextTick(cb); else stream.once('finish', cb);
          }

          state.ended = true;
          stream.writable = false;
        }

        function onCorkedFinish(corkReq, state, err) {
          var entry = corkReq.entry;
          corkReq.entry = null;

          while (entry) {
            var cb = entry.callback;
            state.pendingcb--;
            cb(err);
            entry = entry.next;
          } // reuse the free corkReq.


          state.corkedRequestsFree.next = corkReq;
        }

        Object.defineProperty(Writable.prototype, 'destroyed', {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            if (this._writableState === undefined) {
              return false;
            }

            return this._writableState.destroyed;
          },
          set: function set(value) {
            // we ignore the value if the stream
            // has not been initialized yet
            if (!this._writableState) {
              return;
            } // backward compatibility, the user is explicitly
            // managing destroyed


            this._writableState.destroyed = value;
          }
        });
        Writable.prototype.destroy = destroyImpl.destroy;
        Writable.prototype._undestroy = destroyImpl.undestroy;

        Writable.prototype._destroy = function (err, cb) {
          cb(err);
        };
      }).call(this)
    }).call(this, require('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  }, { "../errors": 166, "./_stream_duplex": 167, "./internal/streams/destroy": 174, "./internal/streams/state": 178, "./internal/streams/stream": 179, "_process": 163, "buffer": 126, "inherits": 144, "util-deprecate": 182 }], 172: [function (require, module, exports) {
    (function (process) {
      (function () {
        'use strict';

        var _Object$setPrototypeO;

        function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

        var finished = require('./end-of-stream');

        var kLastResolve = Symbol('lastResolve');
        var kLastReject = Symbol('lastReject');
        var kError = Symbol('error');
        var kEnded = Symbol('ended');
        var kLastPromise = Symbol('lastPromise');
        var kHandlePromise = Symbol('handlePromise');
        var kStream = Symbol('stream');

        function createIterResult(value, done) {
          return {
            value: value,
            done: done
          };
        }

        function readAndResolve(iter) {
          var resolve = iter[kLastResolve];

          if (resolve !== null) {
            var data = iter[kStream].read(); // we defer if data is null
            // we can be expecting either 'end' or
            // 'error'

            if (data !== null) {
              iter[kLastPromise] = null;
              iter[kLastResolve] = null;
              iter[kLastReject] = null;
              resolve(createIterResult(data, false));
            }
          }
        }

        function onReadable(iter) {
          // we wait for the next tick, because it might
          // emit an error with process.nextTick
          process.nextTick(readAndResolve, iter);
        }

        function wrapForNext(lastPromise, iter) {
          return function (resolve, reject) {
            lastPromise.then(function () {
              if (iter[kEnded]) {
                resolve(createIterResult(undefined, true));
                return;
              }

              iter[kHandlePromise](resolve, reject);
            }, reject);
          };
        }

        var AsyncIteratorPrototype = Object.getPrototypeOf(function () { });
        var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
          get stream() {
            return this[kStream];
          },

          next: function next() {
            var _this = this;

            // if we have detected an error in the meanwhile
            // reject straight away
            var error = this[kError];

            if (error !== null) {
              return Promise.reject(error);
            }

            if (this[kEnded]) {
              return Promise.resolve(createIterResult(undefined, true));
            }

            if (this[kStream].destroyed) {
              // We need to defer via nextTick because if .destroy(err) is
              // called, the error will be emitted via nextTick, and
              // we cannot guarantee that there is no error lingering around
              // waiting to be emitted.
              return new Promise(function (resolve, reject) {
                process.nextTick(function () {
                  if (_this[kError]) {
                    reject(_this[kError]);
                  } else {
                    resolve(createIterResult(undefined, true));
                  }
                });
              });
            } // if we have multiple next() calls
            // we will wait for the previous Promise to finish
            // this logic is optimized to support for await loops,
            // where next() is only called once at a time


            var lastPromise = this[kLastPromise];
            var promise;

            if (lastPromise) {
              promise = new Promise(wrapForNext(lastPromise, this));
            } else {
              // fast path needed to support multiple this.push()
              // without triggering the next() queue
              var data = this[kStream].read();

              if (data !== null) {
                return Promise.resolve(createIterResult(data, false));
              }

              promise = new Promise(this[kHandlePromise]);
            }

            this[kLastPromise] = promise;
            return promise;
          }
        }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
          return this;
        }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
          var _this2 = this;

          // destroy(err, cb) is a private API
          // we can guarantee we have that here, because we control the
          // Readable class this is attached to
          return new Promise(function (resolve, reject) {
            _this2[kStream].destroy(null, function (err) {
              if (err) {
                reject(err);
                return;
              }

              resolve(createIterResult(undefined, true));
            });
          });
        }), _Object$setPrototypeO), AsyncIteratorPrototype);

        var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
          var _Object$create;

          var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
            value: stream,
            writable: true
          }), _defineProperty(_Object$create, kLastResolve, {
            value: null,
            writable: true
          }), _defineProperty(_Object$create, kLastReject, {
            value: null,
            writable: true
          }), _defineProperty(_Object$create, kError, {
            value: null,
            writable: true
          }), _defineProperty(_Object$create, kEnded, {
            value: stream._readableState.endEmitted,
            writable: true
          }), _defineProperty(_Object$create, kHandlePromise, {
            value: function value(resolve, reject) {
              var data = iterator[kStream].read();

              if (data) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(data, false));
              } else {
                iterator[kLastResolve] = resolve;
                iterator[kLastReject] = reject;
              }
            },
            writable: true
          }), _Object$create));
          iterator[kLastPromise] = null;
          finished(stream, function (err) {
            if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
              var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
              // returned by next() and store the error

              if (reject !== null) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                reject(err);
              }

              iterator[kError] = err;
              return;
            }

            var resolve = iterator[kLastResolve];

            if (resolve !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve(createIterResult(undefined, true));
            }

            iterator[kEnded] = true;
          });
          stream.on('readable', onReadable.bind(null, iterator));
          return iterator;
        };

        module.exports = createReadableStreamAsyncIterator;
      }).call(this)
    }).call(this, require('_process'))
  }, { "./end-of-stream": 175, "_process": 163 }], 173: [function (require, module, exports) {
    'use strict';

    function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    var _require = require('buffer'),
      Buffer = _require.Buffer;

    var _require2 = require('util'),
      inspect = _require2.inspect;

    var custom = inspect && inspect.custom || 'inspect';

    function copyBuffer(src, target, offset) {
      Buffer.prototype.copy.call(src, target, offset);
    }

    module.exports =
      /*#__PURE__*/
      function () {
        function BufferList() {
          _classCallCheck(this, BufferList);

          this.head = null;
          this.tail = null;
          this.length = 0;
        }

        _createClass(BufferList, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0) this.tail.next = entry; else this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0) this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0) return;
            var ret = this.head.data;
            if (this.length === 1) this.head = this.tail = null; else this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join(s) {
            if (this.length === 0) return '';
            var p = this.head;
            var ret = '' + p.data;

            while (p = p.next) {
              ret += s + p.data;
            }

            return ret;
          }
        }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0) return Buffer.alloc(0);
            var ret = Buffer.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;

            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }

            return ret;
          } // Consumes a specified amount of bytes or characters from the buffered data.

        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;

            if (n < this.head.data.length) {
              // `slice` is the same for buffers and strings.
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              // First chunk is a perfect match.
              ret = this.shift();
            } else {
              // Result spans more than one buffer.
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }

            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          } // Consumes a specified amount of characters from the buffered data.

        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;

            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length) ret += str; else ret += str.slice(0, n);
              n -= nb;

              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next) this.head = p.next; else this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }

                break;
              }

              ++c;
            }

            this.length -= c;
            return ret;
          } // Consumes a specified amount of bytes from the buffered data.

        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;

            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;

              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next) this.head = p.next; else this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }

                break;
              }

              ++c;
            }

            this.length -= c;
            return ret;
          } // Make sure the linked list only shows the minimal necessary information.

        }, {
          key: custom,
          value: function value(_, options) {
            return inspect(this, _objectSpread({}, options, {
              // Only inspect one level.
              depth: 0,
              // It should not recurse.
              customInspect: false
            }));
          }
        }]);

        return BufferList;
      }();
  }, { "buffer": 126, "util": 123 }], 174: [function (require, module, exports) {
    (function (process) {
      (function () {
        'use strict'; // undocumented cb() API, needed for core, not for public API

        function destroy(err, cb) {
          var _this = this;

          var readableDestroyed = this._readableState && this._readableState.destroyed;
          var writableDestroyed = this._writableState && this._writableState.destroyed;

          if (readableDestroyed || writableDestroyed) {
            if (cb) {
              cb(err);
            } else if (err) {
              if (!this._writableState) {
                process.nextTick(emitErrorNT, this, err);
              } else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                process.nextTick(emitErrorNT, this, err);
              }
            }

            return this;
          } // we set destroyed to true before firing error callbacks in order
          // to make it re-entrance safe in case destroy() is called within callbacks


          if (this._readableState) {
            this._readableState.destroyed = true;
          } // if this is a duplex stream mark the writable part as destroyed as well


          if (this._writableState) {
            this._writableState.destroyed = true;
          }

          this._destroy(err || null, function (err) {
            if (!cb && err) {
              if (!_this._writableState) {
                process.nextTick(emitErrorAndCloseNT, _this, err);
              } else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                process.nextTick(emitErrorAndCloseNT, _this, err);
              } else {
                process.nextTick(emitCloseNT, _this);
              }
            } else if (cb) {
              process.nextTick(emitCloseNT, _this);
              cb(err);
            } else {
              process.nextTick(emitCloseNT, _this);
            }
          });

          return this;
        }

        function emitErrorAndCloseNT(self, err) {
          emitErrorNT(self, err);
          emitCloseNT(self);
        }

        function emitCloseNT(self) {
          if (self._writableState && !self._writableState.emitClose) return;
          if (self._readableState && !self._readableState.emitClose) return;
          self.emit('close');
        }

        function undestroy() {
          if (this._readableState) {
            this._readableState.destroyed = false;
            this._readableState.reading = false;
            this._readableState.ended = false;
            this._readableState.endEmitted = false;
          }

          if (this._writableState) {
            this._writableState.destroyed = false;
            this._writableState.ended = false;
            this._writableState.ending = false;
            this._writableState.finalCalled = false;
            this._writableState.prefinished = false;
            this._writableState.finished = false;
            this._writableState.errorEmitted = false;
          }
        }

        function emitErrorNT(self, err) {
          self.emit('error', err);
        }

        function errorOrDestroy(stream, err) {
          // We have tests that rely on errors being emitted
          // in the same tick, so changing this is semver major.
          // For now when you opt-in to autoDestroy we allow
          // the error to be emitted nextTick. In a future
          // semver major update we should change the default to this.
          var rState = stream._readableState;
          var wState = stream._writableState;
          if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err); else stream.emit('error', err);
        }

        module.exports = {
          destroy: destroy,
          undestroy: undestroy,
          errorOrDestroy: errorOrDestroy
        };
      }).call(this)
    }).call(this, require('_process'))
  }, { "_process": 163 }], 175: [function (require, module, exports) {
    // Ported from https://github.com/mafintosh/end-of-stream with
    // permission from the author, Mathias Buus (@mafintosh).
    'use strict';

    var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

    function once(callback) {
      var called = false;
      return function () {
        if (called) return;
        called = true;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        callback.apply(this, args);
      };
    }

    function noop() { }

    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === 'function';
    }

    function eos(stream, opts, callback) {
      if (typeof opts === 'function') return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;

      var onlegacyfinish = function onlegacyfinish() {
        if (!stream.writable) onfinish();
      };

      var writableEnded = stream._writableState && stream._writableState.finished;

      var onfinish = function onfinish() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      };

      var readableEnded = stream._readableState && stream._readableState.endEmitted;

      var onend = function onend() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      };

      var onerror = function onerror(err) {
        callback.call(stream, err);
      };

      var onclose = function onclose() {
        var err;

        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }

        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };

      var onrequest = function onrequest() {
        stream.req.on('finish', onfinish);
      };

      if (isRequest(stream)) {
        stream.on('complete', onfinish);
        stream.on('abort', onclose);
        if (stream.req) onrequest(); else stream.on('request', onrequest);
      } else if (writable && !stream._writableState) {
        // legacy streams
        stream.on('end', onlegacyfinish);
        stream.on('close', onlegacyfinish);
      }

      stream.on('end', onend);
      stream.on('finish', onfinish);
      if (opts.error !== false) stream.on('error', onerror);
      stream.on('close', onclose);
      return function () {
        stream.removeListener('complete', onfinish);
        stream.removeListener('abort', onclose);
        stream.removeListener('request', onrequest);
        if (stream.req) stream.req.removeListener('finish', onfinish);
        stream.removeListener('end', onlegacyfinish);
        stream.removeListener('close', onlegacyfinish);
        stream.removeListener('finish', onfinish);
        stream.removeListener('end', onend);
        stream.removeListener('error', onerror);
        stream.removeListener('close', onclose);
      };
    }

    module.exports = eos;
  }, { "../../../errors": 166 }], 176: [function (require, module, exports) {
    module.exports = function () {
      throw new Error('Readable.from is not available in the browser')
    };

  }, {}], 177: [function (require, module, exports) {
    // Ported from https://github.com/mafintosh/pump with
    // permission from the author, Mathias Buus (@mafintosh).
    'use strict';

    var eos;

    function once(callback) {
      var called = false;
      return function () {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }

    var _require$codes = require('../../../errors').codes,
      ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
      ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

    function noop(err) {
      // Rethrow the error if it exists to avoid swallowing it
      if (err) throw err;
    }

    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === 'function';
    }

    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on('close', function () {
        closed = true;
      });
      if (eos === undefined) eos = require('./end-of-stream');
      eos(stream, {
        readable: reading,
        writable: writing
      }, function (err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function (err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true; // request.destroy just do .end - .abort is what we want

        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === 'function') return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED('pipe'));
      };
    }

    function call(fn) {
      fn();
    }

    function pipe(from, to) {
      return from.pipe(to);
    }

    function popCallback(streams) {
      if (!streams.length) return noop;
      if (typeof streams[streams.length - 1] !== 'function') return noop;
      return streams.pop();
    }

    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }

      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];

      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS('streams');
      }

      var error;
      var destroys = streams.map(function (stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function (err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }

    module.exports = pipeline;
  }, { "../../../errors": 166, "./end-of-stream": 175 }], 178: [function (require, module, exports) {
    'use strict';

    var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }

    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : 'highWaterMark';
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }

        return Math.floor(hwm);
      } // Default value


      return state.objectMode ? 16 : 16 * 1024;
    }

    module.exports = {
      getHighWaterMark: getHighWaterMark
    };
  }, { "../../../errors": 166 }], 179: [function (require, module, exports) {
    module.exports = require('events').EventEmitter;

  }, { "events": 134 }], 180: [function (require, module, exports) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    'use strict';

    /*<replacement>*/

    var Buffer = require('safe-buffer').Buffer;
    /*</replacement>*/

    var isEncoding = Buffer.isEncoding || function (encoding) {
      encoding = '' + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw':
          return true;
        default:
          return false;
      }
    };

    function _normalizeEncoding(enc) {
      if (!enc) return 'utf8';
      var retried;
      while (true) {
        switch (enc) {
          case 'utf8':
          case 'utf-8':
            return 'utf8';
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return 'utf16le';
          case 'latin1':
          case 'binary':
            return 'latin1';
          case 'base64':
          case 'ascii':
          case 'hex':
            return enc;
          default:
            if (retried) return; // undefined
            enc = ('' + enc).toLowerCase();
            retried = true;
        }
      }
    };

    // Do not cache `Buffer.isEncoding` when checking encoding names as some
    // modules monkey-patch it to support additional encodings
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
      return nenc || enc;
    }

    // StringDecoder provides an interface for efficiently splitting a series of
    // buffers into a series of JS strings without breaking apart multi-byte
    // characters.
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case 'utf16le':
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case 'utf8':
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case 'base64':
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer.allocUnsafe(nb);
    }

    StringDecoder.prototype.write = function (buf) {
      if (buf.length === 0) return '';
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return '';
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || '';
    };

    StringDecoder.prototype.end = utf8End;

    // Returns only complete characters in a Buffer
    StringDecoder.prototype.text = utf8Text;

    // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
    StringDecoder.prototype.fillLast = function (buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };

    // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
    // continuation byte. If an invalid byte is detected, -2 is returned.
    function utf8CheckByte(byte) {
      if (byte <= 0x7F) return 0; else if (byte >> 5 === 0x06) return 2; else if (byte >> 4 === 0x0E) return 3; else if (byte >> 3 === 0x1E) return 4;
      return byte >> 6 === 0x02 ? -1 : -2;
    }

    // Checks at most 3 bytes at the end of a Buffer in order to detect an
    // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
    // needed to complete the UTF-8 character (if applicable) are returned.
    function utf8CheckIncomplete(self, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0; else self.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }

    // Validates as many continuation bytes for a multi-byte UTF-8 character as
    // needed or are available. If we see a non-continuation byte where we expect
    // one, we "replace" the validated continuation bytes we've seen so far with
    // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
    // behavior. The continuation byte check is included three times in the case
    // where all of the continuation bytes for a character exist in the same buffer.
    // It is also done this way as a slight performance increase instead of using a
    // loop.
    function utf8CheckExtraBytes(self, buf, p) {
      if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return '\ufffd';
      }
      if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
          self.lastNeed = 1;
          return '\ufffd';
        }
        if (self.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 0xC0) !== 0x80) {
            self.lastNeed = 2;
            return '\ufffd';
          }
        }
      }
    }

    // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== undefined) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }

    // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
    // partial character, the character's bytes are buffered until the required
    // number of bytes are available.
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString('utf8', i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString('utf8', i, end);
    }

    // For UTF-8, a replacement character is added when ending on a partial
    // character.
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : '';
      if (this.lastNeed) return r + '\ufffd';
      return r;
    }

    // UTF-16LE typically needs two bytes per character, but even if we have an even
    // number of bytes available, we need to check if we end on a leading/high
    // surrogate. In that case, we need to wait for the next two bytes in order to
    // decode the last character properly.
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString('utf16le', i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 0xD800 && c <= 0xDBFF) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString('utf16le', i, buf.length - 1);
    }

    // For UTF-16LE we do not explicitly append special replacement characters if we
    // end on a partial character, we simply let v8 handle that.
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : '';
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString('utf16le', 0, end);
      }
      return r;
    }

    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString('base64', i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString('base64', i, buf.length - n);
    }

    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : '';
      if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
      return r;
    }

    // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }

    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : '';
    }
  }, { "safe-buffer": 164 }], 181: [function (require, module, exports) {
    (function (global) {
      (function () {
        /*! *****************************************************************************
        Copyright (c) Microsoft Corporation.
        
        Permission to use, copy, modify, and/or distribute this software for any
        purpose with or without fee is hereby granted.
        
        THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
        PERFORMANCE OF THIS SOFTWARE.
        ***************************************************************************** */

        /* global global, define, System, Reflect, Promise */
        var __extends;
        var __assign;
        var __rest;
        var __decorate;
        var __param;
        var __metadata;
        var __awaiter;
        var __generator;
        var __exportStar;
        var __values;
        var __read;
        var __spread;
        var __spreadArrays;
        var __await;
        var __asyncGenerator;
        var __asyncDelegator;
        var __asyncValues;
        var __makeTemplateObject;
        var __importStar;
        var __importDefault;
        var __classPrivateFieldGet;
        var __classPrivateFieldSet;
        var __createBinding;
        (function (factory) {
          var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
          if (typeof define === "function" && define.amd) {
            define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
          }
          else if (typeof module === "object" && typeof module.exports === "object") {
            factory(createExporter(root, createExporter(module.exports)));
          }
          else {
            factory(createExporter(root));
          }
          function createExporter(exports, previous) {
            if (exports !== root) {
              if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
              }
              else {
                exports.__esModule = true;
              }
            }
            return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
          }
        })
          (function (exporter) {
            var extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

            __extends = function (d, b) {
              extendStatics(d, b);
              function __() { this.constructor = d; }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };

            __assign = Object.assign || function (t) {
              for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
              }
              return t;
            };

            __rest = function (s, e) {
              var t = {};
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
              if (s != null && typeof Object.getOwnPropertySymbols === "function")
                for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                  if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
                }
              return t;
            };

            __decorate = function (decorators, target, key, desc) {
              var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
              if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
              else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
              return c > 3 && r && Object.defineProperty(target, key, r), r;
            };

            __param = function (paramIndex, decorator) {
              return function (target, key) { decorator(target, key, paramIndex); }
            };

            __metadata = function (metadataKey, metadataValue) {
              if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
            };

            __awaiter = function (thisArg, _arguments, P, generator) {
              function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
              return new (P || (P = Promise))(function (resolve, reject) {
                function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
                function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
                function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };

            __generator = function (thisArg, body) {
              var _ = { label: 0, sent: function () { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
              return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
              function verb(n) { return function (v) { return step([n, v]); }; }
              function step(op) {
                if (f) throw new TypeError("Generator is already executing.");
                while (_) try {
                  if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                  if (y = 0, t) op = [op[0] & 2, t.value];
                  switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
                  }
                  op = body.call(thisArg, _);
                } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
                if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
              }
            };

            __createBinding = function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            };

            __exportStar = function (m, exports) {
              for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
            };

            __values = function (o) {
              var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
              if (m) return m.call(o);
              if (o && typeof o.length === "number") return {
                next: function () {
                  if (o && i >= o.length) o = void 0;
                  return { value: o && o[i++], done: !o };
                }
              };
              throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };

            __read = function (o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m) return o;
              var i = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
              }
              catch (error) { e = { error: error }; }
              finally {
                try {
                  if (r && !r.done && (m = i["return"])) m.call(i);
                }
                finally { if (e) throw e.error; }
              }
              return ar;
            };

            __spread = function () {
              for (var ar = [], i = 0; i < arguments.length; i++)
                ar = ar.concat(__read(arguments[i]));
              return ar;
            };

            __spreadArrays = function () {
              for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
              for (var r = Array(s), k = 0, i = 0; i < il; i++)
                for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                  r[k] = a[j];
              return r;
            };

            __await = function (v) {
              return this instanceof __await ? (this.v = v, this) : new __await(v);
            };

            __asyncGenerator = function (thisArg, _arguments, generator) {
              if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
              var g = generator.apply(thisArg, _arguments || []), i, q = [];
              return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
              function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
              function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
              function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
              function fulfill(value) { resume("next", value); }
              function reject(value) { resume("throw", value); }
              function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
            };

            __asyncDelegator = function (o) {
              var i, p;
              return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
              function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
            };

            __asyncValues = function (o) {
              if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
              var m = o[Symbol.asyncIterator], i;
              return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
              function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
              function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
            };

            __makeTemplateObject = function (cooked, raw) {
              if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
              return cooked;
            };

            __importStar = function (mod) {
              if (mod && mod.__esModule) return mod;
              var result = {};
              if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
              result["default"] = mod;
              return result;
            };

            __importDefault = function (mod) {
              return (mod && mod.__esModule) ? mod : { "default": mod };
            };

            __classPrivateFieldGet = function (receiver, privateMap) {
              if (!privateMap.has(receiver)) {
                throw new TypeError("attempted to get private field on non-instance");
              }
              return privateMap.get(receiver);
            };

            __classPrivateFieldSet = function (receiver, privateMap, value) {
              if (!privateMap.has(receiver)) {
                throw new TypeError("attempted to set private field on non-instance");
              }
              privateMap.set(receiver, value);
              return value;
            };

            exporter("__extends", __extends);
            exporter("__assign", __assign);
            exporter("__rest", __rest);
            exporter("__decorate", __decorate);
            exporter("__param", __param);
            exporter("__metadata", __metadata);
            exporter("__awaiter", __awaiter);
            exporter("__generator", __generator);
            exporter("__exportStar", __exportStar);
            exporter("__createBinding", __createBinding);
            exporter("__values", __values);
            exporter("__read", __read);
            exporter("__spread", __spread);
            exporter("__spreadArrays", __spreadArrays);
            exporter("__await", __await);
            exporter("__asyncGenerator", __asyncGenerator);
            exporter("__asyncDelegator", __asyncDelegator);
            exporter("__asyncValues", __asyncValues);
            exporter("__makeTemplateObject", __makeTemplateObject);
            exporter("__importStar", __importStar);
            exporter("__importDefault", __importDefault);
            exporter("__classPrivateFieldGet", __classPrivateFieldGet);
            exporter("__classPrivateFieldSet", __classPrivateFieldSet);
          });

      }).call(this)
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  }, {}], 182: [function (require, module, exports) {
    (function (global) {
      (function () {

        /**
         * Module exports.
         */

        module.exports = deprecate;

        /**
         * Mark that a method should not be used.
         * Returns a modified function which warns once by default.
         *
         * If `localStorage.noDeprecation = true` is set, then it is a no-op.
         *
         * If `localStorage.throwDeprecation = true` is set, then deprecated functions
         * will throw an Error when invoked.
         *
         * If `localStorage.traceDeprecation = true` is set, then deprecated functions
         * will invoke `console.trace()` instead of `console.error()`.
         *
         * @param {Function} fn - the function to deprecate
         * @param {String} msg - the string to print to the console when `fn` is invoked
         * @returns {Function} a new "deprecated" version of `fn`
         * @api public
         */

        function deprecate(fn, msg) {
          if (config('noDeprecation')) {
            return fn;
          }

          var warned = false;
          function deprecated() {
            if (!warned) {
              if (config('throwDeprecation')) {
                throw new Error(msg);
              } else if (config('traceDeprecation')) {
                console.trace(msg);
              } else {
                console.warn(msg);
              }
              warned = true;
            }
            return fn.apply(this, arguments);
          }

          return deprecated;
        }

        /**
         * Checks `localStorage` for boolean values for the given `name`.
         *
         * @param {String} name
         * @returns {Boolean}
         * @api private
         */

        function config(name) {
          // accessing global.localStorage can trigger a DOMException in sandboxed iframes
          try {
            if (!global.localStorage) return false;
          } catch (_) {
            return false;
          }
          var val = global.localStorage[name];
          if (null == val) return false;
          return String(val).toLowerCase() === 'true';
        }

      }).call(this)
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  }, {}], 183: [function (require, module, exports) {
    arguments[4][119][0].apply(exports, arguments)
  }, { "dup": 119 }], 184: [function (require, module, exports) {
    // Currently in sync with Node.js lib/internal/util/types.js
    // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

    'use strict';

    var isArgumentsObject = require('is-arguments');
    var isGeneratorFunction = require('is-generator-function');
    var whichTypedArray = require('which-typed-array');
    var isTypedArray = require('is-typed-array');

    function uncurryThis(f) {
      return f.call.bind(f);
    }

    var BigIntSupported = typeof BigInt !== 'undefined';
    var SymbolSupported = typeof Symbol !== 'undefined';

    var ObjectToString = uncurryThis(Object.prototype.toString);

    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);

    if (BigIntSupported) {
      var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }

    if (SymbolSupported) {
      var symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }

    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== 'object') {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }

    exports.isArgumentsObject = isArgumentsObject;
    exports.isGeneratorFunction = isGeneratorFunction;
    exports.isTypedArray = isTypedArray;

    // Taken from here and modified for better browser support
    // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
    function isPromise(input) {
      return (
        (
          typeof Promise !== 'undefined' &&
          input instanceof Promise
        ) ||
        (
          input !== null &&
          typeof input === 'object' &&
          typeof input.then === 'function' &&
          typeof input.catch === 'function'
        )
      );
    }
    exports.isPromise = isPromise;

    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }

      return (
        isTypedArray(value) ||
        isDataView(value)
      );
    }
    exports.isArrayBufferView = isArrayBufferView;


    function isUint8Array(value) {
      return whichTypedArray(value) === 'Uint8Array';
    }
    exports.isUint8Array = isUint8Array;

    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === 'Uint8ClampedArray';
    }
    exports.isUint8ClampedArray = isUint8ClampedArray;

    function isUint16Array(value) {
      return whichTypedArray(value) === 'Uint16Array';
    }
    exports.isUint16Array = isUint16Array;

    function isUint32Array(value) {
      return whichTypedArray(value) === 'Uint32Array';
    }
    exports.isUint32Array = isUint32Array;

    function isInt8Array(value) {
      return whichTypedArray(value) === 'Int8Array';
    }
    exports.isInt8Array = isInt8Array;

    function isInt16Array(value) {
      return whichTypedArray(value) === 'Int16Array';
    }
    exports.isInt16Array = isInt16Array;

    function isInt32Array(value) {
      return whichTypedArray(value) === 'Int32Array';
    }
    exports.isInt32Array = isInt32Array;

    function isFloat32Array(value) {
      return whichTypedArray(value) === 'Float32Array';
    }
    exports.isFloat32Array = isFloat32Array;

    function isFloat64Array(value) {
      return whichTypedArray(value) === 'Float64Array';
    }
    exports.isFloat64Array = isFloat64Array;

    function isBigInt64Array(value) {
      return whichTypedArray(value) === 'BigInt64Array';
    }
    exports.isBigInt64Array = isBigInt64Array;

    function isBigUint64Array(value) {
      return whichTypedArray(value) === 'BigUint64Array';
    }
    exports.isBigUint64Array = isBigUint64Array;

    function isMapToString(value) {
      return ObjectToString(value) === '[object Map]';
    }
    isMapToString.working = (
      typeof Map !== 'undefined' &&
      isMapToString(new Map())
    );

    function isMap(value) {
      if (typeof Map === 'undefined') {
        return false;
      }

      return isMapToString.working
        ? isMapToString(value)
        : value instanceof Map;
    }
    exports.isMap = isMap;

    function isSetToString(value) {
      return ObjectToString(value) === '[object Set]';
    }
    isSetToString.working = (
      typeof Set !== 'undefined' &&
      isSetToString(new Set())
    );
    function isSet(value) {
      if (typeof Set === 'undefined') {
        return false;
      }

      return isSetToString.working
        ? isSetToString(value)
        : value instanceof Set;
    }
    exports.isSet = isSet;

    function isWeakMapToString(value) {
      return ObjectToString(value) === '[object WeakMap]';
    }
    isWeakMapToString.working = (
      typeof WeakMap !== 'undefined' &&
      isWeakMapToString(new WeakMap())
    );
    function isWeakMap(value) {
      if (typeof WeakMap === 'undefined') {
        return false;
      }

      return isWeakMapToString.working
        ? isWeakMapToString(value)
        : value instanceof WeakMap;
    }
    exports.isWeakMap = isWeakMap;

    function isWeakSetToString(value) {
      return ObjectToString(value) === '[object WeakSet]';
    }
    isWeakSetToString.working = (
      typeof WeakSet !== 'undefined' &&
      isWeakSetToString(new WeakSet())
    );
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports.isWeakSet = isWeakSet;

    function isArrayBufferToString(value) {
      return ObjectToString(value) === '[object ArrayBuffer]';
    }
    isArrayBufferToString.working = (
      typeof ArrayBuffer !== 'undefined' &&
      isArrayBufferToString(new ArrayBuffer())
    );
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === 'undefined') {
        return false;
      }

      return isArrayBufferToString.working
        ? isArrayBufferToString(value)
        : value instanceof ArrayBuffer;
    }
    exports.isArrayBuffer = isArrayBuffer;

    function isDataViewToString(value) {
      return ObjectToString(value) === '[object DataView]';
    }
    isDataViewToString.working = (
      typeof ArrayBuffer !== 'undefined' &&
      typeof DataView !== 'undefined' &&
      isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
    );
    function isDataView(value) {
      if (typeof DataView === 'undefined') {
        return false;
      }

      return isDataViewToString.working
        ? isDataViewToString(value)
        : value instanceof DataView;
    }
    exports.isDataView = isDataView;

    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === '[object SharedArrayBuffer]';
    }
    isSharedArrayBufferToString.working = (
      typeof SharedArrayBuffer !== 'undefined' &&
      isSharedArrayBufferToString(new SharedArrayBuffer())
    );
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBuffer === 'undefined') {
        return false;
      }

      return isSharedArrayBufferToString.working
        ? isSharedArrayBufferToString(value)
        : value instanceof SharedArrayBuffer;
    }
    exports.isSharedArrayBuffer = isSharedArrayBuffer;

    function isAsyncFunction(value) {
      return ObjectToString(value) === '[object AsyncFunction]';
    }
    exports.isAsyncFunction = isAsyncFunction;

    function isMapIterator(value) {
      return ObjectToString(value) === '[object Map Iterator]';
    }
    exports.isMapIterator = isMapIterator;

    function isSetIterator(value) {
      return ObjectToString(value) === '[object Set Iterator]';
    }
    exports.isSetIterator = isSetIterator;

    function isGeneratorObject(value) {
      return ObjectToString(value) === '[object Generator]';
    }
    exports.isGeneratorObject = isGeneratorObject;

    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === '[object WebAssembly.Module]';
    }
    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports.isNumberObject = isNumberObject;

    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports.isStringObject = isStringObject;

    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports.isBooleanObject = isBooleanObject;

    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports.isBigIntObject = isBigIntObject;

    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports.isSymbolObject = isSymbolObject;

    function isBoxedPrimitive(value) {
      return (
        isNumberObject(value) ||
        isStringObject(value) ||
        isBooleanObject(value) ||
        isBigIntObject(value) ||
        isSymbolObject(value)
      );
    }
    exports.isBoxedPrimitive = isBoxedPrimitive;

    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== 'undefined' && (
        isArrayBuffer(value) ||
        isSharedArrayBuffer(value)
      );
    }
    exports.isAnyArrayBuffer = isAnyArrayBuffer;

    ['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function (method) {
      Object.defineProperty(exports, method, {
        enumerable: false,
        value: function () {
          throw new Error(method + ' is not supported in userland');
        }
      });
    });

  }, { "is-arguments": 145, "is-generator-function": 146, "is-typed-array": 147, "which-typed-array": 186 }], 185: [function (require, module, exports) {
    (function (process) {
      (function () {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
          function getOwnPropertyDescriptors(obj) {
            var keys = Object.keys(obj);
            var descriptors = {};
            for (var i = 0; i < keys.length; i++) {
              descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
            }
            return descriptors;
          };

        var formatRegExp = /%[sdj%]/g;
        exports.format = function (f) {
          if (!isString(f)) {
            var objects = [];
            for (var i = 0; i < arguments.length; i++) {
              objects.push(inspect(arguments[i]));
            }
            return objects.join(' ');
          }

          var i = 1;
          var args = arguments;
          var len = args.length;
          var str = String(f).replace(formatRegExp, function (x) {
            if (x === '%%') return '%';
            if (i >= len) return x;
            switch (x) {
              case '%s': return String(args[i++]);
              case '%d': return Number(args[i++]);
              case '%j':
                try {
                  return JSON.stringify(args[i++]);
                } catch (_) {
                  return '[Circular]';
                }
              default:
                return x;
            }
          });
          for (var x = args[i]; i < len; x = args[++i]) {
            if (isNull(x) || !isObject(x)) {
              str += ' ' + x;
            } else {
              str += ' ' + inspect(x);
            }
          }
          return str;
        };


        // Mark that a method should not be used.
        // Returns a modified function which warns once by default.
        // If --no-deprecation is set, then it is a no-op.
        exports.deprecate = function (fn, msg) {
          if (typeof process !== 'undefined' && process.noDeprecation === true) {
            return fn;
          }

          // Allow for deprecating things in the process of starting up.
          if (typeof process === 'undefined') {
            return function () {
              return exports.deprecate(fn, msg).apply(this, arguments);
            };
          }

          var warned = false;
          function deprecated() {
            if (!warned) {
              if (process.throwDeprecation) {
                throw new Error(msg);
              } else if (process.traceDeprecation) {
                console.trace(msg);
              } else {
                console.error(msg);
              }
              warned = true;
            }
            return fn.apply(this, arguments);
          }

          return deprecated;
        };


        var debugs = {};
        var debugEnvRegex = /^$/;

        if (process.env.NODE_DEBUG) {
          var debugEnv = process.env.NODE_DEBUG;
          debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
            .replace(/\*/g, '.*')
            .replace(/,/g, '$|^')
            .toUpperCase();
          debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
        }
        exports.debuglog = function (set) {
          set = set.toUpperCase();
          if (!debugs[set]) {
            if (debugEnvRegex.test(set)) {
              var pid = process.pid;
              debugs[set] = function () {
                var msg = exports.format.apply(exports, arguments);
                console.error('%s %d: %s', set, pid, msg);
              };
            } else {
              debugs[set] = function () { };
            }
          }
          return debugs[set];
        };


        /**
         * Echos the value of a value. Trys to print the value out
         * in the best way possible given the different types.
         *
         * @param {Object} obj The object to print out.
         * @param {Object} opts Optional options object that alters the output.
         */
        /* legacy: obj, showHidden, depth, colors*/
        function inspect(obj, opts) {
          // default options
          var ctx = {
            seen: [],
            stylize: stylizeNoColor
          };
          // legacy...
          if (arguments.length >= 3) ctx.depth = arguments[2];
          if (arguments.length >= 4) ctx.colors = arguments[3];
          if (isBoolean(opts)) {
            // legacy...
            ctx.showHidden = opts;
          } else if (opts) {
            // got an "options" object
            exports._extend(ctx, opts);
          }
          // set default options
          if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
          if (isUndefined(ctx.depth)) ctx.depth = 2;
          if (isUndefined(ctx.colors)) ctx.colors = false;
          if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
          if (ctx.colors) ctx.stylize = stylizeWithColor;
          return formatValue(ctx, obj, ctx.depth);
        }
        exports.inspect = inspect;


        // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
        inspect.colors = {
          'bold': [1, 22],
          'italic': [3, 23],
          'underline': [4, 24],
          'inverse': [7, 27],
          'white': [37, 39],
          'grey': [90, 39],
          'black': [30, 39],
          'blue': [34, 39],
          'cyan': [36, 39],
          'green': [32, 39],
          'magenta': [35, 39],
          'red': [31, 39],
          'yellow': [33, 39]
        };

        // Don't use 'blue' not visible on cmd.exe
        inspect.styles = {
          'special': 'cyan',
          'number': 'yellow',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red'
        };


        function stylizeWithColor(str, styleType) {
          var style = inspect.styles[styleType];

          if (style) {
            return '\u001b[' + inspect.colors[style][0] + 'm' + str +
              '\u001b[' + inspect.colors[style][1] + 'm';
          } else {
            return str;
          }
        }


        function stylizeNoColor(str, styleType) {
          return str;
        }


        function arrayToHash(array) {
          var hash = {};

          array.forEach(function (val, idx) {
            hash[val] = true;
          });

          return hash;
        }


        function formatValue(ctx, value, recurseTimes) {
          // Provide a hook for user-specified inspect functions.
          // Check that value is an object with an inspect function on it
          if (ctx.customInspect &&
            value &&
            isFunction(value.inspect) &&
            // Filter out the util module, it's inspect function is special
            value.inspect !== exports.inspect &&
            // Also filter out any prototype objects using the circular check.
            !(value.constructor && value.constructor.prototype === value)) {
            var ret = value.inspect(recurseTimes, ctx);
            if (!isString(ret)) {
              ret = formatValue(ctx, ret, recurseTimes);
            }
            return ret;
          }

          // Primitive types cannot have properties
          var primitive = formatPrimitive(ctx, value);
          if (primitive) {
            return primitive;
          }

          // Look up the keys of the object.
          var keys = Object.keys(value);
          var visibleKeys = arrayToHash(keys);

          if (ctx.showHidden) {
            keys = Object.getOwnPropertyNames(value);
          }

          // IE doesn't make error fields non-enumerable
          // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
          if (isError(value)
            && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
            return formatError(value);
          }

          // Some type of object without properties can be shortcutted.
          if (keys.length === 0) {
            if (isFunction(value)) {
              var name = value.name ? ': ' + value.name : '';
              return ctx.stylize('[Function' + name + ']', 'special');
            }
            if (isRegExp(value)) {
              return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
            }
            if (isDate(value)) {
              return ctx.stylize(Date.prototype.toString.call(value), 'date');
            }
            if (isError(value)) {
              return formatError(value);
            }
          }

          var base = '', array = false, braces = ['{', '}'];

          // Make Array say that they are Array
          if (isArray(value)) {
            array = true;
            braces = ['[', ']'];
          }

          // Make functions say that they are functions
          if (isFunction(value)) {
            var n = value.name ? ': ' + value.name : '';
            base = ' [Function' + n + ']';
          }

          // Make RegExps say that they are RegExps
          if (isRegExp(value)) {
            base = ' ' + RegExp.prototype.toString.call(value);
          }

          // Make dates with properties first say the date
          if (isDate(value)) {
            base = ' ' + Date.prototype.toUTCString.call(value);
          }

          // Make error with message first say the error
          if (isError(value)) {
            base = ' ' + formatError(value);
          }

          if (keys.length === 0 && (!array || value.length == 0)) {
            return braces[0] + base + braces[1];
          }

          if (recurseTimes < 0) {
            if (isRegExp(value)) {
              return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
            } else {
              return ctx.stylize('[Object]', 'special');
            }
          }

          ctx.seen.push(value);

          var output;
          if (array) {
            output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
          } else {
            output = keys.map(function (key) {
              return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
            });
          }

          ctx.seen.pop();

          return reduceToSingleString(output, base, braces);
        }


        function formatPrimitive(ctx, value) {
          if (isUndefined(value))
            return ctx.stylize('undefined', 'undefined');
          if (isString(value)) {
            var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
              .replace(/'/g, "\\'")
              .replace(/\\"/g, '"') + '\'';
            return ctx.stylize(simple, 'string');
          }
          if (isNumber(value))
            return ctx.stylize('' + value, 'number');
          if (isBoolean(value))
            return ctx.stylize('' + value, 'boolean');
          // For some reason typeof null is "object", so special case here.
          if (isNull(value))
            return ctx.stylize('null', 'null');
        }


        function formatError(value) {
          return '[' + Error.prototype.toString.call(value) + ']';
        }


        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
          var output = [];
          for (var i = 0, l = value.length; i < l; ++i) {
            if (hasOwnProperty(value, String(i))) {
              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                String(i), true));
            } else {
              output.push('');
            }
          }
          keys.forEach(function (key) {
            if (!key.match(/^\d+$/)) {
              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
                key, true));
            }
          });
          return output;
        }


        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
          var name, str, desc;
          desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
          if (desc.get) {
            if (desc.set) {
              str = ctx.stylize('[Getter/Setter]', 'special');
            } else {
              str = ctx.stylize('[Getter]', 'special');
            }
          } else {
            if (desc.set) {
              str = ctx.stylize('[Setter]', 'special');
            }
          }
          if (!hasOwnProperty(visibleKeys, key)) {
            name = '[' + key + ']';
          }
          if (!str) {
            if (ctx.seen.indexOf(desc.value) < 0) {
              if (isNull(recurseTimes)) {
                str = formatValue(ctx, desc.value, null);
              } else {
                str = formatValue(ctx, desc.value, recurseTimes - 1);
              }
              if (str.indexOf('\n') > -1) {
                if (array) {
                  str = str.split('\n').map(function (line) {
                    return '  ' + line;
                  }).join('\n').substr(2);
                } else {
                  str = '\n' + str.split('\n').map(function (line) {
                    return '   ' + line;
                  }).join('\n');
                }
              }
            } else {
              str = ctx.stylize('[Circular]', 'special');
            }
          }
          if (isUndefined(name)) {
            if (array && key.match(/^\d+$/)) {
              return str;
            }
            name = JSON.stringify('' + key);
            if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
              name = name.substr(1, name.length - 2);
              name = ctx.stylize(name, 'name');
            } else {
              name = name.replace(/'/g, "\\'")
                .replace(/\\"/g, '"')
                .replace(/(^"|"$)/g, "'");
              name = ctx.stylize(name, 'string');
            }
          }

          return name + ': ' + str;
        }


        function reduceToSingleString(output, base, braces) {
          var numLinesEst = 0;
          var length = output.reduce(function (prev, cur) {
            numLinesEst++;
            if (cur.indexOf('\n') >= 0) numLinesEst++;
            return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
          }, 0);

          if (length > 60) {
            return braces[0] +
              (base === '' ? '' : base + '\n ') +
              ' ' +
              output.join(',\n  ') +
              ' ' +
              braces[1];
          }

          return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
        }


        // NOTE: These type checking functions intentionally don't use `instanceof`
        // because it is fragile and can be easily faked with `Object.create()`.
        exports.types = require('./support/types');

        function isArray(ar) {
          return Array.isArray(ar);
        }
        exports.isArray = isArray;

        function isBoolean(arg) {
          return typeof arg === 'boolean';
        }
        exports.isBoolean = isBoolean;

        function isNull(arg) {
          return arg === null;
        }
        exports.isNull = isNull;

        function isNullOrUndefined(arg) {
          return arg == null;
        }
        exports.isNullOrUndefined = isNullOrUndefined;

        function isNumber(arg) {
          return typeof arg === 'number';
        }
        exports.isNumber = isNumber;

        function isString(arg) {
          return typeof arg === 'string';
        }
        exports.isString = isString;

        function isSymbol(arg) {
          return typeof arg === 'symbol';
        }
        exports.isSymbol = isSymbol;

        function isUndefined(arg) {
          return arg === void 0;
        }
        exports.isUndefined = isUndefined;

        function isRegExp(re) {
          return isObject(re) && objectToString(re) === '[object RegExp]';
        }
        exports.isRegExp = isRegExp;
        exports.types.isRegExp = isRegExp;

        function isObject(arg) {
          return typeof arg === 'object' && arg !== null;
        }
        exports.isObject = isObject;

        function isDate(d) {
          return isObject(d) && objectToString(d) === '[object Date]';
        }
        exports.isDate = isDate;
        exports.types.isDate = isDate;

        function isError(e) {
          return isObject(e) &&
            (objectToString(e) === '[object Error]' || e instanceof Error);
        }
        exports.isError = isError;
        exports.types.isNativeError = isError;

        function isFunction(arg) {
          return typeof arg === 'function';
        }
        exports.isFunction = isFunction;

        function isPrimitive(arg) {
          return arg === null ||
            typeof arg === 'boolean' ||
            typeof arg === 'number' ||
            typeof arg === 'string' ||
            typeof arg === 'symbol' ||  // ES6 symbol
            typeof arg === 'undefined';
        }
        exports.isPrimitive = isPrimitive;

        exports.isBuffer = require('./support/isBuffer');

        function objectToString(o) {
          return Object.prototype.toString.call(o);
        }


        function pad(n) {
          return n < 10 ? '0' + n.toString(10) : n.toString(10);
        }


        var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
          'Oct', 'Nov', 'Dec'];

        // 26 Feb 16:19:34
        function timestamp() {
          var d = new Date();
          var time = [pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())].join(':');
          return [d.getDate(), months[d.getMonth()], time].join(' ');
        }


        // log is just a thin wrapper to console.log that prepends a timestamp
        exports.log = function () {
          console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
        };


        /**
         * Inherit the prototype methods from one constructor into another.
         *
         * The Function.prototype.inherits from lang.js rewritten as a standalone
         * function (not on Function.prototype). NOTE: If this file is to be loaded
         * during bootstrapping this function needs to be rewritten using some native
         * functions as prototype setup using normal JavaScript does not work as
         * expected during bootstrapping (see mirror.js in r114903).
         *
         * @param {function} ctor Constructor function which needs to inherit the
         *     prototype.
         * @param {function} superCtor Constructor function to inherit prototype from.
         */
        exports.inherits = require('inherits');

        exports._extend = function (origin, add) {
          // Don't do anything if add isn't an object
          if (!add || !isObject(add)) return origin;

          var keys = Object.keys(add);
          var i = keys.length;
          while (i--) {
            origin[keys[i]] = add[keys[i]];
          }
          return origin;
        };

        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }

        var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

        exports.promisify = function promisify(original) {
          if (typeof original !== 'function')
            throw new TypeError('The "original" argument must be of type Function');

          if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
            var fn = original[kCustomPromisifiedSymbol];
            if (typeof fn !== 'function') {
              throw new TypeError('The "util.promisify.custom" argument must be of type Function');
            }
            Object.defineProperty(fn, kCustomPromisifiedSymbol, {
              value: fn, enumerable: false, writable: false, configurable: true
            });
            return fn;
          }

          function fn() {
            var promiseResolve, promiseReject;
            var promise = new Promise(function (resolve, reject) {
              promiseResolve = resolve;
              promiseReject = reject;
            });

            var args = [];
            for (var i = 0; i < arguments.length; i++) {
              args.push(arguments[i]);
            }
            args.push(function (err, value) {
              if (err) {
                promiseReject(err);
              } else {
                promiseResolve(value);
              }
            });

            try {
              original.apply(this, args);
            } catch (err) {
              promiseReject(err);
            }

            return promise;
          }

          Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

          if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn, enumerable: false, writable: false, configurable: true
          });
          return Object.defineProperties(
            fn,
            getOwnPropertyDescriptors(original)
          );
        }

        exports.promisify.custom = kCustomPromisifiedSymbol

        function callbackifyOnRejected(reason, cb) {
          // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
          // Because `null` is a special error value in callbacks which means "no error
          // occurred", we error-wrap so the callback consumer can distinguish between
          // "the promise rejected with null" or "the promise fulfilled with undefined".
          if (!reason) {
            var newReason = new Error('Promise was rejected with a falsy value');
            newReason.reason = reason;
            reason = newReason;
          }
          return cb(reason);
        }

        function callbackify(original) {
          if (typeof original !== 'function') {
            throw new TypeError('The "original" argument must be of type Function');
          }

          // We DO NOT return the promise as it gives the user a false sense that
          // the promise is actually somehow related to the callback's execution
          // and that the callback throwing will reject the promise.
          function callbackified() {
            var args = [];
            for (var i = 0; i < arguments.length; i++) {
              args.push(arguments[i]);
            }

            var maybeCb = args.pop();
            if (typeof maybeCb !== 'function') {
              throw new TypeError('The last argument must be of type Function');
            }
            var self = this;
            var cb = function () {
              return maybeCb.apply(self, arguments);
            };
            // In true node style we process the callback on `nextTick` with all the
            // implications (stack, `uncaughtException`, `async_hooks`)
            original.apply(this, args)
              .then(function (ret) { process.nextTick(cb.bind(null, null, ret)) },
                function (rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
          }

          Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
          Object.defineProperties(callbackified,
            getOwnPropertyDescriptors(original));
          return callbackified;
        }
        exports.callbackify = callbackify;

      }).call(this)
    }).call(this, require('_process'))
  }, { "./support/isBuffer": 183, "./support/types": 184, "_process": 163, "inherits": 144 }], 186: [function (require, module, exports) {
    (function (global) {
      (function () {
        'use strict';

        var forEach = require('foreach');
        var availableTypedArrays = require('available-typed-arrays');
        var callBound = require('es-abstract/helpers/callBound');

        var $toString = callBound('Object.prototype.toString');
        var hasSymbols = require('has-symbols')();
        var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';

        var typedArrays = availableTypedArrays();

        var $slice = callBound('String.prototype.slice');
        var toStrTags = {};
        var gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');
        var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
        if (hasToStringTag && gOPD && getPrototypeOf) {
          forEach(typedArrays, function (typedArray) {
            if (typeof global[typedArray] === 'function') {
              var arr = new global[typedArray]();
              if (!(Symbol.toStringTag in arr)) {
                throw new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');
              }
              var proto = getPrototypeOf(arr);
              var descriptor = gOPD(proto, Symbol.toStringTag);
              if (!descriptor) {
                var superProto = getPrototypeOf(proto);
                descriptor = gOPD(superProto, Symbol.toStringTag);
              }
              toStrTags[typedArray] = descriptor.get;
            }
          });
        }

        var tryTypedArrays = function tryAllTypedArrays(value) {
          var foundName = false;
          forEach(toStrTags, function (getter, typedArray) {
            if (!foundName) {
              try {
                var name = getter.call(value);
                if (name === typedArray) {
                  foundName = name;
                }
              } catch (e) { }
            }
          });
          return foundName;
        };

        var isTypedArray = require('is-typed-array');

        module.exports = function whichTypedArray(value) {
          if (!isTypedArray(value)) { return false; }
          if (!hasToStringTag) { return $slice($toString(value), 8, -1); }
          return tryTypedArrays(value);
        };

      }).call(this)
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  }, { "available-typed-arrays": 121, "es-abstract/helpers/callBound": 132, "es-abstract/helpers/getOwnPropertyDescriptor": 133, "foreach": 135, "has-symbols": 140, "is-typed-array": 147 }], 187: [function (require, module, exports) {
    'use strict'
    module.exports = function (Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value
        }
      }
    }

  }, {}], 188: [function (require, module, exports) {
    'use strict'
    module.exports = Yallist

    Yallist.Node = Node
    Yallist.create = Yallist

    function Yallist(list) {
      var self = this
      if (!(self instanceof Yallist)) {
        self = new Yallist()
      }

      self.tail = null
      self.head = null
      self.length = 0

      if (list && typeof list.forEach === 'function') {
        list.forEach(function (item) {
          self.push(item)
        })
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self.push(arguments[i])
        }
      }

      return self
    }

    Yallist.prototype.removeNode = function (node) {
      if (node.list !== this) {
        throw new Error('removing node which does not belong to this list')
      }

      var next = node.next
      var prev = node.prev

      if (next) {
        next.prev = prev
      }

      if (prev) {
        prev.next = next
      }

      if (node === this.head) {
        this.head = next
      }
      if (node === this.tail) {
        this.tail = prev
      }

      node.list.length--
      node.next = null
      node.prev = null
      node.list = null

      return next
    }

    Yallist.prototype.unshiftNode = function (node) {
      if (node === this.head) {
        return
      }

      if (node.list) {
        node.list.removeNode(node)
      }

      var head = this.head
      node.list = this
      node.next = head
      if (head) {
        head.prev = node
      }

      this.head = node
      if (!this.tail) {
        this.tail = node
      }
      this.length++
    }

    Yallist.prototype.pushNode = function (node) {
      if (node === this.tail) {
        return
      }

      if (node.list) {
        node.list.removeNode(node)
      }

      var tail = this.tail
      node.list = this
      node.prev = tail
      if (tail) {
        tail.next = node
      }

      this.tail = node
      if (!this.head) {
        this.head = node
      }
      this.length++
    }

    Yallist.prototype.push = function () {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i])
      }
      return this.length
    }

    Yallist.prototype.unshift = function () {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i])
      }
      return this.length
    }

    Yallist.prototype.pop = function () {
      if (!this.tail) {
        return undefined
      }

      var res = this.tail.value
      this.tail = this.tail.prev
      if (this.tail) {
        this.tail.next = null
      } else {
        this.head = null
      }
      this.length--
      return res
    }

    Yallist.prototype.shift = function () {
      if (!this.head) {
        return undefined
      }

      var res = this.head.value
      this.head = this.head.next
      if (this.head) {
        this.head.prev = null
      } else {
        this.tail = null
      }
      this.length--
      return res
    }

    Yallist.prototype.forEach = function (fn, thisp) {
      thisp = thisp || this
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this)
        walker = walker.next
      }
    }

    Yallist.prototype.forEachReverse = function (fn, thisp) {
      thisp = thisp || this
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this)
        walker = walker.prev
      }
    }

    Yallist.prototype.get = function (n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        // abort out of the list early if we hit a cycle
        walker = walker.next
      }
      if (i === n && walker !== null) {
        return walker.value
      }
    }

    Yallist.prototype.getReverse = function (n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        // abort out of the list early if we hit a cycle
        walker = walker.prev
      }
      if (i === n && walker !== null) {
        return walker.value
      }
    }

    Yallist.prototype.map = function (fn, thisp) {
      thisp = thisp || this
      var res = new Yallist()
      for (var walker = this.head; walker !== null;) {
        res.push(fn.call(thisp, walker.value, this))
        walker = walker.next
      }
      return res
    }

    Yallist.prototype.mapReverse = function (fn, thisp) {
      thisp = thisp || this
      var res = new Yallist()
      for (var walker = this.tail; walker !== null;) {
        res.push(fn.call(thisp, walker.value, this))
        walker = walker.prev
      }
      return res
    }

    Yallist.prototype.reduce = function (fn, initial) {
      var acc
      var walker = this.head
      if (arguments.length > 1) {
        acc = initial
      } else if (this.head) {
        walker = this.head.next
        acc = this.head.value
      } else {
        throw new TypeError('Reduce of empty list with no initial value')
      }

      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i)
        walker = walker.next
      }

      return acc
    }

    Yallist.prototype.reduceReverse = function (fn, initial) {
      var acc
      var walker = this.tail
      if (arguments.length > 1) {
        acc = initial
      } else if (this.tail) {
        walker = this.tail.prev
        acc = this.tail.value
      } else {
        throw new TypeError('Reduce of empty list with no initial value')
      }

      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i)
        walker = walker.prev
      }

      return acc
    }

    Yallist.prototype.toArray = function () {
      var arr = new Array(this.length)
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value
        walker = walker.next
      }
      return arr
    }

    Yallist.prototype.toArrayReverse = function () {
      var arr = new Array(this.length)
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value
        walker = walker.prev
      }
      return arr
    }

    Yallist.prototype.slice = function (from, to) {
      to = to || this.length
      if (to < 0) {
        to += this.length
      }
      from = from || 0
      if (from < 0) {
        from += this.length
      }
      var ret = new Yallist()
      if (to < from || to < 0) {
        return ret
      }
      if (from < 0) {
        from = 0
      }
      if (to > this.length) {
        to = this.length
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value)
      }
      return ret
    }

    Yallist.prototype.sliceReverse = function (from, to) {
      to = to || this.length
      if (to < 0) {
        to += this.length
      }
      from = from || 0
      if (from < 0) {
        from += this.length
      }
      var ret = new Yallist()
      if (to < from || to < 0) {
        return ret
      }
      if (from < 0) {
        from = 0
      }
      if (to > this.length) {
        to = this.length
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value)
      }
      return ret
    }

    Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1
      }
      if (start < 0) {
        start = this.length + start;
      }

      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next
      }

      var ret = []
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value)
        walker = this.removeNode(walker)
      }
      if (walker === null) {
        walker = this.tail
      }

      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev
      }

      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i])
      }
      return ret;
    }

    Yallist.prototype.reverse = function () {
      var head = this.head
      var tail = this.tail
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev
        walker.prev = walker.next
        walker.next = p
      }
      this.head = tail
      this.tail = head
      return this
    }

    function insert(self, node, value) {
      var inserted = node === self.head ?
        new Node(value, null, node, self) :
        new Node(value, node, node.next, self)

      if (inserted.next === null) {
        self.tail = inserted
      }
      if (inserted.prev === null) {
        self.head = inserted
      }

      self.length++

      return inserted
    }

    function push(self, item) {
      self.tail = new Node(item, self.tail, null, self)
      if (!self.head) {
        self.head = self.tail
      }
      self.length++
    }

    function unshift(self, item) {
      self.head = new Node(item, null, self.head, self)
      if (!self.tail) {
        self.tail = self.head
      }
      self.length++
    }

    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list)
      }

      this.list = list
      this.value = value

      if (prev) {
        prev.next = this
        this.prev = prev
      } else {
        this.prev = null
      }

      if (next) {
        next.prev = this
        this.next = next
      } else {
        this.next = null
      }
    }

    try {
      // add if support for Symbol.iterator is present
      require('./iterator.js')(Yallist)
    } catch (er) { }

  }, { "./iterator.js": 187 }]
}, {}, [7]);
